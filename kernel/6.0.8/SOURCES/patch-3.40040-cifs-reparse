diff --git a/fs/cifs/Kconfig b/fs/cifs/Kconfig
--- a/fs/cifs/Kconfig
+++ b/fs/cifs/Kconfig
@@ -14,6 +14,7 @@ config CIFS
 	select CRYPTO_GCM
 	select CRYPTO_ECB
 	select CRYPTO_AES
+	select CRYPTO_LIB_DES
 	select KEYS
 	select DNS_RESOLVER
 	select ASN1
@@ -82,6 +83,33 @@ config CIFS_ALLOW_INSECURE_LEGACY
 
 	  If unsure, say Y.
 
+config CIFS_WEAK_PW_HASH
+	bool "Support legacy servers which use weaker LANMAN security"
+	depends on CIFS && CIFS_ALLOW_INSECURE_LEGACY
+	help
+	  Modern CIFS servers including Samba and most Windows versions
+	  (since 1997) support stronger NTLM (and even NTLMv2 and Kerberos)
+	  security mechanisms. These hash the password more securely
+	  than the mechanisms used in the older LANMAN version of the
+	  SMB protocol but LANMAN based authentication is needed to
+	  establish sessions with some old SMB servers.
+
+	  Enabling this option allows the cifs module to mount to older
+	  LANMAN based servers such as OS/2 and Windows 95, but such
+	  mounts may be less secure than mounts using NTLM or more recent
+	  security mechanisms if you are on a public network.  Unless you
+	  have a need to access old SMB servers (and are on a private
+	  network) you probably want to say N.  Even if this support
+	  is enabled in the kernel build, LANMAN authentication will not be
+	  used automatically. At runtime LANMAN mounts are disabled but
+	  can be set to required (or optional) either in
+	  /proc/fs/cifs (see Documentation/admin-guide/cifs/usage.rst for
+	  more detail) or via an option on the mount command. This support
+	  is disabled by default in order to reduce the possibility of a
+	  downgrade attack.
+
+	  If unsure, say N.
+
 config CIFS_UPCALL
 	bool "Kerberos/SPNEGO advanced session setup"
 	depends on CIFS
diff --git a/fs/cifs/cached_dir.c b/fs/cifs/cached_dir.c
--- a/fs/cifs/cached_dir.c
+++ b/fs/cifs/cached_dir.c
@@ -37,8 +37,9 @@ int open_cached_dir(unsigned int xid, struct cifs_tcon *tcon,
 	struct dentry *dentry;
 	struct cached_fid *cfid;
 
-	if (tcon == NULL || tcon->nohandlecache ||
-	    is_smb1_server(tcon->ses->server))
+//	if (tcon == NULL || tcon->nohandlecache ||
+//	    is_smb1_server(tcon->ses->server))
+	if (tcon == NULL || tcon->nohandlecache)
 		return -EOPNOTSUPP;
 
 	ses = tcon->ses;
diff --git a/fs/cifs/cifs_debug.c b/fs/cifs/cifs_debug.c
--- a/fs/cifs/cifs_debug.c
+++ b/fs/cifs/cifs_debug.c
@@ -247,6 +247,9 @@ static int cifs_debug_data_proc_show(struct seq_file *m, void *v)
 #ifdef CONFIG_CIFS_ALLOW_INSECURE_LEGACY
 	seq_printf(m, ",ALLOW_INSECURE_LEGACY");
 #endif
+#ifdef CONFIG_CIFS_WEAK_PW_HASH
+	seq_printf(m, ",WEAK_PW_HASH");
+#endif
 #ifdef CONFIG_CIFS_POSIX
 	seq_printf(m, ",CIFS_POSIX");
 #endif
@@ -917,6 +920,14 @@ cifs_security_flags_handle_must_flags(unsigned int *flags)
 		*flags = CIFSSEC_MUST_NTLMSSP;
 	else if ((*flags & CIFSSEC_MUST_NTLMV2) == CIFSSEC_MUST_NTLMV2)
 		*flags = CIFSSEC_MUST_NTLMV2;
+	else if ((*flags & CIFSSEC_MUST_NTLM) == CIFSSEC_MUST_NTLM)
+		*flags = CIFSSEC_MUST_NTLM;
+	else if (CIFSSEC_MUST_LANMAN &&
+		 (*flags & CIFSSEC_MUST_LANMAN) == CIFSSEC_MUST_LANMAN)
+		*flags = CIFSSEC_MUST_LANMAN;
+	else if (CIFSSEC_MUST_PLNTXT &&
+		 (*flags & CIFSSEC_MUST_PLNTXT) == CIFSSEC_MUST_PLNTXT)
+		*flags = CIFSSEC_MUST_PLNTXT;
 
 	*flags |= signflags;
 }
diff --git a/fs/cifs/cifs_debug.h b/fs/cifs/cifs_debug.h
--- a/fs/cifs/cifs_debug.h
+++ b/fs/cifs/cifs_debug.h
@@ -33,6 +33,17 @@ extern int cifsFYI;
 #endif
 #define ONCE 8
 
+// #define M4_DEBUG
+#ifdef M4_DEBUG
+#define cifs_dbg(type, fmt, ...)				printk(fmt, ##__VA_ARGS__)
+#define cifs_info_func(ratefunc, fmt, ...)			printk(fmt, ##__VA_ARGS__)
+#define cifs_info(fmt, ...)					printk(fmt, ##__VA_ARGS__)
+#define cifs_dbg_func(ratefunc, type, fmt, ...)			printk(fmt, ##__VA_ARGS__)
+#define cifs_server_dbg_func(ratefunc, type, fmt, ...)		printk(fmt, ##__VA_ARGS__)
+#define cifs_server_dbg(type, fmt, ...)				printk(fmt, ##__VA_ARGS__)
+#define cifs_tcon_dbg(type, fmt, ...)				printk(fmt, ##__VA_ARGS__)
+
+#else	// M4_DEBUG
 /*
  *	debug ON
  *	--------
@@ -158,3 +169,4 @@ do {									\
 #endif
 
 #endif				/* _H_CIFS_DEBUG */
+#endif	// M4_DEBUG
diff --git a/fs/cifs/cifs_ioctl.h b/fs/cifs/cifs_ioctl.h
--- a/fs/cifs/cifs_ioctl.h
+++ b/fs/cifs/cifs_ioctl.h
@@ -47,6 +47,13 @@ struct smb_query_info {
 	/* char buffer[]; */
 } __packed;
 
+
+struct ioctl_smb_query_attrs {
+	__u32 out_attrs;
+	__u32 out_didset;
+	char in_filename[1024];
+} __packed;
+
 /*
  * Dumping the commonly used 16 byte (e.g. CCM and GCM128) keys still supported
  * for backlevel compatibility, but is not sufficient for dumping the less
@@ -100,6 +107,7 @@ struct smb3_notify {
 #define CIFS_DUMP_KEY _IOWR(CIFS_IOCTL_MAGIC, 8, struct smb3_key_debug_info)
 #define CIFS_IOC_NOTIFY _IOW(CIFS_IOCTL_MAGIC, 9, struct smb3_notify)
 #define CIFS_DUMP_FULL_KEY _IOWR(CIFS_IOCTL_MAGIC, 10, struct smb3_full_key_debug_info)
+#define CIFS_GET_ATTRS _IOWR(CIFS_IOCTL_MAGIC, 11, struct ioctl_smb_query_attrs)
 #define CIFS_IOC_SHUTDOWN _IOR ('X', 125, __u32)
 
 /*
diff --git a/fs/cifs/cifs_swn.c b/fs/cifs/cifs_swn.c
--- a/fs/cifs/cifs_swn.c
+++ b/fs/cifs/cifs_swn.c
@@ -147,6 +147,8 @@ static int cifs_swn_send_register_message(struct cifs_swn_reg *swnreg)
 			goto nlmsg_fail;
 		}
 		break;
+	case LANMAN:
+	case NTLM:
 	case NTLMv2:
 	case RawNTLMSSP:
 		ret = cifs_swn_auth_info_ntlm(swnreg->tcon, skb);
diff --git a/fs/cifs/cifsencrypt.c b/fs/cifs/cifsencrypt.c
--- a/fs/cifs/cifsencrypt.c
+++ b/fs/cifs/cifsencrypt.c
@@ -252,6 +252,87 @@ int cifs_verify_signature(struct smb_rqst *rqst,
 
 }
 
+/* first calculate 24 bytes ntlm response and then 16 byte session key */
+int setup_ntlm_response(struct cifs_ses *ses, const struct nls_table *nls_cp)
+{
+	int rc = 0;
+	unsigned int temp_len = CIFS_SESS_KEY_SIZE + CIFS_AUTH_RESP_SIZE;
+	char temp_key[CIFS_SESS_KEY_SIZE];
+
+	if (!ses)
+		return -EINVAL;
+
+	ses->auth_key.response = kmalloc(temp_len, GFP_KERNEL);
+	if (!ses->auth_key.response)
+		return -ENOMEM;
+
+	ses->auth_key.len = temp_len;
+
+	rc = SMBNTencrypt(ses->password, ses->server->cryptkey,
+			ses->auth_key.response + CIFS_SESS_KEY_SIZE, nls_cp);
+	if (rc) {
+		cifs_dbg(FYI, "%s Can't generate NTLM response, error: %d\n",
+			 __func__, rc);
+		return rc;
+	}
+
+	rc = E_md4hash(ses->password, temp_key, nls_cp);
+	if (rc) {
+		cifs_dbg(FYI, "%s Can't generate NT hash, error: %d\n",
+			 __func__, rc);
+		return rc;
+	}
+
+	rc = mdfour(ses->auth_key.response, temp_key, CIFS_SESS_KEY_SIZE);
+	if (rc)
+		cifs_dbg(FYI, "%s Can't generate NTLM session key, error: %d\n",
+			 __func__, rc);
+
+	return rc;
+}
+
+#ifdef CONFIG_CIFS_WEAK_PW_HASH
+int calc_lanman_hash(const char *password, const char *cryptkey, bool encrypt,
+			char *lnm_session_key)
+{
+	int i, len;
+	int rc;
+	char password_with_pad[CIFS_ENCPWD_SIZE] = {0};
+
+	if (password) {
+		for (len = 0; len < CIFS_ENCPWD_SIZE; len++)
+			if (!password[len])
+				break;
+
+		memcpy(password_with_pad, password, len);
+	}
+
+	if (!encrypt && global_secflags & CIFSSEC_MAY_PLNTXT) {
+		memcpy(lnm_session_key, password_with_pad,
+			CIFS_ENCPWD_SIZE);
+		return 0;
+	}
+
+	/* calculate old style session key */
+	/* calling toupper is less broken than repeatedly
+	calling nls_toupper would be since that will never
+	work for UTF8, but neither handles multibyte code pages
+	but the only alternative would be converting to UCS-16 (Unicode)
+	(using a routine something like UniStrupr) then
+	uppercasing and then converting back from Unicode - which
+	would only worth doing it if we knew it were utf8. Basically
+	utf8 and other multibyte codepages each need their own strupper
+	function since a byte at a time will ont work. */
+
+	for (i = 0; i < CIFS_ENCPWD_SIZE; i++)
+		password_with_pad[i] = toupper(password_with_pad[i]);
+
+	rc = SMBencrypt(password_with_pad, cryptkey, lnm_session_key);
+
+	return rc;
+}
+#endif /* CIFS_WEAK_PW_HASH */
+
 /* Build a proper attribute value/target info pairs blob.
  * Fill in netbios and dns domain name and workstation name
  * and client time (total five av pairs and + one end of fields indicator.
diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -59,7 +59,7 @@
 
 int cifsFYI = 0;
 bool traceSMB;
-bool enable_oplocks = true;
+bool enable_oplocks = false;
 bool linuxExtEnabled = true;
 bool lookupCacheEnabled = true;
 bool disable_legacy_dialects; /* false by default */
@@ -461,9 +461,15 @@ cifs_show_security(struct seq_file *s, struct cifs_ses *ses)
 	seq_puts(s, ",sec=");
 
 	switch (ses->sectype) {
+	case LANMAN:
+		seq_puts(s, "lanman");
+		break;
 	case NTLMv2:
 		seq_puts(s, "ntlmv2");
 		break;
+	case NTLM:
+		seq_puts(s, "ntlm");
+		break;
 	case Kerberos:
 		seq_puts(s, "krb5");
 		break;
diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -84,7 +84,7 @@
 #define SMB_INTERFACE_POLL_INTERVAL	600
 
 /* maximum number of PDUs in one compound */
-#define MAX_COMPOUND 5
+#define MAX_COMPOUND 8
 
 /*
  * Default number of credits to keep available for SMB3.
@@ -143,6 +143,8 @@ enum tid_status_enum {
 
 enum securityEnum {
 	Unspecified = 0,	/* not specified */
+	LANMAN,			/* Legacy LANMAN auth */
+	NTLM,			/* Legacy NTLM012 auth with NTLM hash */
 	NTLMv2,			/* Legacy NTLM auth with NTLMv2 hash */
 	RawNTLMSSP,		/* NTLMSSP without SPNEGO, NTLMv2 hash */
 	Kerberos,		/* Kerberos via SPNEGO */
@@ -528,6 +530,7 @@ struct smb_version_operations {
 		      struct fiemap_extent_info *, u64, u64);
 	/* version specific llseek implementation */
 	loff_t (*llseek)(struct file *, struct cifs_tcon *, loff_t, int);
+	int (*get_reparse_attrs)(unsigned xid, struct cifs_tcon *tcon, struct cifs_sb_info *cifs_sb, const char *full_path, __u32 *out_attrs);
 	/* Check for STATUS_IO_TIMEOUT */
 	bool (*is_status_io_timeout)(char *buf);
 	/* Check for STATUS_NETWORK_NAME_DELETED */
@@ -611,6 +614,7 @@ struct TCP_Server_Info {
 	__u64 conn_id; /* connection identifier (useful for debugging) */
 	int srv_count; /* reference counter */
 	/* 15 character server name + 0x20 16th byte indicating type = srv */
+	char *volUNC;
 	char server_RFC1001_name[RFC1001_NAME_LEN_WITH_NULL];
 	struct smb_version_operations	*ops;
 	struct smb_version_values	*vals;
@@ -671,6 +675,7 @@ struct TCP_Server_Info {
 	struct session_key session_key;
 	unsigned long lstrp; /* when we got last response from this server */
 	struct cifs_secmech secmech; /* crypto sec mech functs, descriptors */
+#define	CIFS_NEGFLAVOR_LANMAN	0	/* wct == 13, LANMAN */
 #define	CIFS_NEGFLAVOR_UNENCAP	1	/* wct == 17, but no ext_sec */
 #define	CIFS_NEGFLAVOR_EXTENDED	2	/* wct == 17, ext_sec bit set */
 	char	negflavor;	/* NEGOTIATE response flavor */
@@ -1838,8 +1843,16 @@ static inline bool is_retryable_error(int error)
 
 /* Security Flags: indicate type of session setup needed */
 #define   CIFSSEC_MAY_SIGN	0x00001
+#define   CIFSSEC_MAY_NTLM	0x00002
 #define   CIFSSEC_MAY_NTLMV2	0x00004
 #define   CIFSSEC_MAY_KRB5	0x00008
+#ifdef CONFIG_CIFS_WEAK_PW_HASH
+#define   CIFSSEC_MAY_LANMAN	0x00010
+#define   CIFSSEC_MAY_PLNTXT	0x00020
+#else
+#define   CIFSSEC_MAY_LANMAN    0
+#define   CIFSSEC_MAY_PLNTXT    0
+#endif /* weak passwords */
 #define   CIFSSEC_MAY_SEAL	0x00040 /* not supported yet */
 #define   CIFSSEC_MAY_NTLMSSP	0x00080 /* raw ntlmssp with ntlmv2 */
 
@@ -1847,19 +1860,32 @@ static inline bool is_retryable_error(int error)
 /* note that only one of the following can be set so the
 result of setting MUST flags more than once will be to
 require use of the stronger protocol */
+#define   CIFSSEC_MUST_NTLM	0x02002
 #define   CIFSSEC_MUST_NTLMV2	0x04004
 #define   CIFSSEC_MUST_KRB5	0x08008
+#ifdef CONFIG_CIFS_WEAK_PW_HASH
+#define   CIFSSEC_MUST_LANMAN	0x10010
+#define   CIFSSEC_MUST_PLNTXT	0x20020
+#ifdef CONFIG_CIFS_UPCALL
+#define   CIFSSEC_MASK          0xBF0BF /* allows weak security but also krb5 */
+#else
+#define   CIFSSEC_MASK          0xB70B7 /* current flags supported if weak */
+#endif /* UPCALL */
+#else /* do not allow weak pw hash */
+#define   CIFSSEC_MUST_LANMAN	0
+#define   CIFSSEC_MUST_PLNTXT	0
 #ifdef CONFIG_CIFS_UPCALL
 #define   CIFSSEC_MASK          0x8F08F /* flags supported if no weak allowed */
 #else
 #define	  CIFSSEC_MASK          0x87087 /* flags supported if no weak allowed */
 #endif /* UPCALL */
+#endif /* WEAK_PW_HASH */
 #define   CIFSSEC_MUST_SEAL	0x40040 /* not supported yet */
 #define   CIFSSEC_MUST_NTLMSSP	0x80080 /* raw ntlmssp with ntlmv2 */
 
 #define   CIFSSEC_DEF (CIFSSEC_MAY_SIGN | CIFSSEC_MAY_NTLMV2 | CIFSSEC_MAY_NTLMSSP)
-#define   CIFSSEC_MAX (CIFSSEC_MUST_NTLMV2)
-#define   CIFSSEC_AUTH_MASK (CIFSSEC_MAY_NTLMV2 | CIFSSEC_MAY_KRB5 | CIFSSEC_MAY_NTLMSSP)
+#define   CIFSSEC_MAX (CIFSSEC_MUST_SIGN | CIFSSEC_MUST_NTLMV2)
+#define   CIFSSEC_AUTH_MASK (CIFSSEC_MAY_NTLM | CIFSSEC_MAY_NTLMV2 | CIFSSEC_MAY_LANMAN | CIFSSEC_MAY_PLNTXT | CIFSSEC_MAY_KRB5 | CIFSSEC_MAY_NTLMSSP)
 /*
  *****************************************************************
  * All constants go here
@@ -2068,6 +2094,10 @@ static inline char *get_security_type_str(enum securityEnum sectype)
 		return "Kerberos";
 	case NTLMv2:
 		return "NTLMv2";
+	case NTLM:
+		return "NTLM";
+	case LANMAN:
+		return "LANMAN";
 	default:
 		return "Unknown";
 	}
diff --git a/fs/cifs/cifspdu.h b/fs/cifs/cifspdu.h
--- a/fs/cifs/cifspdu.h
+++ b/fs/cifs/cifspdu.h
@@ -13,7 +13,13 @@
 #include <asm/unaligned.h>
 #include "../smbfs_common/smbfsctl.h"
 
+#ifdef CONFIG_CIFS_WEAK_PW_HASH
+#define LANMAN_PROT 0
+#define LANMAN2_PROT 1
+#define CIFS_PROT   2
+#else
 #define CIFS_PROT   0
+#endif
 #define POSIX_PROT  (CIFS_PROT+1)
 #define BAD_PROT 0xFFFF
 
@@ -486,8 +492,30 @@ typedef struct negotiate_req {
 	unsigned char DialectsArray[1];
 } __attribute__((packed)) NEGOTIATE_REQ;
 
+/* Dialect index is 13 for LANMAN */
+
 #define MIN_TZ_ADJ (15 * 60) /* minimum grid for timezones in seconds */
 
+typedef struct lanman_neg_rsp {
+	struct smb_hdr hdr;	/* wct = 13 */
+	__le16 DialectIndex;
+	__le16 SecurityMode;
+	__le16 MaxBufSize;
+	__le16 MaxMpxCount;
+	__le16 MaxNumberVcs;
+	__le16 RawMode;
+	__le32 SessionKey;
+	struct {
+		__le16 Time;
+		__le16 Date;
+	} __attribute__((packed)) SrvTime;
+	__le16 ServerTimeZone;
+	__le16 EncryptionKeyLength;
+	__le16 Reserved;
+	__u16  ByteCount;
+	unsigned char EncryptionKey[1];
+} __attribute__((packed)) LANMAN_NEG_RSP;
+
 #define READ_RAW_ENABLE 1
 #define WRITE_RAW_ENABLE 2
 #define RAW_ENABLE (READ_RAW_ENABLE | WRITE_RAW_ENABLE)
diff --git a/fs/cifs/cifsproto.h b/fs/cifs/cifsproto.h
--- a/fs/cifs/cifsproto.h
+++ b/fs/cifs/cifsproto.h
@@ -209,7 +209,8 @@ extern int cifs_get_inode_info_unix(struct inode **pinode,
 			const unsigned char *search_path,
 			struct super_block *sb, unsigned int xid);
 extern int cifs_set_file_info(struct inode *inode, struct iattr *attrs,
-			      unsigned int xid, const char *full_path, __u32 dosattr);
+			      unsigned int xid, const char *full_path, __u32 dosattr,
+			      __le64 creationtime);
 extern int cifs_rename_pending_delete(const char *full_path,
 				      struct dentry *dentry,
 				      const unsigned int xid);
@@ -509,6 +510,9 @@ extern int cifs_sign_smb(struct smb_hdr *, struct TCP_Server_Info *, __u32 *);
 extern int cifs_verify_signature(struct smb_rqst *rqst,
 				 struct TCP_Server_Info *server,
 				__u32 expected_sequence_number);
+extern int SMBNTencrypt(unsigned char *, unsigned char *, unsigned char *,
+			const struct nls_table *);
+extern int setup_ntlm_response(struct cifs_ses *, const struct nls_table *);
 extern int setup_ntlmv2_rsp(struct cifs_ses *, const struct nls_table *);
 extern void cifs_crypto_secmech_release(struct TCP_Server_Info *server);
 extern int calc_seckey(struct cifs_ses *);
@@ -517,6 +521,10 @@ extern int generate_smb30signingkey(struct cifs_ses *ses,
 extern int generate_smb311signingkey(struct cifs_ses *ses,
 				     struct TCP_Server_Info *server);
 
+#ifdef CONFIG_CIFS_WEAK_PW_HASH
+extern int calc_lanman_hash(const char *password, const char *cryptkey,
+				bool encrypt, char *lnm_session_key);
+#endif /* CIFS_WEAK_PW_HASH */
 #ifdef CONFIG_CIFS_ALLOW_INSECURE_LEGACY
 extern int CIFSSMBCopy(unsigned int xid,
 			struct cifs_tcon *source_tcon,
@@ -555,8 +563,11 @@ extern int check_mf_symlink(unsigned int xid, struct cifs_tcon *tcon,
 			      struct cifs_sb_info *cifs_sb,
 			      struct cifs_fattr *fattr,
 			      const unsigned char *path);
+extern int mdfour(unsigned char *, unsigned char *, int);
 extern int E_md4hash(const unsigned char *passwd, unsigned char *p16,
 			const struct nls_table *codepage);
+extern int SMBencrypt(unsigned char *passwd, const unsigned char *c8,
+			unsigned char *p24);
 
 extern int
 cifs_setup_volume_info(struct smb3_fs_context *ctx, const char *mntopts, const char *devname);
diff --git a/fs/cifs/cifssmb.c b/fs/cifs/cifssmb.c
--- a/fs/cifs/cifssmb.c
+++ b/fs/cifs/cifssmb.c
@@ -40,6 +40,10 @@ static struct {
 	int index;
 	char *name;
 } protocols[] = {
+#ifdef CONFIG_CIFS_WEAK_PW_HASH
+	{LANMAN_PROT, "\2LM1.2X002"},
+	{LANMAN2_PROT, "\2LANMAN2.1"},
+#endif /* weak password hashing for legacy clients */
 	{CIFS_PROT, "\2NT LM 0.12"},
 	{POSIX_PROT, "\2POSIX 2"},
 	{BAD_PROT, "\2"}
@@ -49,6 +53,10 @@ static struct {
 	int index;
 	char *name;
 } protocols[] = {
+#ifdef CONFIG_CIFS_WEAK_PW_HASH
+	{LANMAN_PROT, "\2LM1.2X002"},
+	{LANMAN2_PROT, "\2LANMAN2.1"},
+#endif /* weak password hashing for legacy clients */
 	{CIFS_PROT, "\2NT LM 0.12"},
 	{BAD_PROT, "\2"}
 };
@@ -56,9 +64,17 @@ static struct {
 
 /* define the number of elements in the cifs dialect array */
 #ifdef CONFIG_CIFS_POSIX
+#ifdef CONFIG_CIFS_WEAK_PW_HASH
+#define CIFS_NUM_PROT 4
+#else
 #define CIFS_NUM_PROT 2
+#endif /* CIFS_WEAK_PW_HASH */
 #else /* not posix */
+#ifdef CONFIG_CIFS_WEAK_PW_HASH
+#define CIFS_NUM_PROT 3
+#else
 #define CIFS_NUM_PROT 1
+#endif /* CONFIG_CIFS_WEAK_PW_HASH */
 #endif /* CIFS_POSIX */
 
 
@@ -410,6 +426,89 @@ decode_ext_sec_blob(struct cifs_ses *ses, NEGOTIATE_RSP *pSMBr)
 	return 0;
 }
 
+#ifdef CONFIG_CIFS_WEAK_PW_HASH
+static int
+decode_lanman_negprot_rsp(struct TCP_Server_Info *server, NEGOTIATE_RSP *pSMBr)
+{
+	__s16 tmp;
+	struct lanman_neg_rsp *rsp = (struct lanman_neg_rsp *)pSMBr;
+
+	if (server->dialect != LANMAN_PROT && server->dialect != LANMAN2_PROT)
+		return -EOPNOTSUPP;
+
+	server->sec_mode = le16_to_cpu(rsp->SecurityMode);
+	server->maxReq = min_t(unsigned int,
+			       le16_to_cpu(rsp->MaxMpxCount),
+			       cifs_max_pending);
+	set_credits(server, server->maxReq);
+	server->maxBuf = le16_to_cpu(rsp->MaxBufSize);
+	/* set up max_read for readpages check */
+	server->max_read = server->maxBuf;
+	/* even though we do not use raw we might as well set this
+	accurately, in case we ever find a need for it */
+	if ((le16_to_cpu(rsp->RawMode) & RAW_ENABLE) == RAW_ENABLE) {
+		server->max_rw = 0xFF00;
+		server->capabilities = CAP_MPX_MODE | CAP_RAW_MODE;
+	} else {
+		server->max_rw = 0;/* do not need to use raw anyway */
+		server->capabilities = CAP_MPX_MODE;
+	}
+	tmp = (__s16)le16_to_cpu(rsp->ServerTimeZone);
+	if (tmp == -1) {
+		/* OS/2 often does not set timezone therefore
+		 * we must use server time to calc time zone.
+		 * Could deviate slightly from the right zone.
+		 * Smallest defined timezone difference is 15 minutes
+		 * (i.e. Nepal).  Rounding up/down is done to match
+		 * this requirement.
+		 */
+		int val, seconds, remain, result;
+		struct timespec64 ts;
+		time64_t utc = ktime_get_real_seconds();
+		ts = cnvrtDosUnixTm(rsp->SrvTime.Date,
+				    rsp->SrvTime.Time, 0);
+		cifs_dbg(FYI, "SrvTime %lld sec since 1970 (utc: %lld) diff: %lld\n",
+			 ts.tv_sec, utc,
+			 utc - ts.tv_sec);
+		val = (int)(utc - ts.tv_sec);
+		seconds = abs(val);
+		result = (seconds / MIN_TZ_ADJ) * MIN_TZ_ADJ;
+		remain = seconds % MIN_TZ_ADJ;
+		if (remain >= (MIN_TZ_ADJ / 2))
+			result += MIN_TZ_ADJ;
+		if (val < 0)
+			result = -result;
+		server->timeAdj = result;
+	} else {
+		server->timeAdj = (int)tmp;
+		server->timeAdj *= 60; /* also in seconds */
+	}
+	cifs_dbg(FYI, "server->timeAdj: %d seconds\n", server->timeAdj);
+
+
+	/* BB get server time for time conversions and add
+	code to use it and timezone since this is not UTC */
+
+	if (rsp->EncryptionKeyLength ==
+			cpu_to_le16(CIFS_CRYPTO_KEY_SIZE)) {
+		memcpy(server->cryptkey, rsp->EncryptionKey,
+			CIFS_CRYPTO_KEY_SIZE);
+	} else if (server->sec_mode & SECMODE_PW_ENCRYPT) {
+		return -EIO; /* need cryptkey unless plain text */
+	}
+
+	cifs_dbg(FYI, "LANMAN negotiated\n");
+	return 0;
+}
+#else
+static inline int
+decode_lanman_negprot_rsp(struct TCP_Server_Info *server, NEGOTIATE_RSP *pSMBr)
+{
+	cifs_dbg(VFS, "mount failed, cifs module not built with CIFS_WEAK_PW_HASH support\n");
+	return -EOPNOTSUPP;
+}
+#endif
+
 static bool
 should_set_ext_sec_flag(enum securityEnum sectype)
 {
@@ -479,12 +578,16 @@ CIFSSMBNegotiate(const unsigned int xid,
 	server->dialect = le16_to_cpu(pSMBr->DialectIndex);
 	cifs_dbg(FYI, "Dialect: %d\n", server->dialect);
 	/* Check wct = 1 error case */
-	if ((pSMBr->hdr.WordCount <= 13) || (server->dialect == BAD_PROT)) {
+	if ((pSMBr->hdr.WordCount < 13) || (server->dialect == BAD_PROT)) {
 		/* core returns wct = 1, but we do not ask for core - otherwise
 		small wct just comes when dialect index is -1 indicating we
 		could not negotiate a common dialect */
 		rc = -EOPNOTSUPP;
 		goto neg_err_exit;
+	} else if (pSMBr->hdr.WordCount == 13) {
+		server->negflavor = CIFS_NEGFLAVOR_LANMAN;
+		rc = decode_lanman_negprot_rsp(server, pSMBr);
+		goto signing_check;
 	} else if (pSMBr->hdr.WordCount != 17) {
 		/* unknown wct */
 		rc = -EOPNOTSUPP;
@@ -526,6 +629,7 @@ CIFSSMBNegotiate(const unsigned int xid,
 		server->capabilities &= ~CAP_EXTENDED_SECURITY;
 	}
 
+signing_check:
 	if (!rc)
 		rc = cifs_enable_signing(server, ses->sign);
 neg_err_exit:
diff --git a/fs/cifs/connect.c b/fs/cifs/connect.c
--- a/fs/cifs/connect.c
+++ b/fs/cifs/connect.c
@@ -1464,8 +1464,12 @@ static int match_server(struct TCP_Server_Info *server, struct smb3_fs_context *
 		   SMBDEFAULT_VERSION_STRING) == 0) {
 		if (server->vals->protocol_id < SMB21_PROT_ID)
 			return 0;
-	} else if ((server->vals != ctx->vals) || (server->ops != ctx->ops))
+	} else if ((server->vals != ctx->vals) || (server->ops != ctx->ops)) {
 		return 0;
+	} else if (server->volUNC != ctx->UNC ) { /* intentional POINTER test */
+		return 0;
+	}
+
 
 	if (!net_eq(cifs_net_ns(server), current->nsproxy->net_ns))
 		return 0;
@@ -1621,6 +1625,7 @@ cifs_get_tcp_session(struct smb3_fs_context *ctx,
 
 	tcp_ses->ops = ctx->ops;
 	tcp_ses->vals = ctx->vals;
+	tcp_ses->volUNC = ctx->UNC;
 	cifs_set_net_ns(tcp_ses, get_net(current->nsproxy->net_ns));
 
 	tcp_ses->conn_id = atomic_inc_return(&tcpSesNextId);
diff --git a/fs/cifs/file.c b/fs/cifs/file.c
--- a/fs/cifs/file.c
+++ b/fs/cifs/file.c
@@ -263,8 +263,11 @@ cifs_nt_open(const char *full_path, struct inode *inode, struct cifs_sb_info *ci
 	if (f_flags & O_SYNC)
 		create_options |= CREATE_WRITE_THROUGH;
 
+#if 0
+// NO_BUFFER means no intermediate buffering is allowed, which prohibits short writes on servers that care
 	if (f_flags & O_DIRECT)
 		create_options |= CREATE_NO_BUFFER;
+#endif
 
 	oparms.tcon = tcon;
 	oparms.cifs_sb = cifs_sb;
diff --git a/fs/cifs/fs_context.c b/fs/cifs/fs_context.c
--- a/fs/cifs/fs_context.c
+++ b/fs/cifs/fs_context.c
@@ -59,9 +59,12 @@ static const match_table_t cifs_secflavor_tokens = {
 	{ Opt_sec_krb5p, "krb5p" },
 	{ Opt_sec_ntlmsspi, "ntlmsspi" },
 	{ Opt_sec_ntlmssp, "ntlmssp" },
+	{ Opt_ntlm, "ntlm" },
+	{ Opt_sec_ntlmi, "ntlmi" },
 	{ Opt_sec_ntlmv2, "nontlm" },
 	{ Opt_sec_ntlmv2, "ntlmv2" },
 	{ Opt_sec_ntlmv2i, "ntlmv2i" },
+	{ Opt_sec_lanman, "lanman" },
 	{ Opt_sec_none, "none" },
 
 	{ Opt_sec_err, NULL }
@@ -223,12 +226,23 @@ cifs_parse_security_flavors(struct fs_context *fc, char *value, struct smb3_fs_c
 	case Opt_sec_ntlmssp:
 		ctx->sectype = RawNTLMSSP;
 		break;
+	case Opt_sec_ntlmi:
+		ctx->sign = true;
+		fallthrough;
+	case Opt_ntlm:
+		ctx->sectype = NTLM;
+		break;
 	case Opt_sec_ntlmv2i:
 		ctx->sign = true;
 		fallthrough;
 	case Opt_sec_ntlmv2:
 		ctx->sectype = NTLMv2;
 		break;
+#ifdef CONFIG_CIFS_WEAK_PW_HASH
+	case Opt_sec_lanman:
+		ctx->sectype = LANMAN;
+		break;
+#endif
 	case Opt_sec_none:
 		ctx->nullauth = 1;
 		break;
@@ -642,8 +656,10 @@ static int smb3_fs_context_validate(struct fs_context *fc)
 	}
 #endif
 
+#if 0
 	if (ctx->got_version == false)
 		pr_warn_once("No dialect specified on mount. Default has changed to a more secure dialect, SMB2.1 or later (e.g. SMB3.1.1), from CIFS (SMB1). To use the less secure SMB1 dialect to access old servers which do not support SMB3.1.1 (or even SMB3 or SMB2.1) specify vers=1.0 on mount.\n");
+#endif	/* 0 */
 
 
 	if (!ctx->UNC) {
diff --git a/fs/cifs/fs_context.h b/fs/cifs/fs_context.h
--- a/fs/cifs/fs_context.h
+++ b/fs/cifs/fs_context.h
@@ -47,8 +47,11 @@ enum cifs_sec_param {
 	Opt_sec_krb5p,
 	Opt_sec_ntlmsspi,
 	Opt_sec_ntlmssp,
+	Opt_ntlm,
+	Opt_sec_ntlmi,
 	Opt_sec_ntlmv2,
 	Opt_sec_ntlmv2i,
+	Opt_sec_lanman,
 	Opt_sec_none,
 
 	Opt_sec_err
diff --git a/fs/cifs/inode.c b/fs/cifs/inode.c
--- a/fs/cifs/inode.c
+++ b/fs/cifs/inode.c
@@ -1403,7 +1403,7 @@ struct inode *cifs_root_iget(struct super_block *sb)
 
 int
 cifs_set_file_info(struct inode *inode, struct iattr *attrs, unsigned int xid,
-		   const char *full_path, __u32 dosattr)
+		   const char *full_path, __u32 dosattr, __le64 creationtime)
 {
 	bool set_time = false;
 	struct cifs_sb_info *cifs_sb = CIFS_SB(inode->i_sb);
@@ -1446,7 +1446,7 @@ cifs_set_file_info(struct inode *inode, struct iattr *attrs, unsigned int xid,
 	} else
 		info_buf.ChangeTime = 0;
 
-	info_buf.CreationTime = 0;	/* don't change */
+	info_buf.CreationTime = creationtime;   /* don't change, if 0 */
 	info_buf.Attributes = cpu_to_le32(dosattr);
 
 	return server->ops->set_file_info(inode, full_path, &info_buf, xid);
@@ -1696,7 +1696,7 @@ int cifs_unlink(struct inode *dir, struct dentry *dentry)
 			dosattr |= ATTR_NORMAL;
 		dosattr |= ATTR_HIDDEN;
 
-		rc = cifs_set_file_info(inode, attrs, xid, full_path, dosattr);
+		rc = cifs_set_file_info(inode, attrs, xid, full_path, dosattr, 0);
 		if (rc != 0)
 			goto out_reval;
 
@@ -1705,7 +1705,7 @@ int cifs_unlink(struct inode *dir, struct dentry *dentry)
 
 	/* undo the setattr if we errored out and it's needed */
 	if (rc != 0 && dosattr != 0)
-		cifs_set_file_info(inode, attrs, xid, full_path, origattr);
+		cifs_set_file_info(inode, attrs, xid, full_path, origattr, 0);
 
 out_reval:
 	if (inode) {
@@ -3004,7 +3004,7 @@ cifs_setattr_nounix(struct dentry *direntry, struct iattr *attrs)
 
 	if (attrs->ia_valid & (ATTR_MTIME|ATTR_ATIME|ATTR_CTIME) ||
 	    ((attrs->ia_valid & ATTR_MODE) && dosattr)) {
-		rc = cifs_set_file_info(inode, attrs, xid, full_path, dosattr);
+		rc = cifs_set_file_info(inode, attrs, xid, full_path, dosattr, 0);
 		/* BB: check for rc = -EOPNOTSUPP and switch to legacy mode */
 
 		/* Even if error on time set, no sense failing the call if
diff --git a/fs/cifs/ioctl.c b/fs/cifs/ioctl.c
--- a/fs/cifs/ioctl.c
+++ b/fs/cifs/ioctl.c
@@ -68,6 +68,85 @@ static long cifs_ioctl_query_info(unsigned int xid, struct file *filep,
 	return rc;
 }
 
+
+static long cifs_ioctl_query_reparse_attrs(unsigned int xid, struct file *filep, void __user *arg)
+{
+	struct inode *inode = file_inode(filep);
+	struct cifs_sb_info *cifs_sb = CIFS_SB(inode->i_sb);
+	struct cifs_tcon *tcon = cifs_sb_master_tcon(cifs_sb);
+	struct dentry *dentry = filep->f_path.dentry;
+
+	const unsigned char *dirpath = NULL;
+	unsigned char *targetpath = NULL;
+	struct ioctl_smb_query_attrs *qap = NULL;
+
+	int rc = 0;
+	size_t dirlen, inlen, tlen;
+	void *page = alloc_dentry_path();
+
+	qap = kzalloc(sizeof(struct ioctl_smb_query_attrs), GFP_KERNEL);
+	if (qap == NULL) {
+		rc = -ENOMEM;
+		goto done;
+	}
+        if (copy_from_user(qap, arg, sizeof(*qap))) {
+                rc = -EFAULT;
+                goto done;
+        }
+	dirpath = build_path_from_dentry(dentry, page);
+	if (IS_ERR(dirpath)){
+		rc = PTR_ERR(dirpath);
+		goto done;
+	}
+	dirlen = strlen(dirpath);
+
+	if (!*qap->in_filename) {
+		rc = -EINVAL;
+		goto done;
+	}
+	qap->in_filename[sizeof(qap->in_filename)-1] = 0;
+	inlen = strlen(qap->in_filename);
+
+	tlen = dirlen + inlen + 2;			// room for 0 byte + possible backslash + 1 extra.
+	targetpath = kzalloc(tlen, GFP_KERNEL);
+	if (targetpath == NULL) {
+		rc = -ENOMEM;
+		goto done;
+	}
+
+	if (dirlen) {
+		strncpy(targetpath, dirpath, dirlen);
+		targetpath[dirlen] = '\\';
+		dirlen++;
+	}
+	if (inlen) {
+	    strncpy(&targetpath[dirlen], qap->in_filename, inlen);
+	}
+
+	/*pr_info("GETATTRS PATH %s", targetpath);*/
+
+	if (tcon->ses->server->ops->get_reparse_attrs)
+		rc = tcon->ses->server->ops->get_reparse_attrs(xid, tcon, cifs_sb, targetpath, &qap->out_attrs);
+	else
+		rc = -EOPNOTSUPP;
+	if (rc)
+		goto done;
+
+	qap->out_didset= 1;
+
+	if (copy_to_user(arg, qap, sizeof(*qap))) {
+		rc = -EFAULT;
+		goto done;
+	}
+
+done:
+	if (page)	free_dentry_path(page);
+	if (qap)	kfree(qap);
+	if (targetpath) kfree(targetpath);
+	return rc;
+}
+
+
 static long cifs_ioctl_copychunk(unsigned int xid, struct file *dst_file,
 			unsigned long srcfd)
 {
@@ -327,6 +406,10 @@ long cifs_ioctl(struct file *filep, unsigned int command, unsigned long arg)
 
 	cifs_dbg(FYI, "cifs ioctl 0x%x\n", command);
 	switch (command) {
+		case CIFS_GET_ATTRS:
+			rc = cifs_ioctl_query_reparse_attrs(xid, filep, (void __user *)arg);
+			/*pr_info("GETATTRS, %d", rc);*/
+			break;
 		case FS_IOC_GETFLAGS:
 			if (pSMBFile == NULL)
 				break;
@@ -494,7 +577,7 @@ long cifs_ioctl(struct file *filep, unsigned int command, unsigned long arg)
 			rc = cifs_shutdown(inode->i_sb, arg);
 			break;
 		default:
-			cifs_dbg(FYI, "unsupported ioctl\n");
+			cifs_dbg(FYI, "unsupported ioctl 0x%08x\n", command);
 			break;
 	}
 cifs_ioc_exit:
diff --git a/fs/cifs/misc.c b/fs/cifs/misc.c
--- a/fs/cifs/misc.c
+++ b/fs/cifs/misc.c
@@ -526,8 +526,10 @@ cifs_autodisable_serverino(struct cifs_sb_info *cifs_sb)
 		cifs_sb->mnt_cifs_serverino_autodisabled = true;
 		cifs_dbg(VFS, "Autodisabling the use of server inode numbers on %s\n",
 			 tcon ? tcon->treeName : "new server");
+#if 0
 		cifs_dbg(VFS, "The server doesn't seem to support them properly or the files might be on different servers (DFS)\n");
 		cifs_dbg(VFS, "Hardlinks will not be recognized on this mount. Consider mounting with the \"noserverino\" option to silence this message.\n");
+#endif	/* 0 */
 
 	}
 }
diff --git a/fs/cifs/sess.c b/fs/cifs/sess.c
--- a/fs/cifs/sess.c
+++ b/fs/cifs/sess.c
@@ -1138,16 +1138,30 @@ cifs_select_sectype(struct TCP_Server_Info *server, enum securityEnum requested)
 		}
 	case CIFS_NEGFLAVOR_UNENCAP:
 		switch (requested) {
+		case NTLM:
 		case NTLMv2:
 			return requested;
 		case Unspecified:
 			if (global_secflags & CIFSSEC_MAY_NTLMV2)
 				return NTLMv2;
+			if (global_secflags & CIFSSEC_MAY_NTLM)
+				return NTLM;
 			break;
 		default:
 			break;
 		}
-		fallthrough;
+		fallthrough;	/* to attempt LANMAN authentication next */
+	case CIFS_NEGFLAVOR_LANMAN:
+		switch (requested) {
+		case LANMAN:
+			return requested;
+		case Unspecified:
+			if (global_secflags & CIFSSEC_MAY_LANMAN)
+				return LANMAN;
+			fallthrough;
+		default:
+			return Unspecified;
+		}
 	default:
 		return Unspecified;
 	}
@@ -1270,6 +1284,232 @@ sess_sendreceive(struct sess_data *sess_data)
 	return rc;
 }
 
+/*
+ * LANMAN and plaintext are less secure and off by default.
+ * So we make this explicitly be turned on in kconfig (in the
+ * build) and turned on at runtime (changed from the default)
+ * in proc/fs/cifs or via mount parm.  Unfortunately this is
+ * needed for old Win (e.g. Win95), some obscure NAS and OS/2
+ */
+#ifdef CONFIG_CIFS_WEAK_PW_HASH
+static void
+sess_auth_lanman(struct sess_data *sess_data)
+{
+	int rc = 0;
+	struct smb_hdr *smb_buf;
+	SESSION_SETUP_ANDX *pSMB;
+	char *bcc_ptr;
+	struct cifs_ses *ses = sess_data->ses;
+	char lnm_session_key[CIFS_AUTH_RESP_SIZE];
+	__u16 bytes_remaining;
+	struct TCP_Server_Info *server = sess_data->server;
+
+	/* lanman 2 style sessionsetup */
+	/* wct = 10 */
+	rc = sess_alloc_buffer(sess_data, 10);
+	if (rc)
+		goto out;
+
+	pSMB = (SESSION_SETUP_ANDX *)sess_data->iov[0].iov_base;
+	bcc_ptr = sess_data->iov[2].iov_base;
+	(void)cifs_ssetup_hdr(ses, server, pSMB);
+
+	pSMB->req.hdr.Flags2 &= ~SMBFLG2_UNICODE;
+
+	if (ses->user_name != NULL) {
+		/* no capabilities flags in old lanman negotiation */
+		pSMB->old_req.PasswordLength = cpu_to_le16(CIFS_AUTH_RESP_SIZE);
+
+		/* Calculate hash with password and copy into bcc_ptr.
+		 * Encryption Key (stored as in cryptkey) gets used if the
+		 * security mode bit in Negotiate Protocol response states
+		 * to use challenge/response method (i.e. Password bit is 1).
+		 */
+		rc = calc_lanman_hash(ses->password, ses->server->cryptkey,
+				      ses->server->sec_mode & SECMODE_PW_ENCRYPT ?
+				      true : false, lnm_session_key);
+		if (rc)
+			goto out;
+
+		memcpy(bcc_ptr, (char *)lnm_session_key, CIFS_AUTH_RESP_SIZE);
+		bcc_ptr += CIFS_AUTH_RESP_SIZE;
+	} else {
+		pSMB->old_req.PasswordLength = 0;
+	}
+
+	/*
+	 * can not sign if LANMAN negotiated so no need
+	 * to calculate signing key? but what if server
+	 * changed to do higher than lanman dialect and
+	 * we reconnected would we ever calc signing_key?
+	 */
+
+	cifs_dbg(FYI, "Negotiating LANMAN setting up strings\n");
+	/* Unicode not allowed for LANMAN dialects */
+	ascii_ssetup_strings(&bcc_ptr, ses, sess_data->nls_cp);
+
+	sess_data->iov[2].iov_len = (long) bcc_ptr -
+			(long) sess_data->iov[2].iov_base;
+
+	rc = sess_sendreceive(sess_data);
+	if (rc)
+		goto out;
+
+	pSMB = (SESSION_SETUP_ANDX *)sess_data->iov[0].iov_base;
+	smb_buf = (struct smb_hdr *)sess_data->iov[0].iov_base;
+
+	/* lanman response has a word count of 3 */
+	if (smb_buf->WordCount != 3) {
+		rc = -EIO;
+		cifs_dbg(VFS, "bad word count %d\n", smb_buf->WordCount);
+		goto out;
+	}
+
+	if (le16_to_cpu(pSMB->resp.Action) & GUEST_LOGIN)
+		cifs_dbg(FYI, "Guest login\n"); /* BB mark SesInfo struct? */
+
+	ses->Suid = smb_buf->Uid;   /* UID left in wire format (le) */
+	cifs_dbg(FYI, "UID = %llu\n", ses->Suid);
+
+	bytes_remaining = get_bcc(smb_buf);
+	bcc_ptr = pByteArea(smb_buf);
+
+	/* BB check if Unicode and decode strings */
+	if (bytes_remaining == 0) {
+		/* no string area to decode, do nothing */
+	} else if (smb_buf->Flags2 & SMBFLG2_UNICODE) {
+		/* unicode string area must be word-aligned */
+		if (((unsigned long) bcc_ptr - (unsigned long) smb_buf) % 2) {
+			++bcc_ptr;
+			--bytes_remaining;
+		}
+		decode_unicode_ssetup(&bcc_ptr, bytes_remaining, ses,
+				      sess_data->nls_cp);
+	} else {
+		decode_ascii_ssetup(&bcc_ptr, bytes_remaining, ses,
+				    sess_data->nls_cp);
+	}
+
+	rc = sess_establish_session(sess_data);
+out:
+	sess_data->result = rc;
+	sess_data->func = NULL;
+	sess_free_buffer(sess_data);
+}
+
+#endif
+
+static void
+sess_auth_ntlm(struct sess_data *sess_data)
+{
+	int rc = 0;
+	struct smb_hdr *smb_buf;
+	SESSION_SETUP_ANDX *pSMB;
+	char *bcc_ptr;
+	struct cifs_ses *ses = sess_data->ses;
+	__u32 capabilities;
+	__u16 bytes_remaining;
+	struct TCP_Server_Info *server = sess_data->server;
+
+	/* old style NTLM sessionsetup */
+	/* wct = 13 */
+	rc = sess_alloc_buffer(sess_data, 13);
+	if (rc)
+		goto out;
+
+	pSMB = (SESSION_SETUP_ANDX *)sess_data->iov[0].iov_base;
+	bcc_ptr = sess_data->iov[2].iov_base;
+	capabilities = cifs_ssetup_hdr(ses, server, pSMB);
+
+	pSMB->req_no_secext.Capabilities = cpu_to_le32(capabilities);
+	if (ses->user_name != NULL) {
+		pSMB->req_no_secext.CaseInsensitivePasswordLength =
+				cpu_to_le16(CIFS_AUTH_RESP_SIZE);
+		pSMB->req_no_secext.CaseSensitivePasswordLength =
+				cpu_to_le16(CIFS_AUTH_RESP_SIZE);
+
+		/* calculate ntlm response and session key */
+		rc = setup_ntlm_response(ses, sess_data->nls_cp);
+		if (rc) {
+			cifs_dbg(VFS, "Error %d during NTLM authentication\n",
+					 rc);
+			goto out;
+		}
+
+		/* copy ntlm response */
+		memcpy(bcc_ptr, ses->auth_key.response + CIFS_SESS_KEY_SIZE,
+				CIFS_AUTH_RESP_SIZE);
+		bcc_ptr += CIFS_AUTH_RESP_SIZE;
+		memcpy(bcc_ptr, ses->auth_key.response + CIFS_SESS_KEY_SIZE,
+				CIFS_AUTH_RESP_SIZE);
+		bcc_ptr += CIFS_AUTH_RESP_SIZE;
+	} else {
+		pSMB->req_no_secext.CaseInsensitivePasswordLength = 0;
+		pSMB->req_no_secext.CaseSensitivePasswordLength = 0;
+	}
+
+	if (ses->capabilities & CAP_UNICODE) {
+		/* unicode strings must be word aligned */
+		if (sess_data->iov[0].iov_len % 2) {
+			*bcc_ptr = 0;
+			bcc_ptr++;
+		}
+		unicode_ssetup_strings(&bcc_ptr, ses, sess_data->nls_cp);
+	} else {
+		ascii_ssetup_strings(&bcc_ptr, ses, sess_data->nls_cp);
+	}
+
+
+	sess_data->iov[2].iov_len = (long) bcc_ptr -
+			(long) sess_data->iov[2].iov_base;
+
+	rc = sess_sendreceive(sess_data);
+	if (rc)
+		goto out;
+
+	pSMB = (SESSION_SETUP_ANDX *)sess_data->iov[0].iov_base;
+	smb_buf = (struct smb_hdr *)sess_data->iov[0].iov_base;
+
+	if (smb_buf->WordCount != 3) {
+		rc = -EIO;
+		cifs_dbg(VFS, "bad word count %d\n", smb_buf->WordCount);
+		goto out;
+	}
+
+	if (le16_to_cpu(pSMB->resp.Action) & GUEST_LOGIN)
+		cifs_dbg(FYI, "Guest login\n"); /* BB mark SesInfo struct? */
+
+	ses->Suid = smb_buf->Uid;   /* UID left in wire format (le) */
+	cifs_dbg(FYI, "UID = %llu\n", ses->Suid);
+
+	bytes_remaining = get_bcc(smb_buf);
+	bcc_ptr = pByteArea(smb_buf);
+
+	/* BB check if Unicode and decode strings */
+	if (bytes_remaining == 0) {
+		/* no string area to decode, do nothing */
+	} else if (smb_buf->Flags2 & SMBFLG2_UNICODE) {
+		/* unicode string area must be word-aligned */
+		if (((unsigned long) bcc_ptr - (unsigned long) smb_buf) % 2) {
+			++bcc_ptr;
+			--bytes_remaining;
+		}
+		decode_unicode_ssetup(&bcc_ptr, bytes_remaining, ses,
+				      sess_data->nls_cp);
+	} else {
+		decode_ascii_ssetup(&bcc_ptr, bytes_remaining, ses,
+				    sess_data->nls_cp);
+	}
+
+	rc = sess_establish_session(sess_data);
+out:
+	sess_data->result = rc;
+	sess_data->func = NULL;
+	sess_free_buffer(sess_data);
+	kfree(ses->auth_key.response);
+	ses->auth_key.response = NULL;
+}
+
 static void
 sess_auth_ntlmv2(struct sess_data *sess_data)
 {
@@ -1791,6 +2031,21 @@ static int select_sec(struct sess_data *sess_data)
 	}
 
 	switch (type) {
+	case LANMAN:
+		/* LANMAN and plaintext are less secure and off by default.
+		 * So we make this explicitly be turned on in kconfig (in the
+		 * build) and turned on at runtime (changed from the default)
+		 * in proc/fs/cifs or via mount parm.  Unfortunately this is
+		 * needed for old Win (e.g. Win95), some obscure NAS and OS/2 */
+#ifdef CONFIG_CIFS_WEAK_PW_HASH
+		sess_data->func = sess_auth_lanman;
+		break;
+#else
+		return -EOPNOTSUPP;
+#endif
+	case NTLM:
+		sess_data->func = sess_auth_ntlm;
+		break;
 	case NTLMv2:
 		sess_data->func = sess_auth_ntlmv2;
 		break;
diff --git a/fs/cifs/smb1ops.c b/fs/cifs/smb1ops.c
--- a/fs/cifs/smb1ops.c
+++ b/fs/cifs/smb1ops.c
@@ -592,6 +592,25 @@ cifs_query_path_info(const unsigned int xid, struct cifs_tcon *tcon,
 	return rc;
 }
 
+
+static int
+cifs_get_reparse_attrs(unsigned xid, struct cifs_tcon *tcon, struct cifs_sb_info *cifs_sb, const char *full_path, __u32 *out_attrs)
+{
+	int rc;
+
+	FILE_ALL_INFO *data = kmalloc(sizeof(FILE_ALL_INFO), GFP_KERNEL);
+	if (!data)
+		return -ENOMEM;
+
+	rc = CIFSSMBQPathInfo(xid, tcon, full_path, data, 0 /* not legacy */, cifs_sb->local_nls, cifs_remap(cifs_sb));
+
+	*out_attrs = le32_to_cpu(data->Attributes);
+
+	kfree(data);
+	return rc;
+}
+
+
 static int
 cifs_get_srv_inum(const unsigned int xid, struct cifs_tcon *tcon,
 		  struct cifs_sb_info *cifs_sb, const char *full_path,
@@ -1234,6 +1253,7 @@ struct smb_version_operations smb1_operations = {
 	.get_acl_by_fid = get_cifs_acl_by_fid,
 	.set_acl = set_cifs_acl,
 	.make_node = cifs_make_node,
+	.get_reparse_attrs = cifs_get_reparse_attrs,
 };
 
 struct smb_version_values smb1_values = {
diff --git a/fs/cifs/smb2inode.c b/fs/cifs/smb2inode.c
--- a/fs/cifs/smb2inode.c
+++ b/fs/cifs/smb2inode.c
@@ -47,6 +47,20 @@ struct cop_vars {
 	struct smb2_file_link_info link_info;
 };
 
+#define NREQ 8
+struct cop202_vars {
+	struct cifs_open_parms oparms_202;
+	struct kvec rsp_iov_202[NREQ];
+	struct smb_rqst rqst_202[NREQ];
+	struct kvec open_iov_202[SMB2_CREATE_IOV_SIZE];
+	struct kvec qi_iov_202[NREQ];
+	struct kvec si_iov_202[SMB2_SET_INFO_IOV_SIZE];
+	struct kvec close_iov_202[1];
+	struct smb2_file_rename_info rename_info_202;
+	struct smb2_file_link_info link_info_202;
+	int resp_buftype_202[NREQ];
+};
+
 /*
  * note: If cfile is passed, the reference to it is dropped here.
  * So make sure that you do not reuse cfile after return from this func.
@@ -611,6 +625,603 @@ smb311_posix_query_path_info(const unsigned int xid, struct cifs_tcon *tcon,
 	return rc;
 }
 
+
+/* ****************************** */
+/* ****************************** */
+
+#define NREQ_202 8
+static int
+smb202_compound_op(const unsigned int xid, struct cifs_tcon *tcon,
+		 struct cifs_sb_info *cifs_sb, const char *full_path,
+		 __u32 desired_access, __u32 create_disposition,
+		 __u32 create_options, umode_t mode, void *ptr, int command,
+		 struct cifsFileInfo *cfile)
+{
+	struct cop202_vars *vars_202 = NULL;
+	struct kvec *rsp_iov_202;			/* Pointer to rsp_iov in cop202_vars */
+	struct smb_rqst *rast_202;			/* Pointer to rqst in cop202_vars */
+	int rc;
+	__le16 *utf16_path = NULL;
+	__u8 oplock = SMB2_OPLOCK_LEVEL_NONE;
+	struct cifs_fid fid;
+	struct cifs_ses *ses = tcon->ses;
+	struct TCP_Server_Info *server;
+	int num_rqst = 0;
+	int *resp_buftype;			/* Pointer to resp_buftype in cop202_vars */
+	int flags = 0;
+	__u8 delete_pending[8] = {1, 0, 0, 0, 0, 0, 0, 0};
+	unsigned int size[2];
+	void *data[2];
+	int len;
+	int nc = 0;
+
+	vars_202 = kzalloc(sizeof(*vars_202), GFP_ATOMIC);
+	if (vars_202 == NULL) {
+		return -ENOMEM;
+	}
+	rast_202 = &vars_202->rqst_202[0];
+	rsp_iov_202 = &vars_202->rsp_iov_202[0];
+
+	server = cifs_pick_channel(ses);
+
+	if (smb3_encryption_required(tcon))
+		flags |= CIFS_TRANSFORM_REQ;
+
+	resp_buftype = &vars_202->resp_buftype_202[0];
+	for (nc = 0; nc < NREQ_202; nc++)
+	{
+		resp_buftype[nc] = CIFS_NO_BUFFER;
+	}
+
+	/* We already have a handle so we can skip the open */
+	if (cfile)
+		goto after_open;
+
+	/* Open */
+	utf16_path = cifs_convert_path_to_utf16(full_path, cifs_sb);
+	if (!utf16_path) {
+		rc = -ENOMEM;
+		goto finished;
+	}
+
+	vars_202->oparms_202.tcon = tcon;
+	vars_202->oparms_202.desired_access = desired_access;
+	vars_202->oparms_202.disposition = create_disposition;
+	vars_202->oparms_202.create_options = create_options;
+	if (backup_cred(cifs_sb))
+		vars_202->oparms_202.create_options |= CREATE_OPEN_BACKUP_INTENT;
+	vars_202->oparms_202.fid = &fid;
+	vars_202->oparms_202.reconnect = false;
+	vars_202->oparms_202.mode = mode;
+	vars_202->oparms_202.cifs_sb = cifs_sb;
+
+	rast_202[num_rqst].rq_iov = &vars_202->open_iov_202[0];
+	rast_202[num_rqst].rq_nvec = SMB2_CREATE_IOV_SIZE;
+	rc = SMB2_open_init(tcon, server,
+			    &rast_202[num_rqst], &oplock, &vars_202->oparms_202,
+			    utf16_path);
+	kfree(utf16_path);
+	if (rc)
+		goto finished;
+
+	smb2_set_next_command(tcon, &rast_202[num_rqst]);
+ after_open:
+	num_rqst++;
+	rc = 0;
+
+	/* Operation */
+	switch (command) {
+
+#define _X202(_w1, _w2)										  \
+	if (num_rqst >= NREQ_202) {								  \
+		cifs_dbg(FYI, "TOO MANY %d\n", num_rqst); rc = -96; goto finished;		  \
+	}											  \
+	rast_202[num_rqst].rq_iov = &vars_202->qi_iov_202[0] + num_rqst;			  \
+	rast_202[num_rqst].rq_nvec = 1;								  \
+	if (cfile) {										  \
+		rc = SMB2_query_info_init(tcon, server, &rast_202[num_rqst],			  \
+					  cfile->fid.persistent_fid, cfile->fid.volatile_fid,	  \
+					  _w1, SMB2_O_INFO_FILE, 0, sizeof(struct _w2), 0, NULL); \
+	} else {										  \
+		rc = SMB2_query_info_init(tcon, server, &rast_202[num_rqst],			  \
+					  COMPOUND_FID, COMPOUND_FID,				  \
+					  _w1, SMB2_O_INFO_FILE, 0, sizeof(struct _w2), 0, NULL); \
+		if (!rc) {									  \
+			smb2_set_next_command(tcon, &rast_202[num_rqst]);			  \
+			smb2_set_related(&rast_202[num_rqst]);					  \
+		}										  \
+	}											  \
+	if (rc)											  \
+		goto finished;									  \
+	num_rqst++;
+/* End of #define _X202 */
+	case SMB2_OP_QUERY_INFO:
+		_X202(FILE_BASIC_INFORMATION,		smb2_file_basic_info);
+		_X202(FILE_STANDARD_INFORMATION,	smb2_file_standard_info);
+		_X202(FILE_INTERNAL_INFORMATION,	smb2_file_internal_info);
+		_X202(FILE_EA_INFORMATION,		smb2_file_ea_info);
+		_X202(FILE_ACCESS_INFORMATION,		smb2_file_access_info);
+		_X202(FILE_MODE_INFORMATION,		smb2_file_mode_info);
+#undef _X202
+		if (num_rqst != NREQ_202-1) {
+			cifs_dbg(FYI, "MISMATCH %d\n", num_rqst); rc = -96; goto finished;
+		}
+		trace_smb3_query_info_compound_enter(xid, ses->Suid, tcon->tid, full_path);
+		break;
+	case SMB2_OP_DELETE:
+		trace_smb3_delete_enter(xid, ses->Suid, tcon->tid, full_path);
+		break;
+	case SMB2_OP_MKDIR:
+		/*
+		 * Directories are created through parameters in the
+		 * SMB2_open() call.
+		 */
+		trace_smb3_mkdir_enter(xid, ses->Suid, tcon->tid, full_path);
+		break;
+	case SMB2_OP_RMDIR:
+		rast_202[num_rqst].rq_iov = &vars_202->si_iov_202[0];
+		rast_202[num_rqst].rq_nvec = 1;
+
+		size[0] = 1; /* sizeof __u8 See MS-FSCC section 2.4.11 */
+		data[0] = &delete_pending[0];
+
+		rc = SMB2_set_info_init(tcon, server,
+					&rast_202[num_rqst], COMPOUND_FID,
+					COMPOUND_FID, current->tgid,
+					FILE_DISPOSITION_INFORMATION,
+					SMB2_O_INFO_FILE, 0, data, size);
+		if (rc)
+			goto finished;
+		smb2_set_next_command(tcon, &rast_202[num_rqst]);
+		smb2_set_related(&rast_202[num_rqst++]);
+		trace_smb3_rmdir_enter(xid, ses->Suid, tcon->tid, full_path);
+		break;
+	case SMB2_OP_SET_EOF:
+		rast_202[num_rqst].rq_iov = &vars_202->si_iov_202[0];
+		rast_202[num_rqst].rq_nvec = 1;
+
+		size[0] = 8; /* sizeof __le64 */
+		data[0] = ptr;
+
+		rc = SMB2_set_info_init(tcon, server,
+					&rast_202[num_rqst], COMPOUND_FID,
+					COMPOUND_FID, current->tgid,
+					FILE_END_OF_FILE_INFORMATION,
+					SMB2_O_INFO_FILE, 0, data, size);
+		if (rc)
+			goto finished;
+		smb2_set_next_command(tcon, &rast_202[num_rqst]);
+		smb2_set_related(&rast_202[num_rqst++]);
+		trace_smb3_set_eof_enter(xid, ses->Suid, tcon->tid, full_path);
+		break;
+	case SMB2_OP_SET_INFO:
+		rast_202[num_rqst].rq_iov = &vars_202->si_iov_202[0];
+		rast_202[num_rqst].rq_nvec = 1;
+
+		size[0] = sizeof(FILE_BASIC_INFO);
+		data[0] = ptr;
+
+		if (cfile)
+			rc = SMB2_set_info_init(tcon, server,
+					&rast_202[num_rqst],
+					cfile->fid.persistent_fid,
+					cfile->fid.volatile_fid, current->tgid,
+					FILE_BASIC_INFORMATION,
+					SMB2_O_INFO_FILE, 0, data, size);
+		else {
+			rc = SMB2_set_info_init(tcon, server,
+					&rast_202[num_rqst],
+					COMPOUND_FID,
+					COMPOUND_FID, current->tgid,
+					FILE_BASIC_INFORMATION,
+					SMB2_O_INFO_FILE, 0, data, size);
+			if (!rc) {
+				smb2_set_next_command(tcon, &rast_202[num_rqst]);
+				smb2_set_related(&rast_202[num_rqst]);
+			}
+		}
+
+		if (rc)
+			goto finished;
+		num_rqst++;
+		trace_smb3_set_info_compound_enter(xid, ses->Suid, tcon->tid,
+						   full_path);
+		break;
+	case SMB2_OP_RENAME:
+		rast_202[num_rqst].rq_iov = &vars_202->si_iov_202[0];
+		rast_202[num_rqst].rq_nvec = 2;
+
+		len = (2 * UniStrnlen((wchar_t *)ptr, PATH_MAX));
+
+		vars_202->rename_info_202.ReplaceIfExists = 1;
+		vars_202->rename_info_202.RootDirectory = 0;
+		vars_202->rename_info_202.FileNameLength = cpu_to_le32(len);
+
+		size[0] = sizeof(struct smb2_file_rename_info);
+		data[0] = &vars_202->rename_info_202;
+
+		size[1] = len + 2 /* null */;
+		data[1] = (__le16 *)ptr;
+
+		if (cfile)
+			rc = SMB2_set_info_init(tcon, server,
+						&rast_202[num_rqst],
+						cfile->fid.persistent_fid,
+						cfile->fid.volatile_fid,
+					current->tgid, FILE_RENAME_INFORMATION,
+					SMB2_O_INFO_FILE, 0, data, size);
+		else {
+			rc = SMB2_set_info_init(tcon, server,
+					&rast_202[num_rqst],
+					COMPOUND_FID, COMPOUND_FID,
+					current->tgid, FILE_RENAME_INFORMATION,
+					SMB2_O_INFO_FILE, 0, data, size);
+			if (!rc) {
+				smb2_set_next_command(tcon, &rast_202[num_rqst]);
+				smb2_set_related(&rast_202[num_rqst]);
+			}
+		}
+		if (rc)
+			goto finished;
+		num_rqst++;
+		trace_smb3_rename_enter(xid, ses->Suid, tcon->tid, full_path);
+		break;
+	case SMB2_OP_HARDLINK:
+		rast_202[num_rqst].rq_iov = &vars_202->si_iov_202[0];
+		rast_202[num_rqst].rq_nvec = 2;
+
+		len = (2 * UniStrnlen((wchar_t *)ptr, PATH_MAX));
+
+		vars_202->link_info_202.ReplaceIfExists = 0;
+		vars_202->link_info_202.RootDirectory = 0;
+		vars_202->link_info_202.FileNameLength = cpu_to_le32(len);
+
+		size[0] = sizeof(struct smb2_file_link_info);
+		data[0] = &vars_202->link_info_202;
+
+		size[1] = len + 2 /* null */;
+		data[1] = (__le16 *)ptr;
+
+		rc = SMB2_set_info_init(tcon, server,
+					&rast_202[num_rqst], COMPOUND_FID,
+					COMPOUND_FID, current->tgid,
+					FILE_LINK_INFORMATION,
+					SMB2_O_INFO_FILE, 0, data, size);
+		if (rc)
+			goto finished;
+		smb2_set_next_command(tcon, &rast_202[num_rqst]);
+		smb2_set_related(&rast_202[num_rqst++]);
+		trace_smb3_hardlink_enter(xid, ses->Suid, tcon->tid, full_path);
+		break;
+	default:
+		cifs_dbg(VFS, "Invalid command\n");
+		rc = -EINVAL;
+	}
+	if (rc)
+		goto finished;
+
+	/* We already have a handle so we can skip the close */
+	if (cfile)
+		goto after_close;
+	/* Close */
+	rast_202[num_rqst].rq_iov = &vars_202->close_iov_202[0];
+	rast_202[num_rqst].rq_nvec = 1;
+	rc = SMB2_close_init(tcon, server,
+			     &rast_202[num_rqst], COMPOUND_FID,
+			     COMPOUND_FID, false);
+	smb2_set_related(&rast_202[num_rqst]);
+	if (rc)
+		goto finished;
+ after_close:
+	num_rqst++;
+
+	if (cfile) {
+		rc = compound_send_recv(xid, ses, server,
+					flags, num_rqst - 2,
+					&rast_202[1], &resp_buftype[1],
+					&rsp_iov_202[1]);
+	} else
+		rc = compound_send_recv(xid, ses, server,
+					flags, num_rqst,
+					rast_202, resp_buftype,
+					rsp_iov_202);
+
+ finished:
+	if (cfile)
+		cifsFileInfo_put(cfile);
+
+	SMB2_open_free(&rast_202[0]);
+	if (rc == -EREMCHG) {
+		pr_warn_once("server share %s deleted\n", tcon->treeName);
+		tcon->need_reconnect = true;
+	}
+
+	switch (command) {
+
+#define _X202(_what)										\
+	if (!rc) {										\
+		struct kvec *iov;								\
+		struct smb2_query_info_rsp *rsp;						\
+		struct _what *dat = NULL;							\
+												\
+		iov = rsp_iov_202 + nc;								\
+		if (++nc > num_rqst) {								\
+			cifs_dbg(FYI, "TOO MANY on decode %d > %d\n", nc, num_rqst); rc = -96;	\
+		}										\
+		if (rc == 0) {									\
+			rsp = (struct smb2_query_info_rsp *)iov->iov_base;			\
+			if (le32_to_cpu(rsp->OutputBufferLength) < sizeof(struct _what)) {	\
+				cifs_dbg(FYI, "BUFFER too small, %d, %d\n",			\
+				         rsp->OutputBufferLength, (int)sizeof(struct _what));	\
+				rc = -96;							\
+			}									\
+		}										\
+		if (rc == 0) {									\
+			unsigned int off = le16_to_cpu(rsp->OutputBufferOffset);		\
+			rc = smb2_validate_iov(off, sizeof(struct _what), iov,			\
+						sizeof(struct _what));				\
+			if (rc) {								\
+				cifs_dbg(FYI, "BUFFER validate error, %d\n", rc);		\
+			}									\
+			else									\
+				dat = (struct _what *)(off + (char*)iov->iov_base);		\
+		}
+/* End of #define _X202 */
+#define _Y(_f) if (dat) ((struct smb2_file_all_info *)ptr)->_f = dat->_f;
+#define _Z() }
+	case SMB2_OP_QUERY_INFO:
+		if (rc == 0) {
+			nc = 1;
+
+			_X202(smb2_file_basic_info)
+			_Y(CreationTime)
+			_Y(LastAccessTime)
+			_Y(LastWriteTime)
+			_Y(ChangeTime)
+			_Y(Attributes)
+			_Z()
+
+			_X202(smb2_file_standard_info)
+			_Y(AllocationSize)
+			_Y(EndOfFile)
+			_Y(NumberOfLinks)
+			_Y(DeletePending)
+			_Y(Directory)
+			_Z()
+
+			_X202(smb2_file_internal_info)
+			_Y(IndexNumber)
+			_Z()
+	
+			_X202(smb2_file_ea_info)
+			_Y(EASize)
+			_Z()
+	
+			_X202(smb2_file_access_info)
+			_Y(AccessFlags)
+			_Z()
+
+			_X202(smb2_file_mode_info)
+			_Y(Mode)
+			_Z()
+#undef _X202
+#undef _Y
+#undef _Z
+
+			if (nc != num_rqst-1) { cifs_dbg(FYI, "decode MISMATCH %d != %d\n", nc, num_rqst-1); rc = -96; }
+		}
+
+		for (nc = 1; nc < 7; nc++)
+			if (rast_202[nc].rq_iov)
+  {
+				SMB2_query_info_free(&rast_202[nc]);
+  }
+		if (rast_202[nc].rq_iov)
+  {
+			SMB2_close_free(&rast_202[nc]);
+  }
+		if (rc)
+			trace_smb3_query_info_compound_err(xid, ses->Suid,
+						tcon->tid, rc);
+		else
+			trace_smb3_query_info_compound_done(xid, ses->Suid,
+						tcon->tid);
+		break;
+	case SMB2_OP_DELETE:
+		if (rc)
+			trace_smb3_delete_err(xid, ses->Suid, tcon->tid, rc);
+		else
+			trace_smb3_delete_done(xid, ses->Suid, tcon->tid);
+		if (rast_202[1].rq_iov)
+			SMB2_close_free(&rast_202[1]);
+		break;
+	case SMB2_OP_MKDIR:
+		if (rc)
+			trace_smb3_mkdir_err(xid, ses->Suid, tcon->tid, rc);
+		else
+			trace_smb3_mkdir_done(xid, ses->Suid, tcon->tid);
+		if (rast_202[1].rq_iov)
+			SMB2_close_free(&rast_202[1]);
+		break;
+	case SMB2_OP_HARDLINK:
+		if (rc)
+			trace_smb3_hardlink_err(xid, ses->Suid, tcon->tid, rc);
+		else
+			trace_smb3_hardlink_done(xid, ses->Suid, tcon->tid);
+		free_set_inf_compound(rast_202);
+		break;
+	case SMB2_OP_RENAME:
+		if (rc)
+			trace_smb3_rename_err(xid, ses->Suid, tcon->tid, rc);
+		else
+			trace_smb3_rename_done(xid, ses->Suid, tcon->tid);
+		free_set_inf_compound(rast_202);
+		break;
+	case SMB2_OP_RMDIR:
+		if (rc)
+			trace_smb3_rmdir_err(xid, ses->Suid, tcon->tid, rc);
+		else
+			trace_smb3_rmdir_done(xid, ses->Suid, tcon->tid);
+		free_set_inf_compound(rast_202);
+		break;
+	case SMB2_OP_SET_EOF:
+		if (rc)
+			trace_smb3_set_eof_err(xid, ses->Suid, tcon->tid, rc);
+		else
+			trace_smb3_set_eof_done(xid, ses->Suid, tcon->tid);
+		free_set_inf_compound(rast_202);
+		break;
+	case SMB2_OP_SET_INFO:
+		if (rc)
+			trace_smb3_set_info_compound_err(xid, ses->Suid,
+						tcon->tid, rc);
+		else
+			trace_smb3_set_info_compound_done(xid, ses->Suid,
+						tcon->tid);
+		free_set_inf_compound(rast_202);
+		break;
+	}
+
+	for (nc=0; nc < num_rqst; nc++) {
+		free_rsp_buf(resp_buftype[nc], rsp_iov_202[nc].iov_base);
+	}
+	kfree(vars_202);
+	return rc;
+}
+
+#undef NREQ_202
+
+
+int
+smb202_query_path_info(const unsigned int xid, struct cifs_tcon *tcon,
+		     struct cifs_sb_info *cifs_sb, const char *full_path,
+		     FILE_ALL_INFO *data, bool *adjust_tz, bool *reparse)
+{
+	int rc;
+	struct smb2_file_all_info *smb2_data;
+	__u32 create_options = 0;
+	struct cifsFileInfo *cfile;
+#if 0
+	struct cached_fid *cfid = NULL;
+#endif /* 0 */
+
+	*adjust_tz = false;
+	*reparse = false;
+
+	if (tcon == NULL)
+//	|| tcon->nohandlecache)
+                return -EOPNOTSUPP;
+
+	smb2_data = kzalloc(sizeof(struct smb2_file_all_info) + PATH_MAX * 2, GFP_KERNEL);
+	if (smb2_data == NULL)
+		return -ENOMEM;
+
+#if 0
+	if (strcmp(full_path, ""))
+                rc = -ENOENT;
+	else
+		rc = open_cached_dir(xid, tcon, full_path, cifs_sb, false, &cfid);
+	/* If it is a root and its handle is cached then use it */
+
+	if (!strcmp(full_path, "") && !tcon->nohandlecache)
+	{
+		rc = open_shroot_202(xid, tcon, &fid_202);
+// -- goto out;
+		if (rc)
+		{
+			goto out;
+		}
+		if (tcon->cfid->file_all_info_is_valid) {
+			move_smb2_info_to_cifs(data, &tcon->cfid->file_all_info);
+		} else {
+			rc = SMB2_query_info(xid, tcon, tcon->cfid->fid.persistent_fid, tcon->cfid->fid.volatile_fid, smb2_data);
+			if (!rc)
+			{
+				move_smb2_info_to_cifs(data, smb2_data);
+			}
+		}
+		close_cached_dir(tcon->cfid);
+		goto out;
+	}
+#endif	/* 0 */
+
+	if (backup_cred(cifs_sb))
+		create_options |= CREATE_OPEN_BACKUP_INTENT;
+
+	cifs_get_readable_path(tcon, full_path, &cfile);
+	rc = smb202_compound_op(xid, tcon, cifs_sb, full_path,
+			      FILE_READ_ATTRIBUTES, FILE_OPEN, create_options,
+			      ACL_NO_MODE, smb2_data, SMB2_OP_QUERY_INFO, cfile);
+	if (rc == -EOPNOTSUPP) {
+		*reparse = true;
+		create_options |= OPEN_REPARSE_POINT;
+
+		/* Failed on a symbolic link - query a reparse point info */
+		rc = smb202_compound_op(xid, tcon, cifs_sb, full_path,
+				      FILE_READ_ATTRIBUTES, FILE_OPEN,
+				      create_options, ACL_NO_MODE,
+				      smb2_data, SMB2_OP_QUERY_INFO, cfile);
+	}
+	if (rc)
+		goto out;
+
+	move_smb2_info_to_cifs(data, smb2_data);
+out:
+	kfree(smb2_data);
+	return rc;
+}
+ 
+
+static int
+common_smb_get_reparse_attrs(bool do202, unsigned xid, struct cifs_tcon *tcon, struct cifs_sb_info *cifs_sb, const char *full_path, __u32 *out_attrs)
+{
+	int rc;
+	struct smb2_file_all_info *smb2_data;
+	__u32 create_options = 0;
+	struct cifsFileInfo *cfile;
+
+	smb2_data = kzalloc(sizeof(struct smb2_file_all_info) + PATH_MAX * 2, GFP_KERNEL);
+	if (smb2_data == NULL)
+		return -ENOMEM;
+
+	cifs_get_readable_path(tcon, full_path, &cfile);
+	if (backup_cred(cifs_sb))
+		create_options |= CREATE_OPEN_BACKUP_INTENT;
+	create_options |= OPEN_REPARSE_POINT;
+
+	if (do202)
+		rc = smb202_compound_op(xid, tcon, cifs_sb, full_path,
+					FILE_READ_ATTRIBUTES, FILE_OPEN, create_options,
+					ACL_NO_MODE, smb2_data, SMB2_OP_QUERY_INFO, cfile);
+	else
+		rc = smb2_compound_op(xid, tcon, cifs_sb, full_path,
+				      FILE_READ_ATTRIBUTES, FILE_OPEN, create_options,
+				      ACL_NO_MODE, smb2_data, SMB2_OP_QUERY_INFO, cfile);
+
+	if (rc)
+		goto out;
+
+	*out_attrs = smb2_data->Attributes;
+
+out:
+	kfree(smb2_data);
+	return rc;
+}
+
+int
+smb202_get_reparse_attrs(unsigned xid, struct cifs_tcon *tcon, struct cifs_sb_info *cifs_sb, const char *full_path, __u32 *out_attrs)
+{
+	return common_smb_get_reparse_attrs(1, xid, tcon, cifs_sb, full_path, out_attrs);
+}
+
+int
+smb2_get_reparse_attrs(unsigned xid, struct cifs_tcon *tcon, struct cifs_sb_info *cifs_sb, const char *full_path, __u32 *out_attrs)
+{
+	return common_smb_get_reparse_attrs(0, xid, tcon, cifs_sb, full_path, out_attrs);
+}
+
+/* ****************************** */
+
 int
 smb2_mkdir(const unsigned int xid, struct inode *parent_inode, umode_t mode,
 	   struct cifs_tcon *tcon, const char *name,
diff --git a/fs/cifs/smb2ops.c b/fs/cifs/smb2ops.c
--- a/fs/cifs/smb2ops.c
+++ b/fs/cifs/smb2ops.c
@@ -29,6 +29,15 @@
 #include "fs_context.h"
 #include "cached_dir.h"
 
+/* Forward definition. */
+int smb2_get_reparse_attrs(unsigned xid, struct cifs_tcon *tcon, struct cifs_sb_info *cifs_sb,
+			   const char *full_path, __u32 *out_attrs);
+int smb202_query_path_info(const unsigned int xid, struct cifs_tcon *tcon,
+			   struct cifs_sb_info *cifs_sb, const char *full_path,
+			   FILE_ALL_INFO *data, bool *adjust_tz, bool *symlink);
+int smb202_get_reparse_attrs(unsigned xid, struct cifs_tcon *tcon, struct cifs_sb_info *cifs_sb,
+			     const char *full_path, __u32 *out_attrs);
+
 /* Change credits for different ops and return the total number of credits */
 static int
 change_conf(struct TCP_Server_Info *server)
@@ -716,6 +725,252 @@ SMB3_request_interfaces(const unsigned int xid, struct cifs_tcon *tcon, bool in_
 	return rc;
 }
 
+
+int open_shroot_202(unsigned int xid, struct cifs_tcon *tcon, struct cifs_fid *pfid)
+{
+	struct cifs_ses *ses = tcon->ses;
+	struct TCP_Server_Info *server = ses->server;
+	struct cifs_open_parms oparms;
+	struct smb2_create_rsp *o_rsp = NULL;
+#define NCHAINED 7
+	int resp_buftype[NCHAINED];
+	struct smb_rqst rqst[NCHAINED];
+	struct kvec rsp_iov[NCHAINED];
+	struct kvec qi_iov[NCHAINED];
+	struct kvec open_iov[SMB2_CREATE_IOV_SIZE];
+	int rc, flags = 0;
+	__le16 utf16_path = 0; /* Null - since an open of top of share */
+	u8 oplock = SMB2_OPLOCK_LEVEL_II;
+	int nc = 0;
+
+	mutex_lock(&tcon->cfid->fid_mutex);
+
+	if (tcon->cfid->is_valid) {
+		cifs_dbg(FYI, "found a cached root file handle\n");
+		memcpy(pfid, &tcon->cfid->fid, sizeof(struct cifs_fid));
+		kref_get(&tcon->cfid->refcount);
+		mutex_unlock(&tcon->cfid->fid_mutex);
+		return 0;
+	}
+
+	if (smb3_encryption_required(tcon))
+		flags |= CIFS_TRANSFORM_REQ;
+
+	for(nc=0; nc < NCHAINED; nc++) resp_buftype[nc] = CIFS_NO_BUFFER;
+	memset(rqst, 0, sizeof(rqst));
+	memset(rsp_iov, 0, sizeof(rsp_iov));
+	memset(qi_iov, 0, sizeof(qi_iov));
+
+	/* Open */
+	memset(&open_iov, 0, sizeof(open_iov));
+	rqst[0].rq_iov = open_iov;
+	rqst[0].rq_nvec = SMB2_CREATE_IOV_SIZE;
+
+	oparms.tcon = tcon;
+	oparms.create_options = 0;
+	oparms.desired_access = FILE_READ_ATTRIBUTES;
+	oparms.disposition = FILE_OPEN;
+	oparms.fid = pfid;
+	oparms.reconnect = false;
+
+	rc = SMB2_open_init(tcon, server, &rqst[0], &oplock, &oparms, &utf16_path);
+	if (rc)
+		goto oshr_exit;
+	smb2_set_next_command(tcon, &rqst[0]);
+
+	/* INFO */
+
+	for(nc=1; nc < NCHAINED; nc++) {
+		rqst[nc].rq_iov = qi_iov+nc;
+		rqst[nc].rq_nvec = 1;
+	}
+
+	nc = 0;
+
+#define _X202(_w1, _w2) 										\
+	if (++nc >= NCHAINED) { cifs_dbg(FYI, "TOO MANY %d\n", nc); rc = -96; goto oshr_exit; }		\
+	if ((rc = SMB2_query_info_init(tcon, server, &rqst[nc], COMPOUND_FID, COMPOUND_FID, _w1, 	\
+				       SMB2_O_INFO_FILE, 0, sizeof(struct _w2), 0, NULL)))		\
+		goto oshr_exit;										\
+	smb2_set_related(&rqst[nc]);
+
+	_X202( FILE_BASIC_INFORMATION,	smb2_file_basic_info );		smb2_set_next_command(tcon, &rqst[nc]);
+	_X202( FILE_STANDARD_INFORMATION,	smb2_file_standard_info );	smb2_set_next_command(tcon, &rqst[nc]);
+	_X202( FILE_INTERNAL_INFORMATION,	smb2_file_internal_info );	smb2_set_next_command(tcon, &rqst[nc]);
+	_X202( FILE_EA_INFORMATION,	smb2_file_ea_info );		smb2_set_next_command(tcon, &rqst[nc]);
+	_X202( FILE_ACCESS_INFORMATION,	smb2_file_access_info );	smb2_set_next_command(tcon, &rqst[nc]);
+	_X202( FILE_MODE_INFORMATION,	smb2_file_mode_info );
+
+#undef _X202
+
+	if (++nc != NCHAINED) { cifs_dbg(FYI, "MISMATCH %d\n", nc); rc = -96; goto oshr_exit; }
+
+	/*
+	 * We do not hold the lock for the open because in case
+	 * SMB2_open needs to reconnect, it will end up calling
+	 * cifs_mark_open_files_invalid() which takes the lock again
+	 * thus causing a deadlock
+	 */
+
+	mutex_unlock(&tcon->cfid->fid_mutex);
+	rc = compound_send_recv(xid, ses, server, flags, nc, rqst, resp_buftype, rsp_iov);
+	mutex_lock(&tcon->cfid->fid_mutex);
+
+	/*
+	 * Now we need to check again as the cached root might have
+	 * been successfully re-opened from a concurrent process
+	 */
+
+	if (tcon->cfid->is_valid) {
+		/* work was already done */
+
+		/* stash fids for close() later */
+		struct cifs_fid fid = {
+			.persistent_fid = pfid->persistent_fid,
+			.volatile_fid = pfid->volatile_fid,
+		};
+
+		/*
+		 * caller expects this func to set pfid to a valid
+		 * cached root, so we copy the existing one and get a
+		 * reference.
+		 */
+		memcpy(pfid, &tcon->cfid->fid, sizeof(*pfid));
+		kref_get(&tcon->cfid->refcount);
+
+		mutex_unlock(&tcon->cfid->fid_mutex);
+
+		if (rc == 0) {
+			/* close extra handle outside of crit sec */
+			SMB2_close(xid, tcon, fid.persistent_fid, fid.volatile_fid);
+		}
+		goto oshr_free;
+	}
+
+	/* Cached root is still invalid, continue normaly */
+
+	if (rc)
+		goto oshr_exit;
+
+	o_rsp = (struct smb2_create_rsp *)rsp_iov[0].iov_base;
+	oparms.fid->persistent_fid = o_rsp->PersistentFileId;
+	oparms.fid->volatile_fid = o_rsp->VolatileFileId;
+// #ifdef CONFIG_CIFS_DEBUG2
+// 	oparms.fid->mid = le64_to_cpu(o_rsp->sync_hdr.MessageId);
+// #endif /* CIFS_DEBUG2 */
+
+	memcpy(&tcon->cfid->fid, pfid, sizeof(struct cifs_fid));
+	tcon->cfid->tcon = tcon;
+	tcon->cfid->is_valid = true;
+	kref_init(&tcon->cfid->refcount);
+
+
+	/* BB TBD check to see if oplock level check can be removed below */
+
+	if (o_rsp->OplockLevel == SMB2_OPLOCK_LEVEL_LEASE) {
+		kref_get(&tcon->cfid->refcount);
+		smb2_parse_contexts(server, o_rsp,
+				&oparms.fid->epoch,
+				oparms.fid->lease_key, &oplock, NULL, NULL);
+	}
+#if 0
+	else {
+		goto oshr_exit;
+	}
+#endif
+
+	memset((char *)&tcon->cfid->file_all_info, 0, sizeof(tcon->cfid->file_all_info));
+
+	nc = 1;
+
+#define _X202(_what)											\
+	{												\
+		struct kvec *iov;									\
+		struct smb2_query_info_rsp *rsp;							\
+		unsigned int off;									\
+		struct _what *dat;									\
+													\
+		iov = rsp_iov + nc;									\
+		if (++nc > NCHAINED) {									\
+			cifs_dbg(FYI, "TOO MANY on decode %d\n", nc); rc = -96; goto oshr_exit; }	\
+		rsp = (struct smb2_query_info_rsp *)iov->iov_base;					\
+													\
+		if (le32_to_cpu(rsp->OutputBufferLength) < sizeof(struct _what ) ) {			\
+			cifs_dbg(FYI, "BUFFER too small, %d, %d\n", rsp->OutputBufferLength,		\
+				      (int)sizeof(struct _what));					\
+			rc = -96;									\
+			goto oshr_exit;									\
+		}											\
+													\
+		off = le16_to_cpu(rsp->OutputBufferOffset);						\
+													\
+		if ((rc = smb2_validate_iov( off, sizeof(struct _what), iov, sizeof(struct _what)) )) {	\
+			cifs_dbg(FYI, "BUFFER validate error, %d\n", rc);				\
+			goto oshr_exit;									\
+		}											\
+		dat = (struct _what *)(off + (char*)iov->iov_base);
+
+#define _Y(_f)	tcon->cfid->file_all_info._f = dat->_f;
+#define _Z() }
+
+	_X202( smb2_file_basic_info )
+	_Y( CreationTime )
+	_Y( LastAccessTime )
+	_Y( LastWriteTime )
+	_Y( ChangeTime )
+	_Y( Attributes )
+	_Z( )
+
+	_X202( smb2_file_standard_info )
+	_Y( AllocationSize )
+	_Y( EndOfFile )
+	_Y( NumberOfLinks )
+	_Y( DeletePending )
+	_Y( Directory )
+	_Z( )
+
+	_X202( smb2_file_internal_info )
+	_Y( IndexNumber )
+	_Z( )
+
+	_X202( smb2_file_ea_info )
+	_Y( EASize )
+	_Z( )
+
+	_X202( smb2_file_access_info )
+	_Y( AccessFlags )
+	_Z( )
+
+	_X202( smb2_file_mode_info )
+	_Y( Mode )
+	_Z( )
+
+	if (nc != NCHAINED) { cifs_dbg(FYI, "decode MISMATCH %d\n", nc); rc = -96; goto oshr_exit; }
+
+	tcon->cfid->file_all_info_is_valid = 1;
+
+#undef _X202
+#undef _Y
+#undef _Z
+
+oshr_exit:
+	mutex_unlock(&tcon->cfid->fid_mutex);
+
+oshr_free:
+	SMB2_open_free(&rqst[0]);
+	free_rsp_buf(resp_buftype[0], rsp_iov[0].iov_base);
+
+	for(nc=1; nc < NCHAINED; nc++) {
+		SMB2_query_info_free(&rqst[nc]);
+		free_rsp_buf(resp_buftype[nc], rsp_iov[nc].iov_base);
+	}
+
+	if (rc) cifs_dbg(FYI, "INODE RETURNING %d\n", rc);
+
+	return rc;
+}	/* End of open_shroot_202 */
+
+
 static void
 smb3_qfs_tcon(const unsigned int xid, struct cifs_tcon *tcon,
 	      struct cifs_sb_info *cifs_sb)
@@ -5239,7 +5494,10 @@ struct smb_version_operations smb20_operations = {
 	.is_path_accessible = smb2_is_path_accessible,
 	.can_echo = smb2_can_echo,
 	.echo = SMB2_echo,
-	.query_path_info = smb2_query_path_info,
+	.query_path_info = smb202_query_path_info,
+
+	.get_reparse_attrs = smb202_get_reparse_attrs,
+
 	.get_srv_inum = smb2_get_srv_inum,
 	.query_file_info = smb2_query_file_info,
 	.set_path_size = smb2_set_path_size,
@@ -5341,6 +5599,9 @@ struct smb_version_operations smb21_operations = {
 	.can_echo = smb2_can_echo,
 	.echo = SMB2_echo,
 	.query_path_info = smb2_query_path_info,
+
+	.get_reparse_attrs = smb2_get_reparse_attrs,
+
 	.get_srv_inum = smb2_get_srv_inum,
 	.query_file_info = smb2_query_file_info,
 	.set_path_size = smb2_set_path_size,
@@ -5444,6 +5705,9 @@ struct smb_version_operations smb30_operations = {
 	.can_echo = smb2_can_echo,
 	.echo = SMB2_echo,
 	.query_path_info = smb2_query_path_info,
+
+	.get_reparse_attrs = smb2_get_reparse_attrs,
+
 	/* WSL tags introduced long after smb2.1, enable for SMB3, 3.11 only */
 	.query_reparse_tag = smb2_query_reparse_tag,
 	.get_srv_inum = smb2_get_srv_inum,
@@ -5558,6 +5822,9 @@ struct smb_version_operations smb311_operations = {
 	.can_echo = smb2_can_echo,
 	.echo = SMB2_echo,
 	.query_path_info = smb2_query_path_info,
+
+	.get_reparse_attrs = smb2_get_reparse_attrs,
+
 	.query_reparse_tag = smb2_query_reparse_tag,
 	.get_srv_inum = smb2_get_srv_inum,
 	.query_file_info = smb2_query_file_info,
diff --git a/fs/cifs/smb2pdu.h b/fs/cifs/smb2pdu.h
--- a/fs/cifs/smb2pdu.h
+++ b/fs/cifs/smb2pdu.h
@@ -330,6 +330,10 @@ struct smb2_file_full_ea_info { /* encoding of response for level 15 */
 	char   ea_data[]; /* \0 terminated name plus value */
 } __packed; /* level 15 Set */
 
+struct smb2_file_mode_info { /* data block encoding of response to level 16 */
+	__le32 Mode;
+} __packed; /* LEVEL 16 Query */
+
 struct smb2_file_reparse_point_info {
 	__le64 IndexNumber;
 	__le32 Tag;
diff --git a/fs/cifs/smb2proto.h b/fs/cifs/smb2proto.h
--- a/fs/cifs/smb2proto.h
+++ b/fs/cifs/smb2proto.h
@@ -54,6 +54,8 @@ extern bool smb2_is_valid_oplock_break(char *buffer,
 extern int smb3_handle_read_data(struct TCP_Server_Info *server,
 				 struct mid_q_entry *mid);
 
+extern int open_shroot_202(unsigned int xid, struct cifs_tcon *tcon, struct cifs_fid *pfid);
+
 extern void move_smb2_info_to_cifs(FILE_ALL_INFO *dst,
 				   struct smb2_file_all_info *src);
 extern int smb2_query_reparse_tag(const unsigned int xid, struct cifs_tcon *tcon,
diff --git a/fs/cifs/smbencrypt.c b/fs/cifs/smbencrypt.c
--- a/fs/cifs/smbencrypt.c
+++ b/fs/cifs/smbencrypt.c
@@ -18,6 +18,7 @@
 #include <linux/string.h>
 #include <linux/kernel.h>
 #include <linux/random.h>
+#include <crypto/des.h>
 #include "cifs_fs_sb.h"
 #include "cifs_unicode.h"
 #include "cifspdu.h"
@@ -38,8 +39,74 @@
 #define SSVALX(buf,pos,val) (CVAL(buf,pos)=(val)&0xFF,CVAL(buf,pos+1)=(val)>>8)
 #define SSVAL(buf,pos,val) SSVALX((buf),(pos),((__u16)(val)))
 
-/* produce a md4 message digest from data of length n bytes */
+static void
+str_to_key(unsigned char *str, unsigned char *key)
+{
+	int i;
+
+	key[0] = str[0] >> 1;
+	key[1] = ((str[0] & 0x01) << 6) | (str[1] >> 2);
+	key[2] = ((str[1] & 0x03) << 5) | (str[2] >> 3);
+	key[3] = ((str[2] & 0x07) << 4) | (str[3] >> 4);
+	key[4] = ((str[3] & 0x0F) << 3) | (str[4] >> 5);
+	key[5] = ((str[4] & 0x1F) << 2) | (str[5] >> 6);
+	key[6] = ((str[5] & 0x3F) << 1) | (str[6] >> 7);
+	key[7] = str[6] & 0x7F;
+	for (i = 0; i < 8; i++)
+		key[i] = (key[i] << 1);
+}
+
+static int
+smbhash(unsigned char *out, const unsigned char *in, unsigned char *key)
+{
+	unsigned char key2[8];
+	struct des_ctx ctx;
+
+	str_to_key(key, key2);
+
+	if (fips_enabled) {
+		cifs_dbg(VFS, "FIPS compliance enabled: DES not permitted\n");
+		return -ENOENT;
+	}
+
+	des_expand_key(&ctx, key2, DES_KEY_SIZE);
+	des_encrypt(&ctx, out, in);
+	memzero_explicit(&ctx, sizeof(ctx));
+
+	return 0;
+}
+
 static int
+E_P16(unsigned char *p14, unsigned char *p16)
+{
+	int rc;
+	unsigned char sp8[8] =
+	    { 0x4b, 0x47, 0x53, 0x21, 0x40, 0x23, 0x24, 0x25 };
+
+	rc = smbhash(p16, sp8, p14);
+	if (rc)
+		return rc;
+	rc = smbhash(p16 + 8, sp8, p14 + 7);
+	return rc;
+}
+
+static int
+E_P24(unsigned char *p21, const unsigned char *c8, unsigned char *p24)
+{
+	int rc;
+
+	rc = smbhash(p24, c8, p21);
+	if (rc)
+		return rc;
+	rc = smbhash(p24 + 8, c8, p21 + 7);
+	if (rc)
+		return rc;
+	rc = smbhash(p24 + 16, c8, p21 + 14);
+	return rc;
+}
+
+/* produce a md4 message digest from data of length n bytes */
+int
 mdfour(unsigned char *md4_hash, unsigned char *link_str, int link_len)
 {
 	int rc;
@@ -64,6 +131,32 @@ mdfour(unsigned char *md4_hash, unsigned char *link_str, int link_len)
 	return rc;
 }
 
+/*
+   This implements the X/Open SMB password encryption
+   It takes a password, a 8 byte "crypt key" and puts 24 bytes of
+   encrypted password into p24 */
+/* Note that password must be uppercased and null terminated */
+int
+SMBencrypt(unsigned char *passwd, const unsigned char *c8, unsigned char *p24)
+{
+	int rc;
+	unsigned char p14[14], p16[16], p21[21];
+
+	memset(p14, '\0', 14);
+	memset(p16, '\0', 16);
+	memset(p21, '\0', 21);
+
+	memcpy(p14, passwd, 14);
+	rc = E_P16(p14, p16);
+	if (rc)
+		return rc;
+
+	memcpy(p21, p16, 16);
+	rc = E_P24(p21, c8, p24);
+
+	return rc;
+}
+
 /*
  * Creates the MD4 Hash of the users password in NT UNICODE.
  */
@@ -89,3 +182,25 @@ E_md4hash(const unsigned char *passwd, unsigned char *p16,
 
 	return rc;
 }
+
+/* Does the NT MD4 hash then des encryption. */
+int
+SMBNTencrypt(unsigned char *passwd, unsigned char *c8, unsigned char *p24,
+		const struct nls_table *codepage)
+{
+	int rc;
+	unsigned char p16[16], p21[21];
+
+	memset(p16, '\0', 16);
+	memset(p21, '\0', 21);
+
+	rc = E_md4hash(passwd, p16, codepage);
+	if (rc) {
+		cifs_dbg(FYI, "%s Can't generate NT hash, error: %d\n",
+			 __func__, rc);
+		return rc;
+	}
+	memcpy(p21, p16, 16);
+	rc = E_P24(p21, c8, p24);
+	return rc;
+}
diff --git a/fs/cifs/transport.c b/fs/cifs/transport.c
--- a/fs/cifs/transport.c
+++ b/fs/cifs/transport.c
@@ -592,6 +592,10 @@ wait_for_free_credits(struct TCP_Server_Info *server, const int num_credits,
 			 * new sessions.
 			 */
 			spin_lock(&server->req_lock);
+			/* We gave up the lock, then took it again. Did data change badly for us? */
+			if (*credits < num_credits) {
+			    continue;
+			}
 			if (!optype && num_credits == 1 &&
 			    server->in_flight > 2 * MAX_COMPOUND &&
 			    *credits <= MAX_COMPOUND) {
diff --git a/fs/cifs/xattr.c b/fs/cifs/xattr.c
--- a/fs/cifs/xattr.c
+++ b/fs/cifs/xattr.c
@@ -25,6 +25,7 @@
 #define CIFS_XATTR_CIFS_NTSD_FULL "system.cifs_ntsd_full" /* owner/DACL/SACL */
 #define CIFS_XATTR_ATTRIB "cifs.dosattrib"  /* full name: user.cifs.dosattrib */
 #define CIFS_XATTR_CREATETIME "cifs.creationtime"  /* user.cifs.creationtime */
+#define CIFS_XATTR_GETFSATTR "cifs.getfsattr"  /* user.cifs.getfsattr */
 /*
  * Although these three are just aliases for the above, need to move away from
  * confusing users and using the 20+ year old term 'cifs' when it is no longer
@@ -281,6 +282,20 @@ static int cifs_creation_time_get(struct dentry *dentry, struct inode *inode,
 }
 
 
+static int cifs_get_fs_attr(struct cifs_tcon *tcon, void *value, size_t size)
+{
+
+	if (!value || !size)
+		return sizeof(__u32);
+
+	if (size < sizeof(__u32))
+		return -ERANGE;
+
+	*((__u32 *)value) = le32_to_cpu(tcon->fsAttrInfo.Attributes);
+	return sizeof(__u32);
+}
+
+
 static int cifs_xattr_get(const struct xattr_handler *handler,
 			  struct dentry *dentry, struct inode *inode,
 			  const char *name, void *value, size_t size)
@@ -321,6 +336,10 @@ static int cifs_xattr_get(const struct xattr_handler *handler,
 			rc = cifs_creation_time_get(dentry, inode, value, size);
 			break;
 		}
+		else if (!strcmp(name, CIFS_XATTR_GETFSATTR)) {
+			rc = cifs_get_fs_attr(pTcon, value, size);
+			break;
+		}
 
 		if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_NO_XATTR)
 			goto out;
diff --git a/fs/smbfs_common/smb2pdu.h b/fs/smbfs_common/smb2pdu.h
--- a/fs/smbfs_common/smb2pdu.h
+++ b/fs/smbfs_common/smb2pdu.h
@@ -1518,10 +1518,36 @@ struct file_allocated_range_buffer {
 	__le64	length;
 } __packed;
 
+struct smb2_file_basic_info { /* data block encoding of response to level 4 */
+	__le64 CreationTime;	/* Beginning of FILE_BASIC_INFO equivalent */
+	__le64 LastAccessTime;
+	__le64 LastWriteTime;
+	__le64 ChangeTime;
+	__le32 Attributes;
+	__u32  Pad1;		/* End of FILE_BASIC_INFO_INFO equivalent */
+} __packed; /* LEVEL 4 Query */
+
+struct smb2_file_standard_info { /* data block encoding of response to level 5 */
+	__le64 AllocationSize;	/* Beginning of FILE_STANDARD_INFO equivalent */
+	__le64 EndOfFile;	/* size ie offset to first free byte in file */
+	__le32 NumberOfLinks;	/* hard links */
+	__u8   DeletePending;
+	__u8   Directory;
+	__u16  Pad2;		/* End of FILE_STANDARD_INFO equivalent */
+} __packed; /* LEVEL 5 Query */
+
 struct smb2_file_internal_info {
 	__le64 IndexNumber;
 } __packed; /* level 6 Query */
 
+struct smb2_file_ea_info { /* data block encoding of response to level 7 */
+	__le32 EASize;
+} __packed; /* LEVEL 7 Query */
+
+struct smb2_file_access_info { /* data block encoding of response to level 8 */
+	__le32 AccessFlags;
+} __packed; /* LEVEL 8 Query */
+
 struct smb2_file_rename_info { /* encoding of request for level 10 */
 	__u8   ReplaceIfExists; /* 1 = replace existing target with new */
 				/* 0 = fail if target already exists */
@@ -1566,7 +1592,7 @@ struct smb2_file_all_info { /* data block encoding of response to level 18 */
 	__le32 Mode;
 	__le32 AlignmentRequirement;
 	__le32 FileNameLength;
-	char   FileName[1];
+	char   xFileName[0];
 } __packed; /* level 18 Query */
 
 struct smb2_file_eof_info { /* encoding of request for level 10 */
