diff -Nrp -U 7 --strip-trailing-cr a/include/scsi/scsi_host.h b/include/scsi/scsi_host.h
--- a/include/scsi/scsi_host.h	2024-02-12 15:07:46.000000000 -0600
+++ b/include/scsi/scsi_host.h	2024-02-12 15:37:40.413381709 -0600
@@ -556,15 +556,15 @@ struct Scsi_Host {
 
 	struct list_head	eh_abort_list;
 	struct list_head	eh_cmd_q;
 	struct task_struct    * ehandler;  /* Error recovery thread. */
 	struct completion     * eh_action; /* Wait for specific actions on the
 					      host. */
 	wait_queue_head_t       host_wait;
-	const struct scsi_host_template *hostt;
+	struct scsi_host_template *hostt;
 	struct scsi_transport_template *transportt;
 
 	struct kref		tagset_refcnt;
 	struct completion	tagset_freed;
 	/* Area to keep a shared tag map */
 	struct blk_mq_tag_set	tag_set;
 
diff -Nrp -U 7 --strip-trailing-cr a/drivers/scsi/qla2xxx/qla_gbl.h b/drivers/scsi/qla2xxx/qla_gbl.h
--- a/drivers/scsi/qla2xxx/qla_gbl.h	2024-02-12 15:07:46.000000000 -0600
+++ b/drivers/scsi/qla2xxx/qla_gbl.h	2024-02-12 15:37:40.413381709 -0600
@@ -4,14 +4,28 @@
  * Copyright (c)  2003-2014 QLogic Corporation
  */
 #ifndef __QLA_GBL_H
 #define	__QLA_GBL_H
 
 #include <linux/interrupt.h>
 
+// ---------------------------------------------------------------------------
+// Added for Parsec Labs 2017-11-28 -- kzalloc the tables/command/routines/etc. to use.
+#define NEW_ALLOC_SCSI_TRANSPORT_TEMPLATE
+// Added for Parsec Labs 2017-11-29 -- new option in /etc/modprobe.d/qla2xxx.conf.
+#define NEW_MATCH_WWPN
+
+// #define M4_DEBUG_PRINT
+#ifdef M4_DEBUG_PRINT
+  #define m4_debug(...)	pr_info(__VA_ARGS__)
+#else	// M4_DEBUG_PRINT
+  #define m4_debug(...)
+#endif	// M4_DEBUG_PRINT
+// ---------------------------------------------------------------------------
+
 /*
  * Global Function Prototypes in qla_init.c source file.
  */
 extern int qla2x00_initialize_adapter(scsi_qla_host_t *);
 extern int qla24xx_post_prli_work(struct scsi_qla_host *vha, fc_port_t *fcport);
 
 extern int qla2100_pci_config(struct scsi_qla_host *);
diff -Nrp -U 7 --strip-trailing-cr a/drivers/scsi/qla2xxx/qla_init.c b/drivers/scsi/qla2xxx/qla_init.c
--- a/drivers/scsi/qla2xxx/qla_init.c	2024-02-12 15:07:46.000000000 -0600
+++ b/drivers/scsi/qla2xxx/qla_init.c	2024-02-12 15:37:40.414381705 -0600
@@ -36,14 +36,32 @@ static int qla84xx_init_chip(scsi_qla_ho
 static int qla25xx_init_queues(struct qla_hw_data *);
 static void qla24xx_handle_gpdb_event(scsi_qla_host_t *vha,
 				      struct event_arg *ea);
 static void qla24xx_handle_prli_done_event(struct scsi_qla_host *,
     struct event_arg *);
 static void __qla24xx_handle_gpdb_event(scsi_qla_host_t *, struct event_arg *);
 
+/* ----------------------------------------------------------------------------- */
+/* Forward definition (also used in other file(s)). */
+#if defined(M4_DEBUG_PRINT) || defined(NEW_MATCH_WWPN)
+void print_port_name_from_nv(scsi_qla_host_t *, const char *);
+u64 get_port_name_from_nv(scsi_qla_host_t *vha, const char *funct);
+#else	// M4_DEBUG_PRINT
+#define print_port_name_from_nv(a, b)
+#endif	//M4_DEBUG_PRINT
+
+/* External defined routine. */
+#ifdef NEW_MATCH_WWPN
+extern int find_slot_wwpn(struct scsi_qla_host *, u64, int, const char *);
+
+extern char *qlini_targets;
+#endif	// NEW_MATCH_WWPN
+
+/* ----------------------------------------------------------------------------- */
+
 /* SRB Extensions ---------------------------------------------------------- */
 
 void
 qla2x00_sp_timeout(struct timer_list *t)
 {
 	srb_t *sp = from_timer(sp, t, u.iocb_cmd.timer);
 	struct srb_iocb *iocb;
@@ -2661,14 +2679,94 @@ qla83xx_nic_core_fw_load(scsi_qla_host_t
 
 exit:
 	qla83xx_idc_unlock(vha, 0);
 
 	return rval;
 }
 
+/* ------------------------------------------------------------------------ */
+#if defined(M4_DEBUG_PRINT) || defined(NEW_MATCH_WWPN)
+u64 get_port_name_from_nv(scsi_qla_host_t *vha, const char *funct)
+{
+	uint32_t *dptr;
+	struct qla_hw_data *ha = vha->hw;
+	union {
+	    nvram_t nv_2x00;
+	    struct nvram_24xx nv_24xx;
+	    struct nvram_81xx nv_81xx;
+	} u;
+	uint32_t nvram_base;
+	uint32_t nvram_size;
+	struct device_reg_2xxx __iomem *reg_2xxx;
+
+	memset(&u, 0, sizeof(u));
+
+	if (ha == NULL)
+	{
+	    pr_info("%s:%u:from %s vha->hw ==NULL\n", __FILE__,__LINE__,funct);
+	    return 0ULL;
+	}
+
+	// Starting to determine type of system.
+        if (IS_QLA2100(ha) || IS_QLA2200(ha) || IS_QLA23XX(ha)) {
+	    nvram_base = 0;
+	    if (IS_QLA2100(ha) || IS_QLA2200(ha) || IS_QLA2300(ha)) {
+		reg_2xxx = &ha->iobase->isp;
+		if ((rd_reg_word(&reg_2xxx->ctrl_status) >> 14) == 1) {
+		    nvram_base = 0x80;
+		}
+	    }
+	    nvram_size = sizeof(u.nv_2x00);
+	    dptr = (uint32_t *)&u.nv_2x00;
+	    ha->isp_ops->read_nvram(vha, (uint8_t *)dptr, nvram_base, nvram_size);
+	    return (*(u64*)&u.nv_2x00.port_name);
+        }
+	if (IS_QLA24XX_TYPE(ha) || IS_QLA25XX(ha)) {
+	    /* Determine NVRAM starting address. */
+	    if (ha->port_no == 0) {
+		nvram_base = FA_NVRAM_FUNC0_ADDR;
+	    } else {
+		nvram_base = FA_NVRAM_FUNC1_ADDR;
+	    }
+	    nvram_size = sizeof(u.nv_24xx);
+	    dptr = (uint32_t *)&u.nv_24xx;
+	    ha->isp_ops->read_nvram(vha, (uint8_t *)dptr, nvram_base, nvram_size);
+	    return (*(u64*)&u.nv_24xx.port_name);
+        }
+	if (IS_QLA81XX(ha) || IS_QLA82XX(ha) || IS_QLA8044(ha) || \
+	           IS_QLA83XX(ha) || IS_QLA27XX(ha)) {
+	    nvram_base = ha->flt_region_nvram << 2;
+	    nvram_size = sizeof(u.nv_81xx);
+	    dptr = (uint32_t *)&u.nv_81xx;
+	    ha->isp_ops->read_optrom(vha, (uint8_t *)dptr, nvram_base, nvram_size);
+	    return (*(u64*)&u.nv_81xx.port_name);
+	}
+	pr_info("%s:%u:from %s unrecognized QLogic HQ type\n", __FILE__,__LINE__,funct);
+	return 0ULL;
+
+}
+#endif	// M4_DEBUG_PRINT || NEW_MATCH_WWPN
+
+/* ------------------------------------------------------------------------ */
+#if defined(M4_DEBUG_PRINT) || defined(NEW_MATCH_WWPN)
+void print_port_name_from_nv(scsi_qla_host_t *vha, const char *funct)
+{
+	u64 pn;
+
+	if (vha == NULL)
+	{
+	    m4_debug("%s:%u:from %s vha==NULL\n", __FILE__,__LINE__,funct);
+	    return;
+	}
+	pn = get_port_name_from_nv(vha, funct);
+	m4_debug("%s:%u:from %s nv.port_name=%llx\n", __FILE__,__LINE__,funct, swab64(pn));
+}
+#endif	// M4_DEBUG_PRINT || NEW_MATCH_WWPN
+
+/* ------------------------------------------------------------------------ */
 /*
 * qla2x00_initialize_adapter
 *      Initialize board.
 *
 * Input:
 *      ha = adapter block pointer.
 *
@@ -2728,14 +2826,42 @@ qla2x00_initialize_adapter(scsi_qla_host
 	rval = qla2xxx_get_flash_info(vha);
 	if (rval) {
 		ql_log(ql_log_fatal, vha, 0x004f,
 		    "Unable to validate FLASH data.\n");
 		return rval;
 	}
 
+// ==============================================================================
+// WWPN available after this point.
+m4_debug("%s:%u:%s WWPN available now supported_mode(%d) active_mode(%d)\n", __FILE__,__LINE__,__func__, vha->host->hostt->supported_mode, vha->host->active_mode);
+print_port_name_from_nv(vha, __func__);
+#ifdef NEW_MATCH_WWPN
+	/* got port_name here. */
+	/* What we want here is if qlini_mode == disabled	-- do nothing. */
+	/*                      if qlini_mode == enabled	-- any qlini_targets? do nothing. */
+	if (QLA_TGT_MODE_ENABLED())
+	{
+	    ;
+	}
+	else if (*qlini_targets != '\0')	// If possible targets with 'enabled' -- see if this port.
+	{
+	    if (!find_slot_wwpn(vha, swab64(get_port_name_from_nv(vha, __func__)), -1, __func__))
+	    {
+		vha->host->active_mode = MODE_INITIATOR;
+		vha->host->hostt->supported_mode = MODE_INITIATOR;
+	    }
+	    else
+	    {
+		vha->qlini_mode = QLA2XXX_INI_MODE_DISABLED;	// 2019-04-25 M4: slot found in target list.
+	    }
+	}
+m4_debug("%s:%u:%s AFTER SETTING supported_mode(%d) active_mode(%d) port_name=%llx\n", __FILE__,__LINE__,__func__, vha->host->hostt->supported_mode, vha->host->active_mode, swab64(get_port_name_from_nv(vha, __func__)));
+#endif	/* NEW_MATCH_WWPN */
+// ==============================================================================
+
 	if (IS_QLA8044(ha)) {
 		qla8044_read_reset_template(vha);
 
 		/* NOTE: If ql2xdontresethba==1, set IDC_CTRL DONTRESET_BIT0.
 		 * If DONRESET_BIT0 is set, drivers should not set dev_state
 		 * to NEED_RESET. But if NEED_RESET is set, drivers should
 		 * should honor the reset. */
@@ -7944,14 +8070,71 @@ qla24xx_nvram_config(scsi_qla_host_t *vh
 		nv->max_luns_per_target = cpu_to_le16(128);
 		nv->port_down_retry_count = cpu_to_le16(30);
 		nv->link_down_timeout = cpu_to_le16(30);
 
 		rval = 1;
 	}
 
+//----------------------------------------------------------------------------
+m4_debug("%s:%u:%s MOVED nv->port_name=%llx\n", __FILE__,__LINE__,__func__, swab64(*(u64*)nv->port_name));
+m4_debug("%s:%u:%s reading SUPPORTED_MODE(%d) active_mode(%d)\n", __FILE__,__LINE__,__func__, vha->host->hostt->supported_mode, vha->host->active_mode);
+
+#ifdef NEW_MATCH_WWPN
+	if (QLA_TGT_MODE_ENABLED())		// if target mode for everything, nothing to do?
+	{
+m4_debug("%s:%u:%s QLA_TGT_MODE_ENABLED() - do nothing\n", __FILE__,__LINE__,__func__);
+		;
+	}
+	else if (*qlini_targets != '\0')	// initiator mode, unless IP's given.
+	{
+	    /* got port_name here. */
+	    if (find_slot_wwpn(vha, swab64(*(u64*)nv->port_name), -1, __func__))
+	    {
+m4_debug("%s:%u:%s slot found: supported_mode(%d) active_mode(%d)\n", __FILE__,__LINE__,__func__, vha->host->hostt->supported_mode, vha->host->active_mode);
+// 		if (vha->host->active_mode == 0)
+// 		    vha->host->hostt->supported_mode = MODE_TARGET;
+// m4_debug("%s:%u:%s After slot found if: supported_mode(%d) active_mode(%d)\n", __FILE__,__LINE__,__func__, vha->host->hostt->supported_mode, vha->host->active_mode);
+	    }
+	    else
+	    {
+m4_debug("%s:%u:%s slot not found\n", __FILE__,__LINE__,__func__);
+		if (vha->host->active_mode == 0)
+		{
+		    switch (ql2x_ini_mode)
+		    {
+			case QLA2XXX_INI_MODE_DISABLED:
+			    vha->host->hostt->supported_mode = MODE_TARGET;
+			    break;
+
+			case QLA2XXX_INI_MODE_ENABLED:
+			    vha->host->active_mode = MODE_INITIATOR;
+			    vha->host->hostt->supported_mode = MODE_INITIATOR;
+			    break;
+
+			case QLA2XXX_INI_MODE_EXCLUSIVE:
+			default:
+			    vha->host->hostt->supported_mode = MODE_TARGET | MODE_INITIATOR;
+			    break;
+		    }
+m4_debug("%s:%u:%s After setting: supported_mode(%d) active_mode(%d)\n", __FILE__,__LINE__,__func__, vha->host->hostt->supported_mode, vha->host->active_mode);
+		}
+		else
+		{
+m4_debug("%s:%u:%s Do not set, active mode already set! supported_mode(%d) active_mode(%d)\n", __FILE__,__LINE__,__func__, vha->host->hostt->supported_mode, vha->host->active_mode);
+		}
+	    }
+	}
+	else
+	{
+m4_debug("%s:%u:%s initiator mode and no wwpn specified - do nothing\n", __FILE__,__LINE__,__func__);
+	}
+#endif	/* NEW_MATCH_WWPN */
+// ==============================================================================
+m4_debug("%s:%u:%s #2 After HERE_2 SUPPORTED_MODE(%d) active_mode(%d) nv->port_name=%llx\n", __FILE__,__LINE__,__func__, vha->host->hostt->supported_mode, vha->host->active_mode, swab64(*(u64*)nv->port_name));
+
 	if (qla_tgt_mode_enabled(vha)) {
 		/* Don't enable full login after initial LIP */
 		nv->firmware_options_1 &= cpu_to_le32(~BIT_13);
 		/* Don't enable LIP full login for initiator */
 		nv->host_p &= cpu_to_le32(~BIT_10);
 	}
 
diff -Nrp -U 7 --strip-trailing-cr a/drivers/scsi/qla2xxx/qla_isr.c b/drivers/scsi/qla2xxx/qla_isr.c
--- a/drivers/scsi/qla2xxx/qla_isr.c	2024-02-12 15:07:46.000000000 -0600
+++ b/drivers/scsi/qla2xxx/qla_isr.c	2024-02-12 15:37:40.415381702 -0600
@@ -13,14 +13,17 @@
 #include <linux/t10-pi.h>
 #include <scsi/scsi_tcq.h>
 #include <scsi/scsi_bsg_fc.h>
 #include <scsi/scsi_eh.h>
 #include <scsi/fc/fc_fs.h>
 #include <linux/nvme-fc-driver.h>
 
+extern int find_slot_wwpn(struct scsi_qla_host *, u64, int, const char *);
+extern u64 get_port_name_from_nv(scsi_qla_host_t *, const char *);
+
 static void qla2x00_mbx_completion(scsi_qla_host_t *, uint16_t);
 static void qla2x00_status_entry(scsi_qla_host_t *, struct rsp_que *, void *);
 static void qla2x00_status_cont_entry(struct rsp_que *, sts_cont_entry_t *);
 static int qla2x00_error_entry(scsi_qla_host_t *, struct rsp_que *,
 	sts_entry_t *);
 static void qla27xx_process_purex_fpin(struct scsi_qla_host *vha,
 	struct purex_item *item);
@@ -44,14 +47,16 @@ qla27xx_process_purex_fpin(struct scsi_q
 	       "-------- ELS REQ -------\n");
 	ql_dump_buffer(ql_dbg_init + ql_dbg_verbose, vha, 0x508f,
 		       pkt, pkt_size);
 
 	fc_host_fpin_rcv(vha->host, pkt_size, (char *)pkt, 0);
 }
 
+extern char *qlini_targets;
+
 const char *const port_state_str[] = {
 	[FCS_UNKNOWN]		= "Unknown",
 	[FCS_UNCONFIGURED]	= "UNCONFIGURED",
 	[FCS_DEVICE_DEAD]	= "DEAD",
 	[FCS_DEVICE_LOST]	= "LOST",
 	[FCS_ONLINE]		= "ONLINE"
 };
@@ -2139,21 +2144,23 @@ qla2x00_mbx_iocb_entry(scsi_qla_host_t *
 	case MBS_LOOP_ID_USED:
 		break;
 	default:
 		data[0] = MBS_COMMAND_ERROR;
 		break;
 	}
 
+#if 0
 	ql_log(ql_log_warn, vha, 0x5046,
 	    "Async-%s failed - hdl=%x portid=%02x%02x%02x status=%x "
 	    "mb0=%x mb1=%x mb2=%x mb6=%x mb7=%x.\n", type, sp->handle,
 	    fcport->d_id.b.domain, fcport->d_id.b.area, fcport->d_id.b.al_pa,
 	    status, le16_to_cpu(mbx->mb0), le16_to_cpu(mbx->mb1),
 	    le16_to_cpu(mbx->mb2), le16_to_cpu(mbx->mb6),
 	    le16_to_cpu(mbx->mb7));
+#endif	/* 0  -- less messages */
 
 logio_done:
 	sp->done(sp, 0);
 }
 
 static void
 qla24xx_mbx_iocb_entry(scsi_qla_host_t *vha, struct req_que *req,
@@ -2615,28 +2622,30 @@ qla24xx_logio_entry(scsi_qla_host_t *vha
 		}
 		fallthrough;
 	default:
 		data[0] = MBS_COMMAND_ERROR;
 		break;
 	}
 
+#if 0
 	if (logit)
 		ql_log(ql_log_warn, sp->vha, 0x5037, "Async-%s failed: "
 		       "handle=%x pid=%06x wwpn=%8phC comp_status=%x iop0=%x iop1=%x\n",
 		       type, sp->handle, fcport->d_id.b24, fcport->port_name,
 		       le16_to_cpu(logio->comp_status),
 		       le32_to_cpu(logio->io_parameter[0]),
 		       le32_to_cpu(logio->io_parameter[1]));
 	else
 		ql_dbg(ql_dbg_disc, sp->vha, 0x5037, "Async-%s failed: "
 		       "handle=%x pid=%06x wwpn=%8phC comp_status=%x iop0=%x iop1=%x\n",
 		       type, sp->handle, fcport->d_id.b24, fcport->port_name,
 		       le16_to_cpu(logio->comp_status),
 		       le32_to_cpu(logio->io_parameter[0]),
 		       le32_to_cpu(logio->io_parameter[1]));
+#endif	/* 0  -- less messages */
 
 logio_done:
 	sp->done(sp, 0);
 }
 
 static void
 qla24xx_tm_iocb_entry(scsi_qla_host_t *vha, struct req_que *req, void *tsk)
@@ -4526,16 +4535,18 @@ qla24xx_enable_msix(struct qla_hw_data *
 	struct qla_msix_entry *qentry;
 	scsi_qla_host_t *vha = pci_get_drvdata(ha->pdev);
 	int min_vecs = QLA_BASE_VECTORS;
 	struct irq_affinity desc = {
 		.pre_vectors = QLA_BASE_VECTORS,
 	};
 
-	if (QLA_TGT_MODE_ENABLED() && (ql2xenablemsix != 0) &&
-	    IS_ATIO_MSIX_CAPABLE(ha)) {
+	if ((QLA_TGT_MODE_ENABLED() && 			// Must check if in target list.
+	    (*qlini_targets &&
+	     find_slot_wwpn(vha, swab64(get_port_name_from_nv(vha,__func__)),-1,__func__))) &&
+	    (ql2xenablemsix != 0) && IS_ATIO_MSIX_CAPABLE(ha)) {
 		desc.pre_vectors++;
 		min_vecs++;
 	}
 
 	if (USER_CTRL_IRQ(ha) || !ha->mqiobase) {
 		/* user wants to control IRQ setting for target mode */
 		ret = pci_alloc_irq_vectors(ha->pdev, min_vecs,
@@ -4558,15 +4569,17 @@ qla24xx_enable_msix(struct qla_hw_data *
 		    "MSI-X: Using %d vectors\n", ret);
 		ha->msix_count = ret;
 		/* Recalculate queue values */
 		if (ha->mqiobase && (ql2xmqsupport || ql2xnvmeenable)) {
 			ha->max_req_queues = ha->msix_count - 1;
 
 			/* ATIOQ needs 1 vector. That's 1 less QPair */
-			if (QLA_TGT_MODE_ENABLED())
+			if (QLA_TGT_MODE_ENABLED() ||	// Must check if in target list.
+			    (*qlini_targets && find_slot_wwpn(vha,
+				  swab64(get_port_name_from_nv(vha,__func__)),-1,__func__)))
 				ha->max_req_queues--;
 
 			ha->max_rsp_queues = ha->max_req_queues;
 
 			ha->max_qpairs = ha->max_req_queues - 1;
 			ql_dbg_pci(ql_dbg_init, ha->pdev, 0x0190,
 			    "Adjusted Max no of queues pairs: %d.\n", ha->max_qpairs);
@@ -4615,16 +4628,21 @@ qla24xx_enable_msix(struct qla_hw_data *
 		qentry->in_use = 1;
 	}
 
 	/*
 	 * If target mode is enable, also request the vector for the ATIO
 	 * queue.
 	 */
+#ifndef NEW_MATCH_WWPN
 	if (QLA_TGT_MODE_ENABLED() && (ql2xenablemsix != 0) &&
 	    IS_ATIO_MSIX_CAPABLE(ha)) {
+#else  // NEW_MATCH_WWPN
+	if ((*qlini_targets != '\0' || QLA_TGT_MODE_ENABLED()) &&
+	    (ql2xenablemsix != 0) && IS_ATIO_MSIX_CAPABLE(ha)) {
+#endif	// NEW_MATCH_WWPN
 		qentry = &ha->msix_entries[QLA_ATIO_VECTOR];
 		rsp->msix = qentry;
 		qentry->handle = rsp;
 		scnprintf(qentry->name, sizeof(qentry->name),
 		    "qla2xxx%lu_%s", vha->host_no,
 		    msix_entries[QLA_ATIO_VECTOR].name);
 		qentry->in_use = 1;
diff -Nrp -U 7 --strip-trailing-cr a/drivers/scsi/qla2xxx/qla_mid.c b/drivers/scsi/qla2xxx/qla_mid.c
--- a/drivers/scsi/qla2xxx/qla_mid.c	2024-02-12 15:07:46.000000000 -0600
+++ b/drivers/scsi/qla2xxx/qla_mid.c	2024-02-12 15:37:40.415381702 -0600
@@ -492,16 +492,28 @@ qla24xx_vport_create_req_sanity_check(st
 
 scsi_qla_host_t *
 qla24xx_create_vhost(struct fc_vport *fc_vport)
 {
 	scsi_qla_host_t *base_vha = shost_priv(fc_vport->shost);
 	struct qla_hw_data *ha = base_vha->hw;
 	scsi_qla_host_t *vha;
+#ifndef NEW_ALLOC_SCSI_TRANSPORT_TEMPLATE
 	const struct scsi_host_template *sht = &qla2xxx_driver_template;
+#else	// NEW_ALLOC_SCSI_TRANSPORT_TEMPLATE
+	struct scsi_host_template *sht;
+#endif	// NEW_ALLOC_SCSI_TRANSPORT_TEMPLATE
 	struct Scsi_Host *host;
+#ifdef NEW_ALLOC_SCSI_TRANSPORT_TEMPLATE
+	struct fc_function_template *transport_functions;
+
+// NOTDONEYET -- where to free this ??
+	sht = kzalloc(sizeof(qla2xxx_driver_template), GFP_KERNEL);
+	memcpy(sht, &qla2xxx_driver_template, sizeof(*sht));
+m4_debug("%s:%u:%s create vha from template -- ***supported_mode***=1=MODE_INITIATOR(%d)?\n", __FILE__,__LINE__,__func__, sht->supported_mode);
+#endif	// NEW_ALLOC_SCSI_TRANSPORT_TEMPLATE
 
 	vha = qla2x00_create_host(sht, ha);
 	if (!vha) {
 		ql_log(ql_log_warn, vha, 0xa005,
 		    "scsi_host_alloc() failed for vport.\n");
 		return(NULL);
 	}
@@ -545,15 +557,33 @@ qla24xx_create_vhost(struct fc_vport *fc
 		host->max_cmd_len = 32;
 	else
 		host->max_cmd_len = MAX_CMDSZ;
 	host->max_channel = MAX_BUSES - 1;
 	host->max_lun = ql2xmaxlun;
 	host->unique_id = host->host_no;
 	host->max_id = ha->max_fibre_devices;
+#ifndef NEW_ALLOC_SCSI_TRANSPORT_TEMPLATE
 	host->transportt = qla2xxx_transport_vport_template;
+#else	// NEW_ALLOC_SCSI_TRANSPORT_TEMPLATE
+	transport_functions = kzalloc(sizeof(qla2xxx_transport_vport_functions), GFP_KERNEL);
+	if (!transport_functions)       /* Allocation failed */
+	{
+		ql_log(ql_log_fatal, vha, 0x003d,
+		    "Failed to allocate memory for transport_vport_functions(1), aborting.\n");
+		goto create_vhost_failed;
+	}
+	memcpy(transport_functions, &qla2xxx_transport_vport_functions, sizeof(*transport_functions));
+	host->transportt = fc_attach_transport(transport_functions);
+	if (!host->transportt)          /* Allocation failed */
+	{
+		ql_log(ql_log_fatal, vha, 0x003d,
+		    "Failed to allocate memory for transport_vport_functions(2), aborting.\n");
+		goto create_vhost_failed;
+	}
+#endif	// NEW_ALLOC_SCSI_TRANSPORT_TEMPLATE
 
 	ql_dbg(ql_dbg_vport, vha, 0xa007,
 	    "Detect vport hba %ld at address = %p.\n",
 	    vha->host_no, vha);
 
 	vha->flags.init_done = 1;
 
diff -Nrp -U 7 --strip-trailing-cr a/drivers/scsi/qla2xxx/qla_os.c b/drivers/scsi/qla2xxx/qla_os.c
--- a/drivers/scsi/qla2xxx/qla_os.c	2024-02-12 15:07:46.000000000 -0600
+++ b/drivers/scsi/qla2xxx/qla_os.c	2024-02-12 15:37:40.416381698 -0600
@@ -22,14 +22,64 @@
 #include <scsi/scsi_tcq.h>
 #include <scsi/scsicam.h>
 #include <scsi/scsi_transport.h>
 #include <scsi/scsi_transport_fc.h>
 
 #include "qla_target.h"
 
+/* ------------------------------------------------------------------------ */
+/* Externally defined routines. */
+extern int find_slot_wwpn(struct scsi_qla_host *, u64, int, const char *);
+extern u64 get_port_name_from_nv(scsi_qla_host_t *, const char *);
+
+extern char *qlini_targets;
+/* ------------------------------------------------------------------------ */
+/* I need this from the kernel internal routine area! */
+/*
+ * Attribute counts pre object type...
+ * Increase these values if you add attributes
+ */
+#define FC_STARGET_NUM_ATTRS    3
+#define FC_RPORT_NUM_ATTRS      10
+#define FC_VPORT_NUM_ATTRS      9
+#define FC_HOST_NUM_ATTRS       29
+
+struct fc_internal {
+        struct scsi_transport_template t;
+        struct fc_function_template *f;
+
+        /*
+         * For attributes : each object has :
+         *   An array of the actual attributes structures
+         *   An array of null-terminated pointers to the attribute
+         *     structures - used for mid-layer interaction.
+         *
+         * The attribute containers for the starget and host are are
+         * part of the midlayer. As the remote port is specific to the
+         * fc transport, we must provide the attribute container.
+         */
+        struct device_attribute private_starget_attrs[
+                                                        FC_STARGET_NUM_ATTRS];
+        struct device_attribute *starget_attrs[FC_STARGET_NUM_ATTRS + 1];
+
+        struct device_attribute private_host_attrs[FC_HOST_NUM_ATTRS];
+        struct device_attribute *host_attrs[FC_HOST_NUM_ATTRS + 1];
+
+        struct transport_container rport_attr_cont;
+        struct device_attribute private_rport_attrs[FC_RPORT_NUM_ATTRS];
+        struct device_attribute *rport_attrs[FC_RPORT_NUM_ATTRS + 1];
+
+        struct transport_container vport_attr_cont;
+        struct device_attribute private_vport_attrs[FC_VPORT_NUM_ATTRS];
+        struct device_attribute *vport_attrs[FC_VPORT_NUM_ATTRS + 1];
+};
+
+#define to_fc_internal(tmpl)    container_of(tmpl, struct fc_internal, t)
+/* ------------------------------------------------------------------------ */
+
 /*
  * Driver version
  */
 char qla2x00_version_str[40];
 
 static int apidev_major;
 
@@ -365,16 +415,18 @@ MODULE_PARM_DESC(ql2xnvme_queues,
 int ql2xfc2target = 1;
 module_param(ql2xfc2target, int, 0444);
 MODULE_PARM_DESC(qla2xfc2target,
 		  "Enables FC2 Target support. "
 		  "0 - FC2 Target support is disabled. "
 		  "1 - FC2 Target support is enabled (default).");
 
+#ifndef NEW_ALLOC_SCSI_TRANSPORT_TEMPLATE
 static struct scsi_transport_template *qla2xxx_transport_template = NULL;
 struct scsi_transport_template *qla2xxx_transport_vport_template = NULL;
+#endif	// NEW_ALLOC_SCSI_TRANSPORT_TEMPLATE
 
 /* TODO Convert to inlines
  *
  * Timer routines
  */
 
 __inline__ void
@@ -2222,15 +2274,19 @@ qla83xx_iospace_config(struct qla_hw_dat
 		 * (default & rspq)
 		 */
 		if (ql2xmqsupport || ql2xnvmeenable) {
 			/* MB interrupt uses 1 vector */
 			ha->max_req_queues = ha->msix_count - 1;
 
 			/* ATIOQ needs 1 vector. That's 1 less QPair */
+#ifndef NEW_MATCH_WWPN
 			if (QLA_TGT_MODE_ENABLED())
+#else  // NEW_MATCH_WWPN
+			if (*qlini_targets != '\0' || QLA_TGT_MODE_ENABLED())
+#endif // NEW_MATCH_WWPN
 				ha->max_req_queues--;
 
 			ha->max_rsp_queues = ha->max_req_queues;
 
 			/* Queue pairs is the max value minus
 			 * the base queue pair */
 			ha->max_qpairs = ha->max_req_queues - 1;
@@ -2921,17 +2977,23 @@ qla2x00_probe_one(struct pci_dev *pdev,
 	char fw_str[30], wq_name[30];
 	struct scsi_host_template *sht;
 	int bars, mem_only = 0;
 	uint16_t req_length = 0, rsp_length = 0;
 	struct req_que *req = NULL;
 	struct rsp_que *rsp = NULL;
 	int i;
+#ifdef NEW_ALLOC_SCSI_TRANSPORT_TEMPLATE
+	struct fc_internal *fi;
+	struct fc_function_template *transport_functions;
+#endif	// NEW_ALLOC_SCSI_TRANSPORT_TEMPLATE
 
 	bars = pci_select_bars(pdev, IORESOURCE_MEM | IORESOURCE_IO);
+#ifndef NEW_ALLOC_SCSI_TRANSPORT_TEMPLATE
 	sht = &qla2xxx_driver_template;
+#endif	// NEW_ALLOC_SCSI_TRANSPORT_TEMPLATE
 	if (pdev->device == PCI_DEVICE_ID_QLOGIC_ISP2422 ||
 	    pdev->device == PCI_DEVICE_ID_QLOGIC_ISP2432 ||
 	    pdev->device == PCI_DEVICE_ID_QLOGIC_ISP8432 ||
 	    pdev->device == PCI_DEVICE_ID_QLOGIC_ISP5422 ||
 	    pdev->device == PCI_DEVICE_ID_QLOGIC_ISP5432 ||
 	    pdev->device == PCI_DEVICE_ID_QLOGIC_ISP2532 ||
 	    pdev->device == PCI_DEVICE_ID_QLOGIC_ISP8001 ||
@@ -3252,14 +3314,19 @@ qla2x00_probe_one(struct pci_dev *pdev,
 		goto probe_hw_failed;
 	}
 
 	req->max_q_depth = MAX_Q_DEPTH;
 	if (ql2xmaxqdepth != 0 && ql2xmaxqdepth <= 0xffffU)
 		req->max_q_depth = ql2xmaxqdepth;
 
+#ifdef NEW_ALLOC_SCSI_TRANSPORT_TEMPLATE
+// NOTDONEYET -- where to free this ??
+	sht = kzalloc(sizeof(qla2xxx_driver_template), GFP_KERNEL);
+	memcpy(sht,&qla2xxx_driver_template, sizeof(*sht));
+#endif	// NEW_ALLOC_SCSI_TRANSPORT_TEMPLATE
 
 	base_vha = qla2x00_create_host(sht, ha);
 	if (!base_vha) {
 		ret = -ENOMEM;
 		goto probe_hw_failed;
 	}
 
@@ -3312,15 +3379,35 @@ qla2x00_probe_one(struct pci_dev *pdev,
 	host->max_channel = MAX_BUSES - 1;
 	/* Older HBAs support only 16-bit LUNs */
 	if (!IS_QLAFX00(ha) && !IS_FWI2_CAPABLE(ha) &&
 	    ql2xmaxlun > 0xffff)
 		host->max_lun = 0xffff;
 	else
 		host->max_lun = ql2xmaxlun;
+
+#ifndef NEW_ALLOC_SCSI_TRANSPORT_TEMPLATE
 	host->transportt = qla2xxx_transport_template;
+#else //NEW_ALLOC_SCSI_TRANSPORT_TEMPLATE
+	transport_functions = kzalloc(sizeof(qla2xxx_transport_functions), GFP_KERNEL);
+	if (!transport_functions)       /* Allocation failed */
+	{
+		ql_log(ql_log_fatal, base_vha, 0x003d,
+		    "Failed to allocate memory for transport_functions(1), aborting.\n");
+		goto probe_failed;
+	}
+	memcpy(transport_functions, &qla2xxx_transport_functions, sizeof(*transport_functions));
+	host->transportt = fc_attach_transport(transport_functions);
+	if (!host->transportt)          /* Allocation failed */
+	{
+		ql_log(ql_log_fatal, base_vha, 0x003d,
+		    "Failed to allocate memory for transport_functions(2), aborting.\n");
+		goto probe_failed;
+	}
+#endif	//NEW_ALLOC_SCSI_TRANSPORT_TEMPLATE
+
 	sht->vendor_id = (SCSI_NL_VID_TYPE_PCI | PCI_VENDOR_ID_QLOGIC);
 
 	ql_dbg(ql_dbg_init, base_vha, 0x0033,
 	    "max_id=%d this_id=%d "
 	    "cmd_per_len=%d unique_id=%d max_cmd_len=%d max_channel=%d "
 	    "max_lun=%llu transportt=%p, vendor_id=%llu.\n", host->max_id,
 	    host->this_id, host->cmd_per_lun, host->unique_id,
@@ -3445,14 +3532,37 @@ qla2x00_probe_one(struct pci_dev *pdev,
 			ql_log(ql_log_fatal, base_vha, 0x0150,
 			    "HW State: FAILED.\n");
 		}
 
 		ret = -ENODEV;
 		goto probe_failed;
 	}
+//============================================================================
+//WWPN available here.
+#ifdef NEW_ALLOC_SCSI_TRANSPORT_TEMPLATE
+	fi = to_fc_internal(host->transportt);
+        if (ql2x_ini_mode == QLA2XXX_INI_MODE_DISABLED)	// Target mode
+	{
+	    fi->f->disable_target_scan = 1;
+	}
+#ifdef NEW_MATCH_WWPN
+	else if (*qlini_targets &&
+	         find_slot_wwpn(base_vha, swab64(get_port_name_from_nv(base_vha,__func__)),-1,__func__))
+	{
+	    fi->f->disable_target_scan = 1;
+        }
+	else
+	{
+	    fi->f->disable_target_scan = 0;
+	    base_vha->host->active_mode = MODE_INITIATOR;
+	    base_vha->host->hostt->supported_mode = MODE_INITIATOR;
+	}
+#endif	// NEW_MATCH_WWPN
+#endif	// NEW_ALLOC_SCSI_TRANSPORT_TEMPLATE
+//============================================================================
 
 	if (IS_QLAFX00(ha))
 		host->can_queue = QLAFX00_MAX_CANQUEUE;
 	else
 		host->can_queue = req->num_outstanding_cmds - 10;
 
 	ql_dbg(ql_dbg_init, base_vha, 0x0032,
@@ -3467,15 +3577,21 @@ qla2x00_probe_one(struct pci_dev *pdev,
 	if (ha->mqenable) {
 		bool startit = false;
 
 		if (QLA_TGT_MODE_ENABLED())
 			startit = false;
 
 		if (ql2x_ini_mode == QLA2XXX_INI_MODE_ENABLED)
-			startit = true;
+		{
+		    if (*qlini_targets &&
+		        find_slot_wwpn(base_vha, swab64(get_port_name_from_nv(base_vha,__func__)),-1,__func__))
+			    startit = false;
+		    else
+			    startit = true;
+		}
 
 		/* Create start of day qpairs for Block MQ */
 		for (i = 0; i < ha->max_qpairs; i++)
 			qla2xxx_create_qpair(base_vha, 5, 0, startit);
 	}
 	qla_init_iocb_limit(base_vha);
 
@@ -8274,75 +8390,86 @@ qla2x00_module_init(void)
 		return -ENOMEM;
 	}
 
 	/* Initialize target kmem_cache and mem_pools */
 	ret = qlt_init();
 	if (ret < 0) {
 		goto destroy_cache;
+#ifndef NEW_ALLOC_SCSI_TRANSPORT_TEMPLATE
 	} else if (ret > 0) {
 		/*
 		 * If initiator mode is explictly disabled by qlt_init(),
 		 * prevent scsi_transport_fc.c:fc_scsi_scan_rport() from
 		 * performing scsi_scan_target() during LOOP UP event.
 		 */
 		qla2xxx_transport_functions.disable_target_scan = 1;
 		qla2xxx_transport_vport_functions.disable_target_scan = 1;
+#endif // NEW_ALLOC_SCSI_TRANSPORT_TEMPLATE
 	}
 
 	/* Derive version string. */
 	strcpy(qla2x00_version_str, QLA2XXX_VERSION);
 	if (ql2xextended_error_logging)
 		strcat(qla2x00_version_str, "-debug");
 	if (ql2xextended_error_logging == 1)
 		ql2xextended_error_logging = QL_DBG_DEFAULT1_MASK;
 
+#ifndef NEW_ALLOC_SCSI_TRANSPORT_TEMPLATE
 	qla2xxx_transport_template =
 	    fc_attach_transport(&qla2xxx_transport_functions);
 	if (!qla2xxx_transport_template) {
 		ql_log(ql_log_fatal, NULL, 0x0002,
 		    "fc_attach_transport failed...Failing load!.\n");
 		ret = -ENODEV;
 		goto qlt_exit;
 	}
+#endif // NEW_ALLOC_SCSI_TRANSPORT_TEMPLATE
 
 	apidev_major = register_chrdev(0, QLA2XXX_APIDEV, &apidev_fops);
 	if (apidev_major < 0) {
 		ql_log(ql_log_fatal, NULL, 0x0003,
 		    "Unable to register char device %s.\n", QLA2XXX_APIDEV);
 	}
 
+#ifndef NEW_ALLOC_SCSI_TRANSPORT_TEMPLATE
 	qla2xxx_transport_vport_template =
 	    fc_attach_transport(&qla2xxx_transport_vport_functions);
 	if (!qla2xxx_transport_vport_template) {
 		ql_log(ql_log_fatal, NULL, 0x0004,
 		    "fc_attach_transport vport failed...Failing load!.\n");
 		ret = -ENODEV;
 		goto unreg_chrdev;
 	}
+#endif // NEW_ALLOC_SCSI_TRANSPORT_TEMPLATE
 	ql_log(ql_log_info, NULL, 0x0005,
 	    "QLogic Fibre Channel HBA Driver: %s.\n",
 	    qla2x00_version_str);
 	ret = pci_register_driver(&qla2xxx_pci_driver);
 	if (ret) {
 		ql_log(ql_log_fatal, NULL, 0x0006,
 		    "pci_register_driver failed...ret=%d Failing load!.\n",
 		    ret);
 		goto release_vport_transport;
 	}
 	return ret;
 
 release_vport_transport:
+#ifndef NEW_ALLOC_SCSI_TRANSPORT_TEMPLATE
 	fc_release_transport(qla2xxx_transport_vport_template);
 
 unreg_chrdev:
+#endif // NEW_ALLOC_SCSI_TRANSPORT_TEMPLATE
+// NOTDONEYET -- qla2xxx_transport - cannot release.
 	if (apidev_major >= 0)
 		unregister_chrdev(apidev_major, QLA2XXX_APIDEV);
+#ifndef NEW_ALLOC_SCSI_TRANSPORT_TEMPLATE
 	fc_release_transport(qla2xxx_transport_template);
 
 qlt_exit:
+#endif // NEW_ALLOC_SCSI_TRANSPORT_TEMPLATE
 	qlt_exit();
 
 destroy_cache:
 	kmem_cache_destroy(srb_cachep);
 
 	qla_trace_uninit();
 	return ret;
@@ -8353,18 +8480,24 @@ destroy_cache:
  **/
 static void __exit
 qla2x00_module_exit(void)
 {
 	pci_unregister_driver(&qla2xxx_pci_driver);
 	qla2x00_release_firmware();
 	kmem_cache_destroy(ctx_cachep);
+#ifndef NEW_ALLOC_SCSI_TRANSPORT_TEMPLATE
+// NOTDONEYET -- qla2xxx_transport - cannot release.
 	fc_release_transport(qla2xxx_transport_vport_template);
+#endif // NEW_ALLOC_SCSI_TRANSPORT_TEMPLATE
 	if (apidev_major >= 0)
 		unregister_chrdev(apidev_major, QLA2XXX_APIDEV);
+#ifndef NEW_ALLOC_SCSI_TRANSPORT_TEMPLATE
+// NOTDONEYET -- qla2xxx_transport - cannot release.
 	fc_release_transport(qla2xxx_transport_template);
+#endif // NEW_ALLOC_SCSI_TRANSPORT_TEMPLATE
 	qlt_exit();
 	kmem_cache_destroy(srb_cachep);
 	qla_trace_uninit();
 }
 
 module_init(qla2x00_module_init);
 module_exit(qla2x00_module_exit);
diff -Nrp -U 7 --strip-trailing-cr a/drivers/scsi/qla2xxx/qla_target.c b/drivers/scsi/qla2xxx/qla_target.c
--- a/drivers/scsi/qla2xxx/qla_target.c	2024-02-12 15:07:46.000000000 -0600
+++ b/drivers/scsi/qla2xxx/qla_target.c	2024-02-12 15:37:40.416381698 -0600
@@ -27,19 +27,54 @@
 #include <scsi/scsi.h>
 #include <scsi/scsi_host.h>
 #include <scsi/scsi_tcq.h>
 
 #include "qla_def.h"
 #include "qla_target.h"
 
+/* ------------------------------------------------------------------------ */
+/* Forward definition (also used in other file(s). */
+int find_slot_wwpn(struct scsi_qla_host *, u64, int, const char *);
+
+/* Externally defined routines. */
+extern u64 get_port_name_from_nv(scsi_qla_host_t *, const char *);
+/* ------------------------------------------------------------------------ */
+static struct fc_port *qlt_make_local_sess(struct scsi_qla_host *vha,
+					   be_id_t s_id);
+/* ------------------------------------------------------------------------ */
+
 static int ql2xtgt_tape_enable;
 module_param(ql2xtgt_tape_enable, int, S_IRUGO|S_IWUSR);
 MODULE_PARM_DESC(ql2xtgt_tape_enable,
 		"Enables Sequence level error recovery (aka FC Tape). Default is 0 - no SLER. 1 - Enable SLER.");
 
+#ifdef NEW_MATCH_WWPN
+/* No ports that default to target mode upon start. */
+char *qlini_targets = "";
+module_param(qlini_targets, charp, S_IRUGO);
+MODULE_PARM_DESC(qlini_targets,
+	"Determines which Physical slots (or WWPNs) will be set as target mode. "
+	"Value examples: "
+	" a) 2,4 -- physical slots 2 and 4 are target mode. "
+	" b) 21:00:00:24:ff:0f:b0:c5,21:00:00:24:ff:33:db:8e4 -- WWPNs.");
+enum ini_target_types {
+	qlini_physical_slot = 0,
+	qlini_wwpn          = 1,
+	qlini_error         = 2
+};
+struct ini_targets {
+	enum ini_target_types tt;
+	union {
+		int   physical_slot;
+		u64   wwpn;
+	} td;
+	struct ini_targets *next;
+} *ql2x_ini_targets = NULL;
+#endif	// NEW_MATCH_WWPN
+
 static char *qlini_mode = QLA2XXX_INI_MODE_STR_ENABLED;
 module_param(qlini_mode, charp, S_IRUGO);
 MODULE_PARM_DESC(qlini_mode,
 	"Determines when initiator mode will be enabled. Possible values: "
 	"\"exclusive\" - initiator mode will be enabled on load, "
 	"disabled on enabling target mode and then on disabling target mode "
 	"enabled back; "
@@ -664,16 +699,16 @@ void qla24xx_do_nack_work(struct scsi_ql
 		t = e->u.nack.fcport;
 		flush_work(&t->del_work);
 		flush_work(&t->free_work);
 		mutex_lock(&vha->vha_tgt.tgt_mutex);
 		t = qlt_create_sess(vha, e->u.nack.fcport, 0);
 		mutex_unlock(&vha->vha_tgt.tgt_mutex);
 		if (t) {
-			ql_log(ql_log_info, vha, 0xd034,
-			    "%s create sess success %p", __func__, t);
+//			ql_log(ql_log_info, vha, 0xd034,
+//			    "%s create sess success %p", __func__, t);
 			/* create sess has an extra kref */
 			vha->hw->tgt.tgt_ops->put_sess(e->u.nack.fcport);
 		}
 		break;
 	}
 	qla24xx_async_notify_ack(vha, e->u.nack.fcport,
 	    (struct imm_ntfy_from_isp *)e->u.nack.iocb, e->u.nack.type);
@@ -4356,14 +4391,84 @@ static struct qla_tgt_cmd *qlt_get_tag(s
 	cmd->reset_count = vha->hw->base_qpair->chip_reset;
 	cmd->vp_idx = vha->vp_idx;
 	cmd->edif = sess->edif.enable;
 
 	return cmd;
 }
 
+// static void qlt_create_sess_from_atio(struct work_struct *work)
+// {
+// 	struct qla_tgt_sess_op *op = container_of(work,
+// 					struct qla_tgt_sess_op, work);
+// 	scsi_qla_host_t *vha = op->vha;
+// 	struct qla_hw_data *ha = vha->hw;
+// 	struct fc_port *sess;
+// 	struct qla_tgt_cmd *cmd;
+// 	unsigned long flags;
+// 	be_id_t s_id = op->atio.u.isp24.fcp_hdr.s_id;
+// 
+// 	spin_lock_irqsave(&vha->cmd_list_lock, flags);
+// 	list_del(&op->cmd_list);
+// 	spin_unlock_irqrestore(&vha->cmd_list_lock, flags);
+// 
+// 	if (op->aborted) {
+// 		ql_dbg(ql_dbg_tgt_mgt, vha, 0xf083,
+// 		    "sess_op with tag %u is aborted\n",
+// 		    op->atio.u.isp24.exchange_addr);
+// 		goto out_term;
+// 	}
+// 
+// 	ql_dbg(ql_dbg_tgt_mgt, vha, 0xf022,
+// 	    "qla_target(%d): Unable to find wwn login"
+// 	    " (s_id %x:%x:%x), trying to create it manually\n",
+// 	    vha->vp_idx, s_id.domain, s_id.area, s_id.al_pa);
+// 
+// 	if (op->atio.u.raw.entry_count > 1) {
+// 		ql_dbg(ql_dbg_tgt_mgt, vha, 0xf023,
+// 		    "Dropping multy entry atio %p\n", &op->atio);
+// 		goto out_term;
+// 	}
+// 
+// 	sess = qlt_make_local_sess(vha, s_id);
+// 	/* sess has an extra creation ref. */
+// 
+// 	if (!sess)
+// 		goto out_term;
+// 	/*
+// 	 * Now obtain a pre-allocated session tag using the original op->atio
+// 	 * packet header, and dispatch into __qlt_do_work() using the existing
+// 	 * process context.
+// 	 */
+// 	cmd = qlt_get_tag(vha, sess, &op->atio);
+// 	if (!cmd) {
+// 		struct qla_qpair *qpair = ha->base_qpair;
+// 
+// 		spin_lock_irqsave(qpair->qp_lock_ptr, flags);
+// 		qlt_send_busy(qpair, &op->atio, SAM_STAT_BUSY);
+// 		spin_unlock_irqrestore(qpair->qp_lock_ptr, flags);
+// 
+// 		spin_lock_irqsave(&ha->tgt.sess_lock, flags);
+// 		ha->tgt.tgt_ops->put_sess(sess);
+// 		spin_unlock_irqrestore(&ha->tgt.sess_lock, flags);
+// 		kfree(op);
+// 		return;
+// 	}
+// 
+// 	/*
+// 	 * __qlt_do_work() will call qlt_put_sess() to release
+// 	 * the extra reference taken above by qlt_make_local_sess()
+// 	 */
+// 	__qlt_do_work(cmd);
+// 	kfree(op);
+// 	return;
+// out_term:
+// 	qlt_send_term_exchange(vha->hw->base_qpair, NULL, &op->atio, 0, 0);
+// 	kfree(op);
+// }
+
 /* ha->hardware_lock supposed to be held on entry */
 static int qlt_handle_cmd_for_atio(struct scsi_qla_host *vha,
 	struct atio_from_isp *atio)
 {
 	struct qla_hw_data *ha = vha->hw;
 	struct qla_tgt *tgt = vha->vha_tgt.qla_tgt;
 	struct fc_port *sess;
@@ -4380,14 +4485,31 @@ static int qlt_handle_cmd_for_atio(struc
 	id = be_to_port_id(atio->u.isp24.fcp_hdr.s_id);
 	if (IS_SW_RESV_ADDR(id))
 		return -EBUSY;
 
 	sess = ha->tgt.tgt_ops->find_sess_by_s_id(vha, atio->u.isp24.fcp_hdr.s_id);
 	if (unlikely(!sess))
 		return -EFAULT;
+//	{
+//		struct qla_tgt_sess_op *op = kzalloc(sizeof(struct qla_tgt_sess_op),
+//						     GFP_ATOMIC);
+//		if (!op)
+//			return -ENOMEM;
+//
+//		memcpy(&op->atio, atio, sizeof(*atio));
+//		op->vha = vha;
+//
+//		spin_lock_irqsave(&vha->cmd_list_lock, flags);
+//		list_add_tail(&op->cmd_list, &vha->qla_sess_op_cmd_list);
+//		spin_unlock_irqrestore(&vha->cmd_list_lock, flags);
+//
+//		INIT_WORK(&op->work, qlt_create_sess_from_atio);
+//		queue_work(qla_tgt_wq, &op->work);
+//		return 0;
+//	}
 
 	/* Another WWN used to have our s_id. Our PLOGI scheduled its
 	 * session deletion, but it's still in sess_del_work wq */
 	if (sess->deleted) {
 		ql_dbg(ql_dbg_tgt_mgt, vha, 0xf002,
 		    "New command while old session %p is being deleted\n",
 		    sess);
@@ -6352,23 +6474,88 @@ static void qlt_sess_work_fn(struct work
 		spin_lock_irqsave(&tgt->sess_work_lock, flags);
 
 		kfree(prm);
 	}
 	spin_unlock_irqrestore(&tgt->sess_work_lock, flags);
 }
 
+#ifdef NEW_MATCH_WWPN
+/* Check if qla_host qlini_targets: physical slot or wwpn. */
+int find_slot_wwpn(struct scsi_qla_host *vha, u64 pn, int slt, const char *funct)
+{
+	int slot;
+	struct ini_targets *q;
+	fc_port_t *fcport;
+
+	if (vha == NULL)
+		return false;
+
+	q = ql2x_ini_targets;
+	if (vha->host == NULL)
+	    return false;
+
+	while (q != NULL)
+	{
+	    switch (q->tt)
+	    {
+		case qlini_physical_slot:
+		    if (q->td.physical_slot == slt)
+			return true;
+		    if (vha->hw == NULL || vha->hw->pdev == NULL || vha->hw->pdev->slot == NULL)
+			break;
+		    slot = vha->hw->pdev->slot->number;
+		    if (q->td.physical_slot == slot)
+			return true;
+		    break;
+		case qlini_wwpn:
+		    if (pn != 0 && pn == q->td.wwpn)
+			    return true;
+		    if ((struct fc_host_attrs *)(vha->host)->shost_data != NULL)
+			    if (fc_host_port_name(vha->host) == q->td.wwpn)
+				    return true;
+		    list_for_each_entry(fcport, &vha->vp_fcports, list) {
+			if (q->td.wwpn == *((u64*)&fcport->port_name))
+			    return true;
+		    }
+		    break;
+		default:
+		    break;
+	    }
+	    q = q->next;
+	}
+	return false;
+}
+#endif	// NEW_MATCH_WWPN
+
 /* Must be called under tgt_host_action_mutex */
 int qlt_add_target(struct qla_hw_data *ha, struct scsi_qla_host *base_vha)
 {
 	struct qla_tgt *tgt;
 	int rc, i;
 	struct qla_qpair_hint *h;
+#ifdef NEW_MATCH_WWPN
+	int a_m;
+
+	if (ha == NULL)
+		a_m = find_slot_wwpn(base_vha, 0, -1, __func__);
+	else if (ha->pdev == NULL)
+		a_m = find_slot_wwpn(base_vha, 0, -1, __func__);
+	else if (ha->pdev->slot == NULL)
+		a_m = find_slot_wwpn(base_vha, 0, -1, __func__);
+	else
+		a_m = find_slot_wwpn(base_vha, 0, ha->pdev->slot->number, __func__);
+
+	if (!a_m)
+		if (!QLA_TGT_MODE_ENABLED())
+			return 0;
+#else	// NEW_MATCH_WWPN
 
 	if (!QLA_TGT_MODE_ENABLED())
 		return 0;
+#endif // NEW_MATCH_WWPN
 
 	if (!IS_TGT_MODE_CAPABLE(ha)) {
 		ql_log(ql_log_warn, base_vha, 0xe070,
 		    "This adapter does not support target mode.\n");
 		return 0;
 	}
 
@@ -6589,47 +6776,93 @@ void qlt_lport_deregister(struct scsi_ql
 	scsi_host_put(sh);
 }
 EXPORT_SYMBOL(qlt_lport_deregister);
 
 /* Must be called under HW lock */
 void qlt_set_mode(struct scsi_qla_host *vha)
 {
+#ifndef NEW_MATCH_WWPN
 	switch (vha->qlini_mode) {
 	case QLA2XXX_INI_MODE_DISABLED:
 	case QLA2XXX_INI_MODE_EXCLUSIVE:
 		vha->host->active_mode = MODE_TARGET;
 		break;
 	case QLA2XXX_INI_MODE_ENABLED:
 		vha->host->active_mode = MODE_INITIATOR;
 		break;
 	case QLA2XXX_INI_MODE_DUAL:
 		vha->host->active_mode = MODE_DUAL;
 		break;
 	default:
 		break;
 	}
+
+#else	// NEW_MATCH_WWPN
+	int a_m;
+	a_m = find_slot_wwpn(vha, 0, -1, __func__);
+	if (a_m)
+	{
+		vha->host->active_mode = MODE_TARGET;
+		vha->qlini_mode = QLA2XXX_INI_MODE_DISABLED;
+	}
+	else
+		switch (ql2x_ini_mode) {
+		case QLA2XXX_INI_MODE_DISABLED:
+		case QLA2XXX_INI_MODE_EXCLUSIVE:
+			vha->host->active_mode = MODE_TARGET;
+			break;
+		case QLA2XXX_INI_MODE_ENABLED:
+			vha->host->active_mode = MODE_UNKNOWN;
+			break;
+		case QLA2XXX_INI_MODE_DUAL:
+			vha->host->active_mode = MODE_DUAL;
+			break;
+		default:
+			break;
+		}
+#endif	// NEW_MATCH_WWPN
 }
 
 /* Must be called under HW lock */
 static void qlt_clear_mode(struct scsi_qla_host *vha)
 {
+#ifndef NEW_MATCH_WWPN
 	switch (vha->qlini_mode) {
 	case QLA2XXX_INI_MODE_DISABLED:
 		vha->host->active_mode = MODE_UNKNOWN;
 		break;
 	case QLA2XXX_INI_MODE_EXCLUSIVE:
 		vha->host->active_mode = MODE_INITIATOR;
 		break;
 	case QLA2XXX_INI_MODE_ENABLED:
 	case QLA2XXX_INI_MODE_DUAL:
 		vha->host->active_mode = MODE_INITIATOR;
 		break;
 	default:
 		break;
 	}
+#else 	// NEW_MATCH_WWPN
+	if (*qlini_targets != '\0')
+		vha->host->active_mode = MODE_UNKNOWN;
+	else
+		switch (ql2x_ini_mode) {
+		case QLA2XXX_INI_MODE_DISABLED:
+			vha->host->active_mode = MODE_UNKNOWN;
+			break;
+		case QLA2XXX_INI_MODE_EXCLUSIVE:
+			vha->host->active_mode = MODE_INITIATOR;
+			break;
+		case QLA2XXX_INI_MODE_ENABLED:
+		case QLA2XXX_INI_MODE_DUAL:
+			vha->host->active_mode = MODE_INITIATOR;
+			break;
+		default:
+			break;
+		}
+#endif	// NEW_MATCH_WWPN
 }
 
 /*
  * qla_tgt_enable_vha - NO LOCK HELD
  *
  * host_reset, bring up w/ Target Mode Enabled
  */
@@ -6645,14 +6878,15 @@ qlt_enable_vha(struct scsi_qla_host *vha
 		ql_dbg(ql_dbg_tgt, vha, 0xe069,
 		    "Unable to locate qla_tgt pointer from"
 		    " struct qla_hw_data\n");
 		dump_stack();
 		return;
 	}
 	if (vha->qlini_mode == QLA2XXX_INI_MODE_ENABLED)
+	    if (*qlini_targets == '\0' || !find_slot_wwpn(vha, 0, -1, __func__))
 		return;
 
 	if (ha->tgt.num_act_qpairs > ha->max_qpairs)
 		ha->tgt.num_act_qpairs = ha->max_qpairs;
 	spin_lock_irqsave(&ha->hardware_lock, flags);
 	tgt->tgt_stopped = 0;
 	qlt_set_mode(vha);
@@ -6841,16 +7075,25 @@ qlt_24xx_process_atio_queue(struct scsi_
 void
 qlt_24xx_config_rings(struct scsi_qla_host *vha)
 {
 	struct qla_hw_data *ha = vha->hw;
 	struct qla_msix_entry *msix = &ha->msix_entries[2];
 	struct init_cb_24xx *icb = (struct init_cb_24xx *)ha->init_cb;
 
+#ifdef NEW_MATCH_WWPN
+	int a_m;
+
+	a_m = find_slot_wwpn(vha, 0, -1, __func__);
+	if (!a_m)
+	    if (!QLA_TGT_MODE_ENABLED())
+		return;
+#else	// NEW_MATCH_WWPN
 	if (!QLA_TGT_MODE_ENABLED())
 		return;
+#endif	// NEW_MATCH_WWPN
 
 	wrt_reg_dword(ISP_ATIO_Q_IN(vha), 0);
 	wrt_reg_dword(ISP_ATIO_Q_OUT(vha), 0);
 	rd_reg_dword(ISP_ATIO_Q_OUT(vha));
 
 	if (ha->flags.msix_enabled) {
 		if (IS_QLA83XX(ha) || IS_QLA27XX(ha) || IS_QLA28XX(ha)) {
@@ -6874,14 +7117,15 @@ qlt_24xx_config_rings(struct scsi_qla_ho
 void
 qlt_24xx_config_nvram_stage1(struct scsi_qla_host *vha, struct nvram_24xx *nv)
 {
 	struct qla_hw_data *ha = vha->hw;
 	u32 tmp;
 
 	if (!QLA_TGT_MODE_ENABLED())
+	    if (!find_slot_wwpn(vha, swab64(get_port_name_from_nv(vha, __func__)), -1, __func__))
 		return;
 
 	if (qla_tgt_mode_enabled(vha) || qla_dual_mode_enabled(vha)) {
 		if (!ha->tgt.saved_set) {
 			/* We save only once */
 			ha->tgt.saved_exchange_count = nv->exchange_count;
 			ha->tgt.saved_firmware_options_1 =
@@ -6964,31 +7208,47 @@ qlt_24xx_config_nvram_stage1(struct scsi
 
 void
 qlt_24xx_config_nvram_stage2(struct scsi_qla_host *vha,
 	struct init_cb_24xx *icb)
 {
 	struct qla_hw_data *ha = vha->hw;
 
+#ifdef NEW_MATCH_WWPN
+	if (*qlini_targets == '\0' && !QLA_TGT_MODE_ENABLED())
+	    return;
+#else	// NEW_MATCH_WWPN
 	if (!QLA_TGT_MODE_ENABLED())
 		return;
+#endif	// NEW_MATCH_WWPN
 
 	if (ha->tgt.node_name_set) {
 		memcpy(icb->node_name, ha->tgt.tgt_node_name, WWN_SIZE);
 		icb->firmware_options_1 |= cpu_to_le32(BIT_14);
 	}
 }
 
 void
 qlt_81xx_config_nvram_stage1(struct scsi_qla_host *vha, struct nvram_81xx *nv)
 {
 	struct qla_hw_data *ha = vha->hw;
 	u32 tmp;
 
+#ifdef NEW_MATCH_WWPN
+	int a_m;
+	u64 nv_port_name;
+
+	nv_port_name = get_port_name_from_nv(vha, __func__);
+	a_m = find_slot_wwpn(vha, swab64(nv_port_name), -1, __func__);
+	if (!a_m)
+	    if (!QLA_TGT_MODE_ENABLED())
+		return;
+#else	// NEW_MATCH_WWPN
 	if (!QLA_TGT_MODE_ENABLED())
 		return;
+#endif	// NEW_MATCH_WWPN
 
 	if (qla_tgt_mode_enabled(vha) || qla_dual_mode_enabled(vha)) {
 		if (!ha->tgt.saved_set) {
 			/* We save only once */
 			ha->tgt.saved_exchange_count = nv->exchange_count;
 			ha->tgt.saved_firmware_options_1 =
 			    nv->firmware_options_1;
@@ -7067,28 +7327,45 @@ qlt_81xx_config_nvram_stage1(struct scsi
 
 void
 qlt_81xx_config_nvram_stage2(struct scsi_qla_host *vha,
 	struct init_cb_81xx *icb)
 {
 	struct qla_hw_data *ha = vha->hw;
 
+#ifdef NEW_MATCH_WWPN
+	int a_m;
+	u64 nv_port_name;
+
+	nv_port_name = get_port_name_from_nv(vha, __func__);
+	a_m = find_slot_wwpn(vha, swab64(nv_port_name), -1, __func__);
+	if (!a_m)
+	    if (!QLA_TGT_MODE_ENABLED())
+		return;
+#else	// NEW_MATCH_WWPN
+
 	if (!QLA_TGT_MODE_ENABLED())
 		return;
+#endif	// NEW_MATCH_WWPN
 
 	if (ha->tgt.node_name_set) {
 		memcpy(icb->node_name, ha->tgt.tgt_node_name, WWN_SIZE);
 		icb->firmware_options_1 |= cpu_to_le32(BIT_14);
 	}
 }
 
 void
 qlt_83xx_iospace_config(struct qla_hw_data *ha)
 {
+#ifndef NEW_MATCH_WWPN
 	if (!QLA_TGT_MODE_ENABLED())
 		return;
+#else	// NEW_MATCH_WWPN
+	if (*qlini_targets == '\0' && !QLA_TGT_MODE_ENABLED())
+		return;
+#endif	// NEW_MATCH_WWPN
 
 	ha->msix_count += 1; /* For ATIO Q */
 }
 
 
 void
 qlt_modify_vp_config(struct scsi_qla_host *vha,
@@ -7103,16 +7380,22 @@ qlt_modify_vp_config(struct scsi_qla_hos
 		vpmod->options_idx1 &= ~BIT_4;
 }
 
 void
 qlt_probe_one_stage1(struct scsi_qla_host *base_vha, struct qla_hw_data *ha)
 {
 	mutex_init(&base_vha->vha_tgt.tgt_mutex);
+#ifndef NEW_MATCH_WWPN
 	if (!QLA_TGT_MODE_ENABLED())
 		return;
+#else  // NEW_MATCH_WWPN
+	if (ql2x_ini_targets == NULL)
+	    if (!QLA_TGT_MODE_ENABLED())
+		return;
+#endif	// NEW_MATCH_WWPN
 
 	if  (ha->mqenable || IS_QLA83XX(ha) || IS_QLA27XX(ha) || IS_QLA28XX(ha)) {
 		ISP_ATIO_Q_IN(base_vha) = &ha->mqiobase->isp25mq.atio_q_in;
 		ISP_ATIO_Q_OUT(base_vha) = &ha->mqiobase->isp25mq.atio_q_out;
 	} else {
 		ISP_ATIO_Q_IN(base_vha) = &ha->iobase->isp24.atio_q_in;
 		ISP_ATIO_Q_OUT(base_vha) = &ha->iobase->isp24.atio_q_out;
@@ -7198,31 +7481,42 @@ qlt_handle_abts_recv(struct scsi_qla_hos
 	queue_work(qla_tgt_wq, &op->work);
 	return;
 }
 
 int
 qlt_mem_alloc(struct qla_hw_data *ha)
 {
+#ifndef NEW_MATCH_WWPN
 	if (!QLA_TGT_MODE_ENABLED())
 		return 0;
+#else	// NEW_MATCH_WWPN
+	/* If no targets specified and initiator mode enabled, leave */
+	if (*qlini_targets == '\0' && !QLA_TGT_MODE_ENABLED())
+		return 0;
+#endif	// NEW_MATCH_WWPN
 
 	ha->tgt.atio_ring = dma_alloc_coherent(&ha->pdev->dev,
 	    (ha->tgt.atio_q_length + 1) * sizeof(struct atio_from_isp),
 	    &ha->tgt.atio_dma, GFP_KERNEL);
 	if (!ha->tgt.atio_ring) {
 		return -ENOMEM;
 	}
 	return 0;
 }
 
 void
 qlt_mem_free(struct qla_hw_data *ha)
 {
+#ifndef NEW_MATCH_WWPN
 	if (!QLA_TGT_MODE_ENABLED())
 		return;
+#else	// NEW_MATCH_WWPN
+	if (*qlini_targets == '\0' && !QLA_TGT_MODE_ENABLED())
+		return;
+#endif	// NEW_MATCH_WWPN
 
 	if (ha->tgt.atio_ring) {
 		dma_free_coherent(&ha->pdev->dev, (ha->tgt.atio_q_length + 1) *
 		    sizeof(struct atio_from_isp), ha->tgt.atio_ring,
 		    ha->tgt.atio_dma);
 	}
 	ha->tgt.atio_ring = NULL;
