diff -Nrp -U 7 --no-dereference --no-ignore-file-name-case --strip-trailing-cr '--exclude=.git*' a/fs/cifs/ioctl.c b/fs/cifs/ioctl.c
--- a/fs/cifs/ioctl.c	2021-10-12 12:15:15.507068076 -0500
+++ b/fs/cifs/ioctl.c	2021-10-07 17:55:26.000000000 -0500
@@ -72,33 +72,36 @@ static long cifs_ioctl_query_info(unsign
 static long cifs_ioctl_query_reparse_attrs(unsigned int xid, struct file *filep, void __user *arg)
 {
 	struct inode *inode = file_inode(filep);
 	struct cifs_sb_info *cifs_sb = CIFS_SB(inode->i_sb);
 	struct cifs_tcon *tcon = cifs_sb_master_tcon(cifs_sb);
 	struct dentry *dentry = filep->f_path.dentry;
 
-	unsigned char *dirpath = NULL;
+	const unsigned char *dirpath = NULL;
 	unsigned char *targetpath = NULL;
 	struct ioctl_smb_query_attrs *qap = NULL;
 
 	int rc = 0;
 	int dirlen, inlen, tlen;
+	void *page = NULL;
 
 	qap = kzalloc(sizeof(struct ioctl_smb_query_attrs), GFP_KERNEL);
 	if (qap == NULL) {
 		rc = -ENOMEM;
 		goto done;
 	}
         if (copy_from_user(qap, arg, sizeof(*qap))) {
                 rc = -EFAULT;
                 goto done;
         }
-	dirpath = build_path_from_dentry(dentry);
-	if (dirpath == NULL) {
-		rc = -ENOMEM;
+	page = alloc_dentry_path();
+	dirpath = build_path_from_dentry(dentry, page);
+	if (IS_ERR(dirpath)) {
+		free_dentry_path(page);
+		rc = PTR_ERR(dirpath);
 		goto done;
 	}
 	dirlen = strlen(dirpath);
 
 	if (!*qap->in_filename) {
 		rc = -EINVAL;
 		goto done;
diff -Nrp -U 7 --no-dereference --no-ignore-file-name-case --strip-trailing-cr '--exclude=.git*' a/fs/cifs/smb2inode.c b/fs/cifs/smb2inode.c
--- a/fs/cifs/smb2inode.c	2021-10-12 12:15:15.516068334 -0500
+++ b/fs/cifs/smb2inode.c	2021-10-11 14:27:23.000000000 -0500
@@ -42,14 +42,28 @@ struct cop_vars {
 	struct kvec qi_iov[1];
 	struct kvec si_iov[SMB2_SET_INFO_IOV_SIZE];
 	struct kvec close_iov[1];
 	struct smb2_file_rename_info rename_info;
 	struct smb2_file_link_info link_info;
 };
 
+#define NREQ 8
+struct cop_202_vars {
+	struct cifs_open_parms oparms;
+	struct kvec rsp_iov[NREQ];
+	struct smb_rqst rqst[NREQ];
+	struct kvec open_iov[SMB2_CREATE_IOV_SIZE];
+	struct kvec qi_iov[NREQ];
+	struct kvec si_iov[SMB2_SET_INFO_IOV_SIZE];
+	struct kvec close_iov[1];
+	struct smb2_file_rename_info rename_info;
+	struct smb2_file_link_info link_info;
+};
+
+
 static int
 smb2_compound_op(const unsigned int xid, struct cifs_tcon *tcon,
 		 struct cifs_sb_info *cifs_sb, const char *full_path,
 		 __u32 desired_access, __u32 create_disposition,
 		 __u32 create_options, umode_t mode, void *ptr, int command,
 		 struct cifsFileInfo *cfile)
 {
@@ -608,226 +622,312 @@ out:
 /* ****************************** */
 
 
 static int
 smb202_compound_op(const unsigned int xid, struct cifs_tcon *tcon,
 		 struct cifs_sb_info *cifs_sb, const char *full_path,
 		 __u32 desired_access, __u32 create_disposition,
-		 __u32 create_options, void *ptr, int command)
+		 __u32 create_options, umode_t mode, void *ptr, int command,
+		 struct cifsFileInfo *cfile)
 {
+	struct cop_202_vars *vars = NULL;
+	struct kvec *rsp_iov;
+	struct smb_rqst *rqst;
 	int rc;
 	__le16 *utf16_path = NULL;
 	__u8 oplock = SMB2_OPLOCK_LEVEL_NONE;
-	struct cifs_open_parms oparms;
 	struct cifs_fid fid;
 	struct cifs_ses *ses = tcon->ses;
-
-#define NREQ 8
+	struct TCP_Server_Info *server;
 	int nc = 0;
-
 	int num_rqst = 0;
-	struct smb_rqst rqst[NREQ];
 	int resp_buftype[NREQ];
-	struct kvec rsp_iov[NREQ];
-	struct kvec qi_iov[NREQ];
-
-	struct kvec open_iov[SMB2_CREATE_IOV_SIZE];
-	struct kvec si_iov[SMB2_SET_INFO_IOV_SIZE];
-	struct kvec close_iov[1];
+	struct smb2_query_info_rsp *qi_rsp = NULL;
 	int flags = 0;
 	__u8 delete_pending[8] = {1, 0, 0, 0, 0, 0, 0, 0};
 	unsigned int size[2];
 	void *data[2];
-	struct smb2_file_rename_info rename_info;
-	struct smb2_file_link_info link_info;
 	int len;
 
+	vars = kzalloc(sizeof(*vars), GFP_ATOMIC);
+	if (vars == NULL)
+		return -ENOMEM;
+	rqst = &vars->rqst[0];
+	rsp_iov = &vars->rsp_iov[0];
+
+	server = cifs_pick_channel(ses);
+
 	if (smb3_encryption_required(tcon))
 		flags |= CIFS_TRANSFORM_REQ;
 
-	memset(rqst, 0, sizeof(rqst));
-	memset(rsp_iov, 0, sizeof(rsp_iov));
-	for(nc = 0; nc < NREQ; nc++)
-		resp_buftype[nc] = CIFS_NO_BUFFER;
+	for (nc = 0; nc < NREQ; nc++)
+	{
+	    resp_buftype[nc] = CIFS_NO_BUFFER;
+	}
+
+	/* We already have a handle so we can skip the open */
+	if (cfile)
+		goto after_open;
 
 	/* Open */
 	utf16_path = cifs_convert_path_to_utf16(full_path, cifs_sb);
-	if (!utf16_path)
-		return -ENOMEM;
-
-/* 202 */
+	if (!utf16_path) {
+		rc = -ENOMEM;
+		goto finished;
+	}
 
-	oparms.tcon = tcon;
-	oparms.desired_access = desired_access;
-	oparms.disposition = create_disposition;
-	oparms.create_options = create_options;
-	if (backup_cred(cifs_sb))
-		oparms.create_options |= CREATE_OPEN_BACKUP_INTENT;
-	oparms.fid = &fid;
-	oparms.reconnect = false;
+	vars->oparms.tcon = tcon;
+	vars->oparms.desired_access = desired_access;
+	vars->oparms.disposition = create_disposition;
+	vars->oparms.create_options = cifs_create_options(cifs_sb, create_options);
+	vars->oparms.fid = &fid;
+	vars->oparms.reconnect = false;
+	vars->oparms.mode = mode;
+	vars->oparms.cifs_sb = cifs_sb;
 
-	memset(&open_iov, 0, sizeof(open_iov));
-	rqst[num_rqst].rq_iov = open_iov;
+	rqst[num_rqst].rq_iov = &vars->open_iov[0];
 	rqst[num_rqst].rq_nvec = SMB2_CREATE_IOV_SIZE;
-	rc = SMB2_open_init(tcon, ses->server, &rqst[num_rqst], &oplock, &oparms,
+	rc = SMB2_open_init(tcon, server,
+			    &rqst[num_rqst], &oplock, &vars->oparms,
 			    utf16_path);
 	kfree(utf16_path);
 	if (rc)
 		goto finished;
 
-	smb2_set_next_command(tcon, &rqst[num_rqst++]);
+	smb2_set_next_command(tcon, &rqst[num_rqst]);
+ after_open:
+	num_rqst++;
+	rc = 0;
 
-/* 202 */
 	/* Operation */
 	switch (command) {
 	case SMB2_OP_QUERY_INFO:
-
-		memset(&qi_iov, 0, sizeof(qi_iov));
-
-
-        /* INFO */
-
-#define _X(_w1, _w2)                                                                                                                                    		\
-		if (num_rqst >= NREQ) { cifs_dbg(FYI, "TOO MANY %d\n", num_rqst); rc = -96; goto finished; }                                                       	\
-		rqst[num_rqst].rq_iov = qi_iov+num_rqst;														\
-		rqst[num_rqst].rq_nvec = 1;																\
-		if ((rc = SMB2_query_info_init(tcon, ses->server, &rqst[num_rqst], COMPOUND_FID, COMPOUND_FID, _w1,        SMB2_O_INFO_FILE, 0, sizeof(struct _w2), 0, NULL)))     	\
-			goto finished;                                                                                                                         		\
-		smb2_set_next_command(tcon, &rqst[num_rqst]);														\
-		smb2_set_related(&rqst[num_rqst++]);															
+#define _X(_w1, _w2)                                                    \
+		if (num_rqst >= NREQ) {					\
+			cifs_dbg(FYI, "TOO MANY %d\n", num_rqst);	\
+			rc = -96;					\
+			goto finished;					\
+		}                                                      	\
+		rqst[num_rqst].rq_iov = &vars->qi_iov[num_rqst];	\
+		rqst[num_rqst].rq_nvec = 1;				\
+		if (cfile) {						\
+			rc = SMB2_query_info_init(tcon, server,		\
+				&rqst[num_rqst],			\
+				cfile->fid.persistent_fid,		\
+				cfile->fid.volatile_fid,		\
+				FILE_ALL_INFORMATION,			\
+				SMB2_O_INFO_FILE, 0,			\
+				sizeof(struct smb2_file_all_info) +	\
+					  PATH_MAX * 2, 0, NULL);	\
+			if (rc) {					\
+				goto finished;				\
+			}						\
+		} else {						\
+			rc = SMB2_query_info_init(tcon, server,		\
+				&rqst[num_rqst],			\
+				COMPOUND_FID,				\
+				COMPOUND_FID,				\
+				FILE_ALL_INFORMATION,			\
+				SMB2_O_INFO_FILE, 0,			\
+				sizeof(struct smb2_file_all_info) +	\
+					  PATH_MAX * 2, 0, NULL);	\
+			if (rc) {					\
+				goto finished;				\
+			}						\
+		}							\
+		smb2_set_next_command(tcon, &rqst[num_rqst]);		\
+		smb2_set_related(&rqst[num_rqst++]);
+/* End of define _X */
 
 		_X( FILE_BASIC_INFORMATION,     smb2_file_basic_info );
 		_X( FILE_STANDARD_INFORMATION,  smb2_file_standard_info );
 		_X( FILE_INTERNAL_INFORMATION,  smb2_file_internal_info );
 		_X( FILE_EA_INFORMATION,        smb2_file_ea_info );
 		_X( FILE_ACCESS_INFORMATION,    smb2_file_access_info );
 		_X( FILE_MODE_INFORMATION,      smb2_file_mode_info );
-
 #undef _X
+	        if (num_rqst != NREQ-1) {
+			cifs_dbg(FYI, "MISMATCH %d\n", nc);
+			rc = -96;
+			goto finished;
+		}
+		trace_smb3_query_info_compound_enter(xid, ses->Suid, tcon->tid,
+						     full_path);
+		break;
+	case SMB2_OP_POSIX_QUERY_INFO:
+		rqst[num_rqst].rq_iov = &vars->qi_iov[0];
+		rqst[num_rqst].rq_nvec = 1;
 
-	        if (num_rqst != NREQ-1) { cifs_dbg(FYI, "MISMATCH %d\n", nc); rc = -96; goto finished; }
+		if (cfile)
+			rc = SMB2_query_info_init(tcon, server,
+				&rqst[num_rqst],
+				cfile->fid.persistent_fid,
+				cfile->fid.volatile_fid,
+				SMB_FIND_FILE_POSIX_INFO,
+				SMB2_O_INFO_FILE, 0,
+				/* TBD: fix following to allow for longer SIDs */
+				sizeof(struct smb311_posix_qinfo *) + (PATH_MAX * 2) +
+				(sizeof(struct cifs_sid) * 2), 0, NULL);
+		else {
+			rc = SMB2_query_info_init(tcon, server,
+				&rqst[num_rqst],
+				COMPOUND_FID,
+				COMPOUND_FID,
+				SMB_FIND_FILE_POSIX_INFO,
+				SMB2_O_INFO_FILE, 0,
+				sizeof(struct smb311_posix_qinfo *) + (PATH_MAX * 2) +
+				(sizeof(struct cifs_sid) * 2), 0, NULL);
+			if (!rc) {
+				smb2_set_next_command(tcon, &rqst[num_rqst]);
+				smb2_set_related(&rqst[num_rqst]);
+			}
+		}
 
-		trace_smb3_query_info_compound_enter(xid, ses->Suid, tcon->tid, full_path);
+		if (rc)
+			goto finished;
+		num_rqst++;
+		trace_smb3_posix_query_info_compound_enter(xid, ses->Suid, tcon->tid, full_path);
 		break;
-
 	case SMB2_OP_DELETE:
 		trace_smb3_delete_enter(xid, ses->Suid, tcon->tid, full_path);
 		break;
 	case SMB2_OP_MKDIR:
 		/*
 		 * Directories are created through parameters in the
 		 * SMB2_open() call.
 		 */
 		trace_smb3_mkdir_enter(xid, ses->Suid, tcon->tid, full_path);
 		break;
-/* 202 */
 	case SMB2_OP_RMDIR:
-		memset(&si_iov, 0, sizeof(si_iov));
-		rqst[num_rqst].rq_iov = si_iov;
+		rqst[num_rqst].rq_iov = &vars->si_iov[0];
 		rqst[num_rqst].rq_nvec = 1;
 
 		size[0] = 1; /* sizeof __u8 See MS-FSCC section 2.4.11 */
 		data[0] = &delete_pending[0];
 
-		rc = SMB2_set_info_init(tcon, ses->server, &rqst[num_rqst], COMPOUND_FID,
+		rc = SMB2_set_info_init(tcon, server,
+					&rqst[num_rqst], COMPOUND_FID,
 					COMPOUND_FID, current->tgid,
 					FILE_DISPOSITION_INFORMATION,
 					SMB2_O_INFO_FILE, 0, data, size);
 		if (rc)
 			goto finished;
 		smb2_set_next_command(tcon, &rqst[num_rqst]);
 		smb2_set_related(&rqst[num_rqst++]);
 		trace_smb3_rmdir_enter(xid, ses->Suid, tcon->tid, full_path);
 		break;
-/* 202 */
 	case SMB2_OP_SET_EOF:
-		memset(&si_iov, 0, sizeof(si_iov));
-		rqst[num_rqst].rq_iov = si_iov;
+		rqst[num_rqst].rq_iov = &vars->si_iov[0];
 		rqst[num_rqst].rq_nvec = 1;
 
 		size[0] = 8; /* sizeof __le64 */
 		data[0] = ptr;
 
-		rc = SMB2_set_info_init(tcon, ses->server, &rqst[num_rqst], COMPOUND_FID,
+		rc = SMB2_set_info_init(tcon, server,
+					&rqst[num_rqst], COMPOUND_FID,
 					COMPOUND_FID, current->tgid,
 					FILE_END_OF_FILE_INFORMATION,
 					SMB2_O_INFO_FILE, 0, data, size);
 		if (rc)
 			goto finished;
 		smb2_set_next_command(tcon, &rqst[num_rqst]);
 		smb2_set_related(&rqst[num_rqst++]);
 		trace_smb3_set_eof_enter(xid, ses->Suid, tcon->tid, full_path);
 		break;
 	case SMB2_OP_SET_INFO:
-		memset(&si_iov, 0, sizeof(si_iov));
-		rqst[num_rqst].rq_iov = si_iov;
+		rqst[num_rqst].rq_iov = &vars->si_iov[0];
 		rqst[num_rqst].rq_nvec = 1;
 
 
 		size[0] = sizeof(FILE_BASIC_INFO);
 		data[0] = ptr;
 
-		rc = SMB2_set_info_init(tcon, ses->server, &rqst[num_rqst], COMPOUND_FID,
-					COMPOUND_FID, current->tgid,
-					FILE_BASIC_INFORMATION,
-					SMB2_O_INFO_FILE, 0, data, size);
+		if (cfile)
+			rc = SMB2_set_info_init(tcon, server,
+				&rqst[num_rqst],
+				cfile->fid.persistent_fid,
+				cfile->fid.volatile_fid, current->tgid,
+				FILE_BASIC_INFORMATION,
+				SMB2_O_INFO_FILE, 0, data, size);
+		else {
+			rc = SMB2_set_info_init(tcon, server,
+				&rqst[num_rqst],
+				COMPOUND_FID,
+				COMPOUND_FID, current->tgid,
+				FILE_BASIC_INFORMATION,
+				SMB2_O_INFO_FILE, 0, data, size);
+			if (!rc) {
+				smb2_set_next_command(tcon, &rqst[num_rqst]);
+				smb2_set_related(&rqst[num_rqst]);
+			}
+		}
+
 		if (rc)
 			goto finished;
-		smb2_set_next_command(tcon, &rqst[num_rqst]);
-		smb2_set_related(&rqst[num_rqst++]);
+		num_rqst++;
 		trace_smb3_set_info_compound_enter(xid, ses->Suid, tcon->tid,
 						   full_path);
 		break;
-/* 202 */
 	case SMB2_OP_RENAME:
-		memset(&si_iov, 0, sizeof(si_iov));
-		rqst[num_rqst].rq_iov = si_iov;
+		rqst[num_rqst].rq_iov = &vars->si_iov[0];
 		rqst[num_rqst].rq_nvec = 2;
 
 		len = (2 * UniStrnlen((wchar_t *)ptr, PATH_MAX));
 
-		rename_info.ReplaceIfExists = 1;
-		rename_info.RootDirectory = 0;
-		rename_info.FileNameLength = cpu_to_le32(len);
+		vars->rename_info.ReplaceIfExists = 1;
+		vars->rename_info.RootDirectory = 0;
+		vars->rename_info.FileNameLength = cpu_to_le32(len);
 
 		size[0] = sizeof(struct smb2_file_rename_info);
-		data[0] = &rename_info;
+		data[0] = &vars->rename_info;
 
 		size[1] = len + 2 /* null */;
 		data[1] = (__le16 *)ptr;
 
-		rc = SMB2_set_info_init(tcon, ses->server, &rqst[num_rqst], COMPOUND_FID,
-					COMPOUND_FID, current->tgid,
-					FILE_RENAME_INFORMATION,
+		if (cfile)
+			rc = SMB2_set_info_init(tcon, server,
+						&rqst[num_rqst],
+						cfile->fid.persistent_fid,
+						cfile->fid.volatile_fid,
+					current->tgid, FILE_RENAME_INFORMATION,
+					SMB2_O_INFO_FILE, 0, data, size);
+		else {
+			rc = SMB2_set_info_init(tcon, server,
+					&rqst[num_rqst],
+					COMPOUND_FID, COMPOUND_FID,
+					current->tgid, FILE_RENAME_INFORMATION,
 					SMB2_O_INFO_FILE, 0, data, size);
+			if (!rc) {
+				smb2_set_next_command(tcon, &rqst[num_rqst]);
+				smb2_set_related(&rqst[num_rqst]);
+			}
+		}
 		if (rc)
 			goto finished;
-		smb2_set_next_command(tcon, &rqst[num_rqst]);
-		smb2_set_related(&rqst[num_rqst++]);
+		num_rqst++;
 		trace_smb3_rename_enter(xid, ses->Suid, tcon->tid, full_path);
 		break;
-/* 202 */
 	case SMB2_OP_HARDLINK:
-		memset(&si_iov, 0, sizeof(si_iov));
-		rqst[num_rqst].rq_iov = si_iov;
+		rqst[num_rqst].rq_iov = &vars->si_iov[0];
 		rqst[num_rqst].rq_nvec = 2;
 
 		len = (2 * UniStrnlen((wchar_t *)ptr, PATH_MAX));
 
-		link_info.ReplaceIfExists = 0;
-		link_info.RootDirectory = 0;
-		link_info.FileNameLength = cpu_to_le32(len);
+		vars->link_info.ReplaceIfExists = 0;
+		vars->link_info.RootDirectory = 0;
+		vars->link_info.FileNameLength = cpu_to_le32(len);
 
 		size[0] = sizeof(struct smb2_file_link_info);
-		data[0] = &link_info;
+		data[0] = &vars->link_info;
 
 		size[1] = len + 2 /* null */;
 		data[1] = (__le16 *)ptr;
 
-		rc = SMB2_set_info_init(tcon, ses->server, &rqst[num_rqst], COMPOUND_FID,
+		rc = SMB2_set_info_init(tcon, server,
+					&rqst[num_rqst], COMPOUND_FID,
 					COMPOUND_FID, current->tgid,
 					FILE_LINK_INFORMATION,
 					SMB2_O_INFO_FILE, 0, data, size);
 		if (rc)
 			goto finished;
 		smb2_set_next_command(tcon, &rqst[num_rqst]);
 		smb2_set_related(&rqst[num_rqst++]);
@@ -836,115 +936,170 @@ smb202_compound_op(const unsigned int xi
 	default:
 		cifs_dbg(VFS, "Invalid command\n");
 		rc = -EINVAL;
 	}
 	if (rc)
 		goto finished;
 
-/* 202 */
+	/* We already have a handle so we can skip the close */
+	if (cfile)
+		goto after_close;
 	/* Close */
-	memset(&close_iov, 0, sizeof(close_iov));
-	rqst[num_rqst].rq_iov = close_iov;
+	flags |= CIFS_CP_CREATE_CLOSE_OP;
+	rqst[num_rqst].rq_iov = &vars->close_iov[0];
 	rqst[num_rqst].rq_nvec = 1;
-	rc = SMB2_close_init(tcon, ses->server, &rqst[num_rqst], COMPOUND_FID, COMPOUND_FID, false);
-	smb2_set_related(&rqst[num_rqst++]);
+	rc = SMB2_close_init(tcon, server,
+			     &rqst[num_rqst], COMPOUND_FID,
+			     COMPOUND_FID, false);
+	smb2_set_related(&rqst[num_rqst]);
 	if (rc)
 		goto finished;
+ after_close:
+	num_rqst++;
 
-	rc = compound_send_recv(xid, ses, ses->server, flags, num_rqst, rqst, resp_buftype, rsp_iov);
+	if (cfile) {
+		cifsFileInfo_put(cfile);
+		cfile = NULL;
+/* NOTDONEYET - what does below need to be changed to? */
+		rc = compound_send_recv(xid, ses, server,
+					flags, num_rqst - 2,
+					&rqst[1], &resp_buftype[1],
+					&rsp_iov[1]);
+	} else
+		rc = compound_send_recv(xid, ses, server,
+					flags, num_rqst,
+					rqst, resp_buftype,
+					rsp_iov);
 
  finished:
+	if (cfile)
+		cifsFileInfo_put(cfile);
+
 	SMB2_open_free(&rqst[0]);
+	if (rc == -EREMCHG) {
+		pr_warn_once("server share %s deleted\n", tcon->treeName);
+		tcon->need_reconnect = true;
+	}
+
 	switch (command) {
-/* 202 */
 	case SMB2_OP_QUERY_INFO:
 		if (rc == 0) {
 
-#define _X(_what)                                                                                                               		\
-		if (!rc) {                                                                                                              	\
-			struct kvec *iov;                                                                                               	\
-			struct smb2_query_info_rsp *rsp;                                                                                	\
-			struct _what *dat = NULL;                                                                                              	\
-																		\
-			iov = rsp_iov + nc;                                                                                             	\
-			if (++nc > num_rqst ) { cifs_dbg(FYI, "TOO MANY on decode %d\n", nc); rc = -96; }                			\
-			if (rc == 0) {														\
-				rsp = (struct smb2_query_info_rsp *)iov->iov_base;                                                              \
-																		\
-				if (le32_to_cpu(rsp->OutputBufferLength) < sizeof(struct _what ) ) {                                            \
-					cifs_dbg(FYI, "BUFFER too small, %d, %d\n", rsp->OutputBufferLength, (int)sizeof(struct _what));        \
-					rc = -96;                                                                                               \
-				}                                                                                                               \
-			}															\
-			if (rc == 0) {														\
-				unsigned int off = le16_to_cpu(rsp->OutputBufferOffset);                                                         \
-				if ((rc = smb2_validate_iov( off, sizeof(struct _what), iov, sizeof(struct _what)) )) {                         \
-					cifs_dbg(FYI, "BUFFER validate error, %d\n", rc);                                                       \
-				}                                                                                                               \
-				else														\
-					dat = (struct _what *)(off + (char*)iov->iov_base);							\
+#define _X(_what)											\
+			struct _what *dat = NULL;							\
+			struct kvec *iov;								\
+													\
+			iov = rsp_iov + nc;								\
+			if (++nc > num_rqst) {								\
+				cifs_dbg(FYI, "TOO MANY on decode %d\n", nc);				\
+				rc = -96;								\
+			}										\
+			if (rc == 0) {									\
+				qi_rsp = (struct smb2_query_info_rsp *)iov->iov_base;			\
+				if (le32_to_cpu(qi_rsp->OutputBufferLength) < sizeof(struct _what)) {	\
+					cifs_dbg(FYI, "BUFFER too small, %d, %d\n",			\
+						      qi_rsp->OutputBufferLength,			\
+						      (int)sizeof(struct _what));			\
+					rc = -96;							\
+				}									\
+			}										\
+			if (rc == 0) {									\
+				unsigned int off = le16_to_cpu(qi_rsp->OutputBufferOffset);		\
+				rc = smb2_validate_iov(							\
+				        le16_to_cpu(qi_rsp->OutputBufferOffset),			\
+					le32_to_cpu(sizeof(struct _what)),				\
+					iov,								\
+					sizeof(struct _what));						\
+				if (rc) {								\
+					cifs_dbg(FYI, "BUFFER validate error, %d\n", rc);		\
+				}									\
+				else {									\
+					dat = (struct _what *)(off + (char *)iov->iov_base);		\
+				}									\
 			}
-
-#define _Y(_f)  if (dat) ((struct smb2_file_all_info *)ptr)->_f = dat->_f;
-#define _Z() }
+/* End of define _X */
+#define _Y(_f)  	if (dat) {									\
+				((struct smb2_file_all_info *)ptr)->_f = dat->_f;			\
+			}
+/* End of define _Y */
 
         		nc = 1;
-
-			_X( smb2_file_basic_info )
-			_Y( CreationTime )
-			_Y( LastAccessTime )
-			_Y( LastWriteTime )
-			_Y( ChangeTime )
-			_Y( Attributes )
-			_Z( )
-
-			_X( smb2_file_standard_info )
-			_Y( AllocationSize )
-			_Y( EndOfFile )
-			_Y( NumberOfLinks )
-			_Y( DeletePending )
-			_Y( Directory )
-			_Z( )
-
-			_X( smb2_file_internal_info )
-			_Y( IndexNumber )
-			_Z( )
-	
-			_X( smb2_file_ea_info )
-			_Y( EASize )
-			_Z( )
-	
-			_X( smb2_file_access_info )
-			_Y( AccessFlags )
-			_Z( )
-
-			_X( smb2_file_mode_info )
-			_Y( Mode )
-			_Z( )
-
+			if (rc == 0) {
+				_X( smb2_file_basic_info )
+				_Y( CreationTime )
+				_Y( LastAccessTime )
+				_Y( LastWriteTime )
+				_Y( ChangeTime )
+				_Y( Attributes )
+			}
+			if (rc == 0) {
+				_X( smb2_file_standard_info )
+				_Y( AllocationSize )
+				_Y( EndOfFile )
+				_Y( NumberOfLinks )
+				_Y( DeletePending )
+				_Y( Directory )
+			}
+			if (rc == 0) {
+				_X( smb2_file_internal_info )
+				_Y( IndexNumber )
+			}
+			if (rc == 0) {
+				_X( smb2_file_ea_info )
+				_Y( EASize )
+			}
+			if (rc == 0) {
+				_X( smb2_file_access_info )
+				_Y( AccessFlags )
+			}
+			if (rc == 0) {
+				_X( smb2_file_mode_info )
+				_Y( Mode )
+			}
 #undef _X
 #undef _Y
-#undef _Z
-
-			if (nc != num_rqst-1) { cifs_dbg(FYI, "decode MISMATCH %d\n", nc); rc = -96; }
+			if (nc != num_rqst-1) { 
+				cifs_dbg(FYI, "decode MISMATCH %d\n", nc);
+				rc = -96;
+			}
 		}
 
-		for(nc = 1; nc < 7; nc++)
-			if (rqst[nc].rq_iov)
+		for (nc = 1; nc < 6; nc++) {
+			if (rqst[nc].rq_iov) {
 				SMB2_query_info_free(&rqst[nc]);
-		if (rqst[nc].rq_iov)
+			}
+		}
+		if (rqst[nc].rq_iov) {
 			SMB2_close_free(&rqst[nc]);
+		}
+		if (rc) {
+			trace_smb3_query_info_compound_err(xid,  ses->Suid, tcon->tid, rc);
+		}
+		else {
+			trace_smb3_query_info_compound_done(xid, ses->Suid, tcon->tid);
+		}
+		break;
+	case SMB2_OP_POSIX_QUERY_INFO:
+		if (rc == 0) {
+			qi_rsp = (struct smb2_query_info_rsp *)
+				rsp_iov[1].iov_base;
+			rc = smb2_validate_and_copy_iov(
+				le16_to_cpu(qi_rsp->OutputBufferOffset),
+				le32_to_cpu(qi_rsp->OutputBufferLength),
+				&rsp_iov[1], sizeof(struct smb311_posix_qinfo) /* add SIDs */, ptr);
+		}
+		if (rqst[1].rq_iov)
+			SMB2_query_info_free(&rqst[1]);
+		if (rqst[2].rq_iov)
+			SMB2_close_free(&rqst[2]);
 		if (rc)
-			trace_smb3_query_info_compound_err(xid,  ses->Suid,
-						tcon->tid, rc);
+			trace_smb3_posix_query_info_compound_err(xid,  ses->Suid, tcon->tid, rc);
 		else
-			trace_smb3_query_info_compound_done(xid, ses->Suid,
-						tcon->tid);
+			trace_smb3_posix_query_info_compound_done(xid, ses->Suid, tcon->tid);
 		break;
-/* 202 */
 	case SMB2_OP_DELETE:
 		if (rc)
 			trace_smb3_delete_err(xid,  ses->Suid, tcon->tid, rc);
 		else
 			trace_smb3_delete_done(xid, ses->Suid, tcon->tid);
 		if (rqst[1].rq_iov)
 			SMB2_close_free(&rqst[1]);
@@ -967,15 +1122,14 @@ smb202_compound_op(const unsigned int xi
 	case SMB2_OP_RENAME:
 		if (rc)
 			trace_smb3_rename_err(xid,  ses->Suid, tcon->tid, rc);
 		else
 			trace_smb3_rename_done(xid, ses->Suid, tcon->tid);
 		free_set_inf_compound(rqst);
 		break;
-/* 202 */
 	case SMB2_OP_RMDIR:
 		if (rc)
 			trace_smb3_rmdir_err(xid,  ses->Suid, tcon->tid, rc);
 		else
 			trace_smb3_rmdir_done(xid, ses->Suid, tcon->tid);
 		free_set_inf_compound(rqst);
 		break;
@@ -992,78 +1146,75 @@ smb202_compound_op(const unsigned int xi
 						tcon->tid, rc);
 		else
 			trace_smb3_set_info_compound_done(xid, ses->Suid,
 						tcon->tid);
 		free_set_inf_compound(rqst);
 		break;
 	}
-
-	for(nc=0; nc < num_rqst; nc++)
-		free_rsp_buf(resp_buftype[nc], rsp_iov[nc].iov_base);
+	for (nc = 0; nc < num_rqst; nc++) {
+	    free_rsp_buf(resp_buftype[nc], rsp_iov[nc].iov_base);
+	}
+	kfree(vars);
 	return rc;
 }
 
-#undef NREQ
-
 
 int
 smb202_query_path_info(const unsigned int xid, struct cifs_tcon *tcon,
 		     struct cifs_sb_info *cifs_sb, const char *full_path,
-		     FILE_ALL_INFO *data, bool *adjust_tz, bool *symlink)
+		     FILE_ALL_INFO *data, bool *adjust_tz, bool *reparse)
 {
 	int rc;
 	struct smb2_file_all_info *smb2_data;
 	__u32 create_options = 0;
-	struct cifs_fid fid;
-	bool no_cached_open = tcon->nohandlecache;
+	struct cifsFileInfo *cfile;
+	struct cached_fid *cfid = NULL;
 
 	*adjust_tz = false;
-	*symlink = false;
+	*reparse = false;
 
 	smb2_data = kzalloc(sizeof(struct smb2_file_all_info) + PATH_MAX * 2,
 			    GFP_KERNEL);
 	if (smb2_data == NULL)
 		return -ENOMEM;
 
 	/* If it is a root and its handle is cached then use it */
-	if (!strlen(full_path) && !no_cached_open) {
-
-		rc = open_shroot_202(xid, tcon, &fid);
-
-		if (rc)
-			goto out;
-
+	rc = open_cached_dir_202(xid, tcon, full_path, cifs_sb, &cfid);
+	if (!rc) {
 		if (tcon->crfid.file_all_info_is_valid) {
-			move_smb2_info_to_cifs(data, &tcon->crfid.file_all_info);
+			move_smb2_info_to_cifs(data,
+			                       &tcon->crfid.file_all_info);
 		} else {
-			rc = SMB2_query_info(xid, tcon, fid.persistent_fid, fid.volatile_fid, smb2_data);
-
+			rc = SMB2_query_info(xid, tcon,
+			                     cfid->fid->persistent_fid,
+					     cfid->fid->volatile_fid, smb2_data);
 			if (!rc)
 				move_smb2_info_to_cifs(data, smb2_data);
 		}
-		close_shroot(&tcon->crfid);
+		close_cached_dir(&tcon->crfid);
 		goto out;
 	}
 
 	if (backup_cred(cifs_sb))
 		create_options |= CREATE_OPEN_BACKUP_INTENT;
 
+	cifs_get_readable_path(tcon, full_path, &cfile);
 	rc = smb202_compound_op(xid, tcon, cifs_sb, full_path,
 			      FILE_READ_ATTRIBUTES, FILE_OPEN, create_options,
-			      smb2_data, SMB2_OP_QUERY_INFO);
+			      ACL_NO_MODE, smb2_data, SMB2_OP_QUERY_INFO, cfile);
 
 	if (rc == -EOPNOTSUPP) {
-		*symlink = true;
+		*reparse = true;
 		create_options |= OPEN_REPARSE_POINT;
 
 		/* Failed on a symbolic link - query a reparse point info */
 		rc = smb202_compound_op(xid, tcon, cifs_sb, full_path,
 				      FILE_READ_ATTRIBUTES, FILE_OPEN,
-				      create_options, smb2_data,
-				      SMB2_OP_QUERY_INFO);
+				      create_options, ACL_NO_MODE,
+				      smb2_data, SMB2_OP_QUERY_INFO, NULL);
 	}
 	if (rc)
 		goto out;
 
 	move_smb2_info_to_cifs(data, smb2_data);
 out:
 	kfree(smb2_data);
@@ -1083,15 +1234,15 @@ common_smb_get_reparse_attrs(bool do202,
 		return -ENOMEM;
 
 	if (backup_cred(cifs_sb))
 		create_options |= CREATE_OPEN_BACKUP_INTENT;
 	create_options |= OPEN_REPARSE_POINT;
 
 	if (do202)
-		rc = smb202_compound_op(xid, tcon, cifs_sb, full_path, FILE_READ_ATTRIBUTES, FILE_OPEN, create_options, smb2_data, SMB2_OP_QUERY_INFO);
+		rc = smb202_compound_op(xid, tcon, cifs_sb, full_path, FILE_READ_ATTRIBUTES, FILE_OPEN, create_options, ACL_NO_MODE, smb2_data, SMB2_OP_QUERY_INFO, NULL);
 	else
 		rc =   smb2_compound_op(xid, tcon, cifs_sb, full_path, FILE_READ_ATTRIBUTES, FILE_OPEN, create_options, ACL_NO_MODE, smb2_data, SMB2_OP_QUERY_INFO, NULL);
 
 	if (rc)
 		goto out;
 
 	*out_attrs = smb2_data->Attributes;
diff -Nrp -U 7 --no-dereference --no-ignore-file-name-case --strip-trailing-cr '--exclude=.git*' a/fs/cifs/smb2ops.c b/fs/cifs/smb2ops.c
--- a/fs/cifs/smb2ops.c	2021-10-12 12:15:15.508068105 -0500
+++ b/fs/cifs/smb2ops.c	2021-10-11 17:05:12.000000000 -0500
@@ -933,103 +933,144 @@ oshr_free:
 	free_rsp_buf(resp_buftype[1], rsp_iov[1].iov_base);
 	if (rc == 0)
 		*cfid = &tcon->crfid;
 	return rc;
 }
 
 
-int open_shroot_202(unsigned int xid, struct cifs_tcon *tcon, struct cifs_fid *pfid)
+int open_cached_dir_202(unsigned int xid, struct cifs_tcon *tcon,
+		const char *path,
+		struct cifs_sb_info *cifs_sb,
+		struct cached_fid **cfid)
 {
 	struct cifs_ses *ses = tcon->ses;
 	struct TCP_Server_Info *server = ses->server;
 	struct cifs_open_parms oparms;
 	struct smb2_create_rsp *o_rsp = NULL;
 #define NCHAINED 7
 	int resp_buftype[NCHAINED];
 	struct smb_rqst rqst[NCHAINED];
 	struct kvec rsp_iov[NCHAINED];
 	struct kvec qi_iov[NCHAINED];
 	struct kvec open_iov[SMB2_CREATE_IOV_SIZE];
 	int rc, flags = 0;
 	__le16 utf16_path = 0; /* Null - since an open of top of share */
 	u8 oplock = SMB2_OPLOCK_LEVEL_II;
+	struct cifs_fid *pfid;
+	struct dentry *dentry;
 	int nc = 0;
 
-	mutex_lock(&tcon->crfid.fid_mutex);
+	if (tcon->nohandlecache)
+		return -ENOTSUPP;
+
+	if (cifs_sb->root == NULL)
+		return -ENOENT;
+
+	if (strlen(path))
+		return -ENOENT;
+
+	dentry = cifs_sb->root;
 
+	mutex_lock(&tcon->crfid.fid_mutex);
 	if (tcon->crfid.is_valid) {
 		cifs_dbg(FYI, "found a cached root file handle\n");
-		memcpy(pfid, tcon->crfid.fid, sizeof(struct cifs_fid));
+		*cfid = &tcon->crfid;
 		kref_get(&tcon->crfid.refcount);
 		mutex_unlock(&tcon->crfid.fid_mutex);
 		return 0;
 	}
 
+	/*
+	 * We do not hold the lock for the open because in case
+	 * SMB2_open needs to reconnect, it will end up calling
+	 * cifs_mark_open_files_invalid() which takes the lock again
+	 * thus causing a deadlock
+	 */
+
+	mutex_unlock(&tcon->crfid.fid_mutex);
+
 	if (smb3_encryption_required(tcon))
 		flags |= CIFS_TRANSFORM_REQ;
 
-	for(nc=0; nc < NCHAINED; nc++) resp_buftype[nc] = CIFS_NO_BUFFER;
+	if (!server->ops->new_lease_key)
+		return -EIO;
+
+	pfid = tcon->crfid.fid;
+	server->ops->new_lease_key(pfid);
+
+	for (nc = 0; nc < NCHAINED; nc++) {
+		resp_buftype[nc] = CIFS_NO_BUFFER;
+	}
 	memset(rqst, 0, sizeof(rqst));
 	memset(rsp_iov, 0, sizeof(rsp_iov));
 	memset(qi_iov, 0, sizeof(qi_iov));
 
-
 	/* Open */
 	memset(&open_iov, 0, sizeof(open_iov));
 	rqst[0].rq_iov = open_iov;
 	rqst[0].rq_nvec = SMB2_CREATE_IOV_SIZE;
 
 	oparms.tcon = tcon;
-	oparms.create_options = 0;
+	oparms.create_options = cifs_create_options(cifs_sb, 0);
 	oparms.desired_access = FILE_READ_ATTRIBUTES;
 	oparms.disposition = FILE_OPEN;
 	oparms.fid = pfid;
 	oparms.reconnect = false;
 
-	rc = SMB2_open_init(tcon, server, &rqst[0], &oplock, &oparms, &utf16_path);
+	rc = SMB2_open_init(tcon, server,
+			    &rqst[0], &oplock, &oparms, &utf16_path);
 	if (rc)
-		goto oshr_exit;
-	smb2_set_next_command(tcon, &rqst[0]);
-
+		goto oshr_free;
 
 	/* INFO */
 
-	for(nc=1; nc < NCHAINED; nc++) {
+	for (nc = 1; nc < NCHAINED; nc++) {
 		rqst[nc].rq_iov = qi_iov+nc;
 		rqst[nc].rq_nvec = 1;
 	}
 
 	nc = 0;
 
-#define _X(_w1, _w2) 																	\
-	if (++nc >= NCHAINED) { cifs_dbg(FYI, "TOO MANY %d\n", nc); rc = -96; goto oshr_exit; }								\
-	if ((rc = SMB2_query_info_init(tcon, ses->server, &rqst[nc], COMPOUND_FID, COMPOUND_FID, _w1,	SMB2_O_INFO_FILE, 0, sizeof(struct _w2), 0, NULL)))	\
-		goto oshr_exit;																\
+#define _X(_w1, _w2)						\
+	if (++nc >= NCHAINED) {					\
+		cifs_dbg(FYI, "TOO MANY %d\n", nc);		\
+		rc = -96;					\
+		goto oshr_exit;					\
+	}							\
+	rc = SMB2_query_info_init(tcon,				\
+				  ses->server,			\
+				  &rqst[nc], COMPOUND_FID,	\
+				  COMPOUND_FID, _w1,		\
+				  SMB2_O_INFO_FILE, 0,		\
+				  sizeof(struct _w2) +		\
+				  PATH_MAX * 2, 0, NULL);	\
+	if (rc)							\
+		goto oshr_exit;					\
+								\
 	smb2_set_related(&rqst[nc]);
+/* End of define _X */
 
 	_X( FILE_BASIC_INFORMATION,	smb2_file_basic_info );		smb2_set_next_command(tcon, &rqst[nc]);
 	_X( FILE_STANDARD_INFORMATION,	smb2_file_standard_info );	smb2_set_next_command(tcon, &rqst[nc]);
 	_X( FILE_INTERNAL_INFORMATION,	smb2_file_internal_info );	smb2_set_next_command(tcon, &rqst[nc]);
 	_X( FILE_EA_INFORMATION,	smb2_file_ea_info );		smb2_set_next_command(tcon, &rqst[nc]);
 	_X( FILE_ACCESS_INFORMATION,	smb2_file_access_info );	smb2_set_next_command(tcon, &rqst[nc]);
 	_X( FILE_MODE_INFORMATION,	smb2_file_mode_info );
 
 #undef _X
 
-	if (++nc != NCHAINED) { cifs_dbg(FYI, "MISMATCH %d\n", nc); rc = -96; goto oshr_exit; }
-
-	/*
-	 * We do not hold the lock for the open because in case
-	 * SMB2_open needs to reconnect, it will end up calling
-	 * cifs_mark_open_files_invalid() which takes the lock again
-	 * thus causing a deadlock
-	 */
+	if (++nc != NCHAINED) {
+		cifs_dbg(FYI, "MISMATCH %d\n", nc);
+		rc = -96;
+		goto oshr_exit;
+	}
 
-	mutex_unlock(&tcon->crfid.fid_mutex);
-	rc = compound_send_recv(xid, ses, server, flags, nc, rqst, resp_buftype, rsp_iov);
+	rc = compound_send_recv(xid, ses, server,
+				flags, 2, rqst,
+				resp_buftype, rsp_iov);
 	mutex_lock(&tcon->crfid.fid_mutex);
 
 	/*
 	 * Now we need to check again as the cached root might have
 	 * been successfully re-opened from a concurrent process
 	 */
 
@@ -1039,150 +1080,195 @@ int open_shroot_202(unsigned int xid, st
 		/* stash fids for close() later */
 		struct cifs_fid fid = {
 			.persistent_fid = pfid->persistent_fid,
 			.volatile_fid = pfid->volatile_fid,
 		};
 
 		/*
-		 * caller expects this func to set pfid to a valid
-		 * cached root, so we copy the existing one and get a
-		 * reference.
+		 * caller expects this func to set the fid in crfid to valid
+		 * cached root, so increment the refcount.
 		 */
-		memcpy(pfid, tcon->crfid.fid, sizeof(*pfid));
 		kref_get(&tcon->crfid.refcount);
 
 		mutex_unlock(&tcon->crfid.fid_mutex);
 
 		if (rc == 0) {
 			/* close extra handle outside of crit sec */
 			SMB2_close(xid, tcon, fid.persistent_fid, fid.volatile_fid);
 		}
+		rc = 0;
 		goto oshr_free;
 	}
 
 	/* Cached root is still invalid, continue normaly */
 
-	if (rc)
+	if (rc) {
+		if (rc == -EREMCHG) {
+			tcon->need_reconnect = true;
+			pr_warn_once("server share %s deleted\n",
+				     tcon->treeName);
+		}
 		goto oshr_exit;
+	}
+
+	atomic_inc(&tcon->num_remote_opens);
 
 	o_rsp = (struct smb2_create_rsp *)rsp_iov[0].iov_base;
 	oparms.fid->persistent_fid = o_rsp->PersistentFileId;
 	oparms.fid->volatile_fid = o_rsp->VolatileFileId;
 #ifdef CONFIG_CIFS_DEBUG2
 	oparms.fid->mid = le64_to_cpu(o_rsp->sync_hdr.MessageId);
 #endif /* CIFS_DEBUG2 */
 
-	memcpy(tcon->crfid.fid, pfid, sizeof(struct cifs_fid));
 	tcon->crfid.tcon = tcon;
 	tcon->crfid.is_valid = true;
+	tcon->crfid.dentry = dentry;
+	dget(dentry);
 	kref_init(&tcon->crfid.refcount);
 
-
 	/* BB TBD check to see if oplock level check can be removed below */
-
 	if (o_rsp->OplockLevel == SMB2_OPLOCK_LEVEL_LEASE) {
+		/*
+		 * See commit 2f94a3125b87. Increment the refcount when we
+		 * get a lease for root, release it if lease break occurs
+		 */
 		kref_get(&tcon->crfid.refcount);
+		tcon->crfid.has_lease = true;
 		smb2_parse_contexts(server, o_rsp,
 				&oparms.fid->epoch,
-				oparms.fid->lease_key, &oplock, NULL, NULL);
+				    oparms.fid->lease_key, &oplock,
+				    NULL, NULL);
 	}
 #if 0
-	else {
+	} else
 		goto oshr_exit;
-	}
-#endif
+#endif /* 0 */
 
+#if 0
+	qi_rsp = (struct smb2_query_info_rsp *)rsp_iov[1].iov_base;
+	if (le32_to_cpu(qi_rsp->OutputBufferLength) < sizeof(struct smb2_file_all_info))
+		goto oshr_exit;
+	if (!smb2_validate_and_copy_iov(
+				le16_to_cpu(qi_rsp->OutputBufferOffset),
+				sizeof(struct smb2_file_all_info),
+				&rsp_iov[1], sizeof(struct smb2_file_all_info),
+				(char *)&tcon->crfid.file_all_info))
+		tcon->crfid.file_all_info_is_valid = true;
+#endif /* 0 */
 	memset((char *)&tcon->crfid.file_all_info, 0, sizeof(tcon->crfid.file_all_info));
 
 	nc = 1;
 
-#define _X(_what)														\
-	{															\
-		struct kvec *iov;												\
-		struct smb2_query_info_rsp *rsp;										\
-		unsigned int off;												\
-		struct _what *dat;												\
-																\
-		iov = rsp_iov + nc;												\
-		if (++nc > NCHAINED) { cifs_dbg(FYI, "TOO MANY on decode %d\n", nc); rc = -96; goto oshr_exit; }		\
-		rsp = (struct smb2_query_info_rsp *)iov->iov_base;								\
-																\
-		if (le32_to_cpu(rsp->OutputBufferLength) < sizeof(struct _what ) ) {						\
-			cifs_dbg(FYI, "BUFFER too small, %d, %d\n", rsp->OutputBufferLength, (int)sizeof(struct _what));	\
-			rc = -96;												\
-			goto oshr_exit;												\
-		}														\
-																\
-		off = le16_to_cpu(rsp->OutputBufferOffset);									\
-																\
-		if ((rc = smb2_validate_iov( off, sizeof(struct _what), iov, sizeof(struct _what)) )) {				\
-			cifs_dbg(FYI, "BUFFER validate error, %d\n", rc);							\
-			goto oshr_exit;												\
-		}														\
+#define _X(_what)									\
+		struct kvec *iov;							\
+		struct smb2_query_info_rsp *rsp;					\
+		unsigned int off;							\
+		struct _what *dat;							\
+											\
+		iov = rsp_iov + nc;							\
+		if (++nc > NCHAINED) {							\
+			cifs_dbg(FYI, "TOO MANY on decode %d\n", nc);			\
+			rc = -96;							\
+			goto oshr_exit;							\
+		}									\
+		rsp = (struct smb2_query_info_rsp *)iov->iov_base;			\
+											\
+		if (le32_to_cpu(rsp->OutputBufferLength) < sizeof(struct _what)) {	\
+			cifs_dbg(FYI, "BUFFER too small, %d, %d\n",			\
+			         rsp->OutputBufferLength, (int)sizeof(struct _what));	\
+			rc = -96;							\
+			goto oshr_exit;							\
+		}									\
+											\
+		off = le16_to_cpu(rsp->OutputBufferOffset);				\
+											\
+		rc = smb2_validate_iov(off,						\
+				       sizeof(struct _what),				\
+				       iov, sizeof(struct _what));			\
+		if (rc) {								\
+			cifs_dbg(FYI, "BUFFER validate error, %d\n", rc);		\
+			goto oshr_exit;							\
+		}									\
 		dat = (struct _what *)(off + (char*)iov->iov_base);
+/* End of define _X */
 
 #define _Y(_f)	tcon->crfid.file_all_info._f = dat->_f;
-#define _Z() }
+/* End of define _Y */
 
-	_X( smb2_file_basic_info )
-	_Y( CreationTime )
-	_Y( LastAccessTime )
-	_Y( LastWriteTime )
-	_Y( ChangeTime )
-	_Y( Attributes )
-	_Z( )
-
-	_X( smb2_file_standard_info )
-	_Y( AllocationSize )
-	_Y( EndOfFile )
-	_Y( NumberOfLinks )
-	_Y( DeletePending )
-	_Y( Directory )
-	_Z( )
-
-	_X( smb2_file_internal_info )
-	_Y( IndexNumber )
-	_Z( )
-
-	_X( smb2_file_ea_info )
-	_Y( EASize )
-	_Z( )
-
-	_X( smb2_file_access_info )
-	_Y( AccessFlags )
-	_Z( )
-
-	_X( smb2_file_mode_info )
-	_Y( Mode )
-	_Z( )
+	{
+		_X( smb2_file_basic_info )
+		_Y( CreationTime )
+		_Y( LastAccessTime )
+		_Y( LastWriteTime )
+		_Y( ChangeTime )
+		_Y( Attributes )
+	}
 
-	if (nc != NCHAINED) { cifs_dbg(FYI, "decode MISMATCH %d\n", nc); rc = -96; goto oshr_exit; }
+	{
+		_X( smb2_file_standard_info )
+		_Y( AllocationSize )
+		_Y( EndOfFile )
+		_Y( NumberOfLinks )
+		_Y( DeletePending )
+		_Y( Directory )
+	}
 
-	tcon->crfid.file_all_info_is_valid = 1;
+	{
+		_X( smb2_file_internal_info )
+		_Y( IndexNumber )
+	}
 
+	{
+		_X( smb2_file_ea_info )
+		_Y( EASize )
+	}
+
+	{
+		_X( smb2_file_access_info )
+		_Y( AccessFlags )
+	}
+
+	{
+		_X( smb2_file_mode_info )
+		_Y( Mode )
+	}
+
+	if (nc != NCHAINED) {
+		cifs_dbg(FYI, "decode MISMATCH %d\n", nc);
+		rc = -96;
+		goto oshr_exit;
+	}
 #undef _X
 #undef _Y
-#undef _Z
+	tcon->crfid.file_all_info_is_valid = true;
+	tcon->crfid.time = jiffies;
+
 
 oshr_exit:
 	mutex_unlock(&tcon->crfid.fid_mutex);
-
 oshr_free:
 	SMB2_open_free(&rqst[0]);
+//	SMB2_query_info_free(&rqst[1]);
 	free_rsp_buf(resp_buftype[0], rsp_iov[0].iov_base);
+//	free_rsp_buf(resp_buftype[1], rsp_iov[1].iov_base);
 
-	for(nc=1; nc < NCHAINED; nc++) {
+	for (nc = 1; nc < NCHAINED; nc++) {
 		SMB2_query_info_free(&rqst[nc]);
 		free_rsp_buf(resp_buftype[nc], rsp_iov[nc].iov_base);
 	}
 
-	if (rc) cifs_dbg(FYI, "INODE RETURNING %d\n", rc);
-
+	if (rc) {
+		cifs_dbg(FYI, "INODE RETURNING %d\n", rc);
+	}
+	else {
+//	if (rc == 0)
+		*cfid = &tcon->crfid;
+	}
 	return rc;
-}
+}	/* End of open_cached_dir_202 */
 
 
 int open_cached_dir_by_dentry(struct cifs_tcon *tcon,
 			      struct dentry *dentry,
 			      struct cached_fid **cfid)
 {
 	mutex_lock(&tcon->crfid.fid_mutex);
diff -Nrp -U 7 --no-dereference --no-ignore-file-name-case --strip-trailing-cr '--exclude=.git*' a/fs/cifs/smb2proto.h b/fs/cifs/smb2proto.h
--- a/fs/cifs/smb2proto.h	2021-10-12 12:15:15.508068105 -0500
+++ b/fs/cifs/smb2proto.h	2021-10-08 12:16:44.000000000 -0500
@@ -54,17 +54,18 @@ extern bool smb2_is_valid_oplock_break(c
 extern int smb3_handle_read_data(struct TCP_Server_Info *server,
 				 struct mid_q_entry *mid);
 
 extern int open_cached_dir(unsigned int xid, struct cifs_tcon *tcon,
 			   const char *path,
 			   struct cifs_sb_info *cifs_sb,
 			   struct cached_fid **cfid);
-
-extern int open_shroot_202(unsigned int xid, struct cifs_tcon *tcon,
-			struct cifs_fid *pfid);
+extern int open_cached_dir_202(unsigned int xid, struct cifs_tcon *tcon,
+			       const char *path,
+			       struct cifs_sb_info *cifs_sb,
+			       struct cached_fid **cfid);
 
 extern int open_cached_dir_by_dentry(struct cifs_tcon *tcon,
 				     struct dentry *dentry,
 				     struct cached_fid **cfid);
 extern void close_cached_dir(struct cached_fid *cfid);
 extern void close_cached_dir_lease(struct cached_fid *cfid);
 extern void close_cached_dir_lease_locked(struct cached_fid *cfid);
