/* vim: tabstop=8 expandtab shiftwidth=4 softtabstop=4
 */

/* This file sorts a single linked list. */
/* ------------------------------------------------------------------------ */
#include <stddef.h>

/* ------------------------------------------------------------------------ */
struct element
{
    struct element *next;
    int             value;
    long            junk;
};
typedef struct element element;

/* ------------------------------------------------------------------------ */
/* The compare function. */
static int cmp(struct element *a, struct element *b)
{
    return (a->value - b->value);
}

/* ------------------------------------------------------------------------ */
/* Sorted list returned. */
struct element *listsort(struct element *list)
{
    struct element *p;
    struct element *q;
    struct element *e;
    struct element *tail;
    int             nmerges;
    int             psize;
    int             qsize;
    int             i;
    int             insize = 1;

    if (!list)
    {
        return (NULL);
    }

    while (1)
    {
        p = list;
        list = NULL;
        tail = NULL;
        nmerges = 0;                            /* count number of merges we do in this pass */
        while (p)
        {
            nmerges++;                          /* there exists a merge to be done */
            /* step `insize' places along from p */
            q = p;
            psize = 0;
            for (i = 0; i < insize; i++)
            {
                psize++;
                q = q->next;
                if (!q)
                    break;
            }

            /* if q hasn't fallen off end, we have two lists to merge */
            qsize = insize;

            /* now we have two lists; merge them */
            while (psize > 0 || (qsize > 0 && q))
            {

                /* decide whether next element of merge comes from p or q */
                if (psize == 0)
                {
                    /* p is empty; e must come from q. */
                    e = q;
                    q = q->next;
                    qsize--;
                }
                else if (qsize == 0 || !q)
                {
                    /* q is empty; e must come from p. */
                    e = p;
                    p = p->next;
                    psize--;
                }
                else if (cmp(p, q) <= 0)
                {
                    /* First element of p is lower (or same);
                     * e must come from p. */
                    e = p;
                    p = p->next;
                    psize--;
                }
                else
                {
                    /* First element of q is lower; e must come from q. */
                    e = q;
                    q = q->next;
                    qsize--;
                }

                /* add the next element to the merged list */
                if (tail)
                {
                    tail->next = e;
                }
                else
                {
                    list = e;
                }
                tail = e;
            }

            /* now p has stepped `insize' places along, and q has too */
            p = q;
        }
        tail->next = NULL;

        /* If we have done only one merge, we're finished. */
        if (nmerges <= 1)                       /* allow for nmerges==0, the empty list case */
        {
            return (list);
        }
        /* Otherwise repeat, merging lists twice the size */
        insize *= 2;
    }
}   /* End of listsort */

/* ------------------------------------------------------------------------ */
#define lenof(x) (sizeof(x)/sizeof(*(x)))
#include <stdio.h>
#include <string.h>

#define nmax 13
struct element  k[nmax];

int print_and_check_list(struct element *head, int expected_len, int check_ordering)
{
    unsigned long   bits_used;
    struct element *tail;
    struct element *e;

    /*
     * Check over the list in the forward direction, to find its tail
     * and make sure it covers exactly the expected set of elements.
     */
    bits_used = 0;
    e = head;
    do
    {
        unsigned long   bit;

        if (!(e >= k && e < k + expected_len))
        {
            printf("!! Out-of-range pointer !!");
            return (0);
        }

        bit = 1U << (e - head);
        if (bits_used & bit)
        {
            printf("!! Duplicate element !!");
            return (0);
        }
        bits_used |= bit;

        tail = e;
        e = e->next;
    } while (e && e != head);

    /*
     * Check links at the ends.
     */
    if (tail->next != NULL)
    {
        printf("!! Bad next link from list tail !!");
        return (0);
    }

    /* Check the list is sorted. */
    if (check_ordering)
    {
        for (e = head; e->next && e->next != head; e = e->next)
        {
            if (!(e->next->value > e->value))
            {
                printf("!! Bad ordering between nodes %d '%c' and %d '%c' !!",
                       (int)(e - k), e->value, (int)(e->next - k), e->next->value);
                return (0);
            }
        }
    }

    putchar('[');
    e = head;
    do
    {
        putchar(e->value);
        e = e->next;
    } while (e && e != head);
    putchar(']');
    return (1);
}   /* End of print_and_check_list */

/* ------------------------------------------------------------------------ */
int main(void)
{
    /*
     * Three orders of a length-13 list. (The length is chosen
     * because that means some passes will have an extra list at
     * the end and some will not.)
     */
    static const char *const testcases[] = {
        "abcdefghijklm",
        "gcielbmhdjfak",
        "mlkjihgfedcba",
    };
    int             npasses = 0;
    int             nfails = 0;

    printf("testing %s %s linked list\n", "straight", "singly");

    for (int i = 0; i < (int)lenof(testcases); i++)
    {
        int             pass = 1;
        struct element *head;
        int             j;
        int             n = strlen(testcases[i]);

        for (j = 0; j < n; j++)
        {
            k[j].value = testcases[i][j];
            k[j].next = (j + 1 < n ? &k[j + 1] : NULL);
        }
        printf("    ");
        head = &k[0];
        if (!print_and_check_list(head, n, 0))
        {
            pass = 0;
        }
        else
        {
            head = listsort(head);
            printf(" -> ");
            if (!print_and_check_list(head, n, 1))
            {
                pass = 0;
            }
        }
        if (pass)
        {
            printf(" ok");
            npasses++;
        }
        else
        {
            nfails++;
        }
        printf("\n");
    }
    printf("passed %d failed %d total %d\n", npasses, nfails, npasses + nfails);
    return (nfails != 0);
}   /* End of main */

/* ------------------------------------------------------------------------ */
