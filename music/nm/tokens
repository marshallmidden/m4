#!/usr/bin/python3 -B
# ----------------------------------------------------------------------------
# vim: tabstop=8 expandtab shiftwidth=4 softtabstop=4
# ----------------------------------------------------------------------------
# TODO: Need to save and restore token area for when ABC(2,1) ... restore so that n_token=ABC and not 1 after).
# ----------------------------------------------------------------------------
# block   from, to, length (words)
# ------------------------------------------------------------------------------
# find    object,start,length,return  [, increment, mask]
# ------------------------------------------------------------------------------
# ------------------------------------------------------------------------------
# deletes s, s.nvals + n_nvwrds; size1 * size2, 1, 1, size1 * size2
# ------------------------------------------------------------------------------
# findsa  varnam + n_maclev, s, csymb(1); n_cvdef, 2, 1, 10, ptr
#     binary chop alpha sorted - object,list;length,increment,1stchar_of_search,numchrs,return [,mask}
# ------------------------------------------------------------------------------
# inserts vsymb[1], s, csymb(1); n_cvdef, 2, ptr
#         insert into list:
#                 object,list;length,increment,posit,number
# ------------------------------------------------------------------------------
# ------------------------------------------------------------------------------
# move   from, char_position, to, new_position, #chars
# ------------------------------------------------------------------------------
# pack line, lchars, @0a, token, tlength@1 = @0s, value, 10@1")
# ------------------------------------------------------------------------------
# packc   gliss == 1, token, tlength
#         expression, place, count,  string<0, string0, ...        if eoln after count, then eoln's only.
#         count blank if returned not desired.
#         <|s,n20|>     Embedded shows     - show, showe, showa, showo, showt, showz, showh
# ------------------------------------------------------------------------------
# search  '+', 1, varnam, 10, 1, ret
#         string,length,start,number,begin,return,places
# ------------------------------------------------------------------------------
# ------------------------------------------------------------------------------
# transfr info; s, s.stack + n_stkptr + lth; 1   # save info
#               storage, #
#         from;to;length
# ------------------------------------------------------------------------------
# ----------------------------------------------------------------------------
import argparse
import os
import re
import readline
import shlex
import sys
import random
#-- import pprint
#-- # Usage:   pprint.pprint(v_t_lines, width=110, sort_dicts=False)

from fractions import Fraction

import inspect
#++ print(inspect.currentframe().f_code.co_name + ' - #0', file=sys.stderr, flush=True)
# ----------------------------------------------------------------------------
import math
# Log base 2
def Log2(x):
    x = float(x)
    if x == 0:
        return 0
    # fi
    return (math.log10(x) / math.log10(2))
#   End of Log2

# ----------------------------------------------------------------------------
import calculate

calculate.cexp_parser()                         # initialize parser

# Default ancient musicomp values -- not used within this script/program. (For input files.)
calculate.variables['pause'] = 4
calculate.variables['grace'] = 4

# IMS variables
calculate.variables['accent'] = 10              # light accent
calculate.variables['aaccent'] = 20             # heavy accent
calculate.variables['arp'] = 1/32               # Default arpeggiation length
calculate.variables['fermata'] = 1              # fermata
calculate.variables['lferm'] = 1                # No fermata yet.
calculate.variables['stac'] = 0.25              # Staccato length multiplier - used to be 4, but IMS is 1/4.
calculate.variables['marc'] = 0.5               # Marcato length multipliers.

# New default musicomp values for debugging, etc.
calculate.variables['page'] = '-1'
calculate.variables['measure'] = '-1'

# Default MIDI control values.
calculate.variables['default_reverb'] = 0       # No reverb.
calculate.variables['default_pan'] = 64         # Center of left<->right balance.
calculate.variables['default_intensity'] = 100  # Volume = intensity% * velocity% * vol(ff)%.
calculate.variables['default_velocity'] = 120   # Note attack (when played. (Leave 7) Appears to be volume.

#-----------------------------------------------------------------------------
from itertools import permutations

def the_perms(pre, mystr):
    d = {}
    for i in range(1, len(mystr) + 1):
        for comb in permutations(mystr, i):
            d[pre + ''.join(comb)] = 1
        # rof
    # rof
    return d
# End of the_perms

#-----------------------------------------------------------------------------
# For suffix on time -- many variations, but do not duplicate z's with l's.
# This makes each permuation evaluate to '1'.
# TODO - NOTDONEYET - local_variables - for note time length or not. Maybe redo the whole suffix thing!
calculate.variables.update(the_perms('', 'sbtaz'))
calculate.variables.update(the_perms('d', 'sbtaz'))
calculate.variables.update(the_perms('dd', 'sbtaz'))
calculate.variables.update(the_perms('', 'sbtal'))
calculate.variables.update(the_perms('d', 'sbtal'))
calculate.variables.update(the_perms('dd', 'sbtal'))

# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
#-- def handle_n(arg):
#--     # No checking for problems.
#--     a = float(arg)
#--     b = int(a)
#--     which = arg >> 2
#--     if (arg & 1) == 0:
#--         return [ 'ID', 'zvar' + str(a) ]
#--     # fi
#--     return [ 'ID', 'zvar' + str(a) ]
#-- # End of handle_n
#--
#-- calculate.functions['zvar'] = handle_n

global the_zvars
the_zvars = 0

calculate.arrays = []       # warray

numarry_name = 0            # The name of the variable.
numarry_maclevel = 1        # The macro level was in effect when created.
numarry_indexes = 2         # The array indexes. []=value, [3]=1-dimen, [2,4]=2-dimen.
numarry_values = 3          # Array of values ([0] for not an array).
numarry_value_type = 4      # Array of types None=not-set, 0=int/float, 1= character string

#?? zvar ? 
#?? numarry_dimensions - delete
#?? numarry_value_type - now an array of unset/int-or-float/character-string.

# ----------------------------------------------------------------------------
global args
global errors_happened
errors_happened = 0                 # system exit, 0 = okay, 1 = errors happened

global which_file_in
which_file_in = 'stdin'
global linecount
linecount = 0

# ----------------------------------------------------------------------------
def print_error(strg, line):
    global linecount
    global which_file_in
    global errors_happened

    errors_happened = 1             # When exiting, do 1 instead of 0

    print("ERROR -", strg, file=sys.stderr, flush=True)
    print("  File {} Line {} - '{}'".format(which_file_in, linecount, line), file=sys.stderr, flush=True)
    return
# End of print_error

# ----------------------------------------------------------------------------
def print_warning(strg, line):
    global linecount
    global which_file_in

    print("WARNING -", strg, file=sys.stderr, flush=True)
    print("  File {} Line {} - '{}'".format(which_file_in, linecount, line), file=sys.stderr, flush=True)
    return
# End of print_warning

# ----------------------------------------------------------------------------
def print_error_no_line(strg):
    print("ERROR -", strg, file=sys.stderr, flush=True)
    return
# End of print_error_no_line

# ----------------------------------------------------------------------------
def print_warning_no_line(strg):
    print("WARNING -", strg, file=sys.stderr, flush=True)
    return
# End of print_warning_no_line

# ----------------------------------------------------------------------------
def really_print_output(strg):
    global output_descriptor

    print(strg, file=output_descriptor, flush=True)
    return
# End of really_print_output

# ----------------------------------------------------------------------------
def print_debug(strg):
    print("debug -", strg, file=sys.stderr, flush=True)
    return
# End of erint_debug

# ----------------------------------------------------------------------------
def print_output(strg):
    global args
    global array_of_lines
    global fluidsynth_done

    if not args.fluidsynth and not fluidsynth_done:
        really_print_output(strg)
    else:
        if strg == "quit":
            fluidsynth_done = True
        else:
            array_of_lines.append(strg)
        # fi
    # fi
    return
# End of print_output

# ----------------------------------------------------------------------------
def print_output_no_eol(strg):
    global output_descriptor

    print(strg, end='', file=output_descriptor, flush=True)
    return
# End of print_output_no_eol

# ----------------------------------------------------------------------------
# Get a line. Put it in "line" and return it.
def get_new_line(if_full_line):
    global linecount
    global args
    global file_name
    global errors_happened

    full_line = ''
    while True:
        try:
            if args.rest and len(args.rest) >= 1:
                line = file_name.readline()
            else:
                if sys.stdin.isatty():
                    if sys.platform == 'darwin':
                        input('input> ')
                        line = readline.get_line_buffer()
                    else:
                        line = input('input> ')
                    # fi
                else:
                    line = sys.stdin.readline()
                # fi
            # fi
            if line is None or line == '':
                sys.exit(errors_happened)
            # fi
            linecount = linecount + 1
            if line:
                line = line.rstrip()                                    # trailing spaces gone.
                if line and line[-1] == '\\':                           # if continued on next line
                    line = line[:-1]
                    line = line.rstrip()                                # trailing spaces gone.
                    full_line += line
                    continue
                # fi
                full_line += line
                commentdollardollar = ''
                if if_full_line and '$$' in full_line:
                    # delete anything from $$ onwards.
                    commentdollardollar = re.sub(r'^.*[$][$]', '$$', full_line, count=1)
                    commentdollardollar = commentdollardollar.rstrip()  # trailing spaces gone
                    full_line = re.sub(r'[$][$].*$', '', full_line)
                # fi
                # Convert tabs to spaces.
                full_line = full_line.replace("\t", ' ')
                full_line = full_line.rstrip()                                    # trailing spaces gone.
                # NOTDONEYET, the input from Plato Printouts where character ' is a shift.
                # Convert ' followed by something as a "shift". '; = :   'a = A
                return full_line, commentdollardollar
            # fi
        except EOFError:
            if full_line != '':
                return full_line, commentdollardollar
            # fi
            pass            # print("Read gave EOF", file=sys.stderr, flush=True)
        except SystemExit:
            if full_line != '':
                return full_line, commentdollardollar
            # fi
            pass            # print("Read gave system exit", file=sys.stderr, flush=True)
        except KeyboardInterrupt:
            print_error_no_line("Read got keyboard interrupt")
        except:
            if full_line != '':
                return full_line, commentdollardollar
            # fi
            print_error_no_line("Read got a processing error")
            print("    ", sys.exc_info()[0], sys.exc_info, file=sys.stderr, flush=True)
        # yrt
        break
    # elihw
    do_pass2()
    sys.exit(errors_happened)
# End of get_new_line

# ----------------------------------------------------------------------------
def getline(ignore_dollar_dollar):
    precomment = ''
    while True:
        line, commentonline = get_new_line(ignore_dollar_dollar)
        if line:
            # Split line on spaces, then process line.
            while True:
                line = re.sub(r'   *', r' ', line)                      # multiple spaces to single.
                t0 = re.sub(r'(^ *[^ ]*).*$', r'\1', line, count=1)     # First non-space thing on line.
                t1 = re.sub(r'^ *[^ ]*', '', line, count=1)             # Everything after first thing.
                t_tmp = t0.lstrip()                                     # For command lookup.
                t = [ t0, t1 ]                                          # Note: a leading space.
                if t_tmp and t_tmp == '.':                              # Indented lines - plato "."
                    # If command == '.' toss '.'
                    if len(t) == 2 and t[1]:
                        line = t[1]
                    else:
                        t = None
                        line = None
                        break
                    # fi
                    continue                                            # Try again to get line.
                # fi
                break
            # elihw

            if t_tmp and t_tmp[0]:
                # If command == '*' ignore.
                if t_tmp[0] != '*' and line[0] != '*' and t_tmp[0] != '#' and line[0] != '#':
                    return line, commentonline
                elif line[0] == '#':
                    # Parse # line to get line number and file.
                    uxit = re.sub('^ *# ([0-9]+) "([^"]+)".*$', r"\1 \2", line)
                    if uxit != line:               # If no 3rd argument (flags).
                        wxit = re.split(r' ', uxit, maxsplit = 1)
                        linecount = int(wxit[0]) - 1
                        which_file_in = wxit[1]
                    # fi
                else:
                    precomment = precomment + line + "\n"
                # fi
            # fi
        # fi
    # elihw
    return None
#   End of getline

# ----------------------------------------------------------------------------
# Calculate values here.
# Returns:
#   value   -- So far computed value
#   type_error -- type of error

def is_float(strg):
    tree = calculate.parse(strg)            # parse the string

    if tree is not None and len(tree) == 2:
        if tree[0] is not None and tree[0].startswith('ERROR'):
            sexpr = tree[0]
            return strg, sexpr
        # fi
        if tree[1] == '.':
            return strg, "bad input to calculator"
        # fi
        try:
            sexpr = float(tree[1])
            return sexpr, None
        except:
            return strg, "bad input to calculator"
    # fi
    return None, None
# End of is_float

# ----------------------------------------------------------------------------
# wline = 2..4
#          l
#           l+1
#            l+2
# Separate arguments for argument.
def arglist(wline, line, integers):
    newline = []
    splitter = [ ',' ]
    firstcolon = 0
    # break into arguments.
    newstr = ''
    np = 0                              # ()
    nb = 0                              # []
    nc = 0                              # {}
    lth = len(wline)
    l = 0
    while (l < lth):
        c = wline[l]
        if c == ':' and firstcolon == 0:
            firstcolon = 1
        elif firstcolon == 1 and 'c' != ' ':
            firstcolon = 2
        elif firstcolon == 2:
            if args.spaces:
                splitter.append(' ')
            # fi
            firstcolon = 3
        # fi
        if c in splitter and np == 0 and nb == 0 and nc == 0:    # we want to split on commas
            if integers:
                n, msg = is_float(newstr)
                if msg is not None or n is None:
                    print_error("Range first number bad. {}".format(msg), line)
                    return ''
                # fi
                n = int(n)
                newline.append(str(n))
            else:
                newline.append(newstr)
            # fi
            l = l + 1
            if l < lth:
                newstr = ''
            else:
                newstr = None
            # fi
        elif c == '.' and integers:
            if (l + 2) < lth and wline[l + 1] == '.':
                # Range
                if newstr == '':
                    print_error("Range needs number before 'STARTING..ENDING'", line)
                    return ''
                # fi
                first, msg = is_float(newstr)
                if msg is not None or n is None:
                    print_error("Range first number bad. {}".format(msg), line)
                    return ''
                # fi
                # NOTE: comma looked for, not parenthesis/brackets/braces.
                try:
                    comma = wline.find(',', l + 2)
                    if comma >= 0:
                        last = wline[l + 2:comma]
                        l = comma + 1
                    else:
                        last = wline[l + 2:]
                        l = lth + 1
                    # fi
                except:
                    last = wline[l + 2:]
                    l = lth + 1
                # yrt
                last, msg = is_float(last)
                if msg is not none or last is None or last == '':
                    print_error("Range last number bad. {}".format(msg), line)
                    return ''
                # fi
                first = int(first)
                last = int(last)
                for n in range(first, last + 1):
                    newline.append(str(n))
                # rof
                newstr = ''
                continue
            # fi
            print_error("Range needs number after 'STARTING..ENDING'", line)
            return ''
        #-- elif c == ' ' or c == "\t":
        #--     pass
        else:
            newstr = newstr + c
            if c == '(':
                np = np + 1
            elif c == ')':
                if np == 0:
                    print_error("too many right parenthesis", line)
                    return ''
                # fi
                np = np - 1
            elif c == '[':
                nb = nb + 1
            elif c == ']':
                if nb == 0:
                    print_error("too many right brackets", line)
                    return ''
                # fi
                nb = nb - 1
            elif c == '{':
                nc = nc + 1
            elif c == '}':
                if nc == 0:
                    print_error("too many right curly braces", line)
                    return ''
                # fi
                nc = nc - 1
            # fi
            l = l + 1
        # fi
    # elihw
    if np != 0:
        print_error("too many left (by {}) parenthesis".format(np), line)
        return ''
    # fi
    if nb != 0:
        print_error("too many left (by {}) brackets".format(nb), line)
        return ''
    # fi
    if nc != 0:
        print_error("too many left (by {}) curly braces".format(nc), line)
        return ''
    # fi
    if newstr is None:
        newline.append('')
    elif newstr != '':
        if integers:
            n, msg = is_float(newstr)
            if msg is not None or n is None:
                print_error("Range first number bad. {}".format(msg), line)
                return ''
            # fi
            n = int(n)
            newline.append(str(n))
        else:
            newline.append(newstr)
        # fi
    # elif not integers:
    #     newline.append(newstr)
    # fi

    return newline
# End of arglist

# ============================================================================
def parse_args():
    global args
    global pages_to_do
    global measures_to_do
    global voices_to_do

#--    def offset_value(v):
#--        if len(v) > 0:
#--            if v[0] == '=':
#--                v = v[1:]
#--            # fi
#--        # fi
#--        return v
#--    # End of offset_value

#--    for indx in range(len(sys.argv) - 1):
#--        if '--offset' in sys.argv[indx]:
#--            sys.argv[indx + 1] = '={0}'.format(sys.argv[indx + 1])
#--        # fi
#--    # rof
    parser = argparse.ArgumentParser(
        description=__doc__,
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog='this is the epilog')
    parser.add_argument('--vertical', '--vertica', '--vertic', '--verti', '--vert',
                        '--ver', '--ve', '--v', '-v',
                        action='store_true',
                        help = 'Vertical musicomp format output.')
    parser.add_argument('--horizontal', '--horizonta', '--horizont', '--horizon',
                        '--horizo', '--horiz', '--hori', '--hor', '--ho', '--h',
                        action='store_true',
                        help = 'Horizontal musicomp format output.')
    parser.add_argument('--midi1csv', '--midi1cs', '--midi1c', '--midi1', '--midi',
                        '--mid', '--mi', '--m', '--csv', '--cs', '--c', '-c', '-m', '-1',
                        action='store_true',
                        help = 'Output MIDI 1.0 music format output.')
    parser.add_argument('--abc', '-abc',
                        action='store_const', const=1, default=0,
                        help = 'ABC music format output - default.')
    parser.add_argument('--fluidsynth', '--fluidsynt', '--fluidsyn', '--fluidsy', '--fluids',
                        '--fluid', '--flui', '--flu', '--fl', '--f', '--fs',
                        '-fluidsynth', '-fluidsynt', '-fluidsyn', '-fluidsy', '-fluids',
                        '-fluid', '-flui', '-flu', '-fl', '-f', '-fs',
                        action='store_true',
                        help = 'Output fluidsynth music format output.')
    parser.add_argument('--nogoto', '--nogot', '--nogo', '--nog',
                        '-nogoto', '-nogot', '-nogo', '-nog',
                        action='store_true',
                        help = 'Do not parse goto commands, ignore them.')
    parser.add_argument('--noxpose', '--noxpos', '--noxpo', '--noxp', '--nox',
                        '-noxpose', '-noxpos', '-noxpo', '-noxp', '-nox',
                        action='store_true',
                        help = 'Do not parse xpose commands, ignore them.')
#--    parser.add_argument('--offset', default=0, action = 'store', type=offset_value,
#--                        help = 'Offset for midi instruments +1, -1, -12 -- because they CAN differ for playing.')
    parser.add_argument('--shift', type=float, default=0.0,
                        help = 'Shift all measures before printing (0.5 = 1/2 note to left/earlier measure).')
    parser.add_argument('--pages', '--page', '-pages', '-page',
                        default='', action = 'store',
                        help = 'Only parse page(s) specified. "1,2,5" or "1,2,5-8,114". (via cstart/cstop)')
    parser.add_argument('--measures', '--measure', '--measur', '--measu', '--meas', '--mea', '--me',
                        '-measures', '-measure', '-measur', '-measu', '-meas', '-mea', '-me',
                        default='', action = 'store',
                        help = 'Only parse measure(s) specified. "1,2,5" or "1,2,5-8,114a,115". (via cstart/cstop)')
    parser.add_argument('--voices', '--voice', '--voic', '--voi', '--vo',
                        '-voices', '-voice', '-voic', '-voi', '-vo',
                        default='', action = 'store',
                        help = 'Only print voice(s) specified. (parsing done) "1,2,5" or "1,2,5-8,15". (when writing output)')
    parser.add_argument('--wrongties', '--wrongtie', '--wrongti', '--wrongt', '--wrong', '--wron', '--wro', '--wr',
                        '-wrongties', '-wrongtie', '-wrongti', '-wrongt', '-wrong', '-wron', '-wro', '-wr',
                        default='', action = 'store_true',
                        help = 'When reading, ties for --vertical are on the latter note, move to front.')
    parser.add_argument('--nolegato', '--no-legato', action='store_true',
                        help = 'Do not do legatos.')
    parser.add_argument('--multiplemeasures', action='store_true',
                        help = 'If measure appears multiple times, do not fill in voices with rests.')
    parser.add_argument('--D', '-D', action='append', type=str,
                        help = 'Example: "-D WHICH=5" Define variable in calculator. (e.g. "if WHICH==5")')
    parser.add_argument('--two', '-two', '--2', '-2', action='store_true',
                        help = 'Use soundfont number 2.')
    parser.add_argument('--warn_octave_accidental', '-warn_octave_accidental', action='store_true',
                        help = 'Warn if accidental in other octave set/used.')
    parser.add_argument('--spaces', '-spaces', action='store_true',
                        help = 'Use spaces as note separators in addition to commas (input only, not printing vertical/horizontal).')
    parser.add_argument('--xpose', '-xpose',
                        default='', action='store',
                        help = 'Arguments to process as an xpose command before procssing first measure.')
    parser.add_argument('rest', nargs='*',
                        help='Optional command to execute')
    args = parser.parse_args()

#--    if args.offset is not None:
#--        args.offset = int(args.offset)
#--    # fi

    if args.pages is not None and args.pages != '':
        # global pages_to_do
        n = re.sub(r'\s*,\s*', ',', args.pages)
        n = re.sub(r'\s*,\s*', ',', n)
        pages_to_do = arglist(n, 'parsing --pages', True)
    # fi

    if args.measures is not None and args.measures != '':
        n = re.sub(r'\s*,\s*', ',', args.measures)
        n = re.sub(r'\s*,\s*', ',', n)
        measures_to_do = arglist(n, 'parsing --measures', True)
    # fi

    if args.voices is not None and args.voices != '':
        n = re.sub(r'\s*,\s*', ',', args.voices)
        n = re.sub(r'\s*,\s*', ',', n)
        voices_to_do = arglist(n, 'parsing --voices', True)
    # fi

    if args.rest is not None:
        for indx in range(len(args.rest)):
            if args.rest[indx][0] == '=':
                nexn_targv = args.rest[indx]
                if len(nexn_targv) > 0:
                    nexn_targv = nexn_targv[1:]
                # fi
                args.rest[indx] = nexn_targv
            # fi
        # rof
    # fi
    if args.vertical:
        if args.horizontal or args.abc == 1 or args.midi1csv or args.fluidsynth:
            print_error_no_line("Only may have one of --vertical, --horizontal, --abc, --midi1" or --fluidsynth)
            sys.exit(1)
        # fi
    elif args.horizontal:
        if args.abc == 1 or args.midi1csv or args.fluidsynth:
            print_error_no_line("Only may have one of --vertical, --horizontal, --abc, --midi1 or --fluidsynth")
            sys.exit(1)
        # fi
    elif args.midi1csv:
        if args.abc == 1 or args.fluidsynth:
            print_error_no_line("Only may have one of --vertical, --horizontal, --abc, --midi1 or --fluidsynth")
            sys.exit(1)
        # fi
    elif args.fluidsynth:
        if args.abc == 1:
            print_error_no_line("Only may have one of --vertical, --horizontal, --abc, --midi1 or --fluidsynth")
            sys.exit(1)
        # fi
#    else args.abc == 1:
#        print_error_no_line("Only may have one of --vertical, --horizontal, --abc, --midi1 or --fluidsynth")
#        sys.exit(1)
    # fi

    if args.D:
        errs = False
        for D in args.D:                    # If any defines, try to do them.
            sdefs = D.split('=')            # Quick check for assignment.
            if not sdefs or len(sdefs) < 2 or sdefs[0] == '' or sdefs[1] == '':
                print_error_no_line("Argument '-D {}' does not appear to be a variable assignment.".format(D))
                continue
            # fi
            sdef = sdefs[0].strip()
            calculate.variables[sdef] = 0   # pre-define to get rid of error message.
            f1, type_error = is_float(D)
            if type_error is not None or n is None:
                errs = True
                print_error_no_line("#1 Could not compute '-D {}' as a floating point number.".format(D))
                continue
            # fi
            if f1 is None:
                errs = True
                print_error_no_line("#2 Could not compute '-D {}' as a floating point number.".format(D))
                continue
            # fi
        # rof
        if errs:
            sys.exit(1)
        # fi
    return
# End of parse_args

# ----------------------------------------------------------------------------
def NOTDONEYET(string):
    print("NOTDONEYET -", string, file=sys.stderr, flush=True)
#   End of NOTDONEYET

# ----------------------------------------------------------------------------
def v_in(first,second,third):
    if second < first or second > third:
#--        print_debug("v_in - {}<={}<={} return False".format(first,second,third))
        return False
    # fi
#--    print_debug("v_in - {}<={}<={} return True".format(first,second,third))
    return True
#   End of v_in

# ----------------------------------------------------------------------------
# o70 = shift
# o76 = micro
# o7672 = <=
# o7672 = >=
# 07041 = _ (underscore)
# 07042 = ' (single quote)
# 07054 = != (not equal)
# 07056 = " (double quote)
# o61 = [
# 07661 = {
# o62 = ]
# 07662 = }
# o63 = %
# 077 = ;
# 07077 = :
# 07677 = ~
# o64 = x (multiply sign)
# ----------------------------------------------------------------------------
l_voice = 60                # max number of voices              -- NOTDONEYET - can get rid of?
# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
t_strng = 0                 # return character string
t_space = 1                 # string, but keep leading spaces
t_novar = 2                 # string, dont substitute char vars
t_cvnam = 3                 # return name of character variable
t_cvar  = 4                 # get character var (internal)
t_exp   = 5                 # return value of expression
t_nexp  = 6                 # numeric var argument (internal)
t_cexp  = 7                 # character var argument (internal)
t_cind  = 8                 # get char array indices (internal)
# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
# These are saved/restored in unit token
global n_ttype              # Type of token
n_ttype = t_strng
global n_tstart             # Stat of token/expression
n_tstart = 0
global n_targcnt            # Number of varable arguments (if array or not)
n_targcnt = 0
global n_tparen             # Parenthesis level
n_tparen = 0
global n_targ               # Arguments (1 and 2) for array.
n_targ = [-1,-1]
global n_tvarptr            # Start of variable (?)
n_tvarptr = 0
global n_vname
n_vname = None
global n_wary
n_wary = None
global n_vdimen             # Array dimension.
n_vdimen = 0
global n_vsize1             # size of dimension 1 of array
n_vsize1 = 0
global n_vsize2             # size of dimension 2 of array
n_vsize2 = 0
global n_vlen               # length in chars -- NOTDELETEDYET
n_vlen = 0
# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
global n_char
n_char = ''                 # Line buffer.

global n_tlength
n_tlength = 0               # Length of token in characters.
global n_token
n_token = None                # Token.

global n_macnum
n_macnum = 0                # Macro currently being compiled, 0 if compiling source.
global n_pnt
n_pnt = -1                  # Pointer to character after delimiter.
global n_lchars
n_lchars = 0                # length of line in characters.
global n_lastend
n_lastend = ''              # Ending delimiter (0 if end of line).
global n_inloop
n_inloop = 0                # loop depth in this macro
global n_inif
n_inif = 0                  # if depth in this macro
global n_loopind
n_loopind = 0               # Pointer to loop index variable (-1 if nothing - change to None)
global n_loopinc
n_loopinc = 0               # loop increment
global n_loopend
n_loopend = 0               # final loop value

global n_maclev             # macro nesting level
n_maclev = 0


# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
global n_macname
n_macname = { }             # Indexed by macro name.
                            # 1) [macro text]
                            # Entry is array:
                            # 2) [{argument name, initial delimiter, final delimiter},
                            #     {argument name, xxxxxxxxxxxxxxxxx, final delimiter}, ... ]
global n_mdelim0
n_mdelim0 = []              # Delimiter for macro indexed by number.
# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
global n_cvdef              # Character variables defined.
n_cvdef = [ ]               # Array of w_array above.
# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

global n_br
n_br = 0                    # branch return from nm_numtoken ... starts as zero.

global n_result             # Global result.
n_result = 0

# stfson has count of entries in n_staffon(x) table; this
# is count of how many staves these notes are for (usually1)
global n_stfson
n_stfson = 0                # Number of staves. (No staff yet.)

global p_formok             # Indicates if an error occurs in expression.
p_formok = -1               # -1 if okay.  >= 0 if problem.

global n_notes
n_notes = 0
global n_lnotes
n_lnotes = 0
global n_inmacro
n_inmacro = 0               # not in a macro definition
global n_inproc
n_inproc = 0                # not in a process: =1 if in a process, 0 not
global n_nokey
n_nokey = 0
global n_nextwrd
n_nextwrd = 0               # first word in source
global n_getime
n_getime = 0                # for -tempo-, etc commands: set if getting time lth
global n_minlen
n_minlen = 0
global n_incres
n_incres = 0
#-- global n_nvwrds
#-- n_nvwrds = 0                # no numeric vars yet
#-- global n_cvwrds
#-- n_cvwrds = 0                # no character vars yet

# ----------------------------------------------------------------------------
n_vmf = 50
# ----------------------------------------------------------------------------
global n_lastlen
n_lastlen = [ 4 ] * l_voice # default note parameters
global n_lastoct
n_lastoct = 4
global n_lastdot
n_lastdot = 0
global n_lltype             # type of note length
n_lltype = 1
global n_ltype              # type of note length
n_ltype = 1
global n_vol
n_vol = [ n_vmf ] * l_voice # default volume is vmf
global n_voln
n_voln = [ 5 ] * l_voice    # default vol name = vmf
global n_notex
n_notex = [ 0 ] * l_voice   # transcribe notenames
global n_octavex
n_octavex = [ 0 ] * l_voice # transcribe octaves
global n_svinc
n_svinc = 0
global n_span
n_span = 0
global n_pan
n_pan = 0
global n_stemdir
n_stemdir = 0
global n_gliss
n_gliss = 0
global n_process
n_process = [ 0 ] * l_voice # no processes active
global n_sins
n_sins = 0
global n_ingliss
n_ingliss = 0
global n_stfprn
n_stfprn = [ 0 ] * l_voice  # no print commands yet
global n_stfflg
n_stfflg = [ 0 ] * l_voice  # no printed staves yet
# ----------------------------------------------------------------------------
global n_notenam
n_notenam = 0               # note name 0-6
global n_notelen
n_notelen = 0               # note length (4=quarter)
global n_mslur
n_mslur = 0                 # = 1 if slur note modifier
global n_mstac
n_mstac = 0                 # = 1 if staccato note
global n_mtied
n_mtied = 0                 # = 1 if tied note modifier
global n_mmarc
n_mmarc = 0                 # = 1 if marcato note
global n_mleg
n_mleg = 0                  # = 1 if legato note
global n_volume
n_volume = 0                # volume value
global n_dotted
n_dotted = 0                # number of dots on nte
global n_vinc
n_vinc = 0                  # set if cresc/decresc
global n_sharp
n_sharp = 0                 # count of sharps on note
global n_flat
n_flat = 0                  # count of flats on note
global n_nat
n_nat = 0                   # count of naturals on note
global n_acclnow
n_acclnow = 0               # -1 id now in accelerando
global n_ptype
n_ptype = 0                 # type of pitch for note
global n_notenum
n_notenum = 0               # mod12 note number (4c=48)
global n_ntime
n_ntime = 0                 # duration (frac wholes)
global n_octave
n_octave = 0                # octave for note
global n_part
n_part = 0                  # part of note on
global n_simile
n_simile = 0                # != -1 if simile token
global n_ch
n_ch = 0                    # character count
global n_bracket
n_bracket = 0               # 1 if [, -1 if ], 0 none
# ----------------------------------------------------------------------------
global n_tempoc                   # Flag for making sure notes since last tempo command.
n_tempoc = 0
global n_acct
n_acct = 0
global n_volname
n_volname = 0
global n_pos
n_pos = 0
global n_temp
n_temp = 0
global inschk
inschk = 0
#=============================================================================
global nm_note_to_number
nm_note_to_number = { 'c':0, 'd':1, 'e':2, 'f':3, 'g':4, 'a':5, 'b':6}
#=============================================================================
global stack_token
stack_token = []
global stack_tinfo
stack_tinfo = []
global stack_mvars
stack_mvars = []
global stack_line
stack_line = []

# which_stack   = 0     # for token for length l_token.
# which_stack   = 1     # for tinfo for length l_tinfo.
# which_stack   = 2     # for mvars for length l_mvars.
# which_stack   = 3     # for line for length l_words.

def save_stack(which_stack):
    global stack_token
    global stack_tinfo
    global stack_mvars
    global stack_line
    # . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
    # token
    global n_tlength
    global n_token
    # . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
    # tinfo
    global n_ttype
    global n_tstart
    global n_tparen
    global n_targcnt
    global n_targ
    global n_tvarptr
    global n_vname
    global n_wary
    global n_vdimen
    global n_vsize1
    global n_vsize2
    global n_vlen
    # . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
    # mvars
    global n_macnum
    global n_pnt
    global n_lchars
    global n_lastend
    global n_inloop
    global n_inif
    global n_loopind
    global n_loopinc
    global n_loopend
    # . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
    # line
    global n_char

    if which_stack == 0:        # token
        wpush = [ n_tlength, n_token ]
        stack_token.append(wpush)
    elif which_stack == 1:      # tinfo
        wpush = [ n_ttype, n_tstart, n_tparen, n_targcnt, n_wary, n_targ, n_tvarptr, n_vname,
                  n_vdimen, n_vsize1, n_vsize2, n_vlen ]
        stack_tinfo.append(wpush)
    elif which_stack == 2:      # mvars
        wpush = [ n_macnum, n_pnt, n_lchars, n_lastend, n_inloop, n_inif, n_loopind, n_loopinc, n_loopend ]
        stack_mvars.append(wpush)
    else:          # == 3       # line
        wpush = n_char
        stack_line.append(wpush)
    # fi
    return
#   End of save_stack

# ----------------------------------------------------------------------------
def restore_stack(which_stack):
    global stack_token
    global stack_tinfo
    global stack_mvars
    global stack_line
    # . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
    # token
    global n_tlength
    global n_token
    # . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
    # tinfo
    global n_ttype
    global n_tstart
    global n_tparen
    global n_targcnt
    global n_targ
    global n_tvarptr
    global n_vname
    global n_wary
    global n_vdimen
    global n_vsize1
    global n_vsize2
    global n_vlen
    # . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
    # mvars
    global n_macnum
    global n_pnt
    global n_lchars
    global n_lastend
    global n_inloop
    global n_inif
    global n_loopind
    global n_loopinc
    global n_loopend
    # . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
    # line
    global n_char

    if which_stack == 0:        # token
        wpush = stack_token.pop()
        [ n_tlength, n_token ] = wpush
    elif which_stack == 1:      # tinfo
        wpush = stack_tinfo.pop()
        [ n_ttype, n_tstart, n_tparen, n_targcnt, n_wary, n_targ, n_tvarptr, n_vname,
                  n_vdimen, n_vsize1, n_vsize2, n_vlen ] = wpush
    elif which_stack == 2:      # mvars
        wpush = stack_mvars.pop()
        [ n_macnum, n_pnt, n_lchars, n_lastend, n_inloop, n_inif, n_loopind, n_loopinc, n_loopend ] = wpush
    else:          # == 3       # line
        wpush = stack_line.pop()
        n_char = wpush
    # fi
    return
#   End of restore_stack

#=============================================================================
# NOTE: assignment character processing. comment ASSIGNMENT
# NOTE: 0 indexing verses 1 indexing in arrays.
# ----------------------------------------------------------------------------
# global n_pnt   Starting character in line. If -1, start new line.
#                Defaults to character after previous token.
# Entry:
#   ARGttype -- Type of token desired:
#     t_strng  0 = character string (ignore leading spaces).
#     t_space  1 = character string (dont ignore leading spaces or extra
#                  trailing spaces).
#     t_novar  2 = String, don't substitute character variables.
#     t_cvnam  3 = name of charadcter variable.
#     t_cvar   4 = Get character variable (internal).
#     t_exp    5 = Return value of expression.
#     t_nexp   6 = Numeric variable argument (internal).
#     t_cexp   7 = Character variable argument (internal).
#     t_ind    8 = Get Character array indices (internal).
#   pnt   -- Starting character in line.  If -1, start new line.  Defaults to
#              character after previous token.
#   endch -- Ending delimiter. For character string type: Stops at "endch" or
#              end of line. If not specified, stops at any delimiter - except
#              plus (+) and minus (-). The only non-delimiters are a-z and 0-9.
#              For expression type: Stops at end of line, or "endch", comma,
#              or semicolon if not inside parentheses.
# Exit:
#   If token type was expression, its value is returned.
#   n_token   -- Character string for token.
#   n_tlength -- Length of n_token in characters.
#   n_lastend -- Ending delimiter (0 if end of line).
#   n_pnt     -- Pointer to character after delimiter.

def nm_get_token(ARGttype, ARGpnt, endch):
    global n_token
    global n_tlength
    global n_lastend
    global n_pnt
    global n_tparen
    global n_br
    global n_tvarptr
    global n_char
    global n_macnum
    global n_tstart
    global n_targcnt
    global n_targ
    global n_vdimen
    global n_ttype
    global n_lchars

    n_ttype = ARGttype              # set global n_ttype variable
    n_pnt = ARGpnt                  # set global n_pnt variable.
    print_debug("nm_get_token - Entering ({},{},{})".format(n_ttype, n_pnt, endch))
    n_tparen = 0
    n_tlength = 0
    n_token = None

    if n_pnt == -1:
        if n_macnum == 0:
            n_char, commentdollardollar = getline(True)     # Ignore $$ comments
            n_lchars = len(n_char)
        else:
            if nm_nextmacr() is None:
                print_debug("nm_get_token - #1 return None")
                return None
            # fi
        # fi
        print_debug("nm_get_token n_char='{}' ({} chars) commentdollardollar={}".format(n_char, n_lchars, commentdollardollar))
        n_pnt = 0                 # zero based index
    # fi
    print_debug("nm_get_token #1 n_pnt={}".format(n_pnt))
    if n_ttype != t_space:
        while n_pnt < len(n_char) and n_char[n_pnt] == ' ':
            n_pnt = n_pnt + 1
        # elihw
    # fi
    n_tstart = n_pnt

    # Main loop.
    # Find next token. If getting a character variable name, find a sequence of
    # capital letters. Otherwise, find a sequence of lower case letters or digits.

    while True:
        n_tvarptr = n_pnt
        print_debug("nm_get_token #2a n_pnt={}".format(n_pnt))
        # Must start with a character.
        if n_pnt < len(n_char) and n_char[n_pnt].isalpha():
            while n_pnt < len(n_char) and n_char[n_pnt].isalpha():
                n_pnt = n_pnt + 1
            # elihw
        # fi
        # Allow name to have numbers after it (and more alpha-numeric).
        if n_pnt < len(n_char) and (n_char[n_pnt].isalpha() or n_char[n_pnt].isnumeric()):
            while n_pnt < len(n_char) and (n_char[n_pnt].isalpha() or n_char[n_pnt].isnumeric()):
                n_pnt = n_pnt + 1
            # elihw
        # fi
        dpnt = n_pnt
        # If delimiter is a comma, semicolon, or assignment arrow, skip any spaces before it.
        if n_pnt < len(n_char) and n_char[n_pnt] == " " and n_ttype != t_space:
            while n_pnt < len(n_char) and n_char[n_pnt] == " ":
                n_pnt = n_pnt + 1
                print_debug("nm_get_token #D n_pnt={}".format(n_pnt))
            # elihw
            print_debug("nm_get_token #3 n_pnt={} dpnt={}".format(n_pnt, dpnt))
    # NOTDONEYET ASSIGNMENT
            # elihw
            print_debug("nm_get_token #E n_pnt={}".format(n_pnt))
            if n_pnt < len(n_char) and n_char[n_pnt] != "," and n_char[n_pnt] != ";" and n_char[n_pnt] != "=":   # ASSIGNMENT
                n_pnt = n_pnt - 1                   # Move back to one before the space - to have delimitor?
            # fi
            print_debug("nm_get_token #F n_pnt={}".format(n_pnt))
        # fi

        # Assemble character codes for the ending delimiter.
        print_debug("nm_get_token #4 n_pnt={} len(n_char)={} n_char='{}'".format(n_pnt,len(n_char), n_char))
        if n_pnt < len(n_char):
            delim = n_char[n_pnt]
            n_pnt = n_pnt + 1
        else:
            delim = 0
        # fi
        print_debug("nm_get_token - #1 delim='{}'".format(delim))
        print_debug("nm_get_token #5 n_pnt={} dpnt={} delim='{}'".format(n_pnt,dpnt,delim))

        # Start of character variable. Save state and get its name.
        print_debug("nm_get_token #6 n_pnt={} dpnt={} delim='{}' n_ttype={}".format(n_pnt, dpnt, delim,n_ttype))
        print_debug("nm_get_token - type(delim)={} delim='{}' n_ttype={}".format(type(delim), delim,n_ttype))
        if type(delim) is str and delim.isalpha() and n_ttype != t_novar:
            print_debug("nm_get_token - call save_stack(1)")
            save_stack(1)           # which_stack   = 1     # for tinfo for length l_tinfo.
            n_ttype = t_cvar
            n_pnt = dpnt
            continue
        # Found name of character variable. Return it.
        elif n_ttype == t_cvnam:
            print_debug("nm_get_token - n_ttype is t_cvnam, break: n_pnt={} dpnt={} delim='{}' n_ttype={}".format(n_pnt, dpnt, delim,n_ttype))
            break
        # End of character variable. Look up in symbol table.
        elif n_ttype == t_cvar:
            print_debug("nm_get_token#a - calling nm_findcvar, n_ttype is t_cvar: n_pnt={} dpnt={} delim='{}' n_ttype={}".format(n_pnt, dpnt, delim, n_ttype))
            vlth, value = nm_findcvar(n_tvarptr, dpnt - n_tvarptr, -1, -1)
            # Not found in symbol table. Continue after the first capital character (in case 2nd
            # character starts a variable name). Append the character to the n_token buffer.
            if n_wary is None:
                n_pnt = n_tvarptr + 2
                print_debug("nm_get_token - call restore_stack(1)")
                restore_stack(1)            # which_stack   = 1     # for tinfo for length l_tinfo.
                if nm_addtoken(n_tvarptr, 2) is None:
                    print_debug("nm_get_token - #2 return None")
                    return None
                # fi
                continue
            # Found a character variable array. Save state and get expression for the indices.
            elif n_tvarptr + vlth == dpnt and n_vdimen > 0:
                if delim != "(":
                    print_error_no_line("bad dimension, delim != ( n_vdimen={}".format(n_vdimen))
                    print_debug("nm_get_token - #3 return None")
                    return None
                # fi
                n_targcnt = 0
                n_targ = [-1, -1]
                print_debug("nm_get_token - call save_stack(0)")
                save_stack(0)               # which_stack   = 0     # for token for length l_token.
                print_debug("nm_get_token - call save_stack(1)")
                save_stack(1)               # which_stack   = 1     # for tinfo for length l_tinfo.
                n_ttype = t_cind
                n_tstart = n_pnt
                n_tparen = n_tlength = 0
                continue
            # Found a character variable with arguments. Save state and get expression for arguments.
            elif delim == "{" and n_tvarptr + vlth == dpnt:
                n_targcnt = 0
                n_targ = [-1, -1]
                print_debug("nm_get_token - call save_stack(0)")
                save_stack(0)               # which_stack   = 0     # for token for length l_token.
                print_debug("nm_get_token - call save_stack(1)")
                save_stack(1)               # which_stack   = 1     # for tinfo for length l_tinfo.
                n_ttype = t_cexp
                n_tstart = n_pnt
                n_tparen = n_tlength = 0
                continue
            # Found a character variable without arguments. Substitute its value and continue processing the value.
            else:
                if nm_subcvar(n_tvarptr, vlth, 0, 0, 0) is None:
                    print_debug("nm_get_token - #4 return None")
                    return None
                # fi
                n_pnt = n_tvarptr
                print_debug("nm_get_token - call save_stack(1)")
                restore_stack(1)            # which_stack   = 1     # for tinfo for length l_tinfo.
                continue
            # fi
        # Check if this token is a numeric variable in an expression.
        elif v_in(t_exp, n_ttype, t_cind):
            print_debug("nm_get_token v_in(t_exp, n_ttype, t_cind)... ({},{},{})".format(t_exp, n_ttype, t_cind))
            vlth = None
            otype = None
            oparen = None
            value = None
            print_debug("nm_get_token calling nm_numtoken endch={} n_pnt={} dpnt={} vlth={} delim='{}' otype={} oparen={} value={}".format(endch, n_pnt, dpnt, vlth, delim, otype, oparen, value))

            n_br, endch, dpnt, vlth, delim, otype, oparen, value = nm_numtoken(endch, dpnt, vlth, delim, otype, oparen, value)

            print_debug("nm_get_token after nm_numtoken n_br={} endch={} n_pnt={} dpnt={} vlth={} delim='{}' otype={} oparen={} value={}".format(n_br, endch, n_pnt, dpnt, vlth, delim, otype, oparen, value))
            if n_br is None:
                print_debug("nm_get_token - #5 return None")
                return None
            elif n_br == -1:
                continue
            # fi
            break   # 1done
        # Get more of string if there is any. If not, return it in "n_token" and its length in "n_tlength".
        elif n_ttype == t_strng or n_ttype == t_space or n_ttype == t_novar:
            if endch == -1:
                if delim == "+" or delim == "-":
                    continue
                # fi
                break   # 1done
            else:
                if delim == endch or delim == 0:
                    break
                # fi
                continue
            # fi
        # fi
    # elihw - whole entry token2 (which is 1token)
    #
    # All done, return string in "n_token", "n_tlength", and "n_lastend". Return "value" if expression.
    #
    n_tlength = dpnt - n_tstart
    n_lastend = delim
    print_debug("nm_get_token - #10 n_lastend='{}'".format(n_lastend))
    print_debug("nm_get_token #7f n_tstart={} n_tlength='{}' n_char='{}'".format(n_tstart,n_tlength,n_char))
    n_token = n_char[n_tstart:n_tstart + n_tlength]
    if n_ttype == t_exp:
        print_debug("nm_get_token - #6 return value={}".format(value))
        return value
    # fi
    print_debug("nm_get_token #8 n_tlength={} n_lastend='{}' n_token='{}' n_char='{}'".format(n_tlength,n_lastend,n_token,n_char))
    print_debug("nm_get_token - #7 return True - n_token='{}'".format(n_token))
    return True
#   End of nm_get_token

#=============================================================================
# Check if this token is a numeric variable in an expression. This routine is
# called as a major subroutine of token. The variables n_ttype, and n_pnt are
# globals and are already set.

# endch           # ending delimiter (-1 if any)
# dpnt            # points to 1st character of delimiter
# vlth            # length of substituted variable
# delim           # current delimiter
# otype           # temporary token type
# oparen          # temporary paren level
#-- NOTE: none of these are globals.
# Returns:
#       -1 if branch to 1token in unit token2 is desired
#        0 if branch to 1done in unit token2 is desired
#       PLUS the same variables passed in the same order!

def nm_numtoken(endch, dpnt, vlth, delim, otype, oparen, value):
    # floating: value # expression value

    global n_tvarptr
    global n_wary
    global n_char
    global n_tlength
    global n_pnt
    global n_tstart
    global n_tparen
    global n_targ
    global n_targcnt
    global n_vdimen
    global n_ttype
    global n_token
    global n_char

    print_debug("nm_numtoken Entering: endch={} n_pnt={} dpnt={} vlth={} delim='{}' otype={} oparen={} value={}".format(endch, n_pnt, dpnt, vlth, delim, otype, oparen, value))
    print_debug("nm_numtoken n_pnt={} dpnt={} n_tvarptr={}".format(n_pnt, dpnt, n_tvarptr))
    if n_tvarptr < len(n_char):
        print_debug("nm_numtoken n_char[n_tvarptr]={}".format(n_char[n_tvarptr]))
    # fi
    n_wary = None
    if dpnt > n_tvarptr and n_char[n_tvarptr].isalpha():
        print_debug("nm_numtoken - calling nm_findnvar({},{})".format(n_tvarptr, dpnt - n_tvarptr))
        n_wary = nm_findnvar(n_tvarptr, dpnt - n_tvarptr,True)
        print_debug("nm_numtoken after nm_findnvar... n_wary={}".format(n_wary))
    # fi
    print_debug("nm_numtoken n_pnt={} dpnt={} n_tvarptr={} n_vdimen={}".format(n_pnt, dpnt, n_tvarptr, n_vdimen))
    # Found an array element. Save state and get the expressions for the arguments.
    if n_wary is not None and n_vdimen > 0:                  # findnvar found - and dimensions on it.
#--        NOTDONEYET('nm_numtoken - goto delim == "(", x, er("baddimen", n_vdimen, 0)')
        print_debug("nm_numtoken n_vdimen > 0 n_wary={}".format(n_wary))
        if delim != "(":
            print_error_no_line("bad dimension, n_vdimen={}, delim != '('".format(n_vdimen,delim))
            return None, endch, dpnt, vlth, delim, otype, oparen, value
        # fi
        n_targcnt = 0
        n_targ = [-1, -1]
        print_debug("nm_get_token - call save_stack(0)")
        save_stack(0)               # which_stack   = 0     # for token for length l_token.
        print_debug("nm_get_token - call save_stack(1)")
        save_stack(1)               # which_stack   = 1     # for tinfo for length l_tinfo.
        n_ttype = t_nexp
        n_tstart = n_pnt
        n_tparen = n_tlength = 0
    # Return to start of token loop.
        print_debug("nm_numtoken #6 return -1 endch={} dpnt={} vlth={} delim='{}' otype={} oparen={} value={}".format(endch, dpnt, vlth, delim, otype, oparen, value))
        return -1, endch, dpnt, vlth, delim, otype, oparen, value
    # Found a single numerical variable. Add its "zvar(X)" name to the expression being formed in "n_token".
    # findnvar found.
    elif n_wary is not None and n_wary[numarry_values] is not None:
        print_debug("nm_numtoken n_wary is not None, n_wary={}".format(n_wary))
        print_debug("nm_numtoken n_wary[numarry_values]={} is not None".format(n_wary[numarry_values]))
        if n_wary[numarry_value_type] == 0:       # This variable is a number.
            print_debug("nm_numtoken type(n_wary[numarry_values][0])={} is not str".format(type(n_wary[numarry_values][0])))
            if nm_subnvar(n_wary, 0, 0, 0) is None:
                print_debug("nm_numtoken #7 return None endch={} dpnt={} vlth={} delim='{}' otype={} oparen={} value={}".format(endch, dpnt, vlth, delim, otype, oparen, value))
                return None, endch, dpnt, vlth, delim, otype, oparen, value
            # fi
        else:
            print_debug("nm_numtoken n_wary value is str, n_wary={}".format(n_wary))
            print_debug("nm_numtoken n_token='{}' n_char='{}'".format(n_token, n_char))
#--            if nm_addtoken(n_tvarptr, dpnt - n_tvarptr) is None:
            stw = n_wary[numarry_values][0]
            print_debug("nm_numtoken stw='{}' len(stw)='{}'".format(stw, len(stw)))
            if nm_addtoken(stw, len(stw)) is None:
                print_debug("ERROR from nm_addtoken")
                return None, endch, dpnt, vlth, delim, otype, oparen, value
            # fi
            print_debug("nm_numtoken n_token='{}' n_char='{}'".format(n_token, n_char))
        # fi
    # Symbol is not a numeric variable. Add it to the expression unchanged.
    else:
        print_debug("nm_numtoken n_wary is None, n_wary={}".format(n_wary))
        print_debug("nm_numtoken n_pnt={} dpnt={} n_tvarptr={} n_vdimen={}".format(n_pnt, dpnt, n_tvarptr, n_vdimen))
        print_debug("nm_numtoken n_token='{}' n_char='{}'".format(n_token, n_char))
        if nm_addtoken(n_tvarptr, dpnt - n_tvarptr) is None:
            print_debug("nm_numtoken #8 return None endch={} dpnt={} vlth={} delim='{}' otype={} oparen={} value={}".format(endch, dpnt, vlth, delim, otype, oparen, value))
            return None, endch, dpnt, vlth, delim, otype, oparen, value
        # fi
    # fi

    print_debug("nm_numtoken #9 n_token='{}' endch={} n_pnt={} dpnt={} vlth={} delim='{}' otype={} oparen={} value={}".format(n_token, endch, n_pnt, dpnt, vlth, delim, otype, oparen, value))

    # Count parenthesis level in expression.
    if delim == "(" or delim == "{":
        print_debug("nm_numtoken #9a left parenthesis or brace")
        n_tparen = n_tparen + 1
    elif delim == ")" or delim == "}": # or delim == "]"
        print_debug("nm_numtoken #9b left parenthesis or brace")
        n_tparen = n_tparen - 1
    # fi
    # End of subexpression. Evaluate it.

    if delim == 0 or n_tparen < 0 or (n_tparen == 0 and (delim == "," or delim == ";" or delim == endch)):
        print_debug("nm_numtoken #9c delim='{}' n_tparen={}".format(delim,n_tparen))
        value = nm_eval(n_tstart, dpnt - n_tstart)
        if value is None:
            print_debug("nm_numtoken #10 return None endch={} dpnt={} vlth={} delim='{}' otype={} oparen={} value={}".format(endch, dpnt, vlth, delim, otype, oparen, value))
            return None, endch, dpnt, vlth, delim, otype, oparen, value
        # fi
        print_debug("nm_numtoken #9c1 n_ttype='{}'".format(n_ttype))
    # End of expression. Return its value.
        if n_ttype == t_exp:
    # Exit token loop.
            print_debug("nm_numtoken #11 return 0 endch={} dpnt={} vlth={} delim='{}' otype={} oparen={} value={}".format(endch, dpnt, vlth, delim, otype, oparen, value))
            return 0, endch, dpnt, vlth, delim, otype, oparen, value
        # fi
    # Have an argument for a variable. Store it.
        otype = n_ttype
        oparen = n_tparen
        print_debug("nm_get_token - call save_stack(1)")
        save_stack(1)               # which_stack   = 1     # for tinfo for length l_tinfo.
        if n_targcnt == 2:
            print_error_no_line('too many args, n_targcnt==2')
            return None, endch, dpnt, vlth, delim, otype, oparen, value
        # fi
        n_targ[n_targcnt] = value
        n_targcnt = n_targcnt + 1
        print_debug("nm_numtoken #9c2 n_targcnt='{}' n_targ={}".format(n_ttype, n_targ))
    # If more arguments, get next one.
        if oparen == 0:
            print_debug("nm_get_token - call save_stack(1)")
            save_stack(1)               # which_stack   = 1     # for tinfo for length l_tinfo.
            n_ttype = otype
            n_tparen = 0
            n_tstart = n_pnt
            n_tlength = 0
    # Return to start of token loop.
            print_debug("nm_numtoken #12 return -1 endch={} dpnt={} vlth={} delim='{}' otype={} oparen={} value={}".format(endch, dpnt, vlth, delim, otype, oparen, value))
            return -1, endch, dpnt, vlth, delim, otype, oparen, value
        # fi
    # Have all arguments for a variable. Substitute its value.
        print_debug("nm_numtoken #12c n_token={}".format(n_token))
        print_debug("nm_get_token - call restore_stack(0)")
        restore_stack(0)                # which_stack   = 0     # for token for length l_token.
    # Character variable array element indices.
        if otype == t_cind:
            if n_targcnt != 2:
                n_targ[n_targcnt] = 1
            # fi
#--            NOTDONEYET("nm_numtoken - goto n_targ[0] < 1 or n_targ[1] < 1, er('cnofind', n_targ[0], n_targ[1]), x")
            if n_targ[0] < 1 or n_targ[1] < 1:
                print_error_no_line('cannot be found n_targ[0]={} n_targ[1]={}'.format(n_targ[0], n_targ[1]))
                return None, endch, dpnt, vlth, delim, otype, oparen, value
            # fi
            print_debug("nm_get_token#b - calling nm_findcvar")
            vlth, value = nm_findcvar(n_tvarptr, dpnt - n_tvarptr, n_targ[0], n_targ[1])
    # If there is no arguments (not indices) to this character var
    # array element, then substitute the value.
    # (This is checked by seeing if the next character after
    # the delimeter is "{".)
            if n_char[dpnt + 1] != o76 or n_char[dpnt + 2] != o61:
                if nm_subcvar(n_tvarptr, n_pnt - n_tvarptr, 0, 0, 0) is None:
                    print_debug("nm_numtoken #13 return None")
                    return None, endch, dpnt, vlth, delim, otype, oparen, value
                # fi
                print_debug("nm_get_token - call restore_stack(1)")
                restore_stack(1)            # which_stack   = 1     # for tinfo for length l_tinfo.
                n_pnt = n_tvarptr
    # If there are arguments to this character var array element,
    # evaluate the arguments.
            else:
                n_targcnt = 0
                n_targ = [-1, -1]
                print_debug("nm_get_token - call save_stack(0)")
                save_stack(0)               # which_stack   = 0     # for token for length l_token.
                print_debug("nm_get_token - call save_stack(1)")
                save_stack(1)               # which_stack   = 1     # for tinfo for length l_tinfo.
                n_ttype = t_cexp
                n_pnt = dpnt + 3     # skip {
                n_tstart = n_pnt
                n_tparen = n_tlength = 0
            # fi
        elif otype == t_cexp:
            chk = nm_subcvar(n_tvarptr, n_pnt - n_tvarptr, n_targcnt, n_targ[0], n_targ[1])
            print_debug("nm_get_token - call restore_stack(1)")
            restore_stack(1)            # which_stack   = 1     # for tinfo for length l_tinfo.
            n_pnt = n_tvarptr
        else:
            print_debug("nm_numtoken n_token={} n_tvarptr={} n_targcnt={} n_targ[0]={} n_targ[1]={}".format(n_token, n_tvarptr, n_targcnt, n_targ[0], n_targ[1]))
            print_debug("nm_numtoken stack_token={}".format(stack_token))
            print_debug("nm_numtoken stack_tinfo={}".format(stack_tinfo))
            print_debug("nm_numtoken stack_mvars={}".format(stack_mvars))
            print_debug("nm_numtoken stack_line={}".format(stack_line))
            if nm_subnvar(n_tvarptr, n_targcnt, n_targ[0], n_targ[1]) is None:   # wary for variable.
                print_debug("nm_numtoken #14 return None")
                return None, endch, dpnt, vlth, delim, otype, oparen, value
            # fi
        # fi
    # Return to start of token loop.
        print_debug("nm_numtoken #15 return -1 endch={} dpnt={} vlth={} delim='{}' otype={} oparen={} value={}".format(endch, dpnt, vlth, delim, otype, oparen, value))
        return -1, endch, dpnt, vlth, delim, otype, oparen, value
    # Not end of expression. Add delimiter to the expression being formed in n_token.
    else:
        print_debug("nm_numtoken #9d dpnt={} n_pnt={}".format(dpnt,n_pnt))
        if nm_addtoken(dpnt, n_pnt - dpnt) is None:
            print_debug("nm_numtoken #16 return None")
            return None, endch, dpnt, vlth, delim, otype, oparen, value
        # fi
    # fi
    # Return to start of token loop.
    print_debug("nm_numtoken #17 return -1 endch={} dpnt={} vlth={} delim='{}' otype={} oparen={} value={}".format(endch, dpnt, vlth, delim, otype, oparen, value))
    return -1, endch, dpnt, vlth, delim, otype, oparen, value
#   End of nm_numtoken

#=============================================================================
# Subroutine to nm_get_token. Add the string to the end of the n_token buffer.
# String is in the line buffer with pointer and length as passed.
# strptr          # pointer to string
# strlen          # length of string
# Returns: None if error occurred.

def nm_addtoken(strptr, strlen):

    global n_tlength
    global n_token
    global n_char

#--    print_debug("nm_addtoken - Entering: strptr={} strlen={}".format(strptr,strlen))
#--    print_debug("nm_addtoken - n_token='{}' strptr={} + strlen={}".format(n_token, strptr, strlen))
    if n_tlength == 0:
        n_token = None
    # fi
    if n_token is None:
        n_token = n_char[strptr:strptr+strlen]
    else:
        n_token = n_token + n_char[strptr:strptr+strlen]
    # fi
    n_tlength = n_tlength + strlen
#--    print_debug("nm_addtoken - now n_token='{}' and n_tlength={}".format(n_token, n_tlength))
#--    print_debug("nm_addtoken exiting")
    return True                                 # Things are okay
#   End of nm_addtoken

#=============================================================================
# Check if the symbol starting at "start" for "lth" chars is the name of a
# numeric variable. If so, return its name in "vchar" and its information in
# "n_wary".
# start           # pointer to symbol
# lth             # symbol length in chars
# Returns:
#   None if no name. And n_wary is None.
#   w_array if found.

def nm_findnvar(start, lth, CandN):
    global n_maclev
    global n_char
    global n_cvdef
    global n_vname

    print_debug("nm_findnvar - Entering start={} lth={}".format(start,lth))
    n_wary = None                  # flag symbol not found.
    n_vname = ''
    # Get the symbol name.
    print_debug("nm_findnvar n_char='{}' start={} lth={} n_char[..]='{}'".format(n_char,start,lth, n_char[start:start+lth]))
    n_vname = n_char[start:start+lth]
    print_debug("nm_findnvar n_vname='{}'".format(n_vname))
    # Find the symbol with the same name and closest macro to current macro level.
    i = n_maclev
    while i >= 0:
        print_debug("nm_findnvar - n_vname={} i={} n_cvdef={}".format(n_vname,i,n_cvdef))
        for v in n_cvdef:
            print_debug("nm_findnvar - v={}".format(v))
#--            if v[0] == n_vname and v[numarry_maclevel] == i and v[numarry_dimensions] == 0:
            if v[0] == n_vname and v[numarry_maclevel] == i and (v[numarry_value_type] == 0 or CandN):
                # matches!
                print_debug("nm_findnvar - matches v[numarry_values]={} v[numarry_maclevel]={}".format(v[numarry_values], v[numarry_maclevel]))
                print_debug("nm_findnvar - v[numarry_indexes]={}".format(v[numarry_indexes]))
                print_debug("nm_findnvar - v[numarry_values]={}".format(v[numarry_values]))
                print_debug("nm_findnvar - v[numarry_value_type]={}".format(v[numarry_value_type]))
                n_wary = v
                return v                            # Return its information.
            # fi
        # rof
        i = i - 1
    # elihw
    return None
#   End of nm_findnvar

#=============================================================================
# Check if the symbol starting at "start" for "lth" char codes is the name of
# a character variable. Put name in "vchar". Return its length in chars, and
# symbol table entry. If not found, set "n_wary" to None, and return None.
#
# If arg1 == arg2 == -1, then find the first character variable with given name.
#
# Otherwise, arg1 and arg2 give indices for the char var array entry desired.
# Scalar entries are (1, 1), 1d entries are (x, 1) and 2d entries are (x, y).
#
# start           # pointer to symbol
# lth             # symbol length in character codes
# arg1, arg2      # character array variable desired
# Returns:
#   -1 if not found, else number of characters in name.
#   None if no name, and n_wary None.  w_array if found.

def nm_findcvar(start, lth, arg1, arg2):
#--            vlth            # variable name length in chars
#--            ptr             # symbol table entry number
#--            i               # loop index
#--            segment, vchar = n_vname, 6  # chars of n_vname
#--            newname         # name for checking array vars
#--            ptrd, ptru      # up and down search pointers
    global n_char
    global n_maclev
    global n_vsize1
    global n_vsize2
    global n_cvdef
    global n_wary
    global n_vname

    print_debug("nm_findcvar - Entering: start={} lth={} arg1={} arg2={}".format(start, lth, arg1, arg2))
    print_debug("nm_findcvar - n_token='{}' n_tlength={} n_lastend={} n_pnt={} n_tparen={} n_br={} n_tvarptr={}".format( n_token, n_tlength, n_lastend, n_pnt, n_tparen, n_br, n_tvarptr))
    print_debug("nm_findcvar - n_char='{}' n_macnum={} n_tstart={} n_targcnt={} n_targ={} n_vdimen={}".format( n_char, n_macnum, n_tstart, n_targcnt, n_targ, n_vdimen))
    print_debug("nm_findcvar#1 - n_cvdef={}".format(n_cvdef))
# NOTDONEYET
    n_wary = None
    n_vname = n_char[start:start+lth]
    print_debug("nm_findcvar#1b - n_vname={}".format(n_vname))
    # Look for a symbol with the longest name that matches the first chars of this symbol.
    while len(n_vname) >= 1:
        n_wary = None
        for v in n_cvdef:           # foreach name in w_array
            if v[numarry_name] == n_vname:
                if arg1 == -1 and arg2 == -1:   # Any item, assume any dimensions (?)
                    print_debug("nm_findcvar #2 return {}, {}".format(len(n_vname), v))
                    n_wary = v
                    return len(n_vname), v
                # fi
                elif arg2 == 0 and v[numarry_dimensions] == 1 and arg1 == v[numarry_indexes][0]:
                    print_debug("nm_findcvar #3 return {}, {}".format(len(n_vname), v))
                    n_wary = v
                    return len(n_vname), v
                elif (v[numarry_dimensions] == 2 and arg1 == v[numarry_indexes][0] and
                      arg2 == v[numarry_indexes][1]):
                    print_debug("nm_findcvar #4 return {}, {}".format(len(n_vname), v))
                    n_wary = v
                    return len(n_vname), v
                else:           # Not matching ?!
                    print_debug("nm_findcvar #5 Not matching dimensions (??) {}, {}".format(len(n_vname), v))
                    n_wary = v
                    break
                # fi
            # fi
        # rof
        if n_wary is not None:
            break
        # fi
        n_vname = n_vname[:-1]
    # elihw
#-----------------------------------------------------------------------------
    if len(n_vname) <= 0:
        print_debug("nm_findcvar #5 return -1, None")
        return -1, None             # Not found.
    # fi

    # Find the symbol with the same name and closest macro level in the symbol table.
    i = n_maclev
    found = False
    ptr = None
    while i >= 0:
        print_debug("nm_findcvar - n_vname={} i={} n_cvdef={}".format(n_vname,i,n_cvdef))
        for v in n_cvdef:
            print_debug("nm_findcvar - v={}".format(v))
            if v[0] == n_vname and v[numarry_maclevel] == i:
                # matches!
                print_debug("nm_findcvar - matches v[numarry_value_type]={}".format(v[numarry_value_type]))
                vn = v[numarry_value_type]
                print_debug("nm_findcvar - matches v[numarry_values]={}".format(v[numarry_values]))
                print_debug("nm_findcvar - v[numarry_values][{}]={}".format(vn,v[numarry_values][vn]))
                ptr = v
                break                            # Return its information.
            # fi
        # rof
        if ptr is not None:
            break
        # fi
        i = i - 1
    # elihw
    if ptr is None:
        print_debug("nm_findcvar #6 return -1, None")
        return -1, None             # Not found.
    # fi
    # Symbol found, get its information and return its length
    # if searching for first [(-1, -1) case] or have found the desired entry already.
    print_debug("ptr={}".format(ptr))
    if arg1 == -1 and arg2 == -1:
        print_debug("nm_findcvar #7 return {}, {}".format(len(n_vname), ptr))
        n_wary = ptr
        return len(n_vname), ptr
    elif arg1 == n_vsize1 and arg2 == n_vsize2:
        print_debug("nm_findcvar #8 return {}, {}".format(len(n_vname), ptr))
        n_wary = ptr
        return len(n_vname), ptr
    # fi
    # Search forward and backwards from the first found entry for the correct character var array entry.
    print_debug("nm_findcvar #9 return {}, {}".format(len(n_vname), ptr))
    n_wary = ptr
    return len(n_vname), ptr
#   End of nm_findcvar

#=============================================================================
# Add the zvarXXX name for numeric variable or array element with information
# in n_wary to the expression being formed on in n_token. "argcnt" is number
# of array arguments, "arg1" and "arg2" are argument values.
#
# wary            # which w_array to change.
# argcnt          # number of array arguments
# arg1, arg2      # argument values

def nm_subnvar(wary, argcnt, arg1, arg2):
    global n_tlength
    global n_token
    global n_vdimen
    global n_vsize1
    global n_vsize2
    global the_zvars

    print_debug("nm_subnvar - Entering: wary={} argcnt={} arg1={} arg2={}".format(wary, argcnt, arg1, arg2))
    # Check if proper number of arguments, and that arguments have proper values.
#--     if argcnt != wary[numarry_dimensions]:
    if argcnt != n_vdimen:
        print_error_no_line('bad dimen, argcnt={} wary[numarry_dimensions]={}'.format(argcnt,wary[numarry_dimensions]))
        return None
    # fi
    if argcnt > 0:
#--        if v_in(1, arg1, wary[numarry_dimensions][0]):
        if v_in(1, arg1, n_vsize1):
            print_error_no_line('bounds error, argcnt={}, arg1={} wary[numarry_indexes][0]={}'.format(argcnt, arg1, wary[numarry_indexes][0]))
            return None
        # fi
    # fi
    if argcnt > 1:
#--        if v_in(1, arg2, wary[numarry_dimensions][1]):
        if v_in(1, arg2, n_vsize2):
            print_error_no_line('bounds error, argcnt={}, arg2={} wary[numarry_indexes][1]={}'.format(argcnt, arg1, wary[numarry_indexes][1]))
            return None
        # fi
    # fi
    # This can go to many dimensional array.
    if argcnt == 0:
        varnum = 0
    elif argcnt == 1:
        varnum = arg1 - 1
    else:
#--        varnum = (arg1 - 1) + wary[numarry_indexes][0] * (arg2 -1)
        varnum = (arg1 - 1) + n_vsize1 * (arg2 -1)
    # fi
    # New zvar entry in calculate.py.
    new_array = [wary, varnum]
    calculate.zvar.append(new_array)
    newzvar = 'zvar' + str(the_zvars)
    # Create string.
    if n_token is None or n_token == '':
        n_token = newzvar
    else:
        n_token = n_token + newzvar
    # fi
    n_tlength = n_tlength + len(newzvar)
    the_zvars = the_zvars + 1           # Ready for next one.
    print_debug("nm_subnvar created {} with zvar {} with wary={}".format(wary[numarry_name],newzvar,wary))
    return True
#   End of nm_subnvar

#=============================================================================
# Substitute the value for the character variable name with information in
# "n_wary". Replace the string starting at "start" for "lth" chars.
# "argcnt" is the number of arguments, "arg1" and "arg2" are argument values.
#
# No arguments implies entire string.
# 1  argument  implies {x, 100000}
# 2  arguments implies y objects starting at object x.
#
# start           # start of old string
# lth             # length of old string
# argcnt          # number of array arguments
# arg1, arg2      # argument values

def nm_subcvar(start, lth, argcnt, arg1, arg2):
#--            cstart          # start of new string
#--            clth            # length of new string

    global n_lchars
    global n_vlen
    global n_char

    print_debug("nm_subcvar - Entering: start={} lth={} argcnt={} arg1={} arg2={}".format(start, lth, argcnt, arg1, arg2))
    # Find the start and length of the new string.
#--    NOTDONEYET("nm_subcvar - goto argcnt > 0 and arg1 <= 0, er('negcval', arg1), x")
    if argcnt > 0 and arg1 <= 0:
        print_error_no_line('negcval argcnt={} arg1={}'.format(argcnt,arg1))
        return None
    # fi
#--    NOTDONEYET("nm_subcvar - goto argcnt > 1 and arg2 <= 0, er('negcval', arg2), x")
    if argcnt > 1 and arg2 <= 0:
        print_error_no_line("negcval argcnt={} arg2={}".format(argcnt,arg2))
        return None
    # fi
    if argcnt == 0:              # entire value
        cstart = 1
        clth = n_vlen
    else:                            # range of values
        if argcnt == 1:
            arg2 = 100000
        # fi
        cstart, clth = nm_getobj(arg1, arg2)
    # fi
    # Substitute the new string.
#--    NOTDONEYET("nm_subcvar - goto n_lchars - lth + clth >= 10 * l.line, er('linelong'), x")
#--    tmp_move = n_char[start+lth:start+n_lchars - start - lth + 2]
    tmp_move = n_char[start+lth:n_lchars - start - lth + 2]
    tmp_start = n_char[0:start+clth]
#--    tmp_end = n_char[start + clth+n_lchars - start - lth + 2:]
    tmp_end = n_char[clth+n_lchars - start - lth + 2:]
    n_char = tmp_start + tmp_move + tmp_end
    NOTDONEYET("nm_subcvar - stoload nc1, s.cvals + n_vptr, ceil(n_vlen / 10)")
    NOTDONEYET("nm_subcvar - move    nc1, cstart, n_char, start, clth")
#--    NOTDONEYET("nm_subcvar - stoload nc1, 1, 1500")
    n_lchars = n_lchars - lth + clth
    print_debug("nm_subcvar exiting")
#   End of nm_subcvar

#=============================================================================
# Evaluate expression in "n_token" and return its value. All defined numeric
# variables have already been substituted. Update value of compile-time variable
# "time" to length of the selected staff.
#
# If there is an error in the expression, set n_token to the string staring at
# "start" for "lth" characters from the current line. This makes the error
# message more readable.
#
# integer:  start         # start of expression
# integer:  lth           # length of expression

def nm_eval(start, lth):
    #--        floating: value         # value of expression

    global n_tlength
    global n_token
    global n_stfson
    global n_staffon
    global n_char

    print_debug("nm_eval - Entering start={} lth={}".format(start,lth))
    if n_stfson == 0:
        time = -1
    else:
        time = n_minlen(n_staffon[1])
    # fi
    if n_stfson == 0:
        time = -1
    else:
        n_minlen(n_staffon[1])
    # fi
    x, msg = is_float(n_token[0:n_tlength])
    print_debug("nm_eval - n_token='{}' n_tlength={}".format(n_token[0:n_tlength],n_tlength))
    if msg is not None or x is None:
        print_error_no_line("eval gives error: {}".format(msg))
        p_formok = 0                  # Error of some sort.
        value = None
    else:
        p_formok = -1                     # NOTDONEYET - set from above compute.
        value = x                       # NOTDONEYET - set from above compute.
    # fi
    if p_formok != -1:                # error in expression
        n_token = n_char[start:lth]
        n_tlength = lth
        print_error_no_line('bad expressionl - {}'.format(msg))
        return None
    # fi
    print_debug("nm_eval returning {}".format(value))
    return value
#   End of nm_eval

#=============================================================================
# Assign the value passed to the variable in "n_token".
# floating: value         # value to assign

def nm_assign(value):
    #--        integer:  opnt          # place to save "n_pnt"
    #--                  olchars       # place to save "n_lchars"
    #--                  odelim        # place to save "n_lastend"

    global n_lchars
    global n_tlength
    global n_token
    global n_lastend
    global n_pnt

    print_debug("nm_assign - Entering: value={}".format(value))
    # Save current line on stack.
    olchars = n_lchars
    opnt = n_pnt
    odelim = n_lastend
    print_debug("nm_get_token - call save_stack(3)")
    save_stack(3)               # which_stack   = 3     # for line for length l_words.
    # Set up new line with assignment.
    NOTDONEYET("nm_assign - pack line, n_lchars, @0a, n_token, n_tlength@1 = @0s, value, 10@1")
    n_char = n_token[0:tlength] + '=' + str(value)
    print_debug("nm_assign nchar='{}'".format(n_char))
    # Evaluate the expression.
    value = nm_get_token(t_exp, 1, -1)
    if value is None:
        return None
    # fi
    if n_lastend != 0:
        print_error_no_line('bad character, n_lastend={}'.format(n_lastend))
        return None
    # fi
    # Restore old line.
    n_lchars = olchars
    n_pnt = opnt
    n_lastend = odelim
    print_debug("nm_assign - #10 n_lastend='{}'".format(n_lastend))
    print_debug("nm_get_token - call restore_stack(3)")
    restore_stack(3)                # which_stack   = 3     # for line for length l_words.
    print_debug("nm_assign exiting")
    return True
#   End of nm_assign

#=============================================================================
# Replace the current value of the character variable with symbol table entry
# "symbptr" with the string in "n_token".
# symbptr         # pointer to symbol table entry

def nm_setcvar(symbptr,symbargs):
    global n_tlength
    global n_token
    global n_vlen
    global n_cvdef

    print_debug("nm_setcvar - Entering: symbptr={} symbargs={}".format(symbptr, symbargs))
    print_debug("nm_setcvar - n_tlength={} n_token={}".format(n_tlength,n_token))

    arg1 = int(symbargs[0])
    arg2 = int(symbargs[1])
    if symbptr[numarry_dimensions] == 0:
        symbptr[numarry_values][0] = n_token
    elif symbptr[numarry_dimensions] == 1:
        symbptr[numarry_values][arg1] = n_token
    else:
        indx = (arg1 - 1) + int(symbptr[numarry_indexes][0]) * (arg2 -1)
        symbptr[numarry_values][indx] = n_token
    # fi
    print_debug("nm_setcvar exiting symbptr={}".format(symbptr))
    return True
#   End of nm_setcvar

#=============================================================================
# Create a new character variable with name in "varnam". The array dimensions
# are passed in dimen1, dimen2.
#   If dimen1 == dimen2 == 0 then scalar character var
#   If dimen1 != 0 and dimen2 == 0 then 1-d character var.
#   If dimen1 != 0 and dimen2 != 0 then 2-d character var.
# Arrays are stored in the character variable symbol table with the same name
# but different values of n_vsize1 and n_vsize2.
#
# varnam          # name of new variable
# dimen1, dimen2  # dimensions of character var to define
# Return symbol table entry.

def nm_makecvar(varnam, dimen1, dimen2):
    global n_maclev
    global n_cvdef

    print_debug("nm_makecvar - Entering: varnam={} dimen1={} dimen2={}".format(varnam, dimen1, dimen2))
    # Set up symbol table entry and find its place in table.
    n_vdimen = 0
    dims = []
    maxvs = 1
    # Set the character var dimension.
    if dimen1 != 0:
        if dimen2 == 0:
            n_vdimen = 1
            dims = [ dimen1 ]
            maxvs = int(dimen1)
        else:
            n_vdimen = 2
            dims = [ dimen1, dimen2 ]
            maxvs = int(dimen1 * dimen2)
        # fi
    # fi
    w_nums = [None for l in range(0,maxvs)]
    w_ary = [varnam, n_maclev, n_vdimen, dims, 1, w_nums]   # Assume Character value(s). numarry_value_type
    n_cvdef.append(w_ary)
    print_debug("nm_makecvar returning w_ary={}  n_cvdef={}".format(w_ary,n_cvdef))
    return w_ary
#   End of nm_makecvar

#=============================================================================
# Get a range of objects starting with object number "stobj" for a length of
# "nobj" objects from the value of character variable with info in "n_wary".
# Returns a pointer to the starting character code, and length.
# If starting object number is too large, this subroutine returns length of 0.
#
# Objects are strings separated by spaces, commas, brackets, or glissando
# arrows that are not inside parentheses. A bracket itself is an object.
# Separating spaces / commas are not included in object, but glissando arrow is.
#
# stobj           # starting object number
# nobj            # number of objects

def nm_getobj(stobj, nobj):
#--            obj             # current object number
#--            paren           # parenthesis level
#--            ptr             # character pointer
#--            objst           # start of current object
#--            start           # start of range of objects
#--            vlth            # length of variable's value
#--            chr             # char being examined
#--            segment, vchar = nc1, 6  # chars of value

    global n_vlen

    print_debug("nm_getobj - Entering: stobj={} nobj={}".format(stobj, nobj))
    # -stoload- the entire character variable value.
    ptr = obj = 1
    vlth = n_vlen
    paren = 0
    start = -1      # no object found yet
    NOTDONEYET("nm_getobj - stoload nc1, s.cvals + n_vptr, ceil(n_vlen / 10)")
    # Loop through each object, stopping when the last object of the desired range has been processed.
    while obj < stobj + nobj:
    # Remove leading spaces and commas.
        exitoutter = False
        while True:
            if ptr > vlth:
                exitoutter = True
                break
            # fi
            if vchar[ptr] != " " and vchar[ptr] != ",":
                break
            # fi
            ptr = ptr + 1
        # elihw
        if exitoutter:
            break
        # fi
# Mark the start of this object. If it is the first of the
# range of objects, set the start pointer.
        objst = ptr
        if stobj == obj:
            start = ptr
        # fi
# Loop through each character of object.
        while True:
            if ptr > vlth:
                exitoutter = True
                break
            # fi
            chr = vchar[ptr]
#--                if chr = o76:  # access
#--                    ptr = ptr + 1
#--                    chr = (chr $cls$ 6) + vchar(ptr)
#--                # fi
#--                if vchar(ptr) == o70:  # shift
#--                    ptr = ptr + 1
#--                    chr = (chr $cls$ 6) + vchar(ptr)
#--                # fi
    # If not inside parentheses, exit on space, comma, bracket, or glissando arrow.
            if paren <= 0:
                if chr == " " or chr == "," or chr == "@D":
                    break
                # fi
                if chr == "]" or chr == "[":
                    break
                # fi
    # Count parenthesis levels.
                if chr == "(" or chr == "[" or chr == "{":
                    paren = paren + 1
                elif chr == ")" or chr == "]" or chr == "}":
                    paren = paren - 1
                # fi
                ptr = ptr + 1
            # fi
        # elihw
        if exitoutter == True:
            break
        # fi
# Found end of object. Make sure length is greater than
# zero, and include the glissando arrow in the object.
        if objst == ptr or chr == "@D":
            ptr = ptr + 1
        # fi
        obj = obj + 1
    # elihw
    # Return start and length of object.
#--    NOTDONEYET("nm_getobj - stoload nc1, 1, 1500")
    if start != -1:      # first object was found
        print_debug("nm_getobj #8 returning {}, {}".format(start, ptr-start))
        return start, ptr - start
    # fi
    print_debug("nm_getobj #9 returning 1, 0")
    return 1, 0
#   End of nm_getobj

#=============================================================================
# Save "lth" words starting at storage location "start" if "start" is positive,
# else save student vars starting at "-start".
#
# segmentf, start = info, 1, 30, s  # start location
# segmentf, lth   = info, 31, 30    # number of words

def nm_save(start, lth):
    print_debug("nm_save - Entering")
#--    NOTDONEYET("nm_save - goto n_stkptr + lth + 1 > l.stack, er('overflow', 'stack'), x")
    if start > 0:  # save storage
        NOTDONEYET("nm_save - transfr s, start; s, s.stack + n_stkptr; lth")
    else:    # save student vars
        NOTDONEYET("nm_save - transfr n(-start); s, s.stack + n_stkptr; lth")
    # fi
    NOTDONEYET("nm_save - transfr info; s, s.stack + n_stkptr + lth; 1   # save info")
    n_stkptr = n_stkptr + lth + 1
    print_debug("nm_save exiting")
    return True
#   End of nm_save

#=============================================================================
# Restore "nlth" words from stack and place starting at storage location
# "nstart" or student var "-start". This checks that the start location and
# length that was pushed on the stack match what is being asked for.
#
# nstart          # expected starting location
# nlth            # expected length in words

def nm_restore(nstart, nlth):
    print_debug("nm_restore - Entering: nstart={} nlth={}".format(nstart, nlth))

#--    NOTDONEYET("nm_restore - goto n_stkptr == 0, er('badstack'), x")
    if n_stkptr == 0:
        print_error_no_line('badstack')
        return None
    # fi
    NOTDONEYET("nm_restore - transfr s, s.stack + n_stkptr - 1; info; 1  # restore info")
    n_stkptr = n_stkptr - lth - 1
    if start != nstart or lth != nlth:   # check if valid
#--        NOTDONEYET("nm_restore - goto er('badstack')")
        print_error_no_line('bad stack')
        return None
    # fi
    if start > 0:  # restore storage
            NOTDONEYET("nm_restore - transfr s, s.stack + n_stkptr; s, start; lth")
    else:    # restore student vars
            NOTDONEYET("nm_restore - transfr s, s.stack + n_stkptr; n(-start); lth")
    # fi
    print_debug("nm_restore exiting")
    return True
#   End of nm_restore

#=============================================================================
# Discard "nlth" words from stack that came from storage location "nstart".
# This does the same checks as unit "restore" does.
#
# nstart          # expected starting location
# nlth            # expected length in words

def nm_discard(nstart, nlth):
    print_debug("nm_discard - Entering: nstart={} nlth={}".format(nstart, nlth))
    print_debug("nm_discard - This cannot work -- figure out usage.")
    exithere()

    if n_stkptr == 0:
        print_error_no_line('bad stack')
        return None
    # fi
    NOTDONEYET("nm_discard - transfr s, s.stack + n_stkptr - 1; info; 1  # restore info")
    n_stkptr = n_stkptr - lth - 1
    if start != nstart or lth != nlth:   # check if valid
        print_error_no_line('bad stack')
        return None
    # fi
    print_debug("nm_discard exiting")
    return True
#   End of nm_discard

#=============================================================================
# Start processing a macro call to macro number "macn". Get macro arguments,
# save current state, then jump to ml to process macro text.
#
# If this is a process, the first n_token has already been fetched. Get the
# rest of the object and use it as the argument.
#
# For macros, "n_lastend" has the initial delimiter. Get arguments and check
# that delimiters match.
#
# macn            # number of macro being called

def nm_fndmacro(macn):
    global n_lchars
    global n_macnum
    global n_inloop
    global n_inif
    global n_maclev
    global n_nextwrd

    print_debug("nm_fndmacro - Entering: macn={}".format(macn))

    # Get pointer to macro information, and increment macro level counter.
    loc = macloc(macn)
    n_maclev = n_maclev + 1
    # Get the macro arguments.
    if margs[loc] < 0:
        if nm_readnote(loc) is None:
            return None
        # fi
    elif margs[loc] > 0:
        if nm_gen_targs(loc) is None:
            return None
        # fi
    # fi

    # Store current line on stack.
    lwords = int((n_lchars + 1) / 10) + 1
    print_debug("nm_get_token - call save_stack(3)")
    save_stack(3)               # which_stack   = 3     # for line for length l_words.
    # Save all the "current state" information needed to come
    # back to the macro-calling line.
    print_debug("nm_get_token - call save_stack(2)")
    save_stack(2)               # which_stack   = 2     # for mvars for length l_mvars.
    # Set "n_macnum" to the number of the macro being called.
    # Set "n_nextwrd" to point to the first word of macro text.
    n_macnum = macn
    n_nextwrd = mtext(loc)
    # Set -loop- and -if- level count to zero.
    n_inloop = n_inif = 0
    NOTDONEYET("nm_fndmacro - jump    ml")
    print_debug("nm_fndmacro exiting")
    return True
#   End of nm_fndmacro

#=============================================================================
# Get arguments for macro with info at "loc". For each argument, create a
# character variable and initialize it to the argument read from the line.
# Check that delimiters match those of the macro definition.
#
# loc             # start of macro info in "minfo"

def nm_gen_targs(loc):
    global n_lastend
    global n_pnt
    global n_mdelim0

    print_debug("nm_gen_targs - Entering: loc={}".format(loc))

    # Check if initial delimiter matches.
    if n_lastend != n_mdelim0[loc]:
#--        NOTDONEYET("nm_gen_targs - goto er('badelim', n_mdelim0[loc], 0)")
        print_error_no_line("bad delimiter - , n_lastend={} n_mdelim0[loc]={}".format(n_lastend, n_mdelim0[loc]))
        return None
    # fi
    # Now get each argument, checking that delimiters match.
    arg = 1
    while arg < marcs(loc):
        if nm_get_token(t_strng, n_pnt, n_mdelim(loc, arg)) is None:
            return None
        # fi
        if n_lastend != n_mdelim(loc, arg):
#--            NOTDONEYET("nm_gen_targs - goto er('badelim', n_mdelim[loc, arg], arg)")
            print_error_no_line("bad deliminator, n_lastend={} n_mdelim[loc, arg]={} arg={}".format(n_lastend,n_mdelim(loc, arg), arg))
            return None
        # fi
        ptr = nm_makecvar(marg(loc, arg), 0, 0)
        if ptr is None:
            return None
        # fi
        print_debug("nm_gen_targs - calling nm_setcvar({})".format(ptr))
        if nm_setcvar(ptr) is None:
            return None
        # fi
        arg = arg + 1
    # elihw
    print_debug("nm_gen_targs exiting")
    return True
#   End of nm_gen_targs

#=============================================================================
# Remove any variables that were defined in this macro. Symbol table entries
# need to be deleted, but value pointers don't have to be changed because
# values are allocated sequentially.
#
# charvar         # -1 = kill character vars, 0 = numeric

def nm_killvars(charvar):
    global n_maclev
    global n_cvdef
    global n_nvdef                                      # NOTDONEYET nvdef -> cvdef with type(str) check.

    print_debug("nm_killvars - Entering: charvar={}".format(charvar))

    # Set up local variables and -stoload- the symbol table.
    level = n_maclev
    minptr = 100000000
    if charvar:
        nvars = n_cvdef
        NOTDONEYET("nm_killvars - stoload nc1, s.csymb, l.csymb")
    else:
        nvars = n_nvdef                                 # NOTDONEYET nvdef -> cvdef with type(str) check.
        NOTDONEYET("nm_killvars - stoload nc1, s.n_nsymb, l.n_nsymb")
    # fi
    # Loop through table entries. Delete entries at current
    # macro level. Find pointer to beginning of values used by this macro.
    i = 1
    while i <= nvars:
        if vvlevel(i) == level:
            minptr = min(minptr, vvseg2[2 * i])
            NOTDONEYET("nm_killvars - block vventry(i + 1), vventry(i), 2 * (nvars - i)")
            nvars = nvars - 1
        else:
            i = i + 1
        # fi
    # elihw
    # Update symbol table length and words of values used.
#--    NOTDONEYET("nm_killvars - stoload nc1, 1, 1500")
    if charvar and nvars != n_cvdef:
        n_cvdef = nvars
        n_cvwrds = minptr
    elif not(charvar) and nvars != n_nvdef:             # NOTDONEYET nvdef -> cvdef with type(str) check.
        n_nvdef = nvars                                 # NOTDONEYET nvdef -> cvdef with type(str) check.
        n_nvwrds = minptr
    # fi
    print_debug("nm_killvars exiting")
#   End of nm_killvars

#=============================================================================
# Get next line of macro text. If macro has ended, exit it and return to
# previous level.

def nm_nextmacr():
    global n_lchars
    global n_lastend
    global n_macnum
    global n_nextwrd
    global n_inmacro
    global n_inproc

    print_debug("nm_nextmacr - Entering")

    loc = macloc(n_macnum)  # pointer to macro info
    # If macro has ended and there are no more notes on calling
    # line, the the next macro (or source) line and return to
    # token. If there are more notes, jump to ml to continue
    # processing that notes line.
    if n_nextwrd >= mtext(loc) + mwords(loc):
        if nm_popmacro() is None:            # return to calling macro line
            return None
        # fi
        if n_lastend == 0: # no more text on calling line
            if n_macnum == 0:  # no longer in any macro
                getline()       # get source line
            else:    # calling line was macro
#--                NOTDONEYET("nm_nextmacr - goto nm_nextmacr  # get macro line")
                if nm_nextmacr() is None:
                    return None         # get macro line
                # fi
                return True
            # fi
        else:    # there is more on calling line
#--            NOTDONEYET("nm_nextmacr - goto notes(0)")
            if nm_notes(0) is None:
                return None
            # fi
            return True
        # fi
    else:
    # find end of new line
    # note: end-of-line in macro text is a single zero
    # character. the next macro text line starts in the
    # word following the word that contains the zero character.
        NOTDONEYET("nm_nextmacr - transfr s, msource(n_nextwrd); line; l.line")
        NOTDONEYET("nm_nextmacr - search  0, 1, line, zcpw * l.line, 1, n_lchars")
#--        NOTDONEYET("nm_nextmacr - goto n_lchars, er('oops'), x  # end of line found?")
        if n_lchars < 0:
            print_error_no_line('oops')
            return None
        # fi
        thiswrd = n_nextwrd
        n_nextwrd = n_nextwrd + int((n_lchars - 1) / 10) + 1
    # fi
    print_debug("nm_nextmacr exiting")
    return True
#   End of nm_nextmacr

#=============================================================================
# End of current macro has been reached. Pop this all info about this macro
# from the stack and return to the previous level.

def nm_popmacro():
    global n_lchars
    global n_macnum
    global n_inloop
    global n_inif
    global n_maclev

    print_debug("nm_popmacro - Entering")

    # Should not be within an -if-, -loop-, or macro or process
    # definition. Give an error if so.
    if n_inif != 0:
        print_error_no_line('no end for fi')
        return None
    # fi
    if n_inloop != 0:
        while n_inloop > 0:  # clean up loop stack
            if nm_discard(s.mvars, l.mvars) is None:
                return None
            # fi
            n_inloop = n_inloop - 1
        # elihw
        print_error_no_line('no end for endloop')
        return None
    # fi
    if n_inmacro != 0:
        n_inmacro = 0
        print_error_no_line('no end for macro')
        return None
    # fi
    # Clear "n_inproc" if exiting a process.
    if margs(macloc(n_macnum)) == -1:
        n_inproc = 0
    # fi
    # Remove variables that were defined in this macro.
    nm_killvars(0)
    nm_killvars(-1)
    # Restore "current state" variables.
    print_debug("nm_get_token - call restore_stack(2)")
    restore_stack(2)              # which_stack   = 2     # for mvars for length l_mvars.
    n_maclev = n_maclev - 1       # decrement macro level
    # Get back the line that called this macro.
    lwords = int((n_lchars + 1) / 10) + 1
    print_debug("nm_get_token - call restore_stack(3)")
    restore_stack(3)              # which_stack   = 3     # for line for length l_words.
    print_debug("nm_popmacro exiting")
    return True
#   End of nm_popmacro

#=============================================================================
# Get the next note or other notes line object from the current line and use
# it as an argument for the process with information at "loc". The first token
# has already been fetched.
#
# Objects are strings separated by glissando arrows, spaces, commas, or brackets
# that are not inside parentheses. A bracket itself is an object. Separating
# spaces or commas are not included in an object, but the glissando arrow is.
#
# loc             # pointer to process information

def nm_readnote(loc):
    global n_tlength
    global n_token
    global n_lastend
    global n_pnt

    print_debug("nm_readnote - Entering: loc={}".format(loc))

    string = paren = 0
    while n_lastend != 0:
    # If not inside parentheses, exit on space, comma, bracket, or glissando arrow.
        if paren <= 0:
            if n_lastend == " " or n_lastend == ", " or n_lastend == "@D":
                break
            # fi
            if n_lastend == "]" or n_lastend == "[":
                break
            # fi
        # fi
    # Count parenthesis levels.
        if n_lastend == "(" or n_lastend == "["  or n_lastend == "{":
            paren = paren + 1
        elif n_lastend == ")" or n_lastend == "]"  or n_lastend == "}":
            paren = paren - 1
        # fi
    # Note is continued in next token. Add the current token
    # and delimiter to string, and get the next one.
        NOTDONEYET("nm_readnote - pack string(1), , @0a, string(1), 10 * l.line@1@0a, n_token, n_tlength@1@0a, n_lastend@1")
        if nm_get_token(t_space, n_pnt, -1) is None:
            return None
        # fi
    # elihw
    # Object has ended with the current n_token. Add n_token to the
    # string and put in "n_token". If ending delimiter is a
    # glissando arrow or string is zero, add delimiter to
    # string. If not, decrement "n_pnt" so it is gotten next time.
    if [string(1) == 0 and n_tlength == 0] or n_lastend == "@D":
        NOTDONEYET("nm_readnote - pack n_token, n_tlength, @0a, string(1), 10 * l.line@1@0a, n_token, n_tlength@1@0a, n_lastend@1")
    else:
        NOTDONEYET("nm_readnote - pack n_token, n_tlength, @0a, string(1), 10 * l.line@1@0a, n_token, n_tlength@1")
        n_pnt = n_pnt - 1
    # fi
    # Create the character variable and initialize it to the object just gotten.
    if nm_makecvar(marg(loc, 1), 0, 0) is None:
        return None
    # fi
    print_debug("nm_readnote - calling nm_setcvar({})".format(ptr))
    if nm_setcvar(ptr, [-1,-1]) is None:
        return None
    # fi
    print_debug("nm_readnote exiting")
    return True
#   End of nm_readnote

#=============================================================================
# This processes notes lines. This may be called at the start or the middle of
# a line. A notes line may or may not start with a staff select. If it is the
# start of a notes line, and there is no staff select, then write out the
# staves selected for the last notes line IF the previous line was not a notes
# line. Check for staff select if new line.
#
# newln           # -1 if start of new line

def nm_notes(newln):

    global n_lchars
    global n_tlength
    global n_token
    global n_lastend
    global n_pnt
    global n_macname
    global n_stfson
    global n_staffon
    global n_notes

    print_debug("nm_notes - Entering: newln={}".format(newln))

    while True:
        if newln >= 0:
            break
        # fi
        n_notes = -1                                                  # this is a notes line
        stfsent = 0                                                 # staff selects not sent yet
        # Check if there is no staff select on the new line.
#--        NOTDONEYET("nm_notes - search  ':', 2, line, n_lchars, 1, find")
        find = n_char.find(':', 1)
#--        NOTDONEYET("nm_notes - search  '\"', 2, line, n_lchars, 1, dquote")
        dquote = n_char.find('"', 1)
#--        NOTDONEYET("nm_notes - search  o7042 $cls$ 48, 2, line, n_lchars, 1, squote          # single quot")
        squote = n_char.find("'", 1)
        if find == -1 or (dquote < find and dquote != -1) or (squote < find and squote != -1):
            if n_lnotes:                                              # this line & last line are notes
                stfsent = -1                                        # dont write out staff #s")
            # else:
            #   break                                               # re-select staves")
            # fi
            break
        # fi
        # Pick up staff numbers.
        n_stfson = 0 # count of staves in list
        while True:
            NOTDONEYET("nm_notes - find n_token, nc(s.sname), l.sname, find")
            if find < 0:                                                # not a staff name
#--                NOTDONEYET("nm_notes - goto er('badname', n_token)")
                print_error_no_line("bad name, n_token='{}'".format(n_token))
                return None
            # fi
            n_stfson = n_stfson + 1
            n_staffon[n_stfson] = find + 1
            if n_lastend != ",":
                break
            # fi
            if nm_get_token(t_strng, n_pnt, -1) is None:
                return None
            # fi
        # elihw
#--        NOTDONEYET("nm_notes:", x, er("badchar", n_lastend)')
        if n_lastend != ":":
            print_error_no_line("bad character, n_lastend={} is not ':'".format(n_lastend))
            return None
        # fi
        # Get next token.
        if nm_get_token(t_space, n_pnt, -1) is None:
            return None
        # fi
        # Select staves in binary.
        if n_stfson != 0:
#--            wbin(tstaff)
#--            wbin(n_staffon[1])
            stf = 2
            while stf <- n_stfson:
#--                wbin(talso)                                             # notes go on > 1 staff
#--                wbin(n_staffon[stf])
                stf = stf + 1
            # elihw
            stfsent = -1
        # fi
        #
    # elihw
    if newln >= 0:
        if nm_get_token(t_space, -1, -1) is None:
            return None
        # fi
    # fi
    # If "inschk" is -1, check if any instrs are used on more
    # than one staff before processing notes.
    if inschk < 0:
        instrchk()
    # fi
    # Clear the no-notes-since-last-key flag.
    stf = 1
    while stf <= n_stfson:
        NOTDONEYET("nm_notes - lyrbit(n_staffon[stf]) = 0")
        NOTDONEYET("nm_notes - keybit(n_staffon[stf]) = 0")
        stf = stf + 1
    # elihw

    # Process the next notes-line token.
    while True:
        NOTDONEYET("nm_notes - find n_token, n_macname[1], n_nmacs, find  # see if a macro")
        # If "begin" is found, the next token should be a process
        # name. Activate that process for this staff.
        if n_token == 'begin':
#--            NOTDONEYET("nm_notes - goto n_stfson == 0, er('nostaff'), x")
            if n_stfson == 0:
                print_error_no_line('no staff')
                return None
            # fi
#--            NOTDONEYET("nm_notes - goto n_lastend == 0, er('procname'), x")
            if n_lastend == 0:
                print_error_no_line('proc name not found')
                return None
            # fi
            if nm_get_token(t_strng, n_pnt, -1) is None:
                return
            # fi
            NOTDONEYET("nm_notes - find n_token, n_macname[1], n_nmacs, find")
            find = -1               # NOTDONEYET - due to above code
#--            NOTDONEYET("nm_notes - goto find == -1 or n_tlength > 10, er('notaproc'), x")
            if find == -1 or n_tlength > 10:
                print_error_no_line('not a process')
                return None
            # fi
#--            NOTDONEYET("nm_notes - goto margs(macloc(find + 1)) != -1, er('notaproc'), x")
            if margs[macloc[find + 1]] != -1:
                print('not a proc')
                return None
            # fi
            stf = 1
            while stf <= n_stfson:
                n_process[n_staffon[stf]] = find + 1
                stf = stf + 1
            # elihw
        # If "quit" is found, turn off the current process for this staff.
        elif n_token == 'quit':
#--            NOTDONEYET("nm_notes - goto n_stfson == 0, er('nostaff'), x")
            if n_stfson == 0:
                print_error_no_line('no staff')
                return None
            # fi
            stf = 1
            while stf <= n_stfson:
                n_process[n_staffon[stf]] = 0
                stf = stf + 1
            # elihw
        # If this is a macro name, get its arguments and call it.
        # Give an error if it is a process macro.
        elif v_in(1, n_tlength, 10) and n_token in n_macname:       # token exists as macro/proc name.
#--            NOTDONEYET("nm_notes - goto margs(macloc(find + 1)) == -1, er('noproc'), x")
            if margs[macloc[find + 1]] == -1:
                print_error_no_line('no proc')
                return None
            # fi
#--            NOTDONEYET("nm_notes - goto nm_fndmacro(find + 1)")
            if nm_fndmacro(find + 1) is None:
                return None
            # fi
            return True
        # fi
        # If null n_token, do nothing.
        elif n_tlength == 0 and (n_lastend == 0 or n_lastend == " " or n_lastend == ","):
            pass
        else:
        # select staves in binary, if necessary.
            if n_stfson != 0 and not(stfsent):
#--                wbin(tstaff)
#--                wbin(n_staffon[1])
                stf = 2
                while stf <= n_stfson:
#--                    wbin(talso)     # notes go on > 1 staff
#--                    wbin(n_staffon[stf])
                    stf = stf + 1
                # elihw
                stfsent = -1
            # fi
#--            NOTDONEYET("nm_notes - goto n_stfson == 0, er('nostaff'), x")
            if n_stfson == 0:
                print_error_no_line('no staff')
                return None
            # fi
        # Check if a clef change.
            if n_token == 'treble' or n_token == 'bass' or n_token == 'alto' or n_token == 'tenor' or n_token == 'soprano':
                clef
        # Check for key, transpose, beaming, transcribe, glide.
            elif n_token == 'key':
                key(0)
            elif n_token == 'transpose':
                xpose()
            elif n_token == 'beaming' or n_token == 'grouping':
                beaming()
            elif n_token == 'scribe': # obsolete
#--                NOTDONEYET("nm_notes - goto er('scribe')")
                print_error_no_line('scribe is obsolete')
                return None
            elif n_token == 'transcribe':
                tscribe()
            elif n_token == 'glide':
                glide()
            elif n_token == 'hide':
                hide(-1)
            elif n_token == 'show':
                hide(0)
        # Check for MIDI data.
            elif n_token == 'midi':
                midi()
        # Check for lyrics.
            elif n_tlength == 0 and n_lastend == "'":  # "
                lyrics()
        # Check for OPAL text which is not to be compiled.
            elif n_tlength == 0 and n_lastend == "'":  # '
                notcomp()
        # If a process is active for this staff and not already
        # in a process, call the process passing the notes line object.
            elif n_process[n_staffon[1]] != 0 and n_inproc == 0:
                n_inproc = 1
#--                NOTDONEYET("nm_notes - goto fndmacro(n_process[n_staffon[1]])")
                if nm_fndmacro(n_process[n_staffon[1]]) is None:
                    return None
                # fi
                return True
        # Otherwise, compile and output the notes line object.
            else:
                if nm_noteget0(-1) is None:
                    return None
                # fi
                noteout()
            # fi
        # fi

        if n_lastend == 0:
            NOTDONEYET("nm_notes - jump    ml")
        else:
            if nm_get_token(t_space, n_pnt, -1) is None:
                return
            # fi
            continue
        # fi
        break
    # elihw
    print_debug("nm_notes exiting")
    return True
#   End of nm_notes

#=============================================================================
# Get the next note and set the various internal variables. If "default" is -1,
# substitute defualts for unspecified octave or length. If 0, leave unspecified.
#
# default         # -1 to substitute defaults

def nm_noteget(default):
    global n_lastend
    global n_pnt

    print_debug("nm_noteget - Entering: default={}".format(default))

    if n_lastend != "(":
        if nm_get_token(t_space, n_pnt, -1) is None:
            return None
        # fi
    # fi
    if nm_noteget0(default) is None:
        return None
    # fi
    print_debug("nm_noteget exiting")
    return True
#   End of nm_noteget

#=============================================================================
# Form of notes:
#     4c4  4c4d  4c3(4)  4c++4  c  5c 4c16s  r2
#     (48,.25)  (r,.5)
#
# Defaults: if only one element is given it is assumed to be note name.
#
# n_ch will be char number
# n_part will be where in note we are:
#    -1 = nothing yet
#     0 = getting octave
#     1 = getting note name
#     2 = getting accidentals;  waiting for lth
#     3 = getting note lth
#     4 = getting ties, dots, etc.
# ptype is the type of pitch specification:
#     0 = 4c            tnote   octave/notetname
#     1 = (48,.25)      tnote1 or tnote2  note number
#     4 = r             trest   rest
# ltype is the type of length specification:
#     0 = (48,.25)      fractional whole notes
#     1 = 4             standard note lengths
#     3 = 3(4)          triplets, etc

def nm_noteget0(default):          # dont-get-token entry point
    global n_tlength
    global n_token
    global n_lastend
    global n_pnt
    global n_notenam
    global n_notelen
    global n_mslur
    global n_mstac
    global n_mtied
    global n_mmarc
    global n_volume
    global n_dotted
    global n_vinc
    global n_sharp
    global n_flat
    global n_nat
    global n_ptype
    global n_notenum
    global n_ntime
    global n_octave
    global n_part
    global n_simile
    global n_ch
    global n_bracket
    global n_ltype
    global n_grace
    global n_mleg
    global n_pan
    global n_stemdir
    global n_gliss
    global n_temp

    print_debug("nm_noteget0 - Entering: default={}".format(default))

    n_ch = n_sharp = n_flat = n_nat = n_mtied = n_mmarc = n_dotted = n_mstac = n_mslur = 0
    n_vinc = n_mleg = n_acct = n_pan = n_stemdir = n_bracket = n_gliss = 0
    n_grace = 0
    n_octave = n_notenum = n_part = n_ptype = n_ntime = n_volume = -1
    n_simile = n_volname = n_pos = n_notenam = n_notelen = -1
    n_ltype = 1
    # the following code is exactly the same in nm_noteget1.
    # if any changes are made here, make them in nm_noteget1 also.

    while True:
        n_ch = n_ch + 1 # next character
        if n_ch > n_tlength:                # all done with token:
            if n_lastend == " " or n_lastend == "," or n_lastend == 0:
                break
            # fi
            if n_lastend == ";" or n_lastend == ")":
                break
            # fi
            if n_lastend == "@D":
                n_gliss = 1
                break
            elif n_lastend == "[" or n_lastend == "]":
                if n_lastend == "[":
                    n_bracket = 1
                else:
                    n_bracket = -1
                # fi
                break
            else:
                n_temp = n_lastend
            # fi
        else:
            n_temp = n_token[n_ch]            # next char
        # fi
    # the above code is similar in nm_noteget1.
        if n_part < 0:                        # nothing yet
            if type(n_temp) is str and n_temp.isnumeric():
                n_part = 0                # getting octave
                n_octave = int(n_temp)
                n_ptype = 0
            elif n_token == 'arp':
                n_simile = tarpeg
                break
            elif n_token == 'trem0':
                n_simile = ttrem0
                break
            elif n_token == 'trem1':
                n_simile = ttrem1
                break
            elif n_token == 'trem2':
                n_simile = ttrem2
                break
            elif n_token == 'trem3':
                n_simile = ttrem3
                break
            elif n_token == 'fermata':
                n_simile = tferm
                break
            elif n_token == 'lh':
                n_simile = tlh
                break
            elif n_token == 'rh':
                n_simile = trh
                break
            elif n_token == 'normal':
                n_simile = tnormal
                break
            elif n_token == 'perc':
                n_simile = tperc
                break
            elif n_token == 'nohead':
                n_simile = tnohead
                break
            elif n_token == 'oloz':
                n_simile = toloz
                break
            elif n_token == 'floz':
                n_simile = tfloz
                break
            elif n_token == 'oharm':
                n_simile = toharm
                break
            elif n_token == 'fharm':
                n_simile = tfharm
                break
            elif n_temp >= "a" and n_temp <= "g":
                n_ptype = 0
                n_notenam = nm_note_to_number[n_temp]
                n_part = 2 # get accidentals
            elif n_temp == "r":
                n_ptype = 4 # rest
                n_part = 2 # look for note lth
                n_notenum = n_octave = -1
            elif n_temp == "v":
#--                NOTDONEYET("nm_noteget0 - goto n_ch == 1, x, er('badvol')")
                if n_ch != 1:
                    print_error_no_line('badvol')
                    return None
                # fi
                if nm_volume() is None:
                    return None
                # fi
                break
            elif n_temp == "p":
#--                NOTDONEYET("nm_noteget0 - goto n_ch == 1, x, er('badvol')")
                if n_ch != 1:
                    print_error_no_line('bad vol')
                    return None
                # fi
                position()
                break
            elif n_temp == ">" or n_temp == "<":  # ignore
#--                NOTDONEYET("nm_noteget0 - goto n_tlength == 0, x, er('badvol')")
                if n_tlength != 0:
                    print_error_no_line('badvol')
                    return None
                # fi
                if nm_get_token(t_space, n_pnt, -1) is None:             # get vol/pos
                    return None
                # fi
#--                NOTDONEYET("nm_noteget0 - goto n_tlength == 0, er('badvol'), x")
                if n_tlength != 0:
                    print_error_no_line('badvol')
                    return None
                # fi
#--                NOTDONEYET("nm_noteget0v" or n_token[1] == "p", x, er("badvol")')
                if n_token[1] != "v" and n_token[1] != "p":
                    print_error_no_line("badvol")
                    return None
                # fi
                n_ch = 0
            elif n_temp == "(":
                if nm_numeric() is None:
                    return None
                # fi
            elif n_token == 'legato' or n_token == 'leg':
                n_simile = tleg
                break
            elif n_token == 'staccato' or n_token == 'stac':
                n_simile = tstac
                break
            elif n_token == 'marcato' or n_token == 'marc':
                n_simile = tmarc
                break
            elif n_token == 'tie':
                n_simile = ttied
                break
            elif n_token == 'slur':
                n_simile = tslur
                break
            else:
#--                NOTDONEYET("nm_noteget0 - goto er('badchar', n_temp)")
                print_error_no_line('bad character n_temp={}'.format(n_temp))
                return None
            # fi
        elif n_part == 0: # getting octave
            if n_temp >= "0" and n_temp <= "9":
                n_octave = 10 * n_octave + int(n_temp)
            elif n_temp >= "a" and n_temp <= "g":
                n_ptype = 0
                n_notenam = nm_note_to_number[n_temp]
                n_part = 2 # get accidentals
            else:
                n_part = 2 # note value?
                if nm_noteget1() is None:
                    return None
                # fi
                return True
            # fi
        elif n_part == 1: # getting note name
            if n_temp >= "a" and n_temp <= "g":
                n_ptype = 0
                n_notenam = nm_note_to_number[n_temp]
                n_part = 2 # get accidentals
            else:
#--                NOTDONEYET("nm_noteget0 - goto er('badchar', n_temp)")
                print_error_no_line('bad character n_temp={}'.format(n_temp))
                return None
            # fi
        else:            # no more room in unit!
            if nm_noteget1() is None:
                return None
            # fi
            return True
        # fi
        continue                # which is default behavior, merely documenting it here.
    # elihw
    if nm_notechk(default) is None:
        return None
    # fi
    print_debug("nm_noteget0 #9 exiting")
    return True
#   End of nm_noteget0

#=============================================================================
def nm_noteget1():
    global n_tlength
    global n_token
    global n_lastend
    global n_pnt
    global n_ch
    global n_ltype
    global n_mtied
    global n_mmarc
    global n_mstac
    global n_mslur
    global n_bracket
    global n_part
    global n_notelen
    global n_sharp
    global n_flat
    global n_nat
    global n_result
    global n_getime
    global n_grace
    global n_stemdir
    global n_temp

    def extra1(tmpy):
        if tmpy == "d":
            n_dotted = n_dotted + 1
        elif tmpy == "l":
            n_mleg = n_mleg + 1
        elif tmpy == "t":
            n_mtied = n_mtied + 1
        elif tmpy == "m":
            n_mmarc = n_mmarc + 1
        elif tmpy == "s":
            n_mstac = n_mstac + 1
        elif tmpy == "z":
            n_mslur = n_mslur + 1
        elif tmpy == "a":
            n_acct = n_acct + 1
        elif tmpy == "@W" or tmpy == "@X":
#--            NOTDONEYET("nm_noteget1 - goto n_stemdir == 0, x, er('badstem')")
            if n_stemdir != 0:
                print_error_no_line('badstem')
                return None
            # fi
            if tmpy == "@W":
                n_stemdir = 1
            else:
                n_stemdir = -1
            # fi
            if nm_get_token(t_space, n_pnt, -1) is None:
                return None
            # fi
            n_ch = 0
        elif tmpy == "g":
            n_grace = n_grace + 1
        else:
#--            NOTDONEYET("nm_noteget1 - goto er('badchar', tmpy)")
            print_error_no_line('bad character type(tmpy)={} tmpy={}'.format(type(tmpy), tmpy))
            return None
        # fi
        return True
    # End of extra1

    print_debug("nm_noteget1 - Entering")

    # jump into loop with current character, unless coming
    # from "get note value" unit.
    if n_getime < 0:
        first_only = True
    else:
        first_only = False
    # fi
    # this first part if the same as in unit nm_noteget. if you
    # make any changes here, make them in nm_noteget also.
#--    print_debug("first_only={} n_ch={} n_tlength={} n_lastend={}".format(first_only,n_ch,n_tlength,n_lastend))
    while True:
#--        print_debug("first_only={} n_ch={} n_tlength={} n_lastend={}".format(first_only,n_ch,n_tlength,n_lastend))
        if first_only:
#--            print_debug("first_only={} n_ch={} n_tlength={}".format(first_only, n_ch, n_tlength))
            if n_ch+1 > n_tlength: # all done with token
                if n_lastend == " " or n_lastend == "," or n_lastend == 0:
#--                    print_debug("first_only={} and n_lastend={}".format(first_only, n_lastend))
                    break
                # fi
                if n_lastend == ";" or n_lastend == ")":
                    break
                # fi
                if n_lastend == "@D":
                    n_gliss = 1
                    break
                elif n_lastend == "[" or n_lastend == "]":
                    if n_lastend == "[":
                        n_bracket = 1
                    else:
                        n_bracket = -1
                    # fi
                    break
                else:
                    n_temp = n_lastend
                # fi
            else:
                #-- n_temp = n_token[n_ch]        # next char
                n_temp = n_token[n_ch]        # next char
                n_ch = n_ch + 1
        #--        if n_temp == o70:        #shift code
        #--            n_ch = n_ch + 1
        #--            n_temp = o7000 + t(n_ch)
        #--        # fi
            # fi
        # fi
        first_only = True
    # the above code is exactly the same in nm_noteget.
        if n_part == 2: # get accidentals; wait for lth
#--            print_debug("#z1 n_part={} type(n_temp)={} n_temp='{}'".format(n_part,type(n_temp),n_temp))
            if type(n_temp) is str and n_temp.isnumeric():
#--                print_debug("#z2")
                n_ltype = 1
                n_notelen = int(n_temp)
                n_part = 3 # getting note lth
            elif n_temp == "+":
#--                print_debug("#z+")
                n_sharp = n_sharp + 1
            elif n_temp == "-":
#--                print_debug("#z-")
                n_flat = n_flat + 1
            elif n_temp == "n":
#--                print_debug("#zn")
                n_nat = n_nat + 1
            else:
#--                print_debug("#z other")
                n_part = 4 # ties, or somthin?
                if extra1(n_temp) is None:
                    print_debug("#1 None from extra1")
                    return None
                # fi
            # fi
        elif n_part == 3: # getting note length
            if type(n_temp) is str and n_temp.isnumeric():
                n_notelen = 10 * n_notelen + int(n_temp)
                print_debug("nm_noteget1 #y1")
            elif n_temp == "(": # 3(4) format
#--                NOTDONEYET("nm_noteget1 - goto n_notelen == 0, er('badlen'), x")
                print_debug("nm_noteget1 #y2")
                if n_notelen == 0:
                    print_error_no_line('bad length')
                    return None
                # fi
                n_result = nm_get_token(t_exp, n_pnt, -1)
                if n_result is None:
                    return None
                # fi
#--                NOTDONEYET("nm_noteget1)", x, er("badchar", n_lastend)')
                if n_lastend != ")":
                    print_error_no_line("bad character n_lastend={}".format(n_lastend))
                    return None
                # fi
                n_ltype = n_notelen
                n_notelen = n_result
                n_part = 4
                if nm_get_token(t_space, n_pnt, -1) is None:
                    return None
                # fi
                n_ch = 0
            else:
                print_debug("nm_noteget1 #y3")
                n_part = 4 # ties, or somthin?
                if extra1(n_temp) is None:
                    print_debug("nm_noteget1 #2 None from extra1")
                    return None
                # fi
            # fi
        elif n_part == 4: # getting ties, dots, etc.
            if extra1(n_temp) is None:
                print_debug("nm_noteget1 #3 None from extra1")
                return None
            # fi
        else:
#--            NOTDONEYET("nm_noteget1 - goto er('internal', 'nm_noteget')")
            print_error_no_line('internal nm_noteget error')
            return None
        # fi
    # elihw
    print_debug("nm_noteget1 n_getime={}".format(n_getime))
    if n_getime < 0:  # just getting note length
        n_getime = 0
#--        print_debug("nm_noteget1 #8 exiting")
        return True
    else:
        if nm_notechk(default) is None:
            return None
        # fi
    # fi
#--    print_debug("nm_noteget1 #9 exiting")
    return True
#   End of nm_noteget1

#=============================================================================
# Check if this is a valid note. If "default" is -1, substitute default values
# for octave or note length if they are not specified. If "default" is 0, leave
# them unspecified (value == -1); and do not perform any transcribe" functions.
#
# default         # -1 to substitute defaults

def nm_notechk(default):
    global n_stfson
    global n_staffon
    global n_ptype
    global n_grace
    global n_ltype
    global n_octave
    global n_lastoct
    global n_notenam
    global n_notex
    global n_octavex
    global n_sharp
    global n_flat
    global n_nat
    global n_nokey
    global n_notelen
    global n_dotted
    global n_mmarc
    global n_mleg
    global n_mtied
    global n_mslur
    global n_ntime
    global n_lastdot
    global n_lltype
    global n_lastlen
    global n_mstac
    global n_volume
    global n_volname

    print_debug("nm_notechk - Entering: default={}".format(default))

    stfon = n_staffon[1]
    # Check pitch of note.
    if n_ptype == 0:  # standard pitch
    # Use or set default octave.
        if n_octave == -1:
            oct = n_lastoct[stfon]
        else:
            n_lastoct[stfon] = oct = n_octave
        # fi
    # If using defaults, add in note name tranposition and adjust range of result.
#--        NOTDONEYET("nm_notechk - goto n_notenam == -1, er('octnont'), x")
        if n_notenam == -1:
            print_error_no_line('octnont')
            return None
        # fi
        if default:
            n_notenam = n_notenam + n_notex(stfon) + 7 * n_octavex(stfon)
            while n_notenam < 0:
                oct = oct - 1
                n_notenam = n_notenam + 7
            # elihw
            while n_notenam > 6:
                oct = oct + 1
                n_notenam = n_notenam - 7
            # elihw
        # fi
#--        NOTDONEYET("nm_notechk - goto v_in(0, oct, 9), x, er('octoor', oct)")
        if v_in(0, oct, 9):
            pass
        else:
            print_error_no_line('octoor oct={}'.format(oct))
            return None
        # fi
        if default < 0:
            n_octave = oct
        # fi
    # Check accidentals.
#--        NOTDONEYET("nm_notechkmuch", "sharps", 2), x')
#--        NOTDONEYET("nm_notechkmuch", "flats", 2), x')
#--        NOTDONEYET("nm_notechkmuch", "natural", 1), x')
#--        NOTDONEYET("nm_notechk - goto sign(n_sharp) + sign(n_flat) + n_nat > 1, er('onetype'), x")
        if n_sharp > 2:
            print_error_no_line("too many sharps={}".format(n_sharp))
            return None
        if n_flat > 2:
            print_error_no_line("too many flats={}".format(n_flat))
            return None
        if n_nat > 1:
            print_error_no_line("too many natural={}".format(n_nat))
            return None
        if sign(n_sharp) + sign(n_flat) + n_nat > 1:
            print_error_no_line('onetype of sharp/flat/natural')
            return None
        # fi
    # Set accidental table for this note.
    # If there was no accidental, get default accidental from table.
        acc = n_sharp - n_flat
        if default:
            if n_sharp + n_flat + n_nat != 0 and n_nokey(stfon) == 0:
                stf = 1
                while stf <= n_stfson:
                    NOTDONEYET("nm_notechk -songacc(n_staffon[stf], oct, n_notenam) = acc")
                    n_stfson = n_stfson + 1
                # elihw
            elif n_nokey(stfon) == 0:
                NOTDONEYET("nm_notechk - acc = songacc(stfon, oct, n_notenam)")
            # fi
    # Transcribe accidentals.
            acc = acc + accx(stfon, n_notenam)
#--            NOTDONEYET("nm_notechk - goto abs(acc) > 2, er('badtrans'), x")
            if abs(acc) > 2:
                print_error_no_line('badtrans')
                return None
            # fi
            if n_sharp + n_flat + n_nat != 0:
                if  acc < 0:
                    n_flat = -acc
                else:
                    n_flat = 0
                # fi
                if acc == 0:
                    n_nat = 1
                else:
                    n_nat = 0
                # fi
                if acc > 0:
                    n_sharp = acc
                else:
                    n_sharp = 0
                # fi
            # fi
        # fi
    # Calculate note number using accidental table
        note_numbers = [ 0, 2, 4, 5, 6, 9, 11]
        n_notenum = note_numbers[notname]
        n_notenum = 12 * oct + n_notenum + acc
#--        NOTDONEYET("nm_notechk - goto v_in(0, n_notenum, maxnote), x, er('ntoor', n_notenum)")
        if v_in(0, n_notenum, maxnote):
            pass
        else:
            print_error_no_line('ntoor n_notenum={}'.format(n_notenum))
        # fi
    elif n_ptype == 1:  # numerical note
#--        NOTDONEYET("nm_notechk - goto v_in(0, n_notenum, maxnote), x, er('ntoor', n_notenum)")
        if v_in(0, n_notenum, maxnote):
            pass
        else:
            print_error_no_line('ntoor n_notenum={}'.format(n_notenum))
            return None
        # fi
    # fi

    # Check duration of note.
    if n_gliss == 1:  # glissando
#--        NOTDONEYET("nm_notechk - goto n_notelen != -1 or (n_dotted + n_mstac + n_mmarc + n_mleg + n_mtied + n_mslur + n_acct + n_grace != 0), er('badgliss'), x")
        if n_notelen != -1 or (n_dotted + n_mstac + n_mmarc + n_mleg + n_mtied + n_mslur + n_acct + n_grace != 0):
            print_error_no_line('bad gliss')
            return None
        # fi
    elif n_ltype == 1 and n_notelen == -1:  # no length given
#--        NOTDONEYET("nm_notechk - goto n_dotted == 0, x, er('baddot')")
        if n_dotted != 0:
            print_error_no_line('baddot')
            return None
        # fi
#--        NOTDONEYET("nm_notechk - goto n_ptype == 1, er('badnumer'), x")
        if n_ptype == 1:
            print_error_no_line('badnumer')
            return None
        # fi
        if n_ptype == 0 or n_ptype == 4:
            if default:  # set defaults
                n_ltype = n_lltype[stfon]
                n_notelen = n_lastlen[stfon]
                n_dotted = n_lastdot[stfon]
            # fi
            n_ntime = (2 - (.5 ** n_lastdot[stfon])) / (n_lltype[stfon] * n_lastlen[stfon])
        # fi
    elif n_ltype == 0:  # numerical length
#--        NOTDONEYET("nm_notechk - goto n_ntime <= 0, er('zerotime'), x")
#--        NOTDONEYET("nm_notechk - goto n_ntime > 1000, er('toolarge', 0, n_ntime), x")
        if n_ntime <= 0:
            print_error_no_line('zerotime')
            return None
        # fi
        if n_ntime > 1000:
            print_error_no_line("too large n_ntime={}".format(n_ntime))
            return None
        # fi
    else:    # standard length
#--        NOTDONEYET("nm_notechk - goto n_ltype < 1 or frac(n_ltype) != 0, er('badlen'), x")
#--        NOTDONEYET("nm_notechk - goto n_notelen < 1 or frac(n_notelen) != 0, er('badlen'), x")
#--        NOTDONEYET("nm_notechkmuch", "dots", 2), x')
        if n_ltype < 1 or frac(n_ltype) != 0:
            print_error_no_line('badlen')
            return None
        # fi
        if n_notelen < 1 or frac(n_notelen) != 0:
            print_error_no_line('badlen')
            return None
        # fi
        if n_dotted > 2:
            print_error_no_line("too many dots={}".format(n_dotted))
            return None
        # fi
        n_lltype[stfon] = n_ltype                   # set defaults
        n_lastlen[stfon] = n_notelen
        n_lastdot[stfon] = n_dotted
        n_ntime = (2 - (.5 ** n_dotted)) / (n_ltype * n_notelen)
    # fi
#--    NOTDONEYET("nm_notechk - goto n_mtied + n_mstac + n_mmarc + n_mleg > 1, er('notboth'), x")
#--    NOTDONEYET("nm_notechk - goto n_mtied + n_mleg + n_mslur > 1, er('notboth'), x")
#--    NOTDONEYET("nm_notechk - goto n_acct > 2, er('manymod', 'a', 2), x")
#--    NOTDONEYET("nm_notechk - goto n_grace > 2, er('manymod', 'g', 2), x")
#--    NOTDONEYET("nm_notechkmultoor", "Staccato")')
#--    NOTDONEYET("nm_notechkmultoor", "Marcato")')
#--    NOTDONEYET("nm_notechk - goto v_in(0, accent, 50), x, er('acctout')")
#--    NOTDONEYET("nm_notechk - goto v_in(0, aaccent, 50), x, er('acctout')")
#--    # Check non-notes stuff.
#--    NOTDONEYET("nm_notechk - goto n_volume > 100 or n_volname > 8, er('voloor'), x")
#--    NOTDONEYET("nm_notechk - goto n_pos > 100, er('posoor'), x")
#--    NOTDONEYET("nm_notechk - goto v_in(.01, arp, 20), x, er('arpoor')")
#--    NOTDONEYET("nm_notechkmultoor", "Fermata")')
    print_debug("nm_notechk exiting")
    if n_mtied + n_mstac + n_mmarc + n_mleg > 1:
        print_error_no_line('cannot have two different modifiers')
        return None
    # fi
    if n_mtied + n_mleg + n_mslur > 1:
        print_error_no_line('cannot have two different')
        return None
    # fi
    if n_acct > 2:
        print_error_no_line('too many modifiers n_acct={}'.format(n_acct))
        return None
    # fi
    if n_grace > 2:
        print_error_no_line('too many n_grace notes')
        return None
    # fi
    if v_in(.01, stac, 1):
        pass
    else:
        print_error_no_line("mult oor Staccato")
        return None
    # fi
    if v_in(.01, marc, 1):
        pass
    else:
        print_error_no_line("mult oor Marcato")
        return None
    # fi
    if v_in(0, accent, 50):
        pass
    else:
        print_error_no_line('accent out of range')
        return None
    # fi
    if v_in(0, aaccent, 50):
        pass
    else:
        print_error_no_line('aaccent our of range')
        return None
    # fi
    if n_volume > 100 or n_volname > 8:
        print_error_no_line('volume out of range')
        return None
    # fi
    if n_pos > 100:
        print_error_no_line('pos out of range')
        return None
    # fi
    if v_in(.01, arp, 20):
        pass
    else:
        print_error_no_line('arp out of range')
        return None
    # fi
    if v_in(.01, fermata, 20):
        pass
    else:
        print_error_no_line("multiplier out of range - Fermata")
        return None
    # fi
    return True
#   End of nm_notechk

#=============================================================================
# Process numerical note format:  (48,. 25)

def nm_numeric():
    global n_tlength
    global n_token
    global n_lastend
    global n_pnt
    global n_lastend
    global n_ptype
    global n_ntime
    global n_ch
    global n_part

    print_debug("nm_numeric - Entering")

    ptr = n_pnt
    if nm_get_token(t_strng, n_pnt, -1) is None:                     # see if it is a rest
        return None
    # fi
    if n_token == 'r' and n_lastend == ",":         # (r,.25) format
        n_ptype = 4
    else:    # get note number
        n_notenum = nm_get_token(t_exp, ptr, -1)         # reprocess n_token")
        if n_notenum is None:
            return None
        # fi
        if n_notenum == -1:
            n_ptype = 4
        else:
            n_ptype = 1
        # fi
    # fi
    if n_lastend == ",": # (48,.25) or (r,.25) format
        n_ntime = nm_get_token(t_exp, n_pnt, -1)           # get note length
        if n_ntime is None:
            return None
        # fi
#--        NOTDONEYET("nm_numeric)", x, er("badchar", n_lastend)')
        if n_lastend != ")":
            print_error_no_line("bad character n_lastend={}".format(n_lastend))
            return None
        # fi
        if nm_get_token(t_space, n_pnt, -1)  is None:       # continue with next token
            return
        # fi
        n_ch = 0
        n_ltype = 0                               # floating pt length type
        n_part = 4                                # get note modifiers
    elif n_lastend == ")":                        # (48)@D(49,.25) format
        if nm_get_token(t_space, n_pnt, -1) is None:                 # check for "@D"
            return
        # fi
#--        NOTDONEYET("nm_numeric@D", x, er("badnumer")')
        if n_tlength == 0 and n_lastend == "@D":
            pass
        else:
            print_error_no_line("badnumer")
            return None
        # fi
    else:
#--        NOTDONEYET("nm_numeric - goto er('badchar', n_lastend)")
        print_error_no_line('bad character n_lastend={}'.format(n_lastend))
        return None
    # fi
    print_debug("nm_numeric exiting")
    return True
#   End of nm_numeric

#=============================================================================
# Set "n_volume" to the numeric volume. Set "n_volname" to volume name:
#   0 if numeric, 1 if vppp, 2 if vpp, ... , 8 if vfff
# Set "n_vinc" to -1 or 1 if start of crescendo/decrescendo.
#
# The numerical volume values go from 0-100.
# In pass 2 the range is changed from 0-63, since that is what is sent to terminal.
#
# The numerical values of vppp, vpp, vp, vmp, vmf, vf, vff, vfff can be set in
# music by assigning a value to the variable of the same name.
# (compiler has default values)
#
# Crescendos/decrescendos end at the next volume given in the source.
#
def nm_volume():
    global n_tlength
    global n_token
    global n_lastend
    global n_pnt
    global n_staffon
    global n_volname
    global n_incres
    global n_volume
    global n_vinc

    print_debug("nm_volume - Entering")

    # Check for v(expression) format.
    if n_tlength == 1 and n_lastend == "(":
        n_volume = nm_get_token(t_exp, n_pnt, -1)
        if n_volume is None:
            return None
        # fi
#--        NOTDONEYET("nm_volume)", x, er("badchar", n_lastend)')
        if n_lastend != ")":
            print_error_no_line("badchar n_lastend={}".format(n_lastend))
            return None
        # fi
        n_volname = 0
        if nm_get_token(t_space, n_pnt, -1) is None:        # check for < or >
            return None
        # fi
#--        NOTDONEYET("nm_volume - goto n_tlength == 0, x, er('badchar', n_token[1])")
        if n_tlength != 0:
            print_error_no_line("bad character n_token='{}'".format(n_token[1]))
            return None
        # fi
    # If no volume given and not in a crescendo, use previous value.
    elif n_tlength == 1:
#--        NOTDONEYET("nm_volume - goto n_increspn_staffon[1]] == 1, er('badvol2'), x")
        if n_incres[n_staffon[1]] == 1:
            print_error_no_line('badvol2')
            return None
        # fi
        n_volume = vol[n_staffon[1]]
        n_volname = voln[n_staffon[1]]
    # Check if named volume format.
    # The music print character set is used for plotting.
    elif n_token == 'vppp':
        n_volume = vppp
        n_volname = 1
    elif n_token == 'vpp':
        n_volume = vpp
        n_volname = 2
    elif n_token == 'vp':
        n_volume = vp
        n_volname = 3
    elif n_token == 'vmp':
        n_volume = vmp
        n_volname = 4
    elif n_token == 'vmf':
        n_volume = vmf
        n_volname = 5
    elif n_token == 'vf':
        n_volume = vf
        n_volname = 6
    elif n_token == 'vff':
        n_volume = vff
        n_volname = 7
    elif n_token == 'vfff':
        n_volume = vfff
        n_volname = 8
    # Must be v50 format.
    else:
        n_token[1] = " "  # get rid of the v
        NOTDONEYET("nm_volume - compute n_volume, n_token, n_tlength")
        p_formok = -1                     # NOTDONEYET - set from above compute.
        n_volume = 4                       # NOTDONEYET - set from above compute.
#--        NOTDONEYET("nm_volume - goto p_formok, x, er('badvol')")
        if p_formok >= 0:
            print_error_no_line('badvol')
            return None
        # fi
        n_volname = 0
    # fi
    # Check if beginning a crescendo/decrescendo.
    if n_lastend == ">":  # decrescendo
        n_vinc = -1
    elif n_lastend == "<":  # crescendo
        n_vinc = 1
    else:
        n_vinc = 0
    # fi
#--    NOTDONEYET("nm_volume - goto v_in(0, n_volume, 100) and v_in(0, n_volname, 8), x, er('voloor')")
    if v_in(0, n_volume, 100) and v_in(0, n_volname, 8):
        print_error_no_line('voloor')
        return None
    # fi
    print_debug("nm_volume exiting")
    return True
#   End of nm_volume

#=============================================================================
# Compile the note starting at "start". Get default values for unspecified
# parameters if "default" is -1. Restores "n_pnt" and "n_lastend" to their
# orginal values.
#
# start           # pointer to start of note
# default         # set default values if -1

def nm_compnote(start, default):
    global n_tlength
    global n_token
    global n_lastend
    global n_pnt

    print_debug("nm_compnote - Entering")

    # Save "n_pnt" and "n_lastend".
    pntsave = n_pnt
    lastsav = n_lastend
    # Compile the note.
    n_pnt = start
    if nm_get_token(t_strng, n_pnt, -1) is None:        # ignore leading spaces")
        return None
    # fi
    if nm_noteget0(default) is None:
        return None
    # fi
    # Get the delimiter after the note, if don't already have it.
    if n_lastend != "," and n_lastend != ";":
        if nm_get_token(t_strng, n_pnt, -1) is None:
            return None
        # fi
#--        NOTDONEYET("nm_compnote - goto n_tlength == 0, x, er('badchar', n_token[1])")
        if n_tlength != 0:
            print_error_no_line('bad char n_token[1]={}'.format(n_token[1]))
            return None
        # fi
    # fi
#--    NOTDONEYET("nm_compnote;", x, er("badchar", n_lastend)')
    if n_lastend != ";":
        print_error_no_line("bad char n_lastend={}".format(n_lastend))
        return None
    # fi
    # Restore "n_pnt" and "n_lastend".
    n_pnt = pntsave
    n_lastend = lastsav
    print_debug("nm_compnote - #10 n_lastend='{}'".format(n_lastend))
    print_debug("nm_compnote exiting")
    return True
#   End of nm_compnote

#=============================================================================
# Get note value off of the line. This subroutine will not write anything to
# binary; the value is returned in the same variables as nm_noteget uses.

def nm_valget():
    global n_token
    global n_lastend
    global n_pnt
    global n_part
    global n_notelen
    global n_flat
    global n_sharp
    global n_nat
    global n_mtied
    global n_mslur
    global n_mstac
    global n_dotted
    global n_mleg
    global n_mmarc
    global n_acct
    global n_grace
    global n_getime
    global n_ntime
    global n_dotted
    global n_ltype
    global n_ch

    print_debug("nm_valget - Entering n_lastend={}".format(n_lastend))

    # If tag was "0", return with notelen = 0.
#--    NOTDONEYET("nm_valget - goto lastend == 0, er('noval'), x")
    if n_lastend == 0:
        print_error_no_line('noval')
        return None
    # fi
    if nm_get_token(t_strng, n_pnt, -1) is None:
        print_debug("nm_valget - from nm_get_token: return None")
        return None
    # fi
#--    print_debug("nm_valget - after nm_get_token")
    n_ch = 0
    n_part = 2          # to find out what length
    n_notelen = -1        # dunno what it is yet
    n_flat = n_sharp = n_nat = n_mtied = n_mslur = n_mstac = n_dotted = 0       # init
    n_mleg = n_mmarc = n_acct = n_grace = 0
    n_getime = -1
    if nm_noteget1() is None:
#--        print_debug("nm_valget - after nm_noteget1: return None")
        return None
    # fi
#--    print_debug("nm_valget - after nm_noteget1 n_notelen={}".format(n_notelen))
#--    print_debug("nm_valget - n_flat={} n_sharp={} n_nat={} n_mstac={} n_mmarc={} n_mleg={} n_mtied={} n_mslur={} n_acct={} n_grace={}".format(n_flat,n_sharp,n_nat,n_mstac,n_mmarc,n_mleg,n_mtied,n_mslur,n_acct,n_grace))
#--    NOTDONEYET("nm_valget - goto notelen < 0 or (flat + sharp + nat + mstac + mmarc + mleg + mtied + mslur + acct + grace != 0), er('timerr'), x")
    if n_notelen < 0 or (n_flat + n_sharp + n_nat + n_mstac + n_mmarc + n_mleg + n_mtied + n_mslur + n_acct + n_grace != 0):
        print_error_no_line('timerr')
        return None
    # fi
    n_ntime = (2 - (.5 ** n_dotted)) / (n_ltype * n_notelen)
#--    print_debug("nm_valget exiting")
    return True
#   End of nm_valget

#=============================================================================
# tempo command.
#   tempo   120,4        $$ 120 quarter notes per minute
#   tempo   120,4,accel  $$ accelerate to next tempo command
#   tempo   120,4,rit    $$ decelerate
#   tempo   accel        $$ accelerate from current tempo
#  If accelerated or decelerated up to this tempo command,
#  this tempo command must specify a tempo.

def nm_tempo():
    global n_pnt
    global n_tempoc                   # Flag for making sure notes since last tempo command.
    global n_ntime

    print_debug("nm_tempo entering")
    if n_tempoc < 0:
        print_error_no_line('There have been no notes since last tempo')
        return None
    #-- do      stafflen(0)                        # Require all staffs to be the same length.

    # Check for "accel", or "rit" as only tag.
    if n_lastend == 0:
        print_error_no_line('too few arguments for tempo, need at least one')
        return None
    # fi
    ptr = n_pnt                                  # save position on line
    result = nm_get_token(t_strng, n_pnt, -1)
#--    print_debug("nm_tempo result={}  from nm_get_token - n_tlength={} n_lastend={} n_token='{}'".format(result,n_tlength,n_lastend,n_token))
    if result is None or (n_tlength == 0 and n_lastend == 0):
        print_error_no_line("too few arguments for tempo, need one.")
        return None
    # fi
    if n_token == 'accel' or n_token == 'rit':
        if n_lastend != 0:
            print_error_no_line('bad tempo single argument tempo')
            return None
        # fi
        if n_acclnow < 0:
            print_error_no_line('bad tempo, previous crescendo/ritard needs beats per minute on this one.')
            return None
        # fi
#--        wbin(ttinc)                                 # changing tempo
        n_acclnow = -1
        # Cannot have two tempo commands in a row if the first has an accel on it.
        n_tempoc = -1
    else:
        # Process numerical forms.
        beatspm = nm_get_token(t_exp, ptr, -1)                                   # get beats per minute
        if beatspm is None:
            return None
        # fi
#--        print_debug("nm_tempo beatspm={}  from nm_get_token - n_tlength={} n_lastend={} n_token='{}'".format(beatspm,n_tlength,n_lastend,n_token))
        if n_lastend != "," or beatspm is None:
            print_error_no_line('bad char "{}"'.format(n_lastend))
            return None
        # fi
        if nm_valget() is None:                                                 # get beat value
            print_debug("nm_tempo None from nm_valget")
            return None
        # fi
        if n_notelen == 0:
            print_error_no_line('time error')
            return None
        # fi
        vresult = 60.0 / (beatspm * n_ntime)
        if vresult < 0.01 or vresult > 60:
            print_error_no_line('bad tempo value 0.01 < {} < 60'.format(vresult))
            return None
        # fi
#--        wbin(ttempo)
#--        wfloat(vresult)
        # Check for third arg -- accel/rit.
        if n_lastend == 0:
            n_acclnow = 0                                 # no accelerando
        else:
            result = nm_get_token(t_strng, n_pnt, -1)
            if result is None:
                return None
            # fi
            if n_token != 'accel' and n_token != 'rit':
                print_error_no_line('third argument is not accel nor rit')
                return None
            elif n_lastend != 0:
                print_error_no_line('too many arguments for tempo command, only 3 maximum allowed')
                return None
            # fi
#--            wbin(ttinc)                                 # changing tempo
            n_acclnow = -1
            # Cannot have two tempo commands in a row if the first has an accel on it.
            n_tempoc = -1
        # fi
    # fi
    return True
#   End of nm_tempo

#=============================================================================
def nm_macro():
    print_debug(inspect.currentframe().f_code.co_name + " - Entering")
    return nm_defmacro(0)
    print_debug("nm_macro exiting")
#   End of nm_macro

#=============================================================================
def nm_process():
    print_debug(inspect.currentframe().f_code.co_name + " - Entering")
    return nm_defmacro(-1)
    print_debug("nm_process exiting")
#   End of nm_process

#=============================================================================
# Start of macro definition. "proc" = -1 if this is a process macro definition
# (only one arg allowed). First get each argument and delimiter and put in
# macro info buffer. Then get each line of macro text and put in macro text buffer.
#
# proc            # -1 if a process macro

def nm_defmacro(proc):
    global n_tlength
    global n_token
    global n_lastend
    global n_pnt
    global n_macname
    global n_mdelim0
    global n_inmacro
    global n_wary

    print_debug("nm_defmacro - Entering")
    if proc:
        start = 'process'
        end = 'endprocess'
    else:
        start = 'macro'
        end ='endmacro'
    # fi
    if n_lastend == 0:
        print_error_no_line("too few, start={}".format(start))
        return None
    # fi
    # Get macro name.
    if nm_get_token(t_strng, n_pnt, -1) is None:
        return None
    # fi
    if n_tlength == 0:
        print_error_no_line('too short of a macro name')
        return None
    # fi
    if n_tlength > 10:
        print_error_no_line('too long a name')
        return None
    # fi
    # Check for illegal or duplicating a {staff,command,macro,process} name.
    if n_token in n_sname:
        print_error_no_line('name already used as a staff name')
        return None
    # fi
    if n_token in n_commands:
        print_error_no_line('name already used as a command name')
        return None
    # fi
    if n_token in n_macname:
        print_error_no_line('name already used as a macro name')
        return None
    # fi
    # Store the macro name and initial delimiter.
    #-- loc = minfop + 1  # pointer to info for new macro
    #-- n_macname[n_nmacs + 1] = n_token
    mname = n_token
    #-- n_mdelim0[loc] = n_lastend
    # Store each argument and following delimiter.
    # Character string variable substitution is done for
    # all character strings defined previous to the macro definition.
    arg = 0
    args = []
    while True:
        pntsave = n_pnt
        if nm_get_token(t_cvnam, n_pnt, -1) is None:
            return None
        # fi
        if n_tlength == 0 and n_lastend == 0:
            break
        # fi
        if n_tlength == 0:
            print_error_no_line('bad macro argument')
            return None
        # fi
        if n_tlength > 20:
            print_error_no_line('macro argument too long')
            return None
        # fi
        # Make sure the macro dummy arguments are not defined
        # character string variables at macro definition time.
        print_debug("nm_defmacro#a - calling nm_findcvar")
        ret, ptr = nm_findcvar(pntsave, n_tlength, -1, -1)
        if n_wary is not None:
            print_error_no_line('illegal dummy argument name')
            return None
        # fi
        arg = arg + 1
        NOTDONEYET("nm_defmacro - marg(loc, arg) = n_token")
        NOTDONEYET("nm_defmacro - mchars(loc, arg) = n_tlength")
        NOTDONEYET("nm_defmacro - mdelim(loc, arg) = n_lastend")
        args.append([n_token, n_lastend])
    # elihw
    # Must have exactly one argument for a process macro.
    if proc < 0 and arg != 1:
        print_error_no_line('must have one argument for process macro')
        return None
    # fi
    n_macname.append({n_token: args})
    # Store number of args in macro, and start location of
    # macro text. Number of args is -1 for a process macro.
#--    if proc < 0:
#--        margs[loc] = -1
#--    else:
#--        margs[loc] = arg
#--    # fi
#--    mtext[loc] = msrcp + 1
    mtext = []
    # now read up macro text and put it into msource buffer.
    # (note that this macro may be defined within another!)
    # store n_tokens & the delimiters. if this is a macro,
    # count macro and endmacro commands. if this is a process,
    # count process and endprocess commands. if not in a
    # nested macro definition, store goto labels (and dont
    # put them into macro text buffer).
    n_inmacro = 1  # in a macro definition
    while True:
    # Get command from next line.
    # Stop at "=" to check for "goto" labels; if an "=" is found
    # but is not part of a "goto" label, get the rest of the line.
        if nm_get_token(t_space, -1, "=") is None:
            return None
        # fi
        if n_lastend == "=" and n_tlength != 0:
            if nm_get_token(t_space, 1, 0) is None:
                return None
            # fi
        # fi
    # count nested macro definition levels
        if n_token == start:
            n_inmacro = n_inmacro + 1
        elif n_token == end:
            n_inmacro = n_inmacro - 1
        # fi
    # exit if end of macro/process being defined
        if n_inmacro == 0:
            break
        # fi
#--    # Process -goto- labels. Ignore those that are in macros
#--    # that are defined inside of this one.
#--        if n_tlength == 0 and n_lastend == "=" and n_inmacro == 1:
#--            nm_label()
#--            continue
#--        # fi
    # Store this line in the macro source buffer. Note that
    # a single zero char follows the last char on the line,
    # and this is used to indicate end-of-line. "lchars" is
    # the number of chars on the line, excluding the last 0.
#--        if msrcp >= l.msrc:
#--            print_error_no_line('overflow macro text')
#--            return None
#--        # fi
        if n_lastend != 0:
            NOTDONEYET("nm_defmacro - pack n_token, n_tlength, @0a, n_token, n_tlength@1@0a, n_lastend@1")
        # fi
#--        NOTDONEYET("nm_defmacro - transfr n_token; s, msource(msrcp + 1); int(n_tlength / 10) + 1")
        mtext.append(n_token)
#--        msrcp = msrcp + int(n_tlength / 10) + 1
    # elihw
    # Store number of words of macro text.
    NOTDONEYET("nm_defmacro - mwords(loc) = msrcp - mtext(loc) + 1  # # words of text")
    # Set macro info pointer and update pointer to next free word in info buffer.
    minfop = minfop + 2 * abs(margs[loc]) + 1
    if n_lastend == 0:
        return True
    # fi
    print_error_no_line('too many arguments on line')
    return None
#   End of nm_defmacro

#=============================================================================
# command similar to tutor calcc:
#       calcc   m1 == f4, m2 = @p^u2, ,
# Evaluate expression and get proper tag.

def nm_calcc():
    global n_tlength
    global n_lastend
    global n_pnt
    global n_result

    print_debug("nm_calcc - Entering")

    if lastend == 0:
        print_error_no_line('toofew calcc')
        return None
    # fi
    n_result = nm_get_token(t_exp, n_pnt, -1)
    if n_result is None:
        return None
    # fi
    if n_lastend == 0:
        print_error_no_line('toofew calcc')
        return None
    # fi
    while True:
        ptr = n_pnt
        if nm_get_token(t_strng, n_pnt, ",") is None: # stop at comma
            return None
        # fi
        if n_result < 0:
            break
        # fi
        if n_lastend == 0:                        # if last tag, use it.
            break
        # fi
        n_result = n_result - 1
    # elihw
    if n_tlength > 0:
        n_result = nm_get_token(t_exp, ptr, -1)          # evaluate tag"
        if n_result is None:
            return None
        # fi
    # fi
    return True
#   End of nm_calcc

#=============================================================================
# Command similar to tutor calcs:
#       calcs   m1 - f4, m2 = @p^u2, 3, 4, 1, 5, 8, , 3, 1, ,

def nm_calcs():
    global n_tlength
    global n_token
    global n_lastend
    global n_pnt
    global n_result

    print_debug("nm_calcs - Entering")

    # evaluate expression
    if n_lastend == 0:
        print_error_no_line('too few calcs')
        return None
    # fi
    n_result = nm_get_token(t_exp, n_pnt, -1)
    if n_result is None:
        return None
    # fi
    if n_lastend == 0:
        print_error_no_line('too few calcs')
        return None
    # fi
    # save variable to store it in
    if nm_get_token(t_strng, n_pnt, "=") is None:       # stop at  =
        return None
    # fi
    if n_tlength < 1:
        print_error_no_line('too short')
        return None
    # fi
    if n_tlength > zcpw * varl:
        print_error_no_line('toolong')
        return None
    # fi
    varlth = n_tlength
    NOTDONEYET("nm_calcs - block n_token, var(1), varl  # save variable to assign to")
    # get proper tag
    while True:
        ptr = n_pnt
        if nm_get_token(t_strng, n_pnt, ",") is None:                # stop at comma
            return None
        # fi
        if n_result < 0:
            break
        # fi
        if n_lastend == 0:        # if last tag, use it.
            break
        # fi
        n_result = n_result - 1
    # elihw
    if n_tlength > 0:
        vresult = nm_get_token(t_exp, ptr, -1)         # evaluate tag
        if vresult is None:
            return None
        # fi
        NOTDONEYET("nm_calcs - block var(1), n_token, varl     # put var in n_token")
        n_tlength = varlth
        chk = nm_aassign(vresult)                         # assign to var
        if chk is None:
            return None
        # fi
    # fi
    return True
#   End of nm_calcs

#=============================================================================
def nm_calc():
    global n_lastend

    print_debug("nm_calc - Entering")
    if n_lastend == 0:
        print_error_no_line("too few calc")
        return None
    # fi
    nm_express()
    return True
#   End of nm_calc

#=============================================================================
# -encode- command. Used to manipulate character variables.
#
# encode  A = hi there; after,hi; upto,re
#
# The above command assigns the value " the" to A.
# The keywords are optional.
#
# encode  A = 4c4; octave,3; notelength,2
#
# The above command assigns the value "3c2" to A. If the string after the = is
# a note, compile that note and use keywords to change parameters of the note.
# If no string after the  = , start a note from scratch.
#
# The -debug- command calls this unit to process a character expression.
# "debug" will be -1.

def nm_encode():
    global n_tlength
    global n_token
    global n_lastend
    global n_pnt
    global n_vdimen
    global n_stfson
#--    global n_wary
    global n_staffon

    print_debug("nm_encode - Entering")

    if n_lastend == 0 and not(debug):
        print_error_no_line('toofew encode')
        return None
    # fi
    # Get the name of the character variable to assign to.
    # Not required if from -debug- command.
    pntsave = n_pnt
    if nm_get_token(t_cvnam, n_pnt, -1) is None:
        return None
    # fi
    savtlth = n_tlength
    # See if this character variable name is in symbol table (anywhere).
    print_debug("nm_encode#a - calling nm_findcvar")
    ret, varptr = nm_findcvar(pntsave, savtlth, -1, -1)
    varargvalues = [-1, -1]
    print_debug("nm_encode - ret={} varptr={}".format(ret,varptr))
    if varptr is not None and ret != savtlth:    # If not found, or shorter name than that passed in.
        print_error_no_line('badcvar encode #1')
        return None
    # fi
    # If char var array element, pick up the indices.
    n_vdimen = varptr[numarry_dimensions]
    print_debug("nm_encode - varptr={} n_vdimen={} varptr={}".format(varptr,n_vdimen,varptr))
    if varptr is not None and n_vdimen != 0:
        arg1 = arg2 = 1
        savedim = n_vdimen
        if n_lastend != "(":
            print_error_no_line("bad dimen n_vdimen={}".format(n_vdimen))
            return None
        # fi
        arg1 = nm_get_token(t_exp, n_pnt, -1)
        if arg1 is None:
            return None
        # fi
        if savedim == 2:
            if n_lastend != ",":
                print_error_no_line("bad dimen, need two but only have 1")
                return None
            # fi
            arg2 = nm_get_token(t_exp, n_pnt, -1)
            if arg2 is None:
                return None
            # fi
        # fi
        if n_lastend != ")":
            print_error_no_line("too many arguments for dimensions")
            return None
        # fi
        print_debug("nm_encode#b - calling nm_findcvar")
        ret, varptr = nm_findcvar(pntsave, savtlth, arg1, arg2)
        varargvalues = [arg1, arg2]
        print_debug("nm_encode#b1 - calling nm_get_token for =")
        if nm_get_token(t_strng, n_pnt, "=") is None:
            print_debug("nm_encode#b2 - got None from nm_get_token")
            return None
        # fi
        print_debug("nm_encode#b3 - after nm_get_token, n_token='{}'".format(n_token))
    # fi
    print_debug("nm_encode - here#1 varptr={}".format(varptr))
    if savtlth == 0 or n_lastend != "=":
        print_error_no_line('nocvar')
        return None
    else:
        if varptr is None:
            print_error_no_line('badcvar encode #2')
            return None
        # fi
    # fi
    # Get pointers to the string being assigned.
    start = n_pnt
    tagtype = 0
    append = appends = 0
    if nm_get_token(t_space, n_pnt, ";") is None:                # stop at ;
        return None
    # fi
    lth = n_tlength
    # Get the next keyword.
    print_debug("nm_encode - here#2")
    while True:
        print_debug("nm_encode - here#2a")
        if n_lastend == 0:
            break
        # fi
        print_debug("nm_encode - here#2b")
        if nm_get_token(t_strng, n_pnt, -1) is None:
            return None
        # fi
        print_debug("nm_encode - here#2c")
        if n_tlength == 0:  # delimiter-like keyword?
            lastsav = n_lastend
            if nm_get_token(t_strng, n_pnt, -1) is None:
                return None
            # fi
            if n_tlength != 0:
                print_error_no_line('badchar')
                return None
            # fi
            n_token = lastsav
        # fi
        # Find keyword in table.
        NOTDONEYET("nm_encode - find n_token, keyword(1), nkeywrd, keywdn")
        print_debug("nm_encode - here#2d")
        if keywdn < 0:
            print_error_no_line('badkeywd')
            return None
        # fi
        # Process "after" and "upto" keywords.
        print_debug("nm_encode - here#2e")
        if keywdn == 0 or keywdn == 1:
            if tagtype == 2:
                print_error_no_line('nomix')
                return None
            # fi
            if n_lastend != ",":
                print_error_no_line("bad char n_lastend)={}".format(n_lastend))
                return None
            # fi
            if nm_get_token(t_space, n_pnt, ";") is None:            # stop at ;
                return None
            # fi
            if n_tlength < 1:
                print_error_no_line('tooshort')
                return None
            # fi
            if n_tlength > 10:
                print_error_no_line('toolong')
                return None
            # fi
            if lth != 0:
                NOTDONEYET("nm_encode - search  n_token, n_tlength, line, start + lth - 1, start, ret")
                if ret < 0:         # not found
                    lth = 0
                elif keywdn == 0:      # after
                    lth = lth + start - ret - n_tlength
                    start = ret + n_tlength
                else:                    # upto
                    lth = ret - start
                # fi
            # fi
            tagtype = 1
        # Process the "explicit" keyword. Compile the note,
        # getting the default values for unspecified parameters.
        elif keywdn == 2:
            print_debug("nm_encode - here#2f")
            if tagtype == 1:
                print_error_no_line('nomix')
                return None
            elif tagtype > 1:
                print_error_no_line('exfirst')
                return None
            # fi
            if n_lastend == 0 or n_lastend == ";":
                pass
            else:
                print_error_no_line("bad char n_lastend={}".format(n_lastend))
                return None
            # fi
            if stfson == 0:
                print_error_no_line('noestaff')
                return None
            # fi
            compnote(start, -1)
            if sharp + nat + flat == 0 and ptype == 0:
                NOTDONEYET("nm_encode - ret = songacc(n_staffon[1], octave, notenam)")
                if ret < 0:
                    flat = -ret
                elif ret == 0:
                    nat = 1
                else:
                    sharp = ret
                # fi
            # fi
            tagtype = 2
        # Process the "number" keyword. Convert an number to alpha
        # characters, and append it to the end of the string.
        elif keywdn == 3:
            print_debug("nm_encode - here#2g")
            if tagtype == 2:
                print_error_no_line('nomix')
                return None
            # fi
            if n_lastend != ",":
                print_error_no_line("bad char n_lastend={}".format(n_lastend))
                return None
            # fi
            appendn = nm_get_token(t_exp, n_pnt, -1)
            if appendn is None:
                return None
            # fi
            if n_lastend == ";" or n_lastend == 0:
                pass
            else:
                print_error_no_line("bad char n_lastend={}".format(n_lastend))
                return None
            # fi
            append = -1 # set flag: append number
            tagtype = 1
        # Process the "staffname" keyword. Put the most recently
        # selected staff's name on the end of the char string.
        elif keywdn == 4:
            print_debug("nm_encode - here#2h")
            if tagtype == 2:
                print_error_no_line('nomix')
                return None
            # fi
            if n_lastend == ";" or n_lastend == 0:
                pass
            else:
                print_error_no_line("bad char n_lastend={}".format(n_lastend))
                return None
            # fi
            appends = -1 # set flag: append staffname
            tagtype = 1
        # Process other music keywords. If not already compiled,
        # compile the note, but don't get default values.
        else:
            print_debug("nm_encode - here#2i")
            if tagtype == 1:
                print_error_no_line('nomix')
                return None
            # fi
            if n_lastend != ",":
                print_error_no_line("bad char n_lastend={}".format(n_lastend))
                return None
            # fi
            if tagtype == 0:  # not compiled yet
                if stfson == 0:
                    print_error_no_line('noestaff')
                    return None
                # fi
                compnote(start, 0)
                tagtype = 2
            # fi
            muskeywd(keywdn)
        # fi
        print_debug("nm_encode - here#2j")
        # Go on to the next keyword, if any.
    # elihw
    #
    # Assign the final string to the character variable.
    # If compiling -debug-, return with the resulting string in "n_token".
    print_debug("nm_encode - here#3")
    if tagtype == 2:  # format a note
        print_debug("nm_encode - here#3a")
        if notechk(0) is None:
            return None
        # fi
        print_debug("nm_encode - here#3b")
        makenote()
    else:    # assign the string itself
        print_debug("nm_encode - here#3A")
        n_token = n_char[start:start+lth]
        n_tlength = lth
        if append:  # if there is a number to append
            NOTDONEYET("nm_encode - pack n_token, n_tlength, @0a, n_token, n_tlength@1@0s, appendn, 10@1")
        # fi
        print_debug("nm_encode - here#3B n_token={} n_tlength={}".format(n_token,n_tlength))
        if appends and n_staffon[1] != 0:  # append staff
            NOTDONEYET("nm_encode - pack n_token, n_tlength, @0a, n_token, n_tlength@1@0a, sname(n_staffon[1]), 10@1")
        # fi
        print_debug("nm_encode - here#3C")
    # fi
    print_debug("nm_encode - here#4 varptr={}".format(varptr))
    if varptr is not None:
        print_debug("nm_encode - calling nm_setcvar({})".format(varptr))
        chk = nm_setcvar(varptr, varargvalues)
        if chk is None:
            return None
        # fi
    # fi
    return True
#   End of nm_encode

#=============================================================================
# Decode command. First tag is a note or other notes line object. Each following
# tags is a pair of the form 'keyword,variable'. (Tags are separated by ";".)
# The first tag is compiled and values are assigned to each variable according
# to the keyword.
#       decode  4c+4; octave,oct; notenumber,num; duration,wholes
# Above command sets "oct" to 4, "num" to 49, and "wholes" to 0.25.

def nm_decode():
    global n_tlength
    global n_token
    global n_lastend
    global n_pnt
    global n_stfson

    print_debug("nm_decode - Entering")

    if stfson == 0:
        print_error_no_line('no staff')
        return None
    # fi
    if n_lastend == 0:
        print_error_no_line('too few decode')
        return None
    # fi
    # Compile the first tag.
    if nm_noteget(-1) is None:
        return None
    # fi
    if n_lastend != "," and n_lastend != ";" and n_lastend != 0:
        if nm_get_token(t_strng, n_pnt, -1) is None:
            return None
        # fi
        if n_tlength != 0:
            print_error_no_line('bad character n_token[1]={}'.format(n_token[1]))
            return None
        # fi
    # fi
    if n_lastend == ";" or n_lastend == 0:
        pass
    else:
        print_error_no_line("bad character n_lastend={}".format(n_lastend))
    # fi
    note_type = [-1, 0, 2, 3 + 2 * (ltype != 0)]
    notetyp = note_type[ptype + 1]      # turn -1 into 0.
    # Get the next keyword.
    while n_lastend != 0:
        if nm_get_token(t_strng, n_pnt, -1) is None:
            return None
        # fi
        if n_tlength == 0:  # delimiter-like keyword?
            lastsav = n_lastend
            if nm_get_token(t_strng, n_pnt, -1) is None:
                return None
            # fi
            if n_tlength != 0:
                print_error_no_line('bad character n_token[1]={}'.format(n_token[1]))
                return None
            # fi
            n_token = lastsav
        # fi
        if n_lastend != ",":
            print_error_no_line("bad character n_lastend={}".format(n_lastend))
            return None
        # fi
    # Find keyword in table. Disallow the first four.
        NOTDONEYET("nm_decode - find n_token, keyword(1), nkeywrd, ret")
        if ret <= 5:
            print_error_no_line('badkeywd')
            return None
        # fi
    # Get value to assign.
        NOTDONEYET("nm_decode - calcs   ret - 6, value  =                                    \
                octave, notenam, notenum, sharp, flat                       \
                nat, ltype, notelen, dotted, ntime                          \
                gliss, mtied, mmarc, mstac, mslur, mleg                     \
                onezero(acct == 1), onezero(acct == 2)                      \
                onezero(grace == 1), onezero(grace == 2)                    \
                onezero(stemdir == -1), onezero(stemdir == 1)               \
                onezero(bracket == 1), onezero(bracket == -1)               \
                onezero(simile == tarpeg), onezero(simile == tferm)         \
                onezero(simile == tlh), onezero(simile == trh)              \
                onezero(simile == tleg), onezero(simile == tstac)           \
                onezero(simile == tmarc), onezero(simile == ttied)          \
                onezero(simile == tslur), volume, volname                   \
                onezero(vinc != 0), pos, onezero(pan != 0)                  \
                notetyp                                                     \
                , , , , , onezero(simile == tnormal)                        \
                onezero(simile == tperc)                                    \
                onezero(simile == tnohead)                                  \
                onezero(simile == toloz), onezero(simile == tfloz)          \
                onezero(simile == toharm), onezero(simile == tfharm),       \
                onezero(simile == ttrem0), onezero(simile == ttrem1),       \
                onezero(simile == ttrem2), onezero(simile == ttrem3)")
    # Get variable and assign "value" to it.
        if nm_get_token(t_strng, n_pnt, ";") is None:            # stop at ;
            return None
        # fi
        nm_assign(value)
        if chk is None:
            return None
        # fi
    # elihw
    return True
#   End of nm_decode

#=============================================================================
def nm_clef():
    global n_token

    print_debug("nm_clef - Entering")

# Clef types: treble, bass, alto, tenor, soprano
#--    wbin(tclef)
    if n_token == 'treble':
#--        wbin(ctreble)
        pass
    elif n_token == 'bass':
#--        wbin(cbass)
        pass
    elif n_token == 'alto':
#--        wbin(calto)
        pass
    elif n_token == 'tenor':
#--        wbin(ctenor)
        pass
    elif n_token == 'soprano':
#--        wbin(csopran)
        pass
    # fi
    print_debug("nm_clef exiting")
#   End of nm_clef

#=============================================================================
# loop    condition
#
# Enter loop if tag is true (positive) or blank, skip to matching -endloop-
# if tag is false (negative).
#
# loop    index = start, end, increment
#
# Iterative loop with index variable "index". "increment" defaults to 1 if omitted.

def nm_loop():
    global n_tlength
    global n_lastend
    global n_pnt
    global n_inloop
    global n_result
    global n_loopind
    global n_loopinc
    global n_loopend
    global n_wary

    print_debug("nm_loop - Entering")

    # Save current state.
    print_debug("nm_get_token - call save_stack(2)")
    save_stack(2)               # which_stack   = 2     # for mvars for length l_mvars.
    n_inloop = n_inloop + 1    # increment loop level
    n_loopind = -1
    # If no tag, enter conditional loop. If one tag, enter
    # loop if true, or skip to -endloop- if false.
    if n_lastend == 0:     # no tag
        return True
    else:
        ptr1 = n_pnt
        n_result = nm_get_token(t_exp, n_pnt, -1)
        if n_result is None:
            return None
        # fi
        if n_lastend == 0:
            if n_result < 0:
                return True
            else:
                skiploop()
                return True
            # fi
            return None
        # fi
    # fi
    # If more than one tag, assume it's iterative. Get the
    # pointer to the index variable. Previous step has initialized the index variable.
    ptr2 = n_pnt
    if nm_get_token(t_strng, ptr1, -1) is None:
        return None
    # fi
    if n_tlength == 0 or n_lastend != "=":
        print_error_no_line("badloop")
        return None
    # fi
    print_debug("nm_loop - calling nm_findnvar({},{})".format(ptr1, n_tlength))
    wary = nm_findnvar(ptr1, n_tlength, False)
    if wary is None:
        print_error_no_line('badnvar')
        return None
    # fi
    n_loopind = wary
    # Get the ending value and increment.
    n_loopend = nm_get_token(t_exp, ptr2, -1)
    if n_loopend is None:
        return None
    # fi
    if n_lastend == 0:     # no increment
        n_loopinc = 1
    else:
        n_loopinc = nm_get_token(t_exp, n_pnt, -1)
        if n_loopinc is None:
            return None
        # fi
    # fi
    if n_lastend != 0:
        print_error_no_line('too many loops')
        return None
    # fi
    # Enter the loop unless index is past ending value.
    NOTDONEYET("nm_loop - transfr s, s.nvals + n_loopind; vresult; 1")
    if sign(n_loopinc) * (n_loopend - vresult) >= 0:
        return True
    # fi
    skiploop()
    return True
#   End of nm_loop

#=============================================================================
# -loop- tag was false, or iterative loop index was past ending value.
# Skip to matching -endloop-.

def nm_skiploop():
    global n_token
    global n_inloop

    print_debug("nm_skiploop - Entering")

    looplev = 0
    while looplev >= 0:
        if nm_get_token(t_novar, -1, -1) is None:              # get next command
            return None
        # fi
        if n_token == 'loop':  # check for loop & endloop
            n_inloop = n_inloop + 1
            looplev = looplev + 1
        elif n_token == 'endloop':
            n_inloop = n_inloop - 1
            looplev = looplev - 1
        # fi
    # elihw
    # Discard pointers to -loop- line from stack.
    nm_exitloop()
    return
#   End of nm_skiploop

#=============================================================================
# -endloop- command. Marks the end of a loop.
#
# If tag is true (negative): Exit the loop.
#
# If conditional loop: Start compiling at the -loop- command so its condition
# is tested again.
#
# If iterative loop: Add increment to index. Start compiling at line after
# -loop- command if index has not passed ending value. Otherwise, exit the loop.

def nm_endloop():
    global n_linecount
    global n_lastend
    global n_macnum
    global n_inloop
    global n_result
    global n_loopind
    global n_loopinc
    global n_loopend

    print_debug("nm_endloop - Entering")

    if n_inloop == 0:
        print_error_no_line('no loop command')
        return None
    # fi
    n_inloop = n_inloop - 1
    # Evaluate tag. If negative, discard pointers to -loop-
    # and contine compiling with next line.
    if n_lastend != 0:  # there is a tag
        nm_express()
        if n_result < 0:
            nm_exitloop()
            return True
        # fi
    # fi
    # If conditional loop, go back to line with -loop-.
    if n_loopind == -1:
        print_debug("nm_get_token - call restore_stack(2)")
        restore_stack(2)            # which_stack   = 2     # for mvars for length l_mvars.
        if macnum == 0:  # not in a macro
            linecount = linecount - 1
        # fi
        nextwrd = thiswrd
        return True
    # fi
    # If iterative loop, add increment to index. Go back to
    # the line after the -loop- unless index is past ending
    # value. Go back to start of loop by restoring all info
    # in the "s.mvars" buffer except for iterative looping info.
    NOTDONEYET("nm_endloop - transfr s, s.nvals + n_loopind; vresult; 1")
    vresult = vresult + n_loopinc
    NOTDONEYET("nm_endloop - transfr vresult; s, s.nvals + n_loopind; 1")
    if sign(n_loopinc) * (n_loopend - vresult) < 0:  # exit loop
        nm_exitloop()
    else:
        lpsave[1] = n_loopind  # don't restore the
        lpsave[2] = n_loopinc  # iteration info
        lpsave[3] = n_loopend
        print_debug("nm_get_token - call restore_stack(2)")
        restore_stack(2)            # which_stack   = 2     # for mvars for length l_mvars.
        print_debug("nm_get_token - call save_stack(2)")
        save_stack(2)               # which_stack   = 2     # for mvars for length l_mvars.
        n_loopind = lpsave[1]
        n_loopinc = lpsave[2]
        n_loopend = lpsave[3]
        n_inloop = n_inloop + 1
    # fi
    return True
#   End of nm_endloop

#=============================================================================
# Do stack manipulations necessary for exiting a loop: restore the iterative
# looping information to what it was before this loop, but do not change the
# other information in the "s.mvars" buffer.

def nm_exitloop():
    print_debug("nm_exitloop - Entering")

    # get iterative looping info as it was before this loop
    NOTDONEYET("nm_exitloop - block nc(s.mvars), savem(1), l.mvars")
    print_debug("nm_get_token - call restore_stack(2)")
    restore_stack(2)            # which_stack   = 2     # for mvars for length l_mvars.
    lpsave[1] = n_loopind
    lpsave[2] = n_loopinc
    lpsave[3] = n_loopend
    NOTDONEYET("nm_exitloop - block savem(1), nc(s.mvars), l.mvars")
    # update the iterative loop info in "s.mvars" but leave the other info as it was.
    n_loopind = lpsave[1]
    n_loopinc = lpsave[2]
    n_loopend = lpsave[3]
    print_debug("nm_exitloop exiting")
#   End of nm_exitloop

#=============================================================================
# Evaluate rest of line as an expression and return its result in "result"
# and "vresult". Used for calc, endloop, if, etc.

def nm_express():
    global n_lastend
    global n_pnt
    global n_result

    print_debug("nm_express - Entering")

    vresult = nm_get_token(t_exp, n_pnt, -1)
    if vresult is None:
        return None
    # fi
    n_result = vresult
    if n_lastend != 0:
        print_error_no_line('bad character n_lastend={}'.format(n_lastend))
        return None
    # fi
    print_debug("nm_express exiting")
#   End of nm_express

#=============================================================================
# Get staff name:
#
#  staff   staffnam: 1, 2, 3
#  staff   s2: 4, 5, 6
#
# It is possible to reassign voices to staves by using staff commands with the
# same name as previous staff cmnds.

def nm_staff():
    global n_tlength
    global n_token
    global n_lastend
    global n_pnt
    global n_stfson
    global n_result
    global n_temp
    global n_staffon

    print_debug("nm_staff - Entering")

    if n_tlength == 0:  # staff (x) form
        if n_lastend != "(":
            print_error("bad char n_lastend={}".format(n_lastend))
            return None
        # fi
        vresult = nm_get_token(t_exp, n_pnt - 1, ":")
        if vresult is None:
            return None
        # fi
        NOTDONEYET("nm_staff - pack n_token, n_tlength, @0s, vresult, 7@1")
    else:
        if nm_get_token(t_strng, n_pnt, -1) is None:
            return None
        # fi
    # fi
    if n_lastend == 0 or n_lastend == ":":
        pass
    else:
        print_error("bad char n_lastend={}".format(n_lastend))
        return None
    # fi
    if n_tlength < 1:
        print_error('tooshort')
        return None
    # fi
    if n_tlength > 5:
        print_error('toolong')
        return None
    # fi
    NOTDONEYET("nm_staff - find n_token, sname(1), staves, n_temp")
    if n_temp == -1: # not previously defined
        n_staffon[1] = staves = staves + 1
        stfson = 1
        sname[n_staffon[1]] = n_token
    # write out staff name.
#--        wbin(tstfnam)
#--        wbin(n_tlength)
        n_temp = 1
        while n_temp <= n_tlength:
#--            wbin(n_token[n_temp])
            n_temp = n_temp + 1
        # elihw
    else:
        n_staffon[1] = n_temp + 1
        stfson = 1
    # fi
    sins[n_staffon[1]] = 0
    # now get voices, if any.
#--    wbin(tstvc)
#--    wbin(n_staffon[1])
    if n_lastend != 0:                # skip if no instrs
        inschk = -1    # check duplicate instrs
        while True:
            n_result = nm_get_token(t_exp, n_pnt, -1)
            if n_result is None:
                return None
            # fi
            if n_result < 1 or n_result > l.voice:
                print_error('bad value for voice')
                return None
            # fi
#--            wbin(n_result)
            if n_result > voices:
                voices = n_result         # max number of voices
            # fi
            NOTDONEYET("nm_staff - sins[n_staffon[1]] = sins[n_staffon[1]] $union$ [1 $cls$ (n_result - 1)]")
            if n_lastend != ", ":
                break
            # fi
        # elihw
    # fi
#--    wbin(tstvce)    # end of staff selection
    stfson = 0
#--    if bfull:
#--        bfull()
#--    # fi
    if n_lastend == 0:
        return True
    # fi
    print_error('bad char n_lastend={}'.format(n_lastend))
    return None
#   End of nm_staff

#=============================================================================
# Process music keyword number "keywdn".
# integer:  keywdn        # keyword number

def nm_muskeywd(keywdn):
#--                      ntype         # != 0 if type change
#--                      ngrace        # != 0 if grace change
#--                      nacct         # != 0 if accent change
#--                      stem          # != 0 if stem direct change
#--                      brack         # != 0 if bracket change
#--                      sim           # != 0 if simile change
#--                      ret           # return var
#--            floating: value         # keyword value

    global n_lastend
    global n_pnt

    print_debug("nm_muskeywd - Entering")

    # Evaluate the expression after keyword.
    value = nm_get_token(t_exp, n_pnt, -1)
    if value is None:
        return None
    # fi
    if n_lastend == ";" or n_lastend == 0:
        pass
    else:
        print_error_no_line("bad char n_lastend={}".format(n_lastend))
        return None
    # fi
    ntype = stem = brack = sim = ngrace = 0
    nacct = 0
    # Set appropriate internal variables.
    if keywdn < 6:
        octave = value
    elif keywd == 6:
        notenam = value
    elif keywd == 7:
        notenum = value
    elif keywd == 8:
        sharp = value
    elif keywd == 9:
        flat = value
    elif keywd == 10:
        nat = value
    elif keywd == 11:
        ltype = value
    elif keywd == 12:
        notelen = value
    elif keywd == 13:
        dotted = value
    elif keywd == 14:
        ntime = value
    elif keywd == 15:
        gliss = value
    elif keywd == 16:
        mtied = value
    elif keywd == 17:
        mmarc = value
    elif keywd == 18:
        mstac = value
    elif keywd == 19:
        mslur = value
    elif keywd == 20:
        mleg = value
    elif keywd == 21:
        nacct = 1
    elif keywd == 22:
        nacct = 2
    elif keywd == 23:
        ngrace = 1
    elif keywd == 24:
        ngrace = 2
    elif keywd == 25:
        stem = 1
    elif keywd == 26:
        stem = -1
    elif keywd == 27:
        brack = 1
    elif keywd == 28:
        brack = -1
    elif keywd == 29:
        sim = tarpeg
    elif keywd == 30:
        sim = tferm
    elif keywd == 31:
        sim = tlh
    elif keywd == 32:
        sim = trh
    elif keywd == 33:
        sim = tleg
    elif keywd == 34:
        sim = tstac
    elif keywd == 35:
        sim = tmarc
    elif keywd == 36:
        sim = ttied
    elif keywd == 37:
        sim = tslur
    elif keywd == 38:
        volume = value
    elif keywd == 39:
        volname = value
    elif keywd == 40:
        vinc = value
    elif keywd == 41:
        pos = value
    elif keywd == 42:
        pan = value
    elif keywd == 43:
        ntype = 1
    elif keywd == 44:
        pass
    elif keywd == 45:
        pass
    elif keywd == 46:
        pass
    elif keywd == 47:
        pass
    elif keywd == 48:
        pass
    elif keywd == 49:
        sim = tnormal
    elif keywd == 50:
        sim = tperc
    elif keywd == 51:
        sim = tnohead
    elif keywd == 52:
        sim = toloz
    elif keywd == 53:
        sim = tfloz
    elif keywd == 54:
        sim = toharm
    elif keywd == 55:
        sim = tfharm
    elif keywd == 56:
        sim = ttrem0
    elif keywd == 57:
        sim = ttrem1
    elif keywd == 48:
        sim = ttrem2
    elif keywd == 59:
        sim = ttrem3
    else:
        b = a[1111]
    # Check to make sure that modifier is for proper type.
    if ptype == 4 and ltype != 0:  # standard notation rest
        if v_in(12, keywdn, 14) or keywdn == 16 or v_in(19, keywdn, 20) or v_in(25, keywdn, 26) or keywdn == 43:
            pass
        else:
            print_error_no_line('badptyp')
            return None
        # fi
    elif v_in(5, keywdn, 6) or v_in(8, keywdn, 13):
        if ptype != 0:
            print_error_no_line('badptyp')
            return None
        # fi
    elif keywdn == 7 or keywdn == 14:
        if ptype == 0:
            print_error_no_line('badptyp')
            return None
        # fi
    # fi
    if sim != 0:  # change simile
        if value == 1:
            simile = sim
        elif value == 0 and simile == sim:
            simile = 0
        # fi
    elif brack != 0:  # change bracket
        if value == 1:
            bracket = brack
        elif value == 0 and bracket == brack:
            bracket = 0
        # fi
    elif stem != 0:  # change stem direction
        if value == 1:
            stemdir = stem
        elif value == 0 and stemdir == stem:
            stemdir = 0
        # fi
    elif ngrace != 0:  # change grace note type
        if value == 1:
            grace = ngrace
        elif value == 0 and grace == ngrace:
            grace = 0
        # fi
    elif nacct != 0:  # change accent
        if value == 1:
            acct = nacct
        elif value == 0 and acct == nacct:
            acct = 0
        # fi
    elif ntype != 0:  # change type
        if value < 0:
            ptype = -1
        elif value == 0:
            ptype = 0
        elif value == 1:
            ptype = 4
        elif value == 2:
            ptype = 1
        else:
            ptype = 4
        # fi
        if notelen != -1 and value >= 2:
            ltype = 0
        # fi
    # fi
    return None
#   End of nm_muskeywd

#=============================================================================
# Compile the note starting at "start". Get default values for unspecified
# parameters if "default" is -1. Restores "pnt" and "n_lastend" to their
# original values.
#
# start           # pointer to start of note
# default         # set default values if -1

def nm_compnote(start, default):
    global n_tlength
    global n_token
    global n_lastend
    global n_pnt

    print_debug("nm_compnote - Entering")

    # Save "n_pnt" and "n_lastend".
    pntsave = n_pnt
    lastsav = n_lastend
    # Compile the note.
    n_pnt = start
    if nm_get_token(t_strng, n_pnt, -1) is None:     # ignore leading spaces")
        return None
    # fi
    if nm_noteget0(default) is None:
        return None
    # fi
    # Get the delimiter after the note, if don't already have it.
    if n_lastend != "," and n_lastend != ";":
        if nm_get_token(t_strng, n_pnt, -1) is None:
            return None
        # fi
        if n_tlength != 0:
            print_error_no_line('bad char n_token[1]={}'.format(n_token[1]))
            return None
        # fi
    # fi
    if n_lastend != ";":
        print_error_no_line("bad char n_lastend={}".format(n_lastend))
        return None
    # fi
    # Restore "n_pnt" and "n_lastend".
    n_pnt = pntsave
    n_lastend = lastsav
    print_debug("nm_compnote exiting")
    return True
#   End of nm_compnote

#=============================================================================
# Put character string into "n_token" for current note or other notes line object.

def nm_makenote():
    # Simile.

    global n_tlength
    global n_token

    print_debug("nm_makenote - Entering")

    if simile != -1:
        if simile == tarpeg:
            n_token = 'arp'
        elif simile == ttrem0:
            n_token = 'trem0'
        elif simile == ttrem1:
            n_token = 'trem1'
        elif simile == ttrem2:
            n_token = 'trem2'
        elif simile == ttrem3:
            n_token = 'trem3'
        elif simile == tferm:
            n_token = 'fermata'
        elif simile == trh:
            n_token = 'rh'
        elif simile == tlh:
            n_token = 'lh'
        elif simile == tnormal:
            n_token = 'normal'
        elif simile == tperc:
            n_token = 'perc'
        elif simile == tnohead:
            n_token = 'nohead'
        elif simile == toloz:
            n_token = 'oloz'
        elif simile == tfloz:
            n_token = 'floz'
        elif simile == toharm:
            n_token = 'oharm'
        elif simile == tfharm:
            n_token = 'fharm'
        else:
            if simile < tleg:
                n_token = 'simile?'
            elif simile == tleg:
                n_token = 'legato'
            elif simile == ttied:
                n_token = 'tie'
            elif simile == ttied:
                n_token = 'staccato'
            elif simile == ttied:
                n_token = 'marcato'
            elif simile == ttied:
                n_token = 'slur'
            else:
                n_token = 'simile?'
            # fi
        # fi
        n_tlength = chars(n_token)
    # Volume/crescendo.
    elif volume >= 0:
        NOTDONEYET("nm_makenote - packc   volname - 1, n_token, n_tlength,                        \
                v@0s, volume@1, vppp, vpp, vp, vmp, vmf, vf, vff, vfff")
        NOTDONEYET("nm_makenote - packc   vinc, n_token, n_tlength                                \
                @0a, n_token, n_tlength@1>                                          \
                @0a, n_token, n_tlength@1                                           \
                @0a, n_token, n_tlength@1<")
    # Postion/pan.
    elif pos >= 0:
        NOTDONEYET("nm_makenote - packc   pan, n_token, n_tlength                                 \
                @0s, pos@1<                                                     \
                @0s, pos@1                                                      \
                @0s, pos@1<")
    # Numeric notes.
    elif ptype != -1:
        if ltype == 0:
            if ptype == 4:  # rest
                NOTDONEYET("nm_makenote - pack n_token, n_tlength, (r, @0s, ntime, 15@1)")
            else:
                NOTDONEYET("nm_makenote - packc   gliss == 1, n_token, n_tlength                  \
                        (@0s, notenum, 5@1)@D                                   \
                        (@0s, notenum, 5@1, @0s, ntime, 15@1)")
            # fi
    # Standard notes.
        else:
            NOTDONEYET("nm_makenote - pack = 0")
            if ptype == 4:  # rest
                pack[1] = "r"
            else:
                NOTDONEYET("nm_makenote - packc   octave, pack(1), , , @0s, octave@1")
                NOTDONEYET('nm_makenote - calcs   notenam - 1, pack(2)  =                     \
                        "c", "d", "e", "f", "g", "a", "b"")')
            # fi
            NOTDONEYET('nm_makenote - calcs   flat - 1, pack(3) = 0, "-", "--"')
            NOTDONEYET('nm_makenote - calcs   nat - 1, pack(4) = 0, "n", "nn"')
            NOTDONEYET('nm_makenote - calcs   sharp - 1, pack(5) = 0, "+", "++"')
            NOTDONEYET('nm_makenote - calcs   gliss - 1, pack(6) = 0, "@D"')
            if notelen != -1:
                NOTDONEYET("nm_makenote - packc   ltype - 2, pack(7),                         \
                        @0s, notelen@1                                          \
                        @0s, ltype@1(@0s, notelen@1)")
            # fi
            NOTDONEYET('nm_makenote - calcs   dotted - 1, pack(8) = 0, "d", "dd"')
            NOTDONEYET("nm_makenote - pack n_token, n_tlength, @0a, pack(1), 80@1")
        # fi
    # Note modifiers.
        NOTDONEYET("nm_makenote - pack = 0")
        NOTDONEYET('nm_makenote - calcs   mtied - 1, pack(1) = 0, "t"')
        NOTDONEYET('nm_makenote - calcs   mleg - 1, pack(2) = 0, "l"')
        NOTDONEYET('nm_makenote - calcs   mstac - 1, pack(3) = 0, "s"')
        NOTDONEYET('nm_makenote - calcs   mmarc - 1, pack(4) = 0, "m"')
        NOTDONEYET('nm_makenote - calcs   mslur - 1, pack(5) = 0, "z"')
        NOTDONEYET('nm_makenote - calcs   grace - 1, pack(6) = 0, "g", "gg"')
        NOTDONEYET('nm_makenote - calcs   acct - 1, pack(7) = 0, "a", "aa"')
        NOTDONEYET('nm_makenote - calcs   stemdir, pack(8) = "@X", 0, "@W"')
        NOTDONEYET("nm_makenote - pack n_token, n_tlength, @0a, n_token, n_tlength@1@0a, pack(1), 80@1")
    # Chord brackets.
    elif bracket != 0:
        NOTDONEYET("nm_makenote - calcs   bracket, n_token = ']', '['")
        n_tlength = 1
    else:
        n_tlength = 0
    # fi
    print_debug("nm_makenote exiting")
#   End of nm_makenote

#=============================================================================
# nm_vars    cows, EAT, grass(2,10), ME(2,2)
#
# Define numeric or character variables.
#
# Above, "cows" is a single numeric variable. "grass" is a 2 by 10 array of
# numeric variables. One and two dimensional arrays are allowed.
#
# "EAT" is a character variable. ME is a two dimensional character variable.
#
# Variables defined within a macro are local to that macro and any macros it
# calls. Newly defined variables are initialized to zero.

def nm_vars():
    #--        varnam          # name of new variable
    #--         segment, vchar == varnam, 6  # chars of varnam
    #--        dimen           # dimension of numeric var
    #--        n_size1, n_size2    # size of each dimension
    #--        charvar         # -1 if char var, 0 if numeric var
    #--        vsymb(2)        # symbol table entry
    #--        ptr             # pointer into symbol table
    #--        ret             # return var
    #--        i               # loop index

    global n_tlength
    global n_token
    global n_lastend
    global n_pnt
    global n_maclev
    global n_vdimen
    global n_vn_size1
    global n_vn_size2
    global n_vlen

    print_debug("nm_vars - Entering")

    if n_lastend == 0:
        print_error_no_line("too few vars")
        return None
    # fi
    # Get the next variable name. First try to get a character
    # variable. If that doesn't work, assume its numeric.
    while True:
        ptr = n_pnt  # save position on line
        if nm_get_token(t_cvnam, n_pnt, -1) is None:
            return None
        # fi
        # Get numeric variable name.
        if n_tlength == 0:
            if nm_get_token(t_strng, ptr, -1) is None:
                return None
            # fi
            if n_tlength == 0:
                print_error_no_line('bad char n_lastend={}'.format(n_lastend))
                return None
            # fi
            varnam = n_token
            charvar = 0
        else:
            if n_lastend == "," or n_lastend == "(" or n_lastend == 0:
                pass
            else:
                print_error_no_line("bad character n_lastend={}".format(n_lastend))
                return None
            # fi
            varnam = n_token
            charvar = -1
        # fi
        # Check for funky variable names.
        if varnam[0].isdigit():
            print_error_no_line("badvname")
            return None
        # fi
        if '+' in varnam:
            print_error_no_line('badvname, cannot have a plus sign')
            return None
        elif '-' in varnam:
            print_error_no_line('badvname, cannot have a minus sign')
            return None
        # fi
        # Check if new var was previously defined at this macro
        # level. If not, find place to insert it in symbol table.
        if charvar < 0:
            for i in n_cvdef:
                if i[0] != varnam or i[1] != n_maclev:
                    continue
                # fi
                print_error_no_line('redefine cvdef')
                return None
            # rof
        else:
            for i in n_nvdef:                                 # NOTDONEYET nvdef -> cvdef with type(str) check.
                if i[0] != varnam or i[1] != n_maclev:
                    continue
                # fi
                print_error_no_line('redefine nvdef')
                return None
            # rof
        # fi
#--        if ptr >= 0:
#--            print_error_no_line('redefine')
#--            return None
#--        # fi
#--        ptr = -ptr
        # Check if new var has the same name as a compile time var.
        if not(charvar):
            NOTDONEYET("nm_vars - compute ret, varnam, 10")
            formok = -1                     # NOTDONEYET - set from above compute.
            ret = 4                       # NOTDONEYET - set from above compute.
            if formok < 0:
                print_error_no_line('compvar')
                return None
            # fi
        # fi
        # Get the dimension and sizes of the variable.
        if n_lastend == "(":
            n_size1 = nm_get_token(t_exp, n_pnt, -1)
            if n_size1 is None:
                return None
            # fi
            if n_size1 < 1:
                print_error_no_line('badarray')
                return None
            # fi
            if n_lastend == ",":
                n_size2 = nm_get_token(t_exp, n_pnt, -1)
                if n_size2 is None:
                    return None
                # fi
                if n_size2 < 1:
                    print_error_no_line('badarray')
                    return None
                # fi
                dimen = 2
            else:
                dimen = n_size2 = 1
            # fi
            if n_lastend != ")":
                print_error_no_line("bad character n_lastend={}".format(n_lastend))
                return None
            # fi
            if nm_get_token(t_strng, n_pnt, -1) is None:
                return None
            # fi
            if n_tlength != 0:
                print_error_no_line('bad character n_token[1]={}'.format(n_token[1]))
                return None
            # fi
        else:
            dimen = 0
            n_size1 = n_size2 = 1
        # fi
        if n_lastend == "," or n_lastend == 0:
            pass
        else:
            print_error_no_line("bad character n_lastend={}".format(n_lastend))
            return None
        # fi
        print_debug("nm_vars n_token='{}'".format(n_token))
        n_vdimen = dimen
        vn_size1 = n_size1
        vn_size2 = n_size2
        # Add the new variable to symbol table and initialize it.
        if charvar:
            if n_vdimen == 0:
                if nm_makecvar(varnam, 0, 0) is None:
                    return None
                # fi
            elif n_vdimen == 1:
                if nm_makecvar(varnam, n_size1, 0) is None:
                    return None
                # fi
            else:
                if nm_makecvar(varnam, n_size1, n_size2) is None:
                    return None
                # fi
            # fi
        else:
            vsymb[1] = varnam + maclev
            vsymb[2] = n_wary
            NOTDONEYET("nm_vars - inserts vsymb[1], s, nsymb(1); n_nvdef, 2, ptr")
            n_nvdef = n_nvdef + 1               # NOTDONEYET nvdef -> cvdef with type(str) check.
            NOTDONEYET("nm_vars - deletes s, s.nvals + n_nvwrds; n_size1 * n_size2, 1, 1, n_size1 * n_size2")
            n_nvwrds = n_nvwrds + n_size1 * n_size2
        # fi
        # Process the next tag.
        if n_lastend == 0:
            break
        # fi
    # elihw
    return True
#   End of nm_vars

# ============================================================================
global debug_count
debug_count = 0

def nm_debug():
    global debug_count

    debug_count = debug_count + 1
    # If no argument.
    if n_lastend == 0:
        value = 'count: ' + str(debug_count)
    else:
        ptr = n_pnt                                 # save position on line
        # Process numerical forms.
        value = nm_get_token(t_exp, ptr, -1)
        if value is None:                           # If error
            value = 'message: ' + n_char[ptr:]
        else:
            value = 'value: ' + str(value) + ' -- ' + n_char[ptr:]
        # fi
    # fi
    print('DEBUG ' + value, file=sys.stderr, flush=True)
    return True
#   End of nm_debug

#=============================================================================
def nm_repeat():                        # NOTDONEYET
    print_error_no_line("NOTDONEYET")
#   End of nm_repeat

def nm_measure():                       # NOTDONEYET
    print_error_no_line("NOTDONEYET")
#   End of nm_measure

def nm_title():                         # NOTDONEYET
    print_error_no_line("NOTDONEYET")
#   End of nm_title

def nm_endmacro():                      # NOTDONEYET
    print_error_no_line("NOTDONEYET")
#   End of nm_endmacro

def nm_if():                            # NOTDONEYET
    print_error_no_line("NOTDONEYET")
#   End of nm_if

def nm_else():                          # NOTDONEYET
    print_error_no_line("NOTDONEYET")
#   End of nm_else

def nm_elseif():                        # NOTDONEYET
    print_error_no_line("NOTDONEYET")
#   End of nm_elseif

def nm_endif():                         # NOTDONEYET
    print_error_no_line("NOTDONEYET")
#   End of nm_endif

def nm_randu():                         # NOTDONEYET
    print_error_no_line("NOTDONEYET")
#   End of nm_randu

def nm_randp():                         # NOTDONEYET
    print_error_no_line("NOTDONEYET")
#   End of nm_randp

def nm_setperm():                       # NOTDONEYET
    print_error_no_line("NOTDONEYET")
#   End of nm_setperm

def nm_instr():                         # NOTDONEYET
    print_error_no_line("NOTDONEYET")
#   End of nm_instr

def nm_tuning():                        # NOTDONEYET
    print_error_no_line("NOTDONEYET")
#   End of nm_tuning

def nm_goto():                          # NOTDONEYET
    print_error_no_line("NOTDONEYET")
#   End of nm_goto

def nm_print():                         # NOTDONEYET
    print_error_no_line("NOTDONEYET")
#   End of nm_print

def nm_time():                          # NOTDONEYET
    print_error_no_line("NOTDONEYET")
#   End of nm_time

def nm_format():                        # NOTDONEYET
    print_error_no_line("NOTDONEYET")
#   End of nm_format

def nm_stop():                          # NOTDONEYET
    print_error_no_line("NOTDONEYET")
#   End of nm_stop

def nm_endproc():                       # NOTDONEYET
    print_error_no_line("NOTDONEYET")
#   End of nm_endproc

def nm_include():                       # NOTDONEYET
    print_error_no_line("NOTDONEYET")
#   End of nm_include

#=============================================================================
global n_sname                  # staff names.
n_sname = { }

#=============================================================================
global n_commands
n_commands = {
    'tempo': nm_tempo,
    'repeat': nm_repeat,
    'measure': nm_measure,
    'title': nm_title,
    'macro': nm_macro,
    'endmacro': nm_endmacro,
    'loop': nm_loop,
    'endloop': nm_endloop,
    'if': nm_if,
    'else': nm_else,
    'elseif': nm_elseif,
    'endif': nm_endif,
    'staff': nm_staff,
    'calc': nm_calc,
    'calcs': nm_calcs,
    'randu': nm_randu,
    'randp': nm_randp,
    'setperm': nm_setperm,
    'instr': nm_instr,
    'tuning': nm_tuning,
    'debug': nm_debug,
    'goto': nm_goto,
    'calcc': nm_calcc,
    'print': nm_print,
    'time': nm_time,
    'format': nm_format,
    'decode': nm_decode,
    'stop': nm_stop,
    'vars': nm_vars,
    'encode': nm_encode,
    'process': nm_process,
    'endproc': nm_endproc,
    'include': nm_include,
}

#=============================================================================
# Main program follows.
def main():
    global header
    global measure_meter
    global measure_meter_value
    global args
    global file_name
    global output_descriptor
    global meter
    global key_default
    global which_file_in

    global n_notes
    global n_token
    global n_char
    global n_pnt
    global n_targcnt
    global n_lnotes
    global n_tlength
    global n_lastend
    global n_lastend
    global n_token
    global n_tlength
    global n_acclnow
    global n_process
    global n_inproc
    global n_temp

    parse_args()
    if args.vertical or args.horizontal:
        header = ( "meter   4/4\n" )
        key_default = "c"                   # Default to key of c.
                                            # At the end of header, print out the key - then follows notes.
        measure_meter = { '': '4/4'}        # Each measure change can have a different meter.
        measure_meter_value = 1             # Computed value for measure.
        meter = '4/4'
    elif args.midi1csv or args.fluidsynth:
        header = []
        key_default = 0                     # Default to key of C.
        measure_meter = { '': '4/4'}        # Each measure change can have a different meter.
        measure_meter_value = 1             # Computed value for measure.
        meter = '4/4'
    else:           # ABC
        header = (  "X:1\n" +               # Song number 1 in the output file.
                    "M:none\n" )            # No meter supposedly means don't check.
        key_default = "C"                   # Default to key of C.
                                            # At the end of header, print out the key - then follows notes.
        measure_meter = { '': 'none'}       # Each measure change can have a different meter.
        measure_meter_value = 1             # Computed value for measure.
        meter = 'none'
    # fi

    output_descriptor = sys.stdout
    if args.rest:
        if len(args.rest) >= 1:             # Input.
            which_file_in = args.rest[0]
            file_name = open(args.rest[0], 'r')
        # fi
        if len(args.rest) >= 2:             # Output.
            output_descriptor = open(args.rest[1], 'w')
        # fi
        if len(args.rest) > 2:              # Too many.
            print_error_no_line("Too many arguments, input, output only. {}".format(args.rest))
            sys.exit(1)
        # fi
    # fi

    # unit ml - main compiler loop.
    while True:
        n_targcnt = 0                       # number of var arguments
        if nm_get_token(t_strng, -1, -1) is None:
            continue
        # fi
        n_lnotes = n_notes                  # Previous notes line flag.
        n_notes = 0                         # Assume not a notes line.
        if n_tlength == 0:

            print_debug("main n_token='{}' n_tlength={} n_lastend={} n_pnt={} n_tparen={} n_br={} n_tvarptr={}".format( n_token, n_tlength, n_lastend, n_pnt, n_tparen, n_br, n_tvarptr))
            print_debug("main n_char='{}' n_macnum={} n_tstart={} n_targcnt={} n_targ={} n_vdimen={}".format( n_char, n_macnum, n_tstart, n_targcnt, n_targ, n_vdimen))

            if n_lastend == '=':
                # Ignore label
                print_debug("ml: label - n_token='{}' n_lnotes={} n_tlength={}".format(n_token, n_lnotes, n_tlength))
            else:
                # Ignore notes for now.
                print_debug("ml: unexpected delimiter for first n_token='{}' n_lnotes={} n_tlength={}".format(n_token, n_lnotes, n_tlength))
            # fi
            continue
        elif n_lastend == ':':                  # staffname: type of thing.
            print_debug("ml: staffname type of thing nm_notes(-1)")
            nm_notes(-1)
            continue
        elif not n_token[0].isalpha():
            print_debug("ml: token starts with non alpha thing n_token='{}' n_lnotes={} n_tlength={}".format(n_token, n_lnotes, n_tlength))
            nm_notes(-1)
            continue
        elif n_token in n_commands:
            if n_commands[n_token]() is None:     # if error occurred, ...
                pass
            # fi
            continue
        else:
            NOTDONEYET("find    n_token,command(1),ncomnd,n_temp")
            print_debug("main: n_token='{}' n_char='{}'".format(n_token, n_char))
            continue
        # fi
    # elihw
    do_pass2()
    sys.exit(errors_happened)
# End of main

# ----------------------------------------------------------------------------
if __name__ == '__main__':
    main()
# fi
# ----------------------------------------------------------------------------
exit(errors_happened)
# ----------------------------------------------------------------------------
# End of file tokens
# ----------------------------------------------------------------------------
