#!/usr/bin/python3 -B
# ----------------------------------------------------------------------------
# vim: tabstop=8 expandtab shiftwidth=4 softtabstop=4
# ----------------------------------------------------------------------------
import argparse
import os
import re
import readline
import sys
# ----------------------------------------------------------------------------
global errors_happened
errors_happened = 0
# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
global which_file_in
which_file_in = 'stdin'
global linecount
linecount = 0
global which_file_out
which_file_out = 'stdout'
global which_file_hint
which_file_hint = 'None'
# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
global input_file                   # File to read for input (default is use tty - stdin).
input_file = None
global output_file                  # File to print to (default is sys.stdout).
output_file = sys.stdout
global hint_file                    # File to print to (default is None).
hint_file = None
# ----------------------------------------------------------------------------
def print_stderr(strg):
    print(strg, file=sys.stderr, flush=True)
    return
# End of print_stderr

# ----------------------------------------------------------------------------
def print_debug(strg):
    print_stderr('DEBUG - ' + strg)
    return
# End of print_debug

# ----------------------------------------------------------------------------
def print_error(strg):
    print_stderr('ERROR - ' + strg)
    return
# End of print_error

# ----------------------------------------------------------------------------
def print_output(strg):
    global output_file

    print(strg.rstrip(), file=output_file, flush=True)
    return
# End of print_output

# ----------------------------------------------------------------------------
# NOTDONEYET - gcs output.
#-- def print_gcs(strg):
#--     global array_of_gcs
#-- 
#-- # TO DO: below is wrong.
#--     if len(array_of_gcs) > 0:
#--         last = array_of_gcs[-1]
#--         if last[0:6] == 'sleep ' and strg[0:6] == 'sleep ':
#--             new_time1 = float(last[6:])
#--             new_time2 = float(strg[6:])
#--             array_of_gcs[-1] = f'sleep {(new_time1 + new_time2):.3f}'
#--             return
#--         elif last == strg:                          # Delete duplicates.
#--             return
#--         # fi
#--     # fi
#--     array_of_gcs.append(strg)
#--     return
#-- # End of print_gcs

# ----------------------------------------------------------------------------
global args

# ----------------------------------------------------------------------------
def parse_args():
    global args

    parser = argparse.ArgumentParser(
        description=__doc__,
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog='this is the epilog')
    parser.add_argument('--lines', '-lines', action='store_true',
                        help='Print each line as it is read from file or macro or loop.')
    parser.add_argument('rest', nargs='*',
                        help='Optionals: inputfile(stdin) outputfile(stdout) hintfile(none)')
    args = parser.parse_args()
    return
# End of parse_args

# ----------------------------------------------------------------------------
parse_args()

# ----------------------------------------------------------------------------
global voices                       # Number of voices
voices = 1
# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
global array_of_original_lines      # For input, have an array of the original lines.
array_of_original_lines = []

# NOTDONEYET - gcs output.
#-- global array_of_gcs                 # For gcs first pass output.
#-- array_of_gcs = []

# ----------------------------------------------------------------------------
#-- # Following does not do multiple sharps or flats, but that is crazy anyway. Neither naturals.
#-- global key_sig
#-- key_sig = { 'c+':7, 'f+':6, 'b':5, 'bn':5, 'e':4, 'en':4, 'a':3, 'an':3, 'd':2,
#--             'dn':2, 'g':1, 'gn':1, 'c':0, 'cn':0, 'f':-1, 'b-':-2, 'e-':-3,
#--             'a-':-4, 'd-':-5, 'g-':-6, 'c-':-7 }
#-- 
#-- global key_sig_int
#-- key_sig_int = {}
#-- for i in key_sig:
#--     if key_sig[i] not in key_sig_int:
#--         key_sig_int[key_sig[i]] = i
#--     # fi
#-- # rof
#-- 
# ----------------------------------------------------------------------------
#-- global default_little_time
#-- default_little_time = 0.1
# ----------------------------------------------------------------------------
#-- def print_fluidsynth_header():
#--     # set audio.coreaudio.device coreaudio
#--     print_fs('set audio.driver coreaudio')
#--     print_fs('set midi.driver coremidi')
#--     print_fs('unload 1')
#--     print_fs('unload 2')
#--     print_fs('unload 3')
#--     print_fs('unload 4')
#--     print_fs('unload 5')
#--     print_fs('set synth.default-soundfont /Users/m4/src/GeneralUser/GeneralUser.sf2')
#--     print_fs('set synth.midi-channels 128')
#--     print_fs('set synth.verbose 0')
#--     print_fs('reset')
#--     print_fs('reset')
#--     print_fs('load /Users/m4/src/GeneralUser/GeneralUser.sf2')
#--     #
#--     print_fs('set synth.reverb.active 1')
#--     print_fs('set synth.reverb.room-size 0.61')
#--     print_fs('set synth.reverb.damp 0.23')
#--     print_fs('set synth.reverb.width 0.76')
#--     print_fs('set synth.reverb.level 0.57')
#--     #
#--     print_fs('set synth.chorus.active 1')
#--     print_fs('set synth.chorus.nr 3')
#--     print_fs('set synth.chorus.level 1.2')
#--     print_fs('set synth.chorus.speed 0.3')
#--     print_fs('set synth.chorus.depth 8')
#--     #
#--     print_fs('prog 00 000')
#--     #
#--     return
#-- # End of print_fluidsynth_header

# ----------------------------------------------------------------------------
global fs_other_echo
fs_other_echo = ''
global this_time
this_time = []
global MIDICLICKSPERQUARTER
MIDICLICKSPERQUARTER = 480.0
# ----------------------------------------------------------------------------
#-- def process_fs_check(what, lth, min_next, vtlines, tempo_s, tempo_l):
#--     global this_time
#--     global fs_other_echo
#--     global key_sig_int
#--     global voices
#--     global MIDICLICKSPERQUARTER
#-- 
#--     for voice, lines in vtlines.items():
#--         v = int(voice)
#--         if this_time[v] >= len(lines):
#--             continue
#--         # fi
#--         t = lines[this_time[v]].split(' ', 1) # 2 elements
#--         t[0].strip()
#--         time = float(t[0])
#--         while time <= min_next:
#--             strg = t[1].rstrip()
#--             if strg == 'End_track':
#--                 pass
#--             elif strg[0:lth] == what:
#--                 if what != 'cc':
#--                     print_fs(strg)
#--                 # fi
#--             elif strg[0:5] == 'echo ':           # echo 'measure xxx'
#--                 if strg[0:6] == 'echo "':
#--                     print_fs(f'{strg}')
#--                 elif strg != fs_other_echo:
#--                     strg1 = strg.replace('"', "'")
#--                     if strg1[0:11] == 'echo meter ':
#-- #--                         print_fs(f'echo "meter {meter_readable(strg1[11:])}"')
#--                         print_fs(f'echo "meter {strg1[11:]}"')
#--                     elif strg1[0:9] == 'echo key ':
#--                         x = strg1[9:]
#--                         y = x.split(' ', 1)          # Key number.
#--                         x = y[1]
#--                         y = int(y[0].replace(',', '').strip())
#--                         if y in key_sig_int:
#--                             y = key_sig_int[y].upper()
#--                         # fi
#--                         print_fs(f'echo "key {y} {x}"')
#--                     elif strg1[0:13] == 'echo Title_t ':
#--                         print_fs(f'echo "Title {strg1[13:]}"')
#--                     elif strg != fs_other_echo:
#--                         print_fs(f'echo "{strg1[5:]}"')
#--                     # fi
#--                     fs_other_echo = strg
#--                 # fi
#--             elif strg[0:7] == 'select ':
#--                 print_fs(f'{strg}')
#--             elif strg[0:4] == 'set ':
#--                 print_fs(f'{strg}')
#--             elif strg[0:6] == 'reset ':
#--                 print_fs(f'{strg}')
#--             elif strg[0:5] == 'load ':
#--                 print_fs(f'{strg}')
#--             elif strg[0:7] == 'unload ':
#--                 print_fs(f'{strg}')
#--             elif strg[0:5] == 'prog ':
#--                 print_fs(f'{strg}')
#--             elif strg[0:11] == 'pitch_bend ':
#--                 print_fs(f'{strg}')
#--             elif strg[0:6] == 'tempo ':
#--                 x = strg[6:].split()
#--                 if len(x) < 1 or len(x) > 2:
#--                     print_error('Tempo needs a speed - line="{t}"')
#--                 elif len(x) == 1:
#--                     #    1/(### / (60.0 * 1000000.0)) = 60.02400 = t              for l = 4 (quarter note).
#--                     tempo_s = int(1/(int(x[0]) / (60.0 * 1000000.0)))
#--                     tempo_l = 0.25
#--                 else:
#--                     tempo_s, tempo_l = strg[6:].split()
#--                 # fi
#--             elif strg[0:7] == 'Header ':
#--                 # f'0, 0, Header, 1, {len(volume)+1}, {round(MIDICLICKSPERQUARTER)}'
#--                 h = strg[7:].split(', ')
#--                 voices = int(h[1])
#--                 MIDICLICKSPERQUARTER = int(h[2])
#--             elif strg[0:3] == 'cc ':
#--                 break
#--             elif strg[0:8] == 'noteoff ':
#--                 h = strg[8:].split(', ')
#--                 break
#--             elif strg[0:7] == 'noteon ':
#--                 h = strg[7:].split(', ')
#--                 break
#--             else:
#--                 print_error(f'Unrecognized - line="{}"')
#-- #--                error_now = error_now + 1               # DIE NOW!
#-- #--                break
#--             # fi
#--             this_time[v] += 1
#--             if this_time[v] >= len(lines):
#--                 break
#--             # fi
#--             t = lines[this_time[v]].split(' ', 1) # 2 elements
#--             time = float(t[0])
#--         # elihw
#--     # rof
#--     return tempo_s, tempo_l
#-- # End of process_fs_check

# ----------------------------------------------------------------------------
# Thinking if we get each of the tracks in csvmidi format, in array, then go
# through them and order by:
    # track, time: In array order for each track.
    #       controls
    #       noteoff
    #       noteon
    # ... is that all that is needed? (And obvious format change.)

#-- def print_out_fluidsynth():
#--     global array_of_lines
#--     global this_time
#--     global default_little_time
#-- 
#--     change_name = {
#--         'Text_t': 'echo',
#--         'Title_t': 'echo Title_t',
#--         'Time_signature': 'echo meter',
#--         'Key_signature': 'echo key',
#--         'Note_on_c': 'noteon',
#--         'Note_off_c': 'noteoff',
#--         'Tempo': 'tempo',
#--         'Control_c': 'cc',
#--         'Pitch_bend_c': 'pitch_bend',
#--         # Track, Time, MIDI_port, Number This meta-event specifies that subsequent events in
#--         # the Track should be sent to MIDI port (bus) Number, between 0 and 255. This meta-event
#--         # usually appears at the start of a track with Time zero, but may appear within a track
#--         # should the need arise to change the port while the track is being played.
#--     }
#--     ignore_these = {
#--         'Copyright_t',
#--         'Marker_t',
#--         'End_of_file',
#--     }
#--     okay_these = {
#--         'Header',
#--         'MIDI_port',
#--     }
#--     midi_port = 0
#-- 
#--     v_t_lines = { }
#--     tempo_s = 60
#--     tempo_l = 0.5
#-- 
#--     max_midi_time = 0
#-- 
#--     voices = 0
#--     for i in array_of_lines:
#--         # "2, 5280, Note_on_c, 0, 43, 127"
#--         t = i.split(', ', 3)        # 4 elements.
#--         if len(t) < 3:
#--             print_die(f'line does not have MIDI format with voice, time, command - "{i}"')
#--         elif len(t) < 4:
#--             t.append('')
#--         # fi
#--         t[0] = t[0].strip()
#--         if t[0] not in v_t_lines:
#--             v_t_lines[t[0]] = []
#--         # fi
#--         if 2 > len(t) or t[2] == 'Start_track':
#--             continue
#--         # fi
#--         t[1] = t[1].strip()
#--         t[2] = t[2].strip()
#--         if t[2] in change_name:
#--             t[2] = change_name[t[2]]
#--             t[3] = t[3].strip()
#--             if t[2] != 'echo':
#--                 t[3] = t[3].replace(',', '').strip()
#--             # fi
#--             if t[2] == 'noteon':
#--                 h = t[3].split(' ')
#--                 if h[2] == '0':
#--                     t[2] = 'noteoff'
#--                 # fi
#--             # fi
#--         elif t[2] in ignore_these:
#--             continue
#--         elif t[2] in okay_these:
#--             if t[2] == 'MIDI_port':
#--                 midi_port = t[3]
#--                 continue
#--             # fi
#--             pass
#-- #--         elif t[2] == 'FS':
#-- #--             t[3] = t[3].strip()
#-- #--             t[2] = t[3]
#-- #--             t[3] = ''
#--         elif t[2] == 'Program_c':
#-- # select chan sfont bank prog
#--             t[2] = 'select'
#--             t[3] = t[3].strip()
#--             s = t[3].split(', ', 2)     # 3 elements - channel, bank, program.
#--             if len(s) < 3:
#--                 s += midi_port
#--             # fi
#--             if s[0] != '9':
#--                 t[3] = f'{s[0]} 1 {s[2]} {s[1]}'
#--             else:
#-- #               select 9 2 128 0  Combination of bank-select and program-change
#--                 t[3] = '{s[0]} 1 128 0'
#--             # fi
#--             t[2] = 'select'
#--         elif t[2] == 'End_track':
#--             if max_midi_time < float(t[1]):
#--                 max_midi_time = float(t[1])
#--             # fi
#--             t.append('')
#--         else:
#--             print_error('Unexpected midi command - t="{t}"')
#--         # fi
#--         if voices < int(t[0]):
#--             voices = int(t[0])
#--         # fi
#--         if t[2] == '' and t[3] == '':
#--             xxx = t[1]
#--         elif t[3] == '':
#--             xxx = t[1] + ' ' + t[2]
#--         else:
#--             xxx = ' '.join(t[1:])
#--         # fi
#-- #--         print_debug(f't[0]={t[0]} xxx={xxx}')
#--         v_t_lines[t[0]].append(xxx)
#--     # rof
#--     current_time = -1
#--     this_time = []
#--     for v in range(0, voices+1):
#--         this_time.append(0)
#--     # rof
#--     while current_time < max_midi_time:
#--         # Find smallest time difference.
#--         min_next = max_midi_time + 1
#--         for voice, lines in v_t_lines.items():
#--             v = int(voice)
#--             if this_time[v] >= len(lines):
#--                 continue
#--             # fi
#--             t = lines[this_time[v]].split(' ', 1) # 2 elements
#--             time = float(t[0])
#--             if min_next > time:
#--                 min_next = time
#--             # fi
#--         # rof
#--         if current_time >= 0 and (min_next - current_time) != 0:
#--             ms_1000 = float(min_next - current_time)
#--             if ms_1000 < default_little_time:
#--                 ms_1000 = default_little_time
#--             else:
#--                 # 480 => 250
#--                 ms_1000 = ms_1000 * 1000.0
#--                 ms_1000 = ms_1000 / ((float(tempo_s)/60.0) * (float(tempo_l) * 4.0))
#--                 ms_1000 = int((ms_1000 / MIDICLICKSPERQUARTER) * 1000)
#--                 ms_1000 = float(ms_1000) / 1000.0
#--             # fi
#--             print_fs(f'sleep {ms_1000}')
#--         # fi
#--         current_time = min_next
#--         # Move all this_time voices forward past min_next.
#--     # . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
#--         tempo_s, tempo_l = process_fs_check('cc', 2, min_next, v_t_lines, tempo_s, tempo_l)
#--         tempo_s, tempo_l = process_fs_check('noteoff', 7, min_next, v_t_lines, tempo_s, tempo_l)
#--         tempo_s, tempo_l = process_fs_check('noteon', 6, min_next, v_t_lines, tempo_s, tempo_l)
#--     # elihw
#-- 
#--     print_fs('quit')
#--     return
#-- # End of print_out_fluidsynth

# ----------------------------------------------------------------------------
global no_notes_yet
no_notes_yet = True

global titles
titles = ''
global comments
comments = ''
global key_default
key_default = None
global meter_default
meter_default = None
global key_previous
key_previous = None
global meter_previous
meter_previous = None
global instrument_bank          # Indexed by voice number.
instrument_bank = {}
global instrument_number        # Indexed by voice number.
instrument_number = {}

# ----------------------------------------------------------------------------
# FF 58 04 nn dd cc bb Time Signature
# The time signature is expressed as four numbers. nn and dd represent the numerator
# and denominator of the time signature as it would be notated. The denominator
# is a negative power of two: 2 represents a quarter-note, 3 represents an eighth-note,
# etc. The cc parameter expresses the number of MIDI clocks in a metronome click.
# The bb parameter expresses the number of notated 32nd-notes in a MIDI quarter-note
# (24 MIDI clocks). This was added because there are already multiple programs which
# allow a user to specify that what MIDI thinks of as a quarter-note (24 clocks) is
# to be notated as, or related to in terms of, something else.
# 
# Therefore, the complete event for 6/8 time, where the metronome clicks every three
# eighth-notes, but there are 24 clocks per quarter-note, 72 to the bar, would be (in hex):
#       FF 58 04 06 03 24 08
#                nn dd cc bb
# That is, 6/8 time (8 is 2 to the 3rd power, so this is 06 03), 36 MIDI clocks per
# dotted-quarter (24 hex!), and eight notated 32nd-notes per quarter-note. 
#    i.e. 2*32=1/16, 4*32=1/8, 8*32=1/4.  And a 1/4 note is 0x24 time deltas long.
# If the 8 was changed to 16, then a 1/2 note is 0x24 long. (0x24=36)

def meter_readable(strg):
    s = strg.split()
    if len(s) != 4:
        print_error(f'meter line does not have enough arguments, want 4, not {len(s)}.')
        return None
    # fi
    numerator = int(s[0])
    denominator = 2 ** int(s[1])
    return f'{numerator}/{denominator}'
# End of print_out_midi1csv_ts

# ----------------------------------------------------------------------------
global header_commands_ignore
header_commands_ignore = [ 'set', 'unload', 'load', 'reset', 'prog', 'sleep', 'pitch_bend' ]

def process_header_lines(q):
    global header_commands_ignore
    global titles
    global comments
    global key_default
    global key_previous
    global meter_default
    global meter_previous
    global instrument_bank
    global instrument_number

    if q[0] in header_commands_ignore:
        return
    # fi
    if q[0] == 'echo':
        if q[1][0:7] == '"Title ':
            titles += q[1][7:]
            return
        # fi
        if q[1][0:7] == '"meter ':
            if meter_default is not None and meter_previous != q[1]:
                print_error(f'Did not expect two meter lines - "{meter_previous}" verses "{q[0]}"')
                return
            # fi
            if q[1][-1] != '"':
                print_error('meter line expected to end with a double quote')
                return
            # fi
            meter_previous = q[1]
            meter_default = meter_readable(q[1][7:-1])
            print_debug(f'meter_default={meter_default}')
            return
        # fi
        if q[1][0:5] == '"key ':
            if key_default is not None and key_previous != q[1]:
                print_error(f'Did not expect two key lines that did not match - "{key_previous}" verses "{q[1]}"')
                return
            # fi
            a = q[1][5:].split(None)
            if len(a) < 2 or len(a) > 4:
                print_error(f'key line expects key followed by "major" not {q[1]}')
                return
            elif a[1] != "'major'\"":
                print_error(f'key line expects "major" not {q[1]}')
                return
            # fi
            key_previous = q[1]
            key_default = a[0]
            return
        # fi
        comments += q[1]
        return
    elif q[0] == 'select':
        a = q[1].split()
        if len(a) < 1 or len(a) > 4:
            print_error(f'select line wants 4 arguments not {len(a)} - {q[1]}')
            return
        # fi
        # a[0] = voice #
        # a[1] = timeclicks
        # a[2] = bank
        # a[3] = instrument
        vn = int(a[0])
        ibank = int(a[2])
        instr = int(a[3])
        if vn in instrument_bank:
            if instrument_bank[vn] != ibank or instrument_number[vn] != instr:
                print_error(f'select line for voice {vn} does not match previous bank {instrument_bank[vn]} instrument {instrument_number[vn]}')
                return
            # fi
            return
        # fi
        instrument_bank[vn] = ibank
        instrument_number[vn] = instr
        return
    else:
        print_error(f'Line is unexpected - {q}')
    # fi
    return
# End of process_header_lines

# ----------------------------------------------------------------------------
def process_note_lines(q):
    print_die('NOTDONEYET - process_note_lines')
# End of process_note_lines

# ----------------------------------------------------------------------------
# Parse and process line.
#
# Need: # voices used.
#   'cc'                # Maximum = total.
#   'select'            # Maximum = total.
#   'prog' decoding.    # Maximum = total.
# Need: Standard header removed.
#   Deleted everything until first select/cc/prog. (Keep echos.)
# Need: meter.
#   echo "meter"  -> meter.
# Need: title.
#   echo "        -> title if before any select/cc/noteon. (Edit down by hand.)
#                 -> comment if after noteon.

def process_line(original_line):
    global array_of_original_lines
    global no_notes_yet

    qline = original_line
    array_of_original_lines.append(qline)

    if qline is None:
        print_error('Line is None -- bad input.')
        return True
    elif qline == 'quit':
        return True                     # Done with input file.
    elif qline == '':
        print_error('Line is empty -- bad input -- but keep going.')
        return False
    # fi
    q = qline.split(None, 1)            # Command, arguments.
    if len(q) <= 1:
        print_error('Line must have a command and at least one argument, but keep going.')
        return False
    # fi
    if no_notes_yet and q[0] != 'noteon':
        process_header_lines(q)
        return False
    # fi
    no_notes_yet = False
    process_note_lines(q)
    return True
# End of process_line

# ----------------------------------------------------------------------------
# Get the next line, file, or macro.
# Return:
#   line        - the line without trailing spaces.
#   None        - if End of File.

def read_next_line():
    global args
    global linecount
    global which_in_filename
    global which_out_filename
    global input_file                   # File to read for input (default is use tty - stdin).
    global output_file                  # File to print to (default is sys.stdout).
    global errors_happened

    try:
        if input_file is not None:
            line = input_file.readline()
        else:
            if sys.stdin.isatty():
                if sys.platform == 'darwin':
                    input('input> ')
                    line = readline.get_line_buffer()
                else:
                    line = input('input> ')
                # fi
            else:
                line = sys.stdin.readline()
            # fi
        # fi
        if line is None or line == '':
            sys.exit(errors_happened)
        # fi
        linecount = linecount + 1
        if line:
            line = line.rstrip()                # trailing spaces gone.
            return line
        # fi
    except EOFError:
        pass            # print('Read gave EOF', file=sys.stderr, flush=True)
    except SystemExit:
        pass            # print('Read gave system exit', file=sys.stderr, flush=True)
    except KeyboardInterrupt:
        print_error('Read got keyboard interrupt')
    except:
        print_error('Read got a processing error')
        print_stderr('    ' + sys.exc_info()[0] + sys.exc_info)
    # yrt
    return None
# End of read_next_line

# ----------------------------------------------------------------------------
def readthefile():
    global linecount
    global args

    ifdone = False
    while not ifdone:                       # Read the file loop.
        line = read_next_line()
        if args.lines:
            print_stderr(f'linecount={linecount} line="{line}"')
        # fi
        if line is None:  # If end of file.
            return
        elif not line or len(line) <= 0 or line == '':
            continue
        # fi
        line = line.rstrip()
        if not line or len(line) <= 0 or line == '':
            continue
        # fi
        line = line.strip()
        if len(line) == 0:                                  # Ignore empty line.
            continue
        # fi
        ifdone = process_line(line)
    # elihw
    return
# End of readthefile

# ----------------------------------------------------------------------------
# Main program follows.
def main():
    global args
    global which_in_filename
    global which_out_filename
    global which_hint_filename
    global input_file                   # File to read for input (default is use tty - stdin).
    global output_file                  # File to print to (default is sys.stdout).
    global hint_file                    # File to print to (default is None).
    global array_of_original_lines

    if args.rest:
        if len(args.rest) >= 1:             # Input.
            which_file_in = args.rest[0]
            input_file = open(which_file_in, 'r')
        # fi
        if len(args.rest) >= 2:             # Output.
            which_file_out = args.rest[1]
            output_file = open(args.rest[1], 'w')
        # fi
        if len(args.rest) >= 3:             # Hint.
            which_file_hint = args.rest[2]
            hint_file = open(args.rest[2], 'r')
        # fi
        if len(args.rest) > 3:              # Too many.
            print_error(f'Too many arguments, input, output, hint only. {args.rest}')
            sys.exit(1)
        # fi
    # fi

    readthefile()

    for i in array_of_original_lines:
        print_output(i)
    # rof

#__     get_fluidsynth_header()
#__     convert_file_to_gcs()

#--     print_out_fluidsynth()
    return
# End of main

# ----------------------------------------------------------------------------
if __name__ == '__main__':
    main()
# fi
# ----------------------------------------------------------------------------
sys.exit(errors_happened)
# ----------------------------------------------------------------------------
# End of program fs2gcs
# ----------------------------------------------------------------------------
