#!/usr/bin/python3 -B
# Need to sort voices/channels by highest midi note first.
#      If chord note length is the same - sort notes in sort, highest first.
# ----------------------------------------------------------------------------
# vim: tabstop=8 expandtab shiftwidth=4 softtabstop=4
# ----------------------------------------------------------------------------
import argparse
import os
import re
import readline
import shlex
import sys
#-- import pprint
#-- # Usage:   pprint.pprint(v_t_lines, width=110, sort_dicts=False)

from fractions import Fraction
# ----------------------------------------------------------------------------
#++ import inspect
#++ print(inspect.currentframe().f_code.co_name, '#0', file=sys.stderr, flush=True)
# ----------------------------------------------------------------------------
import math
# ----------------------------------------------------------------------------
d = os.path.dirname(__file__)
while d.endswith('/.'):
    d = re.sub(r'/[.]$', r'', d)
# elihw
if d.endswith('/fs2gcs'):
    d = os.path.dirname(d)
    while d.endswith('/.'):
        d = re.sub(r'/[.]$', r'', d)
    # elihw
# fi
sys.path.insert(0, d)                       # for calculate.py

import calculate

calculate.cexp_parser()                     # initialize parser
#
# ============================================================================
global errors_happened              # Count of number of errors that occurred.
errors_happened = 0
global warnings_happened            # Count of number of warnings that occurred.
warnings_happened = 0
global line                         # For printing errors, the line to print.
line = ''
global line_from_file               # For printing errors, where the line came from.
line_from_file = ''
# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
global which_file_input             # Input file name (default to stdin).
which_file_input = 'stdin'
global linecount                    # Line number from input file
linecount = 0
global which_file_output            # Output file name (default to stdout).
which_file_output = 'stdout'
global which_file_hint              # Hint file name.
which_file_hint = 'None'
# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
global input_file                   # File to read for input (default is use tty - stdin).
input_file = None
global output_file                  # File to print to (default is sys.stdout).
output_file = sys.stdout
global hint_file                    # File for hints (default is None).
hint_file = None
# ----------------------------------------------------------------------------
def print_stderr(strg, end="\n"):
    print(strg, file=sys.stderr, flush=True, end=end)
    return
# End of print_stderr

# ----------------------------------------------------------------------------
def print_debug(strg, end="\n"):
    print_stderr('DEBUG - ' + strg, end=end)
    return
# End of print_debug

# ----------------------------------------------------------------------------
def print_error(strg):
    global errors_happened          # Count of number of errors that occurred.
    global line_from_file
    global line
    global linecount

    errors_happened = errors_happened + 1
    print_stderr(f'ERROR - {strg}')
    if line is not None:
        print_stderr(f'    {line_from_file}:{linecount} line={line}')
    # fi
    return
# End of print_error

# ----------------------------------------------------------------------------
def print_warning(strg):
    global warnings_happened        # Count of number of warnings that occurred.
    global line_from_file
    global line
    global linecount

    warnings_happened = warnings_happened + 1
    print_stderr('WARNING - ' + strg)
    if line is not None:
        print_stderr(f'    {line_from_file}:{linecount} line={line}')
    # fi
    return
# End of print_warning

# ----------------------------------------------------------------------------
def print_output(strg, end="\n"):
    global output_file

    print(strg.rstrip(), file=output_file, flush=True, end=end)
    return
# End of print_output

# ----------------------------------------------------------------------------
global args

# ----------------------------------------------------------------------------
def parse_args():
    global args

    parser = argparse.ArgumentParser(
        description=__doc__,
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog='this is the epilog')
    parser.add_argument('--lines', '-lines', action='store_true',
                        help='Print each line as it is read from file or macro or loop.')
    parser.add_argument('rest', nargs='*',
                        help='Optionals: inputfile(stdin) outputfile(stdout) hintfile(none)')
    args = parser.parse_args()
    return
# End of parse_args

# ----------------------------------------------------------------------------
parse_args()

# ----------------------------------------------------------------------------
global channels                     # Number of channels (instruments).
channels = None
global new_channels
new_channels = None
global last_fs_channel
last_fs_channel = None
# ----------------------------------------------------------------------------
MAXCHANNELS = 256
# ----------------------------------------------------------------------------
global MIDICLICKSPERQUARTER
MIDICLICKSPERQUARTER = 480.0
global tempo_s                      # 60 beats per quarter note.
tempo_s = 60
global tempo_l                      # The quarter note for tempo beats.
tempo_l = 0.25
global first_note_time              # When the first note starts.
first_note_time = 0                 # Nothing yet.
global running_time                 # The running time for 'sleep'. At end, it is the end.
running_time = 0                    # Nothing yet.
# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
global no_notes_yet
no_notes_yet = True
# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
global titles
titles = []
# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
global comments
comments = []
global comments_clicks
comments_clicks = []
# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
global echo_key                     # echo_key[channel] = ... .
echo_key = {}
echo_key['ALL'] = [ 'c' ]           # A default
global echo_key_clicks              # echo_key_clicks = running_time.
echo_key_clicks = {}
echo_key_clicks['ALL'] = [ 0 ]      # Default start of it.
global measures_key                 # Dictionary of measures [1-...]: key
measures_key = {}                   # measures_key[channel][measure] = key
global measures_instrument          # Dictionary of measures [1-...]: instruments
measures_instrument = {}            # measures_instrument[channel][measure] = instrument
# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
global instrument                   # Indexed by channel number.
instrument = {}                     # Array by channel: [bank, number, running_time]
# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
global meter                        # Printable meter (text).
meter = []
global meter_fractions              # MIDICLICKSPERQUARTER*4 * meter_fraction (clicks per measure)
meter_fractions = []
global meter_clicks                 # Where in running time clicks the meter occurred.
meter_clicks = []
global last_measure                 # Set in 2nd pass, figuring out measure placements - last measure number.
last_measure = None
global measures_clicks_start        # Dictionary of clicks for when measure starts.
measures_clicks_start = {}
global measures_clicks_length       # Dictionary of clicks in each measure.
measures_clicks_length = {}
global measures_meter               # Dictionary of meter_string for when measure starts.
measures_meter = {}
# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
global bufs_notes_channel           # Array of notes for chords on this channel.
bufs_notes_channel = {}
global bufs_notes                   # Midi note number. An array indexed by channel.
bufs_notes = {}                     # bufs_notes[ch] = []            Midi note number.
global bufs_notes_start             # calculated clicks to start of each note for a channel.
bufs_notes_start = {}
global bufs_notes_end               # calculated clicks to end of each note for a channel.
bufs_notes_end = {}                 #   Used to recognize 'chords'.
global bufs_notes_velocity          # The intensity of note start. (Typically the total volume. *sigh*)
bufs_notes_velocity = {}
global bufs_cc_start                # [channel][cc#]      time in clicks when CC occurred.
bufs_cc_start = {}
global bufs_cc_end                  # [channel][cc#]      time in clicks when CC occurred.
bufs_cc_end = {}
global last_cc                      # If doing a note, the last_cc. NOTE: defaults for 7,10,11,64,68,91.
last_cc = {}
global bufs_suffix
bufs_suffix = {}
global bufs_gcs_length
bufs_gcs_length = {}
global bufs_gcs_note
bufs_gcs_note = {}

for ch in range(0, MAXCHANNELS):    # Channels if multiple-notes turned on, use to alternative(s).
    bufs_notes_channel[ch] = []     # Start with 1:1 channel to chord channel. Note: channels global set with Header -> max.
    bufs_notes[ch] = []             # No notes yet.
    bufs_notes_start[ch] = []       # No starting time click time for notes.
    bufs_notes_end[ch] = []         # No ending time click time for notes.
    bufs_notes_velocity[ch] = []    # No note start intensity volume levels.
    bufs_cc_start[ch] = []          # No starting cc values.
    bufs_cc_end[ch] = []            # No ending cc values.
    bufs_suffix[ch] = []            # No suffixes yet.
    bufs_gcs_length[ch] = []        # GCS note length.
    bufs_gcs_note[ch] = []          # GCS note.
    last_cc[ch] = []
    for cc in range(0, 127):
        bufs_cc_start[ch].append([]) # No starting cc's.
        bufs_cc_end[ch].append([])  # No ending cc's.
        last_cc[ch].append(0)       # No previous cc's.
        if cc == 7:
            last_cc[ch][cc] = 100   # default_volume variable.
        elif cc == 10:
            last_cc[ch][cc] = 64    # default_pan variable.
        elif cc == 11:
            last_cc[ch][cc] = 100   # default_intensity variable.
        elif cc == 64:
            last_cc[ch][cc] = 0     # damper off.
        elif cc == 68:
            last_cc[ch][cc] = 0     # legato off.
        elif cc == 91:
            last_cc[ch][cc] = 0     # reverb none.
        else:
            last_cc[ch][cc] = 0     # Otherwise intialize to 0.
        # fi
    # rof
# rof
# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
global array_of_original_lines      # For input, have an array of the original lines.
array_of_original_lines = []
# ----------------------------------------------------------------------------
# These are from the Hints file, and are for printing out the GCS source.
global staff_hint                   # hint staff name to channel number.
staff_hint = {}
global bars_measures_hint           # hint number of bars per measure.
bars_measures_hint = {}
global clef_channel_measures_hint   # hint clefs by ChannelNumber and measure.
clef_channel_measures_hint = {}
global instrument_channel_measures_hint # hint instrument by ChannelNumber and measure.
instrument_channel_measures_hint = {}
global key_channel_measures_hint    # hint key by ChannelNumber and measure.
key_channel_measures_hint = {}
global meters_measures_hint         # hint text for meters by measures.
meters_measures_hint = {}
global meters_values_hint           # hint value for meters by measures.
meters_values_hint = {}
global pages_measures_hint          # hint number of pages by measures.
pages_measures_hint = {}
global pages_measures_hint_comments # hint number of pages by measures.
pages_measures_hint_comments = {}
global xpose_channel                # Transpose ChannelNumber up/down this many semi-tones.
xpose_channel = {}
global skip_measure_hint            # Delete these measures during print_gcs.
skip_measure_hint = {}
# ----------------------------------------------------------------------------
global midi_2_note_lengths                          # clicks => ( '4', 1.0 / 4 )
midi_2_note_lengths = {}
global midi_2_note_lengths_nl                       # note values (1,2,4,8,...) -> 480,240,120,...
midi_2_note_lengths_nl = {}
global midi_2_note_lengths_sorted_keys
midi_2_note_lengths_sorted_keys = []
global midi_2_note_lengths_dotted                   # clicks => ( '4', 1.0 / 4 )
midi_2_note_lengths_dotted = {}
global midi_2_note_lengths_dotted_sorted_keys
midi_2_note_lengths_dotted_sorted_keys = []
global midi_2_note_lengths_double_dotted            # clicks => ( '4', 1.0 / 4 )
midi_2_note_lengths_double_dotted = {}
global midi_2_note_lengths_double_dotted_sorted_keys
midi_2_note_lengths_double_dotted_sorted_keys = []
global CLICKS_SLOP
CLICKS_SLOP = 8589934592
# ----------------------------------------------------------------------------
global acc_v_init_v_or_h            # Last accidental on a note in measure.
acc_v_init_v_or_h = { '0c':'', '0d':'', '0e':'', '0f':'', '0g':'', '0a':'', '0b':'',
                      '1c':'', '1d':'', '1e':'', '1f':'', '1g':'', '1a':'', '1b':'',
                      '2c':'', '2d':'', '2e':'', '2f':'', '2g':'', '2a':'', '2b':'',
                      '3c':'', '3d':'', '3e':'', '3f':'', '3g':'', '3a':'', '3b':'',
                      '4c':'', '4d':'', '4e':'', '4f':'', '4g':'', '4a':'', '4b':'',
                      '5c':'', '5d':'', '5e':'', '5f':'', '5g':'', '5a':'', '5b':'',
                      '6c':'', '6d':'', '6e':'', '6f':'', '6g':'', '6a':'', '6b':'',
                      '7c':'', '7d':'', '7e':'', '7f':'', '7g':'', '7a':'', '7b':'',
                      '8c':'', '8d':'', '8e':'', '8f':'', '8g':'', '8a':'', '8b':''}
# ----------------------------------------------------------------------------
def do_note_length_calculate():
    global MIDICLICKSPERQUARTER
    global midi_2_note_lengths
    global midi_2_note_lengths_nl
    global midi_2_note_lengths_sorted_keys
    global midi_2_note_lengths_dotted
    global midi_2_note_lengths_dotted_sorted_keys
    global midi_2_note_lengths_double_dotted
    global midi_2_note_lengths_double_dotted_sorted_keys
    global CLICKS_SLOP

    for nl in (1,2,4,8,16,32,64,128):
        # note length.
        m = (MIDICLICKSPERQUARTER / 0.25) / nl
        if int(m * 1000) != int(m)*1000:        # Ignore non-completely-divisable numbers.
            pass
        else:
            m = int(m)
            if m == 0:
                print_debug(f'Note length {nl} gives midi click value of 0')
            else:
                if m < CLICKS_SLOP:             # Smallest note value that is fully divisable.
                    CLICKS_SLOP = m - 1
                # fi
                midi_2_note_lengths_sorted_keys.append(m)
                midi_2_note_lengths[m] = ( str(nl), 1.0 / nl )
                midi_2_note_lengths_nl[nl] = m
            # fi
        # fi
    # rof
    for nl in (1,2,4,8,16,32,64,128):
        # Dotted note lengths.
        md = ((MIDICLICKSPERQUARTER / 0.25) / nl) * 1.5
        if int(md * 1000) != int(md)*1000:      # Ignore non-completely-divisable numbers.
            pass
        else:
            md = int(md)
            if md == 0:
                print_debug(f'Note length {nl} gives midi click value of 0')
            elif md not in midi_2_note_lengths:
                midi_2_note_lengths_dotted_sorted_keys.append(md)
                midi_2_note_lengths_dotted[md] = ( str(nl) + 'd', (1.0/nl)*1.5 )
                if md < CLICKS_SLOP:                # Smallest note value that is fully divisable.
                    CLICKS_SLOP = md - 1
                # fi
            else:
                print_debug(f'Note length {nl}d has clicks {md} already in array as {midi_2_note_lengths[md]}')
            # fi
        # fi
    # rof

    for nl in (1,2,4,8,16,32,64,128):
        # double dotted note lengths.
        mdd = ((MIDICLICKSPERQUARTER / 0.25) / nl) * 1.75
        if int(mdd * 1000) != int(mdd)*1000:        # Ignore non-completely-divisable numbers.
            pass
        else:
            mdd = int(mdd)
            if mdd == 0:
                print_debug(f'Note length {nl} gives midi click value of 0')
            elif mdd not in midi_2_note_lengths and mdd not in midi_2_note_lengths_dotted:
                midi_2_note_lengths_double_dotted_sorted_keys.append(mdd)
                midi_2_note_lengths_double_dotted[mdd] = ( str(nl) + 'd' + 'd', (1.0/nl)*1.75 )
                if mdd < CLICKS_SLOP:               # Smallest note value that is fully divisable.
                    CLICKS_SLOP = mdd - 1
                # fi
            else:
                print_debug(f'Note length {nl}dd has clicks {mdd} already in array as {midi_2_note_lengths[mdd]}')
                print_debug(f'or in dotted array {midi_2_note_lengths_dotted[mdd]}')
            # fi
        # fi
    # rof
    return
# End of do_note_length_calculate

# ----------------------------------------------------------------------------
# Insert a rest @ entry n, channel ch, starting note time, ending time.

def insert_rest(ch, n, start, end):
    global bufs_notes                   # Midi note number. An array indexed by measure, channels.
    global bufs_notes_start             # calculated clicks to start of each note for a channel.
    global bufs_notes_end               # calculated clicks to end of each note for a channel.
    global bufs_notes_velocity          # The intensity of note start. (Typically the total volume. *sigh*)
    global bufs_cc_start                # [channel][cc#]    time in clicks when CC occurred.
    global bufs_cc_end                  # [channel][cc#]    CC when note stops occurred.
    global bufs_gcs_length
    global bufs_gcs_note
    global bufs_suffix                  # No suffixes yet.

    note_start = start
    note_end = end
    if n > len(bufs_notes[ch]):
        bufs_notes_start[ch].append(start)
        bufs_notes_end[ch].append(end)
        bufs_notes[ch].append(0)
        bufs_notes_velocity[ch].append(0)
        bufs_cc_start[ch][7].append(0)
        bufs_cc_end[ch][7].append(0)
        bufs_cc_start[ch][10].append(0)
        bufs_cc_end[ch][10].append(0)
        bufs_cc_start[ch][11].append(0)
        bufs_cc_end[ch][11].append(0)
        bufs_cc_start[ch][64].append(0)
        bufs_cc_end[ch][64].append(0)
        bufs_cc_start[ch][65].append(0)
        bufs_cc_end[ch][65].append(0)
        bufs_cc_start[ch][91].append(0)
        bufs_cc_end[ch][91].append(0)
        bufs_gcs_length[ch].append('')
        bufs_gcs_note[ch].append('')
        bufs_suffix[ch].append('')
        return
    # fi
    bufs_notes_start[ch].insert(n, start)
    bufs_notes_end[ch].insert(n, end)
    bufs_notes[ch].insert(n, 0)
    bufs_notes_velocity[ch].insert(n, 0)
    bufs_cc_start[ch][7].insert(n, 0)
    bufs_cc_end[ch][7].insert(n, 0)
    bufs_cc_start[ch][10].insert(n, 0)
    bufs_cc_end[ch][10].insert(n, 0)
    bufs_cc_start[ch][11].insert(n, 0)
    bufs_cc_end[ch][11].insert(n, 0)
    bufs_cc_start[ch][64].insert(n, 0)
    bufs_cc_end[ch][64].insert(n, 0)
    bufs_cc_start[ch][65].insert(n, 0)
    bufs_cc_end[ch][65].insert(n, 0)
    bufs_cc_start[ch][91].insert(n, 0)
    bufs_cc_end[ch][91].insert(n, 0)
    bufs_gcs_length[ch].insert(n, '')
    bufs_gcs_note[ch].insert(n, '')
    bufs_suffix[ch].insert(n, '')
    return
# End of insert_rest

# ----------------------------------------------------------------------------
def short_note_and_split_it(ch, n, note_ends_here, lth_first_note):
    global bufs_notes                   # Midi note number. An array indexed by measure, channel.
    global bufs_notes_start             # calculated clicks to start of each note for a channel.
    global bufs_notes_end               # calculated clicks to end of each note for a channel.
    global bufs_notes_velocity          # The intensity of note start. (Typically the total volume. *sigh*)
    global bufs_cc_start                # [channel][cc#]      time in clicks when CC occurred.
    global bufs_cc_end                  # [channel][cc#]      CC when note stops occurred.
    global bufs_gcs_length
    global bufs_gcs_note
    global bufs_suffix                  # No suffixes yet.

    bufs_notes_start[ch].insert(n, bufs_notes_start[ch][n])
    bufs_notes_start[ch][n + 1] = bufs_notes_start[ch][n + 1] + lth_first_note
    bufs_notes_end[ch].insert(n, note_ends_here)
    bufs_notes[ch].insert(n, bufs_notes[ch][n])
    bufs_notes_velocity[ch].insert(n, bufs_notes_velocity[ch][n])
    bufs_gcs_length[ch].insert(n, '')
    bufs_gcs_note[ch].insert(n, '')
    bufs_cc_start[ch][7].insert(n, bufs_cc_start[ch][7][n])
    bufs_cc_end[ch][7].insert(n, bufs_cc_end[ch][7][n])
    bufs_cc_start[ch][10].insert(n, bufs_cc_start[ch][10][n])
    bufs_cc_end[ch][10].insert(n, bufs_cc_end[ch][10][n])
    bufs_cc_start[ch][11].insert(n, bufs_cc_start[ch][11][n])
    bufs_cc_end[ch][11].insert(n, bufs_cc_end[ch][11][n])
    bufs_cc_start[ch][64].insert(n, bufs_cc_start[ch][64][n])
    bufs_cc_end[ch][64].insert(n, bufs_cc_end[ch][64][n])
    bufs_cc_start[ch][65].insert(n, bufs_cc_start[ch][65][n])
    bufs_cc_end[ch][65].insert(n, bufs_cc_end[ch][65][n])
    bufs_cc_start[ch][91].insert(n, bufs_cc_start[ch][91][n])
    bufs_cc_end[ch][91].insert(n, bufs_cc_end[ch][91][n])
    if bufs_notes[ch][n] != 0:
        bufs_suffix[ch].insert(n, 't')
    else:
        bufs_suffix[ch].insert(n, '')
    # fi
    return
# End of short_note_and_split_it

# ----------------------------------------------------------------------------
def notes_fit_into_measures():
    global channels
    global last_measure
    global bufs_notes
    global bufs_notes_start
    global bufs_notes_end
    global bufs_gcs_length
    global bufs_gcs_note
    global measures_clicks_start
    global measures_clicks_length
    global running_time
    global CLICKS_SLOP

    ch = 0
    while channels is not None and ch <= channels:
        if len(bufs_notes[ch]) is None or len(bufs_notes[ch]) <= 0:
            ch = ch + 1
            continue
        # fi
        m = 1                           # measure number 1
        n = 0                           # first note in bufs_notes[ch]
        where_we_are = first_note_time  # first measure should be this value too.
        while m <= last_measure:
            note_start = bufs_notes_start[ch][n]
            if abs(where_we_are - note_start) <= CLICKS_SLOP:
                note_start = where_we_are
                bufs_notes_start[ch][n] = where_we_are
            # fi
            note_end = bufs_notes_end[ch][n]
            if where_we_are < measures_clicks_start[m]:
                insert_rest(ch, n, where_we_are, measures_clicks_start[m])
                continue
            # fi
            if where_we_are < note_start:
                insert_rest(ch, n, where_we_are, note_start)
                continue
            # fi
            measure_click_end = measures_clicks_start[m] + measures_clicks_length[m]
            # At this point where_we_are >= note_start ... so, should be equal. :)
            # So now we know that note_start is in this measure, and we are ready to play it.
            if note_end < measures_clicks_start[m]:
                print_error(f'note_end ({note_end}) < measure_clicks_start[{m}] ({measures_clicks_start[m]})')
                return
            # fi
            if abs(measure_click_end - note_end) <= CLICKS_SLOP:
                note_end = measure_click_end
                bufs_notes_end[ch][n] = measure_click_end
            # fi

            if note_end < measure_click_end or note_start == note_end:            # Note plays.
                if note_start != note_end:
                    n = n + 1                               # To next note.
                else:
                    bufs_notes[ch].pop(n)                   # Remove zero length note.
                    bufs_notes_velocity[ch].pop(n)
                    bufs_notes_start[ch].pop(n)
                    bufs_notes_end[ch].pop(n)
                    bufs_gcs_length[ch].pop(n)
                    bufs_gcs_note[ch].pop(n)
                    bufs_cc_start[ch][7].pop(n)
                    bufs_cc_end[ch][7].pop(n)
                    bufs_cc_start[ch][10].pop(n)
                    bufs_cc_end[ch][10].pop(n)
                    bufs_cc_start[ch][11].pop(n)
                    bufs_cc_end[ch][11].pop(n)
                    bufs_cc_start[ch][64].pop(n)
                    bufs_cc_end[ch][64].pop(n)
                    bufs_cc_start[ch][65].pop(n)
                    bufs_cc_end[ch][65].pop(n)
                    bufs_cc_start[ch][91].pop(n)
                    bufs_cc_end[ch][91].pop(n)
                    if n > 0:
                        # Tie to essentially a nothing note is tossed.
                        bufs_suffix[ch][n-1] = bufs_suffix[ch][n]   # Move suffix backwards.
                    # fi
                    bufs_suffix[ch].pop(n)
                # fi
                where_we_are += (note_end - note_start)
                if n >= len(bufs_notes[ch]):
                    if where_we_are >= running_time:    # At end of song.
                        break
                    # fi
                    # insert rest to end of song.
                    insert_rest(ch, n, where_we_are, running_time)
                    continue
                # fi
                if where_we_are >= measure_click_end or note_end == measure_click_end:
                    m = m + 1
                # fi
                continue
            # fi
            # Note: note_end > measure_click_end
            # Note is too long, insert short note before, with tie, and shorten next note by this length.
            # End of new note is at measure_click_end, and length of this note is last arg, and shorten by that.
            short_note_and_split_it(ch, n, measure_click_end, measure_click_end - note_start)
            n = n + 1
            where_we_are += (measure_click_end - note_start)
            if where_we_are >= measure_click_end or note_end == measure_click_end:
                m = m + 1
            # fi
            continue
        # elihw
        if len(bufs_notes_start[ch]) > 0:
            note_start = bufs_notes_start[ch][-1]
            note_end = bufs_notes_end[ch][-1]
            if note_start == note_end:
                bufs_notes[ch].pop(n)                    # Remove zero length note.
                bufs_notes_velocity[ch].pop(n)
                bufs_notes_start[ch].pop(n)
                bufs_notes_end[ch].pop(n)
                bufs_gcs_length[ch].pop(n)
                bufs_gcs_note[ch].pop(n)
                bufs_cc_start[ch][7].pop(n)
                bufs_cc_end[ch][7].pop(n)
                bufs_cc_start[ch][10].pop(n)
                bufs_cc_end[ch][10].pop(n)
                bufs_cc_start[ch][11].pop(n)
                bufs_cc_end[ch][11].pop(n)
                bufs_cc_start[ch][64].pop(n)
                bufs_cc_end[ch][64].pop(n)
                bufs_cc_start[ch][65].pop(n)
                bufs_cc_end[ch][65].pop(n)
                bufs_cc_start[ch][91].pop(n)
                bufs_cc_end[ch][91].pop(n)
                bufs_suffix[ch].pop(n)
            # fi
        # fi
        ch = ch + 1
    # while
    return
# End of notes_fit_into_measures

# ----------------------------------------------------------------------------
def check_contiguous_notes():
    global channels
    global bufs_notes
    global first_note_time
    global bufs_notes_start
    global bufs_notes_end

    ch = 0
    while channels is not None and ch <= channels:
        if len(bufs_notes[ch]) is None or len(bufs_notes[ch]) <= 0:
            ch = ch + 1
            continue
        # fi
        prev_end = first_note_time
        for n in range(0, len(bufs_notes[ch])):
            note_start = bufs_notes_start[ch][n]
            if prev_end != note_start:
                print_error(f'check_contiguous_notes - channel={ch} measure={m} n={n} - note_start({note_start}) != prev_end ({prev_end})')
                die('something wrong.')
            # fi
            note_end = bufs_notes_end[ch][n]
            if note_start >= note_end:
                print_error(f'check_contiguous_notes - channel={ch} measure={m} n={n} - note_start({note_start}) >= note_end({note_end})')
                die('something wrong.')
            # fi
            prev_end = note_end
        # rof
        ch = ch + 1
    # elihw
    return
# End of check_contiguous_notes

# ----------------------------------------------------------------------------
# Returns:
#     which_q_ptr    = {midi_2_note_lengths, midi_2_note_lengths_dotted, midi_2_note_lengths_double_dotted}
#     which_q_single = entry in which_q_ptr.
#     closest_single = abs(diff between which_q_single and this note length) - i.e. left-over amount.

def check_note_lth(lth):
    global midi_2_note_lengths
    global midi_2_note_lengths_dotted
    global midi_2_note_lengths_double_dotted
    global midi_2_note_lengths_sorted_keys
    global midi_2_note_lengths_dotted_sorted_keys
    global midi_2_note_lengths_double_dotted_sorted_keys

    closest_single = 8589934592
    which_q_ptr = None
    which_q_single = None
    for q in midi_2_note_lengths_sorted_keys:
        c = abs(lth - q)
        if c < closest_single:
            which_q_ptr = midi_2_note_lengths
            closest_single = c
            which_q_single = q
            if which_q_single == 0:
                return which_q_ptr, which_q_single, closest_single
            # fi
        # fi
    # rof
    for q in midi_2_note_lengths_dotted_sorted_keys:
        c = abs(lth - q)
        if c < closest_single:
            which_q_ptr = midi_2_note_lengths_dotted
            closest_single = c
            which_q_single = q
            if which_q_single == 0:
                return which_q_ptr, which_q_single, closest_single
            # fi
        # fi
    # rof
    for q in midi_2_note_lengths_double_dotted_sorted_keys:
        c = abs(lth - q)
        if c < closest_single:
            which_q_ptr = midi_2_note_lengths_double_dotted
            closest_single = c
            which_q_single = q
            if which_q_single == 0:
                return which_q_ptr, which_q_single, closest_single
            # fi
        # fi
    # rof
    return which_q_ptr, which_q_single, closest_single
# End of check_note_lth

# ----------------------------------------------------------------------------
# Returns:
#     which_q_ptr    = {midi_2_note_lengths, midi_2_note_lengths_dotted, midi_2_note_lengths_double_dotted}
#     which_q_single = entry in which_q_ptr.
#     closest_3      = abs(diff between which_q_single and this note length) - i.e. left-over amount.
def check_single_note_lth(ch, n):
    global bufs_notes_start
    global bufs_notes_end

    note_start = bufs_notes_start[ch][n]
    note_end = bufs_notes_end[ch][n]
    lth = note_end - note_start
    which_q_ptr, which_q_single, closest_single = check_note_lth(lth)
    return which_q_ptr, which_q_single, closest_single
# End of check_single_note_lth

# ----------------------------------------------------------------------------
# Returns:
#     which_q_ptr    = {midi_2_note_lengths, midi_2_note_lengths_dotted, midi_2_note_lengths_double_dotted}
#     which_q_x      = entry in which_q_ptr.
#     closest_x      = abs(diff between which_q_x and this note length) - i.e. left-over amount.
#     x              = number in sequence.

def check_triplets(ch, n, m, closet_single):
    global bufs_notes_start
    global bufs_notes_end
    global measures_clicks_start
    global measures_clicks_length

    which_q_ptr = None
    which_q_x = None
    closest_x = 8589934592
    saved_x = 0                                         # Set for return, not used if closes

    if n+3 > len(bufs_notes[ch]):
        return which_q_ptr, which_q_x, closest_x, saved_x
    # fi
    # Cannot have a rest in a triplet. (Although reality is that it could ...)
    if bufs_notes[ch][n] == 0 or bufs_notes[ch][n + 1] == 0:
        return which_q_ptr, which_q_x, closest_x, saved_x
    # fi

    lth1 = bufs_notes_end[ch][n] - bufs_notes_start[ch][n]
    lth2 = bufs_notes_end[ch][n + 1] - bufs_notes_start[ch][n + 1]
    if lth1 != lth2:
        return which_q_ptr, which_q_x, closest_x, saved_x
    # fi
    lth = lth1 + lth2
    if bufs_notes_start[ch][n] + lth > measures_clicks_start[m] + measures_clicks_length[m]:
        return which_q_ptr, which_q_x, closest_x, saved_x
    # fi

    # It is possible for dotted, double dotted note lengths to be a sequence/trill.
    #      3          4          5         6         7        8         9        10.
    # triple, quadruple, quintuple, sextuple, septuple, octuple, nontuple, dectuple.
    for x in range(3, 40):
        if n + x >= len(bufs_notes_end[ch]):            # Not enough notes for more.
            return which_q_ptr, which_q_x, closest_x, saved_x
        # fi
        lth_xy =  bufs_notes_end[ch][n + x] - bufs_notes_start[ch][n + x]
        if lth1 != lth_xy:                              # +/- one ... lengths must be the same.
            return which_q_ptr, which_q_x, closest_x, saved_x
        # fi

        lth =  lth + lth_xy
        # If goes beyond end of measure, stop.
        if bufs_notes_start[ch][n] + lth > measures_clicks_start[m] + measures_clicks_length[m]:
            return which_q_ptr, which_q_x, closest_x, saved_x
        # fi

        # which_q_ptr    = {midi_2_note_lengths, midi_2_note_lengths_dotted, midi_2_note_lengths_double_dotted}
        # which_q_x      = entry in which_q_ptr.
        # closest_x      = abs(diff between which_q_x and this note length) - i.e. left-over amount.
        new_q_ptr, new_q_x, new_x = check_note_lth(lth)
        if new_x < closet_single and new_x <= closest_x:
            closest_x = new_x
            which_q_ptr = new_q_ptr
            which_q_x = new_q_x
            saved_x = x
        # fi
    # rof
    return which_q_ptr, which_q_x, closest_x, saved_x
# End of check_triplets

# ----------------------------------------------------------------------------
def check_staccatto(ch, n, m, newlth, which_q_ptr):
    global bufs_notes_start
    global bufs_notes_end

    # Note followed by something...
    if n + 1 >= len(bufs_notes_end[ch]):
        return
    # fi
    # Note followed by rest.
    if bufs_notes[ch][n] == 0 or bufs_notes[ch][n + 1] != 0:
        return
    # fi
    # Following note must be in same measure.
    note_end_2 = bufs_notes_end[ch][n + 1]
    # NOTDONEYET - rest goes over measure. Could be staccato at end of measure, followed by rest.
    if note_end_2 > measures_clicks_start[m] + measures_clicks_length[m]:
        return
    # fi

    note_start_1 = bufs_notes_start[ch][n]
    note_end_1 = bufs_notes_end[ch][n]
    lth1 = note_end_1 - note_start_1
    note_start_2 = bufs_notes_start[ch][n + 1]
    lth2 = note_end_2 - note_start_2
    # The lengths of the note and rest must be about the same.
    l_12 = int(abs(lth1 - lth2)) >> 1
    if l_12 != 0:          # +/- one.
        return
    # fi
    # Add staccato and delete following rest.
    bufs_suffix[ch][n] = bufs_suffix[ch][n] + 's'
    # New note end.
    bufs_notes_end[ch][n] = bufs_notes_end[ch][n + 1]
    if newlth not in which_q_ptr:
        print_error(f'check_staccatto - newlth={newlth} not in which_q_ptr={list(which_q_ptr.keys())}')
        return
    # fi

    # NOTDONEYET - rest goes over measure. Staccato at end of measure -- break rest, do not delete.

    bufs_gcs_length[ch][n] = which_q_ptr[newlth][0]

    # Delete rest.
    del bufs_notes_end[ch][n + 1]
    del bufs_notes_start[ch][n + 1]

    del bufs_notes[ch][n + 1]
    del bufs_notes_velocity[ch][n + 1]

    del bufs_gcs_length[ch][n + 1]
    del bufs_gcs_note[ch][n + 1]
    del bufs_suffix[ch][n + 1]

    del bufs_cc_start[ch][7][n + 1]
    del bufs_cc_end[ch][7][n + 1]

    del bufs_cc_start[ch][10][n + 1]
    del bufs_cc_end[ch][10][n + 1]

    del bufs_cc_start[ch][11][n + 1]
    del bufs_cc_end[ch][11][n + 1]

    del bufs_cc_start[ch][64][n + 1]
    del bufs_cc_end[ch][64][n + 1]

    del bufs_cc_start[ch][65][n + 1]
    del bufs_cc_end[ch][65][n + 1]

    del bufs_cc_start[ch][91][n + 1]
    del bufs_cc_end[ch][91][n + 1]

    return
# End of check_staccatto

# ----------------------------------------------------------------------------
def multiple_note_split(ch, n, m, closest_vals):
    global bufs_notes_start
    global bufs_notes_end
    global midi_2_note_lengths
    global midi_2_note_lengths_nl
    global CLICKS_SLOP

#--     print_stderr(f'multiple_note_split - ch={ch} n={n}')

    note_start_1 = bufs_notes_start[ch][n]
    note_end_1 = bufs_notes_end[ch][n]
    lth = note_end_1 - note_start_1

#--     print_stderr(f'ch={ch} n={n} start={note_start_1} end={note_end_1} lth={lth}')
#--     print_stderr(f'lth={lth} midi_2_note_lengths={midi_2_note_lengths}')
#--     print_stderr(f'lth={lth} midi_2_note_lengths_nl={midi_2_note_lengths_nl}')

    if lth < CLICKS_SLOP:                           # Cannot break if short.
        return None, None, 8589934592
    # fi

    if lth > (2 * midi_2_note_lengths_nl[1]):       # Cannot be more than two whole notes.
        print_error(f'multiple_note_split - ch={ch} n={n} m={m} Cannot have note length greater than 2 whole notes. Fix tempo/meter/Header.')
        return None, None, 8589934592
    # fi

    which_1st = None
    which_2nd = None
    which_2nd_ptr = None
    closest_w = closest_vals
    # First note must always be dotted.
    # Do the two non-dotted values first.

    x = (midi_2_note_lengths, midi_2_note_lengths_dotted, midi_2_note_lengths_double_dotted)
    xs = (midi_2_note_lengths_sorted_keys, midi_2_note_lengths_dotted_sorted_keys, midi_2_note_lengths_double_dotted_sorted_keys)
    for p in (0, 1, 2):
        for q1 in xs[p]:
            for q2 in midi_2_note_lengths_sorted_keys:
                c = abs(lth - (q1 + q2))
                if c < closest_vals:
                    which_1st = q1
                    which_2nd = q2
                    which_1st_ptr = x[p]
                    which_2nd_ptr = midi_2_note_lengths
                    closest_vals = c
                    if closest_vals == 0:
                        return (which_1st, which_2nd), (which_1st_ptr, which_2nd_ptr), closest_vals
                    # fi
                # fi
            # rof

            for q2 in midi_2_note_lengths_dotted_sorted_keys:
                c = abs(lth - (q1 + q2))
                if c < closest_vals:
                    which_1st = q1
                    which_2nd = q2
                    which_1st_ptr = x[p]
                    which_2nd_ptr = midi_2_note_lengths_dotted
                    closest_vals = c
                    if closest_vals == 0:
                        return (which_1st, which_2nd), (which_1st_ptr, which_2nd_ptr), closest_vals
                    # fi
                # fi
            # rof

            for q2 in midi_2_note_lengths_double_dotted_sorted_keys:
                c = abs(lth - (q1 + q2))
                if c < closest_vals:
                    which_1st = q1
                    which_2nd = q2
                    which_1st_ptr = x[p]
                    which_2nd_ptr = midi_2_note_lengths_double_dotted
                    closest_vals = c
                    if closest_vals == 0:
                        return (which_1st, which_2nd), (which_1st_ptr, which_2nd_ptr), closest_vals
                    # fi
                # fi
            # rof
        # rof
    # rof

    if which_1st == None:
        return None, None, 8589934592
    # fi
    return (which_1st, which_2nd), (which_1st_ptr, which_2nd_ptr), closest_vals
# End of multiple_note_split

# ----------------------------------------------------------------------------
# How to put in abs(CLICKS_SLOP) +/- for clicks checking.
# Figure out what bufs_gcs_length[ch][n] is like "4" = 1/4 note.

def determine_note_gcs_lengths():
    global bufs_gcs_length
    global channels
    global bufs_notes
    global first_note_time
    global bufs_notes_start
    global bufs_notes_end
    global bufs_gcs_length
    global bufs_notes_velocity          # The intensity of note start. (Typically the total volume. *sigh*)
    global bufs_cc_start                # [channel][cc#]    time in clicks when CC occurred.
    global bufs_cc_end                  # [channel][cc#]    CC when note stops occurred.
    global bufs_gcs_note
    global bufs_suffix                  # No suffixes yet.
    global CLICKS_SLOP

    ch = 0
    while channels is not None and ch <= channels:
        if len(bufs_notes[ch]) is None or len(bufs_notes[ch]) <= 0:
            ch = ch + 1
            continue
        # fi
        m = 1                           # measure number 1
        n = 0                           # first note in bufs_notes[ch]
        while n < len(bufs_notes[ch]):
            # Need measure for checking staccato or triplets.
            while m + 1 in measures_clicks_start and measures_clicks_start[m + 1] < bufs_notes_start[ch][n]:
                m = m + 1
            # elihw
            #
            which_q_ptr_x = None
            which_q_x = None
            closest_x = 8589934592
            #
            # which_q_ptr    = {midi_2_note_lengths, midi_2_note_lengths_dotted, midi_2_note_lengths_double_dotted}
            # which_q_single = entry in which_q_ptr.
            # closest_single = abs(diff between which_q_single and this note length) - i.e. left-over amount.
            which_q_ptr, which_q_single, closest_single = check_single_note_lth(ch, n)
            if closest_single > 0:                      # If not an absolute match already.
                # which_q_ptr = {midi_2_note_lengths, midi_2_note_lengths_dotted, midi_2_note_lengths_double_dotted}
                # which_q_x = entry in which_q_ptr.
                # closest_x = abs(diff between which_q_x and this note length) - i.e. left-over amount.
                which_q_ptr_x, which_q_x, closest_x, x = check_triplets(ch, n, m, closest_single)
                if closest_x != 8589934592:             # Triplet (or more) closer than single note.
                    which_q_ptr = which_q_ptr_x
                    which_q_single = which_q_x
                    closest_single = closest_x
                # fi

                # Subtract largest note and make another from rest. Split note.
                which_indexes, which_ptrs, closest_mult = multiple_note_split(ch, n, m, closest_single)
#--                 print_stderr(f'determine_note_gcs_lengths: after multiple_note_split - ch={ch} m={m} n={n} closest_mult={closest_mult} closest_single={closest_single}')
                if closest_mult < closest_single:       # Split note into two of them.
#--                     print_stderr(f'determine_note_gcs_lengths: multiple_note_split - ch={ch} m={m} n={n} closest_mult={closest_mult} closest_single={closest_single}')
                    if closest_mult > CLICKS_SLOP:
                        print_error(f'determine_note_gcs_lengths: multiple_note_split - ch={ch} m={m} n={n} ({which_indexes[0]}, {which_indexes[1]}), PTR, closest_mult={closest_mult} CLICKS_SLOP={CLICKS_SLOP}')
                    # fi
                    bufs_notes_start[ch].insert(n + 1, bufs_notes_start[ch][n] + which_indexes[0])
                    bufs_notes_end[ch].insert(n + 1, bufs_notes_end[ch][n])
                    bufs_notes_end[ch][n] = bufs_notes_start[ch][n + 1]
                    bufs_notes[ch].insert(n + 1, bufs_notes[ch][n])
                    bufs_notes_velocity[ch].insert(n + 1, bufs_notes_velocity[ch][n])

                    bufs_gcs_length[ch].insert(n + 1, '')
                    bufs_gcs_length[ch][n] = which_ptrs[0][which_indexes[0]][0]
                    bufs_gcs_length[ch][n + 1] = which_ptrs[1][which_indexes[1]][0]

                    bufs_gcs_note[ch].insert(n + 1, '')

                    bufs_cc_start[ch][7].insert(n + 1, bufs_cc_start[ch][7][n] + which_indexes[0])
                    bufs_cc_end[ch][7].insert(n + 1, bufs_cc_end[ch][7][n])
                    bufs_cc_end[ch][7][n] = bufs_cc_start[ch][7][n + 1]

                    bufs_cc_start[ch][10].insert(n + 1, bufs_cc_start[ch][10][n] + which_indexes[0])
                    bufs_cc_end[ch][10].insert(n + 1, bufs_cc_end[ch][10][n])
                    bufs_cc_end[ch][10][n] = bufs_cc_start[ch][10][n + 1]

                    bufs_cc_start[ch][11].insert(n + 1, bufs_cc_start[ch][11][n] + which_indexes[0])
                    bufs_cc_end[ch][11].insert(n + 1, bufs_cc_end[ch][11][n])
                    bufs_cc_end[ch][11][n] = bufs_cc_start[ch][11][n + 1]

                    bufs_cc_start[ch][64].insert(n + 1, bufs_cc_start[ch][64][n] + which_indexes[0])
                    bufs_cc_end[ch][64].insert(n + 1, bufs_cc_end[ch][64][n])
                    bufs_cc_end[ch][64][n] = bufs_cc_start[ch][64][n + 1]

                    bufs_cc_start[ch][65].insert(n + 1, bufs_cc_start[ch][65][n] + which_indexes[0])
                    bufs_cc_end[ch][65].insert(n + 1, bufs_cc_end[ch][65][n])
                    bufs_cc_end[ch][65][n] = bufs_cc_start[ch][65][n + 1]

                    bufs_cc_start[ch][91].insert(n + 1, bufs_cc_start[ch][91][n] + which_indexes[0])
                    bufs_cc_end[ch][91].insert(n + 1, bufs_cc_end[ch][91][n])
                    bufs_cc_end[ch][91][n] = bufs_cc_start[ch][91][n + 1]

                    # This moves a tie that is broken into two ... so that both are ties. :)
                    if bufs_notes[ch][n] != 0:
                        bufs_suffix[ch].insert(n, 't')
                    else:
                        bufs_suffix[ch].insert(n, '')
                    # fi
                    n = n + 2
                    continue
                # fi
            # fi
            # . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
            if which_q_single is None:
                print_error(f'determine_note_gcs_lengths - Cannot figure out a note length.')
                return
            # fi
            if which_q_x is not None:
                bufs_gcs_length[ch][n] = which_q_ptr[which_q_x][0] + f'/{x}'
                n = n + x
                continue
            # fi
            bufs_gcs_length[ch][n] = which_q_ptr[which_q_single][0]
            check_staccatto(ch, n, m, which_q_single * 2, which_q_ptr)
            n = n + 1
        # elihw
        ch = ch + 1
    # elihw
    return
# End of determine_note_gcs_lengths

# ----------------------------------------------------------------------------
# Figure out what bufs_gcs_notes[ch][n] is "4c" (c, 4th octave).
# NOTE: key for channel and previous +/-/n business.

def determine_note_gcs_notes():
    global bufs_gcs_length
    global midi_value_to_note_sharp_39
    global midi_value_to_note_flat_39
    global bufs_notes
    global channels
    global measures_clicks_start
    global measures_key
    global key_sig

    ch = 0
    while channels is not None and ch <= channels:
        if len(bufs_notes[ch]) is None or len(bufs_notes[ch]) <= 0:
            ch = ch + 1
            continue
        # fi
        m = 1                           # measure number 1
        n = 0                           # first note in bufs_notes[ch]
        acc_m = {}
        for i in acc_v_init_v_or_h:
            acc_m[i] = acc_v_init_v_or_h[i]
        # rof
        acc_last_suffix_tie = ''
        while n < len(bufs_notes[ch]):
            # Need measure for checking staccato or triplets.
            while m + 1 in measures_clicks_start and measures_clicks_start[m + 1] < bufs_notes[ch][n]:
                m = m + 1
                for i in acc_v_init_v_or_h:
                    if acc_last_suffix_tie != i:
                        acc_m[i] = acc_v_init_v_or_h[i]
                    # fi
                # rof
                acc_last_suffix_tie = ''
            # elihw
            # . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
            # Determine note name from midi note number.
            midi_note = bufs_notes[ch][n]
            if midi_note == 0:
                lkj = 'r'
                playing_on = 'r'
                playing_a = ''
                acc_last_suffix_tie = ''
            else:
                # Current key for measure:
                k = measures_key[ch][m]
                nksxnk = key_sig[k]
                if k == 'cn':                               # Special case "cn" to mean use sharps. 'c' uses flats.
                    if midi_note not in midi_value_to_note_flat_39:
                        print_warning(f'determine_note_gcs_notes - midi_note={midi_note} not in midi_value_to_note_sharp_39')
                        lkj = 'r'                           # Make it a rest.
                    else:
                        lkj = midi_value_to_note_sharp_39[midi_note]
                    # fi
                elif nksxnk <= 0:                           # If flat's on staff for key.
                    if midi_note not in midi_value_to_note_flat_39:
                        print_warning(f'determine_note_gcs_notes - midi_note={midi_note} not in midi_value_to_note_flat_39')
                        lkj = 'r'                           # Make it a rest.
                    else:
                        lkj = midi_value_to_note_flat_39[midi_note]
                    # fi
                else:                                       # If sharps's on staff for key.
                    if midi_note not in midi_value_to_note_sharp_39:
                        print_warning(f'determine_note_gcs_notes - midi_note={midi_note} not in midi_value_to_note_sharp_39')
                        lkj = 'r'                           # Make it a rest.
                    else:
                        lkj = midi_value_to_note_sharp_39[midi_note]
                    # fi
                # fi
                if lkj == 'r':
                    playing_on = 'r'
                    playing_a = ''
                    acc_last_suffix_tie = ''
                else:
                    playing_on = lkj[0:2]
                    playing_a = lkj[2:]
                    # See if this note in measure already has +/-/n.
                    acc = acc_m[playing_on]                     # if last note of this had acc already.
                    if acc != '':                               # This note already has sharp/flat/nature
                        if playing_a == '':                     # Set to n.
                            playing_a = acc = 'n'
                        else:
                            acc = playing_a
                        # fi
                    else:
                        if key_convert[k][playing_on] == lkj:
                            playing_a = acc = ''
                        else:
                            acc = playing_a
                        # fi
                    # fi
                    acc_m[playing_on] = acc
                    if 't' in bufs_suffix[ch][n]:
                        acc_last_suffix_tie = playing_on
                    else:
                        acc_last_suffix_tie = ''
                    # fi
                # fi
            # fi
            bufs_gcs_note[ch][n] = playing_on + playing_a
            # . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
            n = n + 1
        # elihw
        ch = ch + 1
    # elihw
    return
# End of determine_note_gcs_notes

# ----------------------------------------------------------------------------
#   a) Change note time into: string.                   - Done
#   b) titles before measure 1.
#   c) key before measure 1.
#   d) instrument before measure 1.  Number -> string.
#   e) Titles within a measure.
#   f) Using keys and acc_m (accidentials in this measure -- remember ties keep
#      that accidental into this measure. (And we always specify accidentals!)
#
# Example of data:
#   measure xyz
#   v1: r4, 3c4, 3d8, 3e(0.333333), r(0.666666)
#   v2: r4, 3c4/3, 3d?, 3e?, 3f4     -> r4, s3(3c,3d,3e)4, 3f4

def printable_measures():
    # Fix to printable strings ... triplets to 's3(note1, note2, note3)lth'.
#--    bufs_gcs_length[ch][n] = str(which_q_ptr_3[which_q_3][0]) + '/3'

    global bufs_gcs_length
    global bufs_notes
    global channels
    global measures_clicks_start
    global measures_key

    ch = 0
    while channels is not None and ch <= channels:
        if len(bufs_notes[ch]) is None or len(bufs_notes[ch]) <= 0:
            ch = ch + 1
            continue
        # fi
        m = 1                           # measure number 1
        n = 0                           # first note in bufs_notes[ch]
        while n < len(bufs_notes[ch]):
            note = bufs_gcs_length[ch][n]
            x = note.find('/')
            if x >= 0:                  # '/' in time field means sequence.
                num = int(note[x+1:])
                prefix = note[0:x]
                bufs_gcs_note[ch][n] = f's{num}({bufs_gcs_note[ch][n]}'
                bufs_gcs_length[ch][n] = ''
                for y in range(1, num - 1):
                    bufs_gcs_length[ch][n + y] = ''
                # rof
                bufs_gcs_note[ch][n + num - 1] = f'{bufs_gcs_note[ch][n + num - 1]})'
                bufs_gcs_length[ch][n + num - 1] = f'{prefix}'
                n = n + num
            else:
                n = n + 1
            # fi
        # elihw
        ch = ch + 1
    # elihw
    return
# End of printable_measures

# ----------------------------------------------------------------------------
# Use instrument_channel_measures_hint and instruments[] to determine when/where.

def set_instrument_measures():
    global instrument               # Array by channel of: (bank, number, running_time)
    global channels
    global measures_instrument     # Dictionary of measures [1-...]: instrument
    global measures_clicks_start
    global measures_clicks_length
    global instrument_channel_measures_hint
    global last_measure

    cn = 0
    while channels is not None and cn <= channels:
        if cn not in measures_instrument:
            measures_instrument[cn] = {}
        # fi
        i = 0
        if cn in instrument:
            last_i_name = check_instr(instrument[cn][i][1], instrument[cn][i][0])
            last_ic = instrument[cn][i][2]
        else:
            last_i_name = 0
            last_ic = 0
        # fi
        if cn in instrument_channel_measures_hint and 1 in instrument_channel_measures_hint[cn]:
            last_i_name = instrument_channel_measures_hint[cn][1]
            last_ic = measures_clicks_start[1]
        # fi
        for m in range(1, last_measure + 1):
            if last_ic <= measures_clicks_start[m]:
                # Move to start of measure.
                if cn in instrument and i < len(instrument[cn]) - 1:
                    if instrument[cn][i+1][2] < measures_clicks_start[m] + measures_clicks_length[m]:
                        i = i + 1
                        last_i_name = check_instr(instrument[cn][i][1], instrument[cn][i][0])
                        last_ic = instrument[cn][i][2]
                    # fi
                # fi
            # fi
            if cn in instrument_channel_measures_hint and m in instrument_channel_measures_hint[cn]:
                last_i_name = instrument_channel_measures_hint[cn][m]
                last_ic = measures_clicks_start[m]
            # fi
            measures_instrument[cn][m] = last_i_name
        # rof
        cn = cn + 1
    # elihw
    return
# End of set_instrument_measures

# ----------------------------------------------------------------------------
# NOTDONEYET? set_keys_if_not_specified - possibly need to redo to match set_instrument_measures loop methodology.

def set_keys_if_not_specified():
    global echo_key
    global echo_key_clicks
    global channels
    global measures_key
    global key_channel_measures_hint
    global measures_clicks_start
    global measures_clicks_length

    # Set keys if not specified. NOTE: This may be an error.
    for k in echo_key:
        if k == 'ALL':
            cn = 0
            while channels is not None and cn <= channels:
                if cn not in echo_key:
                    echo_key[cn] = echo_key['ALL']
                    echo_key_clicks[cn] = echo_key_clicks['ALL']
                # fi
                cn = cn + 1
            # elihw
            break
        # fi
    # rof

    cn = 0
    while channels is not None and cn <= channels:
        if cn not in measures_key:
            measures_key[cn] = {}
        # fi
        k = 0
        if cn in echo_key:
            last_k = echo_key[cn][k]
            last_kc = echo_key_clicks[cn][k]
        else:
            last_k = 'c'
            last_kc = 0
        # fi
        if cn in key_channel_measures_hint and 1 in key_channel_measures_hint[cn]:
            last_k = key_channel_measures_hint[cn][1]
            last_kc = measures_clicks_start[1]
        # fi
        for m in range(1, last_measure + 1):
            if (last_kc >= measures_clicks_start[m] and
                last_kc < measures_clicks_start[m] + measures_clicks_length[m]):
                if cn in echo_key_clicks:
                    # Move to start of measure.     -- Doesn't matter. :)
                    echo_key_clicks[cn][k] = measures_clicks_start[m]
                    last_k = echo_key[cn][k]
                    last_kc = echo_key_clicks[cn][k]
                    if k < len(echo_key[cn]) - 1:
                        k = k + 1
                    # fi
                # fi
            # fi
            if cn in key_channel_measures_hint and m in key_channel_measures_hint[cn]:
                last_k = key_channel_measures_hint[cn][m]
            # fi
            measures_key[cn][m] = last_k
        # rof
        cn = cn + 1
    # elihw
    return
# End of set_keys_if_not_specified

# ----------------------------------------------------------------------------
def figure_out_measure_locations():
    global running_time
    global first_note_time
    global meter                        # Array of printable meter (text).
    global meter_fractions              # Array of MIDICLICKSPERQUARTER*4 * meter_fraction (clicks per measure).
    global meter_clicks                 # Array of where in running clicks meter occurred.
    global last_measure                 # Number of last measure - set when figuring out measure lengths.
    global measures_clicks_start        # Dictionary of clicks for when measure starts.
    global measures_clicks_length       # Dictionary of clicks in each measure.
    global measures_meter               # Dictionary of meters for when measure starts.
    global meters_measures_hint         # hint file text for meter, dictionary by measures.
    global meters_values_hint           # hint file value for meter, dictionary by measures.

    working_time = first_note_time
    lm = 1                              # Start measure at number 1.
    if meter_fractions == []:
        return
    # fi

    last_inc = meter_fractions[0]
    last_meter = meter[0]
    last_clicks = meter_clicks[0]
    for i in range(0, len(meter)):
        while working_time < last_clicks:
            if lm in meters_measures_hint:
                last_inc = meters_values_hint[lm] * MIDICLICKSPERQUARTER * 4    # value
                last_meter = meters_measures_hint[lm]                           # text
            # fi
            measures_clicks_start[lm] = round(working_time)
            measures_clicks_length[lm] = int(last_inc)
            measures_meter[lm] = last_meter
            working_time = working_time + last_inc
            lm = lm + 1
        # elihw
        if lm in meters_measures_hint:
            last_inc = meters_values_hint[lm] * MIDICLICKSPERQUARTER * 4    # value
            last_meter = meters_measures_hint[lm]                           # text
        else:
            last_inc = meter_fractions[i]
            last_meter = meter[i]
        # fi
        last_clicks = meter_clicks[i]
    # rof
    # Do to end of song.
    while working_time < running_time:
        if lm in meters_measures_hint:
            last_inc = meters_values_hint[lm] * MIDICLICKSPERQUARTER * 4    # value
            last_meter = meters_measures_hint[lm]                           # text
        # fi
        measures_clicks_start[lm] = round(working_time)
        measures_clicks_length[lm] = int(last_inc)
        measures_meter[lm] = last_meter
        working_time = working_time + last_inc
        lm = lm + 1
    # elihw
    last_measure = lm - 1
    measures_clicks_length[last_measure] = math.ceil(running_time - (working_time - last_inc))
    return
# End of figure_out_measure_locations

# ----------------------------------------------------------------------------
# FF 58 04 nn dd cc bb Time Signature
# The time signature is expressed as four numbers. nn and dd represent the numerator
# and denominator of the time signature as it would be notated. The denominator
# is a negative power of two: 2 represents a quarter-note, 3 represents an eighth-note,
# etc. The cc parameter expresses the number of MIDI clocks in a metronome click.
# The bb parameter expresses the number of notated 32nd-notes in a MIDI quarter-note
# (24 MIDI clocks). This was added because there are already multiple programs which
# allow a user to specify that what MIDI thinks of as a quarter-note (24 clocks) is
# to be notated as, or related to in terms of, something else.
#
# Therefore, the complete event for 6/8 time, where the metronome clicks every three
# eighth-notes, but there are 24 clocks per quarter-note, 72 to the bar, would be (in hex):
#       FF 58 04 06 03 24 08
#                nn dd cc bb
# That is, 6/8 time (8 is 2 to the 3rd power, so this is 06 03), 36 MIDI clocks per
# dotted-quarter (24 hex!), and eight notated 32nd-notes per quarter-note.
#    i.e. 2*32=1/16, 4*32=1/8, 8*32=1/4.  And a 1/4 note is 0x24 time deltas long.
# If the 8 was changed to 16, then a 1/2 note is 0x24 long. (0x24=36)

def meter_readable(strg1, strg2):
    s = (strg1 + ' ' + strg2).split()
    if len(s) != 4:
        print_error(f'meter line does not have enough arguments, want 4, not {len(s)}.')
        return None, None
    # fi
    numerator = int(s[0])
    denominator = 2 ** int(s[1])
    return f'{numerator}/{denominator}', float(numerator)/float(denominator)
# End of meter_readable

# ----------------------------------------------------------------------------
def process_echo_lines(q):
    global new_channels
    global last_fs_channel
    global MIDICLICKSPERQUARTER
    global titles
    global running_time
    global meter
    global meter_fractions
    global meter_clicks
    global echo_key
    global echo_key_clicks
    global comments
    global comments_clicks
    global tempo_s
    global tempo_l

    if q[0:8] == '"Header ':
        if q[-1] != '"':
            print_error('Header line expected to end with a double quote')
            return
        # fi
        r = q[8:-1].split()
        last_fs_channel = new_channels = int(r[0])                # Remember 0 is the first one.
        MIDICLICKSPERQUARTER = int(r[1])
        if meter == []:
            meter.append('4/4')
            meter_fractions.append(MIDICLICKSPERQUARTER * 4)
            meter_clicks.append(running_time)
        # fi
        do_note_length_calculate()
        return
    # fi
    if q[0:7] == '"Title ':
        titles.append(q[7:])
        return
    # fi
    if q[0:7] == '"meter ':
        if q[-1] != '"':
            print_error('meter line expected to end with a double quote')
            return
        # fi
        vs = q[7:].split(' ', 1)
        meter_new, meter_new_fraction = meter_readable(vs[0], vs[1])
        if meter != [] and meter[-1] != meter_new:
            if running_time == meter_clicks[-1]:
                meter[-1] = meter_new
                meter_fractions[-1] = math.ceil(MIDICLICKSPERQUARTER*4 * meter_new_fraction)
            else:
                meter.append(meter_new)
                meter_fractions.append(math.ceil(MIDICLICKSPERQUARTER*4 * meter_new_fraction))
                meter_clicks.append(running_time)
            # fi
        # fi
        return
    # fi
    if q[0:5] == '"key ':
        vs = q[5:].split(' ', 1)
        if vs[0] != 'ALL':
            v = int(vs[0])
        else:
            v = 'ALL'
        # fi
        # split(delimiter, number) -- delimiter=None for whitespace(default)
        a = vs[1].split(None, 1)
        if len(a) < 2 or len(a) > 4:
            print_error(f'key line expects key followed by "major"/"minor" not {a}')
            return
        elif a[1][0:6] != "'major" and a[1][0:6] != "'minor":
            print_error(f'key line expects "major"/"minor" not {a[1]}')
            return
        # fi
        key_previous = q
        if v not in echo_key:
            echo_key[v] = []
            echo_key_clicks[v] = []
        # fi
        if len(echo_key_clicks[v]) > 0 and echo_key_clicks[v][-1] == running_time:
            echo_key[v][-1] = a[0].lower()
        else:
            echo_key[v].append(a[0].lower())
            echo_key_clicks[v].append(running_time)
        # fi
        return
    # fi
    a = q.split()
    if len(a) == 3 and len(a[1]) > 8 and a[1][0:8] == 'tempo_s=':
# DEBUG - process_echo_lines - q=""tempo_s=150 tempo_l=0.25""
        if q[-1] != '"':
            print_error('tempo_s line expected to end with a double quote')
            return
        # fi
        s = a[1][8:]
        tempo_s = float(s)
        if a[2][0:8] != 'tempo_l=':
            print_error(f'tempo_s line expects tempo_l not {a[2]}')
            return
        # fi
        l = a[2][8:len(a[2]) - 1]
        tempo_l = float(l)
        return
    # fi
    comments.append(q)
    comments_clicks.append(running_time)
    return
# End of process_echo_lines

# ----------------------------------------------------------------------------
global header_commands_ignore
header_commands_ignore = [ 'set', 'unload', 'load', 'reset', 'pitch_bend' ]

def process_header_lines(q):
    global header_commands_ignore
    global instrument
    global running_time

    if q[0] in header_commands_ignore:
        pass
    elif q[0] == 'echo':
        process_echo_lines(q[1])
    elif q[0] == 'sleep':
        process_sleep(q[1])
    elif q[0] == 'prog':
        process_prog(q[1])
    elif q[0] == 'select':
        process_select(q[1])
    elif q[0] == 'cc':
        process_cc(q[1])
    else:
        print_error(f'Line is unexpected - {q}')
    # fi
    return
# End of process_header_lines

# ----------------------------------------------------------------------------
def process_prog(r):
    a = r.split()
    cn = int(a[0])
    instr = int(a[1])
    if instrument == {}:
        instrument[cn] = [ [0, instr, running_time] ]
    else:
        print_error(f"ignoring prog that isn't before select commands. {r}")
    # fi
    return
# End of process_prog

# ----------------------------------------------------------------------------
def process_select(r):
    a = r.split()
    if len(a) < 1 or len(a) > 4:
        print_error(f'select line wants 4 arguments not {len(a)} - {r}')
        return
    # fi
    # a[0] = channel #
    # a[1] = timeclicks
    # a[2] = bank
    # a[3] = instrument
    cn = int(a[0])
    ibank = int(a[2])
    instr = int(a[3])
    if cn in instrument:
        if instrument[cn][-1][0] == ibank and instrument[cn][-1][1] == instr:
            pass
        else:
            if instrument[cn][-1][0] == ibank and instrument[cn][-1][2] == running_time:
                instrument[cn][-1] = [ibank, instr, running_time]
            else:
                instrument[cn].append( [ibank, instr, running_time] )
            # fi
        # fi
    else:
        instrument[cn] = [ [ibank, instr, running_time] ]
    # fi
    return
# End of process_select

# ----------------------------------------------------------------------------
def process_noteon(r):
    global channels
    global new_channels
    global running_time
    global staff_hint
    global bufs_notes_channel           # Notes for chords on this channel.
    global bufs_notes                   # Midi note number. An array indexed by measure, channel.
    global bufs_notes_start             # calculated clicks to start of each note for a channel.
    global bufs_notes_end               # calculated clicks to end of each note for a channel.
    global bufs_notes_velocity          # The intensity of note start. (Typically the total volume. *sigh*)
    global bufs_cc_start                # [channel][cc#]      time in clicks when CC occurred.
    global bufs_cc_end                  # [channel][cc#]      CC when note stops occurred.
    global bufs_gcs_length
    global bufs_gcs_note
    global bufs_suffix                  # No suffixes yet.
    global last_cc                      # If doing a note, the last_cc. NOTE: defaults for 7,10,11,64,68,91.

    global echo_key                     # key[channel] = ... .
    global echo_key_clicks              # echo_key_clicks = running_time.
    global instrument                   # Indexed by channel number.

    a = r.split()
    if len(a) != 3:
        print_error(f'noteon line needs 3 arguments, not {len(a)} - {r}.')
        return
    # fi
    cn = int(a[0])
    n = int(a[1])
    i = int(a[2])
    if i == 0:
        process_noteoff(r)
        return
    # fi
    if channels is None or cn > channels:
        if new_channels is None or cn > new_channels:
            new_channels = cn
        # fi
        channels = cn
    # fi

    # Do transpose.
    if cn in xpose_channel:
        n = n + xpose_channel[cn]
    # fi

    # Okay, we have the channel and the note, and calculated the current 'running_time'.

    # determine which real channel to use... if chords.
    flag = False
    for ch in bufs_notes_channel[cn]:
        # Check if any note is already playing ... if so, then it is chord time.
        if ch in bufs_notes_end and len(bufs_notes_end[ch]) > 0 and bufs_notes_end[ch][-1] == 0:
            continue
        # fi
        flag = ch
        break
    # rof

    if flag is False:                                   # Need a new channel for chord.
        if cn < new_channels and bufs_notes_channel[cn] == []:
            bufs_notes_channel[cn].append(cn)
            ch = cn
        else:
            channels = new_channels = new_channels + 1
            bufs_notes_channel[cn].append(channels)
            if cn in echo_key:
                echo_key[channels] = echo_key[cn]
                echo_key_clicks[channels] = echo_key_clicks[cn]
            # fi
            if cn in instrument:
                instrument[channels] = instrument[cn]
                if channels not in instrument_channel_measures_hint:
                    instrument_channel_measures_hint[channels] = {}
                # fi
                if cn in instrument_channel_measures_hint:
                    instrument_channel_measures_hint[channels] = instrument_channel_measures_hint[cn]
                # fi
                if channels not in clef_channel_measures_hint:
                    clef_channel_measures_hint[channels] = {}
                # fi
                if cn in clef_channel_measures_hint:
                    clef_channel_measures_hint[channels] = clef_channel_measures_hint[cn]
                # fi
                if channels not in key_channel_measures_hint:
                    key_channel_measures_hint[channels] = {}
                # fi
                if cn in key_channel_measures_hint:
                    key_channel_measures_hint[channels] = key_channel_measures_hint[cn]
                # fi
            # fi
            # Chord channels must be xposed too.
            if cn in xpose_channel:
                xpose_channel[channels] = xpose_channel[cn]
            # fi
            ch = channels                               # New channel
            flag_channel = False
            flag_channel_s = None
            flag_new = False
            flag_new_s = None
            for s in staff_hint:
                for v in staff_hint[s]:
                    if v == cn:
                        flag_channel = True
                        flag_channel_s = s
                    # fi
                    if v == ch:
                        flag_new = True
                        flag_new_s = s
                    # fi
                # rof
            # rof
            if flag_channel_s is not None:
                staff_hint[flag_channel_s][ch] = True
            # fi
            if flag_new_s is not None:
                staff_hint[flag_new_s][cn] = True
            # fi
        # fi
    # fi

    bufs_notes[ch].append(n)
    bufs_notes_start[ch].append(running_time)           # Starting time for note.
    bufs_notes_end[ch].append(0)                        # No ending time note.
    bufs_notes_velocity[ch].append(i)                   # Note start intensity volume level.
    for cc in range(0, 127):
        bufs_cc_start[ch][cc].append(last_cc[ch][cc])
        bufs_cc_end[ch][cc].append(0)
    # rof
    bufs_gcs_length[ch].append('')
    bufs_gcs_note[ch].append('')
    bufs_suffix[ch].append('')                          # No suffixes yet.
    return
# End of process_noteon

# -----------------------------------------------------------------------------
# r is the arguments to the noteoff line.

def process_noteoff(r):
    global channels
    global running_time
    global bufs_notes_channel
    global bufs_note
    global bufs_note_end
    global bufs_cc_end
    global last_cc

    a = r.split()
    if len(a) != 3:
        print_error(f'noteoff line needs 3 arguments, not {len(a)} - {r}.')
        return
    # fi
    cn = int(a[0])
    n = int(a[1])
    i = int(a[2])
    if cn > channels:
        print_debug(f'process_noteoff - note not defined for noteoff? - channels={channels}')
        print_error(f'noteoff line for channel not already turned on/defined.')
        return
    # fi
#--     if i != 0:
#--         print_error(f'noteoff line for channel does not turn off note.')
#--         return
#--     # fi

    # Do transpose.
    if cn in xpose_channel:
        n = n + xpose_channel[cn]
    # fi

    # Okay, we have the channel and the note, and calculated the current 'running_time'.
    # determine which real channel to use... if chords.
    flag = False
    for ch in bufs_notes_channel[cn]:
        if ch in bufs_notes and len(bufs_notes[ch]) > 0 and bufs_notes[ch][-1] == n:
            # Check if note is already playing ... last note, then did last note end yet ...
            if ch in bufs_notes_end and len(bufs_notes_end[ch]) > 0 and bufs_notes_end[ch][-1] == 0:
                flag = ch
                break
            # fi
        # fi
    # rof
    if flag is False:                                   # Need a new channel for chord.
#--         print_error(f'noteoff line for channel not already playing.')
        print_warning(f'noteoff line for channel not already playing.')
#--         print_debug_internal_1(f'PROBLEM_process_noteoff')
#--         a = abc[-1]
        return
    # fi

    bufs_notes_end[ch][-1] = running_time
    for cc in range(0, 127):
        bufs_cc_end[ch][cc][-1] = last_cc[cn][cc]
    # rof
    # bufs_suffix[ch].append('') -- already set with noteon. # No suffixes yet.
    return
# End of process_noteoff

# -----------------------------------------------------------------------------
# r is the arguments to the sleep line.

def process_sleep(r):
    global tempo_s
    global tempo_l
    global running_time

# Want note length value.
    v1= float(r) * 1000
    v2 = (v1 * MIDICLICKSPERQUARTER) / 1000
    v3 = v2 * ((tempo_s / 60) * (tempo_l * 4))
    v4 = v3 / 1000
    running_time = running_time + math.ceil(v4)
    return
# End of process_sleep

# -----------------------------------------------------------------------------
# r is the arguments to the cc line.

def process_cc(r):
    global last_cc
    global bufs_notes_channel

    a = r.split()
    if len(a) != 3:
        print_error(f'cc line needs 3 arguments, not {len(a)} - {r}.')
        return
    # fi
    cn = int(a[0])
    ctrl = int(a[1])
    value = int(a[2])

    for cns in bufs_notes_channel[cn]:  # Do all channels for possible chords.
        if ctrl in ( 7, 10, 11, 64, 65, 91):
            last_cc[cns][ctrl] = value
        elif ctrl in (0, 5, 32, 68, 121):
            pass
        else:
            print_error(f'cc {ctrl} for channel {cns} value {value} is unexpected.')
        # fi
    # rof
    return
# End of process_cc

# -----------------------------------------------------------------------------
def process_note_lines(q):
    global running_time
    global instrument

    if q[0] == 'noteon':
        process_noteon(q[1])
    elif q[0] == 'echo':
        process_echo_lines(q[1])
    elif q[0] == 'noteoff':
        process_noteoff(q[1])
    elif q[0] == 'sleep':
        process_sleep(q[1])
    elif q[0] == 'cc':
        process_cc(q[1])
    elif q[0] == 'select':
        process_select(q[1])
    else:
        print_error(f'NOTDONEYET - Unexpected command ({q}) in FS input')
    # fi
    return
# End of process_note_lines

# ----------------------------------------------------------------------------
# Parse and process line.
#
# Need: # channels used.
#   'cc'                # Maximum = total.
#   'select'            # Maximum = total.
#   'prog' decoding.    # Maximum = total.
# Need: Standard header removed.
#   Deleted everything until first select/cc/prog. (Keep echos.)
# Need: meter.
#   echo "meter"  -> meter.
# Need: title.
#   echo "        -> title if before any select/cc/noteon. (Edit down by hand.)
#                 -> comment if after noteon.

def process_line(original_line):
    global array_of_original_lines
    global no_notes_yet
    global first_note_time

    qline = original_line
    array_of_original_lines.append(qline)

    if qline is None:
        print_error('Line is None -- bad input.')
        return True
    elif qline == 'quit':
        return True                     # Done with input file.
    elif qline == 'reset':
        return False                    # Ignore reset command
    elif qline == '':
        print_error('Line is empty -- bad input -- but keep going.')
        return False
    # fi
    q = qline.split(None, 1)            # Command, arguments.
    if len(q) <= 1:
        print_error(f'Line ({original_line}) must have a command and at least one argument, but keep going.')
        return False
    # fi
    if no_notes_yet:
        if q[0] != 'noteon':
            process_header_lines(q)
            return False
        # fi
        no_notes_yet = False
        first_note_time = running_time  # The running time when first note occurs, 1st measure.
    # fi
    process_note_lines(q)
    return False
# End of process_line

# ----------------------------------------------------------------------------
# Get the next line, file, or macro.
# Return:
#   line        - the line without trailing spaces.
#   None        - if End of File.

def read_next_line():
    global args
    global line
    global linecount
    global input_file                   # File to read for input (default is use tty - stdin).
    global output_file                  # File to print to (default is sys.stdout).
    global errors_happened
    global warnings_happened

    try:
        if input_file is not None:
            rline = input_file.readline()
        else:
            if sys.stdin.isatty():
                if sys.platform == 'darwin':
                    input('input> ')
                    rline = readline.get_line_buffer()
                else:
                    rline = input('input> ')
                # fi
            else:
                rline = sys.stdin.readline()
            # fi
        # fi
        if rline is None or rline == '':
            if errors_happened != 0 or warnings_happened != 0:
                print_stderr(f'exiting with errors_happened={errors_happened}  warnings_happened={warnings_happened}')
            # fi
            sys.exit(errors_happened)
        # fi
        linecount = linecount + 1
        if rline:
            rline = rline.rstrip()                # trailing spaces gone.
            line = rline
            return rline
        # fi
    except EOFError:
        pass            # print('Read gave EOF', file=sys.stderr, flush=True)
    except SystemExit:
        pass            # print('Read gave system exit', file=sys.stderr, flush=True)
    except KeyboardInterrupt:
        print_error('Read got keyboard interrupt')
    except:
        print_error('Read got a processing error')
        print('   ', sys.exc_info()[0], sys.exc_info, file=sys.stderr, flush=True)
    # yrt
    line = None
    return None
# End of read_next_line

# ----------------------------------------------------------------------------
def readthefile():
    global linecount
    global args

    ifdone = False
    while not ifdone:                       # Read the file loop.
        line = read_next_line()
        if args.lines:
            print_stderr(f'linecount={linecount} line="{line}"')
        # fi
        if line is None:  # If end of file.
            return
        elif not line or len(line) <= 0 or line == '':
            continue
        # fi
        line = line.rstrip()
        if not line or len(line) <= 0 or line == '':
            continue
        # fi
        line = line.strip()
        if len(line) == 0:                                  # Ignore empty line.
            continue
        # fi
        ifdone = process_line(line)
    # elihw
    return
# End of readthefile

# ----------------------------------------------------------------------------
def print_debug_measures_1(stg):
    global last_measure                 # Number of last measure - set when figuring out measure lengths.
    global measures_clicks_start        # Dictionary of clicks for when measure starts.
    global measures_clicks_length       # Dictionary of clicks in each measure.
    global measures_meter               # Dictionary of meters for when measure starts.

    if last_measure is not None:
        j = int(last_measure / 10) * 10
        for i in range(1, j + 1, 10):
            print_stderr(f'{i:4} - measures_clicks_start: {measures_clicks_start[i]:7} {measures_clicks_start[i + 1]:7} {measures_clicks_start[i + 2]:7} {measures_clicks_start[i + 3]:7} {measures_clicks_start[i + 4]:7} {measures_clicks_start[i + 5]:7} {measures_clicks_start[i + 6]:7} {measures_clicks_start[i + 7]:7} {measures_clicks_start[i + 8]:7} {measures_clicks_start[i + 9]:7}')
            print_stderr(f'{i:4} - measures_clicks_length:{measures_clicks_length[i]:7} {measures_clicks_length[i + 1]:7} {measures_clicks_length[i + 2]:7} {measures_clicks_length[i + 3]:7} {measures_clicks_length[i + 4]:7} {measures_clicks_length[i + 5]:7} {measures_clicks_length[i + 6]:7} {measures_clicks_length[i + 7]:7} {measures_clicks_length[i + 8]:7} {measures_clicks_length[i + 9]:7}')
            print_stderr(f'{i:4} - measures_meter        :{measures_meter[i]:>7} {measures_meter[i + 1]:>7} {measures_meter[i + 2]:>7} {measures_meter[i + 3]:>7} {measures_meter[i + 4]:>7} {measures_meter[i + 5]:>7} {measures_meter[i + 6]:>7} {measures_meter[i + 7]:>7} {measures_meter[i + 8]:>7} {measures_meter[i + 9]:>7}')
            print_stderr('')
        # rof
        if last_measure - j != 0:
            i = j + 1
            print_stderr(f'{i:4} - measures_clicks_start:', end='')
            for k in range(i, last_measure + 1):
                print(f' {measures_clicks_start[k]:7}', file=sys.stderr, end='')
            # rof
            print('', file=sys.stderr)
            print_stderr(f'{i:4} - measures_clicks_length:', end='')
            for k in range(i, last_measure + 1):
                print(f'{measures_clicks_length[k]:7} ', file=sys.stderr, end='')
            # rof
            print('', file=sys.stderr)
            print_stderr(f'{i:4} - measures_meter        :', end='')
            for k in range(i, last_measure + 1):
                print(f'{measures_meter[k]:>7} ', file=sys.stderr, end='')
            # rof
            print('', file=sys.stderr)
        # fi
    # fi
    return
# End of print_debug_measures_1

# ----------------------------------------------------------------------------
def print_debug_title_1(stg):
    global titles

    print_stderr(f'\n{stg}: Title - ')
    for t in range(0, len(titles)):
        print_stderr(f'    "{titles[t]}"')
    # rof
    return
# End of print_debug_title_1

# ----------------------------------------------------------------------------
def print_debug_comments_1(stg):
    global comments
    global comments_clicks

    print_stderr(f'\n{stg}: Comments - ')
    for c in range(0, len(comments)):
        print_stderr(f'    comments_clicks={comments_clicks[c]} - "{comments[c]}"')
    # rof
    return
# End of print_debug_comments_1

# ----------------------------------------------------------------------------
def print_debug_keys_1(stg):
    global last_measure                 # Number of last measure - set when figuring out measure lengths.
    global measures_key
    global channels

    if measures_key == {}:
        return
    # fi
    print_stderr(f'\n{stg}: key -- channels={channels}')
    for m in range(1, last_measure + 1):
        print_stderr(f'  measure={m:3}:', end='')
        ch = 0
        while channels is not None and ch <= channels:
            print_stderr(f' {measures_key[ch][m]}', end='')
            ch = ch + 1
        # elihw
        print_stderr(f'')
    # rof
    return
# End of print_debug_keys_1

# ----------------------------------------------------------------------------
def print_debug_instruments_1(stg):
    global channels
    global instrument

    print_stderr(f'\n{stg} -- instruments - channels={channels}:')
    ch = 0
    while channels is not None and ch <= channels:
        if ch in instrument:
            for i in range(0,len(instrument[ch])):
                print_stderr(f'{ch:4} - instrument bank={instrument[ch][i][0]} number={instrument[ch][i][1]} clicks={instrument[ch][i][2]}')
            # rof
        # fi
        ch = ch + 1
    # elihw

    ch = 0
    while channels is not None and ch <= channels and measures_instrument != {}:
        if ch in measures_instrument:
            last_i = -1
            for m in range(1, last_measure + 1):
                if last_i != measures_instrument[ch][m]:
                    print_stderr(f'{ch:4} - measure {m} instrument={measures_instrument[ch][m]}')
                    last_i = measures_instrument[ch][m]
                # fi
            # rof
        # fi
        ch = ch + 1
    # elihw
    return
# End of print_debug_instruments_1

# ----------------------------------------------------------------------------
def print_debug_notes_1(stg):
    global channels
    global bufs_notes_channel
    global bufs_notes
    global bufs_notes_velocity
    global bufs_gcs_length
    global bufs_notes_start
    global bufs_notes_end
    global bufs_cc_start
    global bufs_cc_end
    global bufs_suffix

    print_stderr(f'\n{stg} -- channels={channels}:')
    ch = 0
    while channels is not None and ch <= channels:
        bstr = ''
        for b in bufs_notes_channel[ch]:
            if bstr != '':
                bstr = bstr + ','
            # fi
            bstr = bstr + f'{b+1}'
        # rof
        print_stderr(f'bufs_notes_channel[{ch}]={bstr}')
        print_stderr(f'gcs note vel lth   clicks-on/off cc7= on/off cc10= on/off cc11= on/off cc64= on/off cc65= on/off cc91= on/off suffix')
        for n in range(0, len(bufs_notes[ch])):
            print_stderr(f'  {bufs_gcs_note[ch][n]:3} {bufs_notes[ch][n]:2} {bufs_notes_velocity[ch][n]:3} {bufs_gcs_length[ch][n]:3} {bufs_notes_start[ch][n]:7} {bufs_notes_end[ch][n]:7} cc7={bufs_cc_start[ch][7][n]:3}-{bufs_cc_end[ch][7][n]:3} cc10={bufs_cc_start[ch][10][n]:3}-{bufs_cc_end[ch][10][n]:3} cc11={bufs_cc_start[ch][11][n]:3}-{bufs_cc_end[ch][11][n]:3} cc64={bufs_cc_start[ch][64][n]:3}-{bufs_cc_end[ch][64][n]:3} cc65={bufs_cc_start[ch][65][n]:3}-{bufs_cc_end[ch][65][n]:3} cc91={bufs_cc_start[ch][91][n]:3}-{bufs_cc_end[ch][91][n]:3} {bufs_suffix[ch][n]}')
        # rof
        ch = ch + 1
    # elihw
    return
# End of print_debug_notes_1

# ----------------------------------------------------------------------------
def print_debug_internal_1(stg):
    global first_note_time

    print_stderr(f'\n{stg}: first_note_time={first_note_time}')

    print_debug_measures_1(stg)

#--     print_debug_title_1(stg)
#--     print_debug_comments_1(stg)
#--     print_debug_keys_1(stg)
#--     print_debug_instruments_1(stg)

    print_debug_notes_1(stg)
    return
# End of print_debug_internal_1

# ============================================================================
def print_debug_hints():
    global staff_hint
    global pages_measures_hint
    global pages_measures_hint_comments
    global bars_measures_hint
    global skip_measure_hint
    global clef_channel_measures_hint
    global instrument_channel_measures_hint
    global key_channel_measures_hint
    global meters_measures_hint
    global meters_values_hint

    for s in staff_hint:
        print_debug(f'staff hint: staff name {s} = {staff_hint[s]}')
    # rof

    for b in pages_measures_hint:
        print_debug(f'page hint: measure {b} = {pages_measures_hint[b]} $$ {pages_measures_hint_comments[b]}')
    # rof
#--
#--     for b in bars_measures_hint:
#--         print_debug(f'bar hint: measure {b} = {bars_measures_hint[b]}')
#--     # rof
#--
    for s in skip_measure_hint:
        print_debug(f'skip measure hint: measure {s} = {skip_measure_hint[s]}')
    # rof
#--
#--     for ch in clef_channel_measures_hint:
#--         for m in clef_channel_measures_hint[ch]:
#--             print_debug(f'clef hint: channel {ch} measure {m} = {clef_channel_measures_hint[ch][m]}')
#--         # rof
#--     # rof
#--
#--     for ch in instrument_channel_measures_hint:
#--         for m in instrument_channel_measures_hint[ch]:
#--             print_debug(f'instrument hint: channel {ch} measure {m} = {instrument_channel_measures_hint[ch][m]}')
#--         # rof
#--     # rof
#--
#--     for ch in key_channel_measures_hint:
#--         for m in key_channel_measures_hint[ch]:
#--             print_debug(f'key hint: channel {ch} measure {m} = {key_channel_measures_hint[ch][m]}')
#--         # rof
#--     # rof
#--
#--     for m in meters_measures_hint:
#--         print_debug(f'meter hint: measure {m} = {meters_measures_hint[m]} ... {meters_values_hint[m]}')
#--     # rof
    return
# End of print_debug_hints

# ============================================================================
is_float_number = 0
is_float_string = 1
# ----------------------------------------------------------------------------
# Calculate values here.
# Input:
#   strg            - The string to compute.
#   type_float      - is_float_number if must be integer.
#                     is_float_string if can return a character var.
#   none_means_none = If true, return '' for None (or not set variable).
# Returns:
#   value      = So far computed value
#   type_error = type of error

def is_float(strg, type_float, none_means_none):
    tree = calculate.parse(strg)            # parse the string
    if tree is None or len(tree) != 2:
        return None, None
    elif tree[0] is None and tree[1] == 'error parsing':
        return strg, tree[1]
    elif tree[0] is not None and tree[0].startswith('ERROR'):
        return strg, tree[0]
    elif tree[1] is None:
        if none_means_none:
            return '', None
        # fi
        return strg, f"is_float -- variable '{strg}' is not set"
    # fi
    elif tree[1] == '.':
        return strg, "bad input to calculator#2"
    # fi
    if type_float == is_float_number:
        try:
            sexpr = float(tree[1])
            if sexpr.is_integer():
                sexpr = int(sexpr)
            # fi
            return sexpr, None
        except:
            return strg, "bad input to calculator#3"
        # yrt
    # fi
    recompute_whichchars()
    return tree[1], None
# End of is_float

# ----------------------------------------------------------------------------
# strng = int_range_to_array(strng)

def int_range_to_array(strng):
    a = strng.find('..')
    if a == 0:
        print_error("Range does not start with number.")
        return [str(strng)]
    elif a < 0:                                 # Not a range
        strng, msg = is_float(strng, is_float_number, False)
        if msg is not None or strng is None:
            return [str(strng)]
        # fi
        if type(strng) is float and strng.is_integer():
            strng = int(strng)
        # fi
        return [str(strng)]
    # fi
    first = strng[0:a]
    second = strng[a + 2:]
    if second is None or second == '':
        print_error("Second number in range bad.")
        return [str(strng)]
    # fi
    n, msg = is_float(first, is_float_number, False)
    if msg is not None or n is None or n == '':
        print_error(f"Range first number bad. {msg} '{first}'")
        return [str(strng)]
    # fi
    o, msg = is_float(second, is_float_number, False)
    if msg is not None or o is None or o == '':
        print_error(f"Range second number bad. {msg}")
        return [str(strng)]
    # fi
    if type(n) is str:
        n = float(n)
    # fi
    if type(n) is float and n.is_integer():
        first = int(n)
    elif type(n) is not int:
        print_error("Range first number not an integer.")
        return [str(strng)]
    # fi
    if type(o) is str:
        o = float(o)
    # fi
    if type(o) is float and o.is_integer():
        second = int(o)
    elif type(o) is not int:
        print_error("Range second number not an integer.")
        return [str(strng)]
    # fi
    array_args = []
    while n < o + 1:
        array_args.append(str(n))
        n = n + 1
    # rof
    return array_args
# End of int_range_to_array

# ----------------------------------------------------------------------------
# strng         is string where token name is.
# terminator    is the termination character looking for.
# doparens      True if should check parens match.
#
# Returns where in strng termination is. -1 if not found. 0=first character.

nest_terminator = { '(':')', '{':'}', "'":"'", '"':'"' }

def find_terminator_in_string(strng, terminators, doparens):
    w = 0
    e = []
    while w < len(strng):
        c = strng[w]
        if c in terminators:
            return w                                # Terminator immediately - blank argument.,
        # fi
        if c in nest_terminator and doparens:
            endterminator = nest_terminator[c]
        else:
            endterminator = None
        # fi
        e.append(endterminator)
        w = w + 1
        if w > len(strng):
            return -1
        # fi
        while endterminator is not None:
            while w < len(strng):
                c = strng[w]
                w = w + 1
                if c == endterminator:
                    break
                # fi
                if endterminator in ['"', "'"]:     # quotes nest nothing.
                    continue
                elif w >= len(strng):
                    if doparens:
                        print_error(f"nested parenthesis, did not find closing {endterminator}.")
                        return -1
                    # fi
                    break
                elif c in nest_terminator:
                    endterminator = nest_terminator[c]
                    e.append(endterminator)
                # fi
            # elihw
            e.pop()
            if e != []:
                endterminator = e[-1]
            else:
                endterminator = None
                break
            # fi
        # elihw
    # elihw
    return -1
# End of find_terminator_in_string

# ----------------------------------------------------------------------------
#   wline         - string to split

def separate_args(wline):
    def b4it(array_args, b4):
        if b4 == '':
            array_args.append(b4)
        else:
            nums = int_range_to_array(b4)
            array_args = array_args + nums
        # fi
        return array_args
    # End of b4it

    global args

    splitter = [ ',', ";" ]
    strng = wline.strip()
    if len(strng) == 0:
        return []
    # fi
    strng = re.sub(r'\s*]', r' ]', strng, count = 1)
    strng = re.sub(r'\s+', r' ', strng)
    strng = re.sub(r'\s*\[', r' [', strng, count = 1)
    strng = re.sub(r'\[\s*', r'[ ', strng, count = 1)
    strng = re.sub(r'\s+', r' ', strng)
    array_args = []
    w = 0
    b4 = ''
    while w < len(strng):
        s = strng[w:]
        x = find_terminator_in_string(s, splitter, True)
        # x == -1   end of strng.
        if x < 0:                           # End of strng reached before splitter character found.
            b4 = s
            break
        # fi
        b4 = s[0:x]
        array_args = b4it(array_args, b4)
        b4 = ''
        w = w + x + 1
    # elihw
    array_args = b4it(array_args, b4)
    return array_args
# End of separate_args

# ----------------------------------------------------------------------------
global allkeys
allkeys = [ 'c', 'd', 'e', 'f', 'g', 'a', 'b',
            'cn', 'dn', 'en', 'fn', 'gn', 'an', 'bn',
            'c-', 'd-', 'e-', 'f-', 'g-', 'a-', 'b-',
            'c--', 'd--', 'e--', 'f--', 'g--', 'a--', 'b--',
            'c+', 'd+', 'e+', 'f+', 'g+', 'a+', 'b+',
            'c++', 'd++', 'e++', 'f++', 'g++', 'a++', 'b++' ]

global vlprint
# 2022-08-12_15-39-03 - allow more space at low range and upper range. (Gives intensity some space.)
vlprint = {  0: 'ppppp',        # Below anything to expect.
            20: 'pppp',
            30: 'ppp',
            40: 'pp',
            50: 'p',
            60: 'mp',
            70: 'mf',
            80: 'f',
            90: 'ff',
            100: 'fff',
            110: 'ffff',
            127: 'fffff',       # Above anything to expect.
          }
global v_name_print
v_name_print = {}
for i in vlprint:
    v_name_print[ vlprint[ i ] ] = i
# rof

# ------------------------------------------------------------------------------
global midi_instruments
# select chan sfont bank prog -      prog, bank.
midi_instruments = {
    'Piano'.lower() : [0, 0],
    'Acoustic Grand Piano'.lower() : [0, 0],
    'Stereo Grand'.lower() : [0, 0],
    'Bright Acoustic Piano'.lower() : [1, 0],
    'Bright Grand'.lower() : [1, 0],
    'Electric Grand Piano'.lower() : [2, 0],
    'Electric Grand'.lower() : [2, 0],
    'Honky-tonk Piano'.lower() : [3, 0],
    'Honky-tonk'.lower() : [3, 0],
    'Electric Piano 1'.lower() : [4, 0],
    'Time Electric Piano 1'.lower() : [4, 0],
    'Electric Piano 2'.lower() : [5, 0],
    'FM Electric Piano'.lower() : [5, 0],
    'Harpsichord'.lower() : [6, 0],
    'Clavi'.lower() : [7, 0],
    'Clavinet'.lower() : [7, 0],
    'Celesta'.lower() : [8, 0],
    'Glockenspiel'.lower() : [9, 0],
    'Music Box'.lower() : [10, 0],
    'Vibraphone'.lower() : [11, 0],
    'Marimba'.lower() : [12, 0],
    'Xylophone'.lower() : [13, 0],
    'Tubular Bells'.lower() : [14, 0],
    'Dulcimer'.lower() : [15, 0],
    'Drawbar Organ'.lower() : [16, 0],
    'Tonewheel Organ'.lower() : [16, 0],
    'Percussive Organ'.lower() : [17, 0],
    'Rock Organ'.lower() : [18, 0],
    'Church Organ'.lower() : [19, 0],
    'Pipe Organ'.lower() : [19, 0],
    'Reed Organ'.lower() : [20, 0],
    'Accordion'.lower() : [21, 0],
    'Harmonica'.lower() : [22, 0],
    'Tango Accordion'.lower() : [23, 0],
    'Bandoneon'.lower() : [23, 0],
    'Acoustic Guitar (nylon)'.lower() : [24, 0],
    'Nylon Guitar'.lower() : [24, 0],
    'Acoustic Guitar (steel)'.lower() : [25, 0],
    'Steel Guitar'.lower() : [25, 0],
    'Electric Guitar (jazz)'.lower() : [26, 0],
    'Jazz Guitar'.lower() : [26, 0],
    'Electric Guitar (clean)'.lower() : [27, 0],
    'Clean Guitar'.lower() : [27, 0],
    'Electric Guitar (muted)'.lower() : [28, 0],
    'Muted Guitar'.lower() : [28, 0],
    'Overdriven Guitar'.lower() : [29, 0],
    'Overdrive Guitar'.lower() : [29, 0],
    'Distortion Guitar'.lower() : [30, 0],
    'Guitar Harmonics'.lower() : [31, 0],
    'Acoustic Bass'.lower() : [32, 0],
    'Electric Bass (finger)'.lower() : [33, 0],
    'Finger Bass'.lower() : [33, 0],
    'Electric Bass (pick)'.lower() : [34, 0],
    'Pick Bass'.lower() : [34, 0],
    'Fretless Bass'.lower() : [35, 0],
    'Slap Bass 1'.lower() : [36, 0],
    'Slap Bass 2'.lower() : [37, 0],
    'Synth Bass 1'.lower() : [38, 0],
    'Synth Bass 2'.lower() : [39, 0],
    'Violin'.lower() : [40, 0],
    'Viola'.lower() : [41, 0],
    'Cello'.lower() : [42, 0],
    'Contrabass'.lower() : [43, 0],
    'Double Bass'.lower() : [43, 0],
    'Tremolo Strings'.lower() : [44, 0],
    'Stero Strings Trem'.lower() : [44, 0],
    'Pizzicato Strings'.lower() : [45, 0],
    'Orchestral Harp'.lower() : [46, 0],
    'Timpani'.lower() : [47, 0],
    'String Ensemble 1'.lower() : [48, 0],
    'Stereo Strings Fast'.lower() : [48, 0],
    'String Ensemble 2'.lower() : [49, 0],
    'Stereo Strings Slow'.lower() : [49, 0],
    'Synth Strings 1'.lower() : [50, 0],
    'Synth Strings 2'.lower() : [51, 0],
    'Choir Aahs'.lower() : [52, 0],
    'Concert Choir'.lower() : [52, 0],
    'Voice Oohs'.lower() : [53, 0],              # NOT RIGHT!
    'Synth Voice'.lower() : [54, 0],             # NOT RIGHT!
    'Orchestra Hit'.lower() : [55, 0],           # strange sound.
    'Trumpet'.lower() : [56, 0],
    'Trombone'.lower() : [57, 0],
    'Tuba'.lower() : [58, 0],
    'Muted Trumpet'.lower() : [59, 0],
    'French Horn'.lower() : [60, 0],
    'French Horns'.lower() : [60, 0],
    'Brass Section'.lower() : [61, 0],
    'Synth Brass 1'.lower() : [62, 0],
    'Synth Brass 2'.lower() : [63, 0],
    'Soprano Sax'.lower() : [64, 0],
    'Alto Sax'.lower() : [65, 0],
    'Tenor Sax'.lower() : [66, 0],
    'Baritone Sax'.lower() : [67, 0],
    'Oboe'.lower() : [68, 0],
    'English Horn'.lower() : [69, 0],
    'Bassoon'.lower() : [70, 0],
    'Clarinet'.lower() : [71, 0],
    'Piccolo'.lower() : [72, 0],
    'Flute'.lower() : [73, 0],
    'Recorder'.lower() : [74, 0],
    'Pan Flute'.lower() : [75, 0],
    'Blown bottle'.lower() : [76, 0],
    'Bottle Blow'.lower() : [76, 0],
    'Shakuhachi'.lower() : [77, 0],
    'Whistle'.lower() : [78, 0],
    'Irish Tin Whistle'.lower() : [78, 0],
    'Ocarina'.lower() : [79, 0],
    'Lead 1 (square)'.lower() : [80, 0],
    'Square Lead'.lower() : [80, 0],
    'Lead 2 (sawtooth)'.lower() : [81, 0],
    'Saw Lead'.lower() : [81, 0],
    'Lead 3 (calliope)'.lower() : [82, 0],
    'Synth Calliope'.lower() : [82, 0],
    'Lead 4 (chiff)'.lower() : [83, 0],
    'Chiffer Lead'.lower() : [83, 0],
    'Lead 5 (charang)'.lower() : [84, 0],
    'Charang'.lower() : [84, 0],
    'Lead 6 (voice)'.lower() : [85, 0],
    'Solo Vox'.lower() : [85, 0],
    'Lead 7 (fifths)'.lower() : [86, 0],
    '5th Saw Wave'.lower() : [86, 0],
    'Lead 8 (bass + lead)'.lower() : [87, 0],
    'Bass & lead'.lower() : [87, 0],
    'Pad 1 (new age)'.lower() : [88, 0],
    'Fantasia'.lower() : [88, 0],
    'Pad 2 (warm)'.lower() : [89, 0],
    'Warm Pad'.lower() : [89, 0],
    'Pad 3 (polysynth)'.lower() : [90, 0],
    'Polysynth'.lower() : [90, 0],
    'Pad 4 (choir)'.lower() : [91, 0],
    'Space Voice'.lower() : [91, 0],
    'Pad 5 (bowed)'.lower() : [92, 0],
    'Bowed Glass'.lower() : [92, 0],
    'Pad 6 (metallic)'.lower() : [93, 0],
    'Metal Pad'.lower() : [93, 0],
    'Pad 7 (halo)'.lower() : [94, 0],
    'Halo Pad'.lower() : [94, 0],
    'Pad 8 (sweep)'.lower() : [95, 0],
    'Sweep Pad'.lower() : [95, 0],
    'FX 1 (rain)'.lower() : [96, 0],
    'Ice Rain'.lower() : [96, 0],
    'FX 2 (soundtrack)'.lower() : [97, 0],
    'Soundtrack'.lower() : [97, 0],
    'FX 3 (crystal)'.lower() : [98, 0],
    'Crystal'.lower() : [98, 0],
    'FX 4 (atmosphere)'.lower() : [99, 0],
    'Atmosphere'.lower() : [99, 0],
    'FX 5 (brightness)'.lower() : [100, 0],
    'Brightness'.lower() : [100, 0],
    'FX 6 (goblins)'.lower() : [101, 0],
    'Goblins'.lower() : [101, 0],
    'FX 7 (echoes)'.lower() : [102, 0],
    'Echo Drops'.lower() : [102, 0],
    'FX 8 (sci-fi)'.lower() : [103, 0],
    'Star Theme'.lower() : [103, 0],
    'Sitar'.lower() : [104, 0],
    'Banjo'.lower() : [105, 0],
    'Shamisen'.lower() : [106, 0],
    'Koto'.lower() : [107, 0],
    'Kalimba'.lower() : [108, 0],
    'Bag pipe'.lower() : [109, 0],
    'Bagpipes'.lower() : [109, 0],
    'Fiddle'.lower() : [110, 0],
    'Shanai'.lower() : [111, 0],
    'Shenai'.lower() : [111, 0],
    'Tinkle Bell'.lower() : [112, 0],
    'Tinker Bell'.lower() : [112, 0],
    'Agogo'.lower() : [113, 0],
    'Steel Drums'.lower() : [114, 0],
    'Woodblock'.lower() : [115, 0],
    'Wood Block'.lower() : [115, 0],
    'Taiko Drum'.lower() : [116, 0],
    'Melodic Tom'.lower() : [117, 0],
    'Synth Drum'.lower() : [118, 0],
    'Reverse Cymbal'.lower() : [119, 0],
    'Guitar Fret Noise'.lower() : [120, 0],
    'Fret Noise'.lower() : [120, 0],
    'Breath Noise'.lower() : [121, 0],
    'Seashore'.lower() : [122, 0],
    'Bird Tweet'.lower() : [123, 0],
    'Birds'.lower() : [123, 0],
    'Telephone Ring'.lower() : [124, 0],
    'Telephone 1'.lower() : [124, 0],
    'Helicopter'.lower() : [125, 0],
    'Applause'.lower() : [126, 0],
    'Gunshot'.lower() : [127, 0],
    'Gun Shot'.lower() : [127, 0],
    'Synth Bass 101'.lower() : [38, 1],
    'Mono Strings Trem'.lower() : [44, 1],
    'Mono Strings Fast'.lower() : [48, 1],
    'Mono Strings Slow'.lower() : [49, 1],
    'Concert Choir Mono'.lower() : [52, 1],
    'Trumpet 2'.lower() : [56, 1],
    'Trombone 2'.lower() : [57, 1],
    'Muted Trumpet 2'.lower() : [59, 1],
    'Solo French Horn'.lower() : [60, 1],
    'Brass Section Mono'.lower() : [61, 1],
    'Square Wave'.lower() : [80, 1],
    'Saw Wave'.lower() : [81, 1],
    'Synth Mallet'.lower() : [98, 1],
    'Cut Noise'.lower() : [120, 1],
    'Fl. Key Click'.lower() : [121, 1],
    'Rain'.lower() : [122, 1],
    'Dog'.lower() : [123, 1],
    'Telephone 2'.lower() : [124, 1],
    'Car-Engine'.lower() : [125, 1],
    'Laughing'.lower() : [126, 1],
    'Machine Gun'.lower() : [127, 1],
    'Echo Pan'.lower() : [102, 2],
    'String Slap'.lower() : [120, 2],
    'Thunder'.lower() : [122, 2],
    'Horse Gallop'.lower() : [123, 2],
    'Door Creaking'.lower() : [124, 2],
    'Car-Stop'.lower() : [125, 2],
    'Scream'.lower() : [126, 2],
    'Lasergun'.lower() : [127, 2],
    'Howling Winds'.lower() : [122, 3],
    'Bird 2'.lower() : [123, 3],
    'Door'.lower() : [124, 3],
    'Car-Pass'.lower() : [125, 3],
    'Punch'.lower() : [126, 3],
    'Explosion'.lower() : [127, 3],
    'Stream'.lower() : [122, 4],
    'Scratch'.lower() : [123, 4],
    'Car-Crash'.lower() : [125, 4],
    'Heart Beat'.lower() : [126, 4],
    'Bubbles'.lower() : [122, 5],
    'Windchime'.lower() : [124, 5],
    'Siren'.lower() : [125, 5],
    'Footsteps'.lower() : [126, 5],
    'Train'.lower() : [125, 6],
    'Jet Plane'.lower() : [125, 7],
    'Chorused Tine EP'.lower() : [4, 8],
    'Chorused FM EP'.lower() : [5, 8],
    'Coupled Harpsichord'.lower() : [6, 8],
    'Church Bells'.lower() : [14, 8],
    'Detuned Tnwl. Organ'.lower() : [16, 8],
    'Detuned Perc. Organ'.lower() : [17, 8],
    'Pipe Organ 2'.lower() : [19, 8],
    'Italian Accordian'.lower() : [21, 8],
    'Ukulele'.lower() : [24, 8],
    '12-String Guitar'.lower() : [25, 8],
    'Hawaiian Guitar'.lower() : [26, 8],
    'Chorused Clean Gt.'.lower() : [27, 8],
    'Funk Guitar'.lower() : [28, 8],
    'Feedback Guitar'.lower() : [30, 8],
    'Guitar Feedback'.lower() : [31, 8],
    'Synth Bass 3'.lower() : [38, 8],
    'Synth Bass 4'.lower() : [39, 8],
    'Orchestra Pad'.lower() : [48, 8],
    'Synth Strings 3'.lower() : [50, 8],
    'Brass Section 2'.lower() : [61, 8],
    'Synth Brass 3'.lower() : [62, 8],
    'Synth Brass 4'.lower() : [63, 8],
    'Sine Wave'.lower() : [80, 8],
    'Doctor Solo'.lower() : [81, 8],
    'Taisho Koto'.lower() : [107, 8],
    'Castanets'.lower() : [115, 8],
    'Concert Bass Drum'.lower() : [116, 8],
    'Melodic Tom 2'.lower() : [117, 8],
    '808 Tom'.lower() : [118, 8],
    'Starship'.lower() : [125, 8],
    'Carillon'.lower() : [14, 9],
    'Burst Noise'.lower() : [125, 9],
    'Piano & Str.-Fade'.lower() : [0, 11],
    'Piano & Str.-Sus'.lower() : [1, 11],
    'Tine & FM EPs'.lower() : [4, 11],
    'Piano & FM EP'.lower() : [5, 11],
    'Tinkling Bells'.lower() : [8, 11],
    'Bell Tower'.lower() : [14, 11],
    'Techno Bass'.lower() : [38, 11],
    'Pulse Bass'.lower() : [39, 11],
    'Stereo Strings Velo'.lower() : [49, 11],
    'Synth Strings 4'.lower() : [50, 11],
    'Synth Strings 5'.lower() : [51, 11],
    'Brass Section 3'.lower() : [61, 11],
    'Whistlin'.lower() : [78, 11],
    'Sawtooth Stab'.lower() : [81, 11],
    "Doctor's Solo".lower() : [87, 11],
    'Harpsi Pad'.lower() : [88, 11],
    'Solar Wind'.lower() : [89, 11],
    'Mystery Pad'.lower() : [96, 11],
    'Synth Chime'.lower() : [98, 11],
    'Bright Saw Stack'.lower() : [100, 11],
    'Cymbal Crash'.lower() : [119, 11],
    'Filter Snap'.lower() : [121, 11],
    'Interference'.lower() : [127, 11],
    'Bell Piano'.lower() : [0, 12],
    'Bell Tine EP'.lower() : [4, 12],
    'Christmas Bells'.lower() : [10, 12],
    'Clean Guitar 2'.lower() : [27, 12],
    'Mean Saw Bass'.lower() : [38, 12],
    'Full Orchestra'.lower() : [48, 12],
    'Mono Strings Velo'.lower() : [49, 12],
    'Square Lead 2'.lower() : [80, 12],
    'Saw Lead 2'.lower() : [81, 12],
    'Fantasia 2'.lower() : [88, 12],
    'Solar Wind 2'.lower() : [89, 12],
    'White Noise Wave'.lower() : [122, 12],
    'Shooting Star'.lower() : [127, 12],
    'Woodwind Choir'.lower() : [48, 13],
    'Square Lead 3'.lower() : [80, 13],
    'Saw Lead 3'.lower() : [81, 13],
    'Night Vision'.lower() : [88, 13],
    'Mandolin'.lower() : [25, 16],
    'Standard Drums'.lower() : [0, 120],
    'Standard 2 Drums'.lower() : [1, 120],
    'Room Drums'.lower() : [8, 120],
    'Power Drums'.lower() : [16, 120],
    'Electronic Drums'.lower() : [24, 120],
    '808/909 Drums'.lower() : [25, 120],
    'Dance Drums'.lower() : [26, 120],
    'Jazz Drums'.lower() : [32, 120],
    'Brush Drums'.lower() : [40, 120],
    'Orchestral Perc.'.lower() : [48, 120],
    'SFX Kit'.lower() : [56, 120],
    'Standard'.lower() : [0, 128],
    'Standard 2'.lower() : [1, 128],
    'Room'.lower() : [8, 128],
    'Power'.lower() : [16, 128],
    'Electronic'.lower() : [24, 128],
    '808/909'.lower() : [25, 128],
    'Dance'.lower() : [26, 128],
    'Jazz'.lower() : [32, 128],
    'Brush'.lower() : [40, 128],
    'Orchestral'.lower() : [48, 128],
    'SFX'.lower() : [56, 128],
}

# ------------------------------------------------------------------------------
global drum_sounds
drum_sounds = {
    'Acoustic Bass Drum'.lower(): 35,
    'Bass Drum 1'.lower(): 36,
    'Side Stick'.lower(): 37,
    'Acoustic Snare'.lower(): 38,
    'Hand Clap'.lower(): 39,
    'Electric Snare'.lower(): 40,
    'Low Floor Tom'.lower(): 41,
    'Closed Hi Hat'.lower(): 42,
    'High Floor Tom'.lower(): 43,
    'Pedal Hi-Hat'.lower(): 44,
    'Low Tom'.lower(): 45,
    'Open Hi-Hat'.lower(): 46,
    'Low-Mid Tom'.lower(): 47,
    'Hi Mid Tom'.lower(): 48,
    'Crash Cymbal 1'.lower(): 49,
    'High Tom'.lower(): 50,
    'Ride Cymbal 1'.lower(): 51,
    'Chinese Cymbal'.lower(): 52,
    'Ride Bell'.lower(): 53,
    'Tambourine'.lower(): 54,
    'Splash Cymbal'.lower(): 55,
    'Cowbell'.lower(): 56,
    'Crash Cymbal 2'.lower(): 57,
    'Vibraslap'.lower(): 58,
    'Ride Cymbal 2'.lower(): 59,
    'Hi Bongo'.lower(): 60,
    'Low Bongo'.lower(): 61,
    'Mute Hi Conga'.lower(): 62,
    'Open Hi Conga'.lower(): 63,
    'Low Conga'.lower(): 64,
    'High Timbale'.lower(): 65,
    'Low Timbale'.lower(): 66,
    'High Agogo'.lower(): 67,
    'Low Agogo'.lower(): 68,
    'Cabasa'.lower(): 69,
    'Maracas'.lower(): 70,
    'Short Whistle'.lower(): 71,
    'Long Whistle'.lower(): 72,
    'Short Guiro'.lower(): 73,
    'Long Guiro'.lower(): 74,
    'Claves'.lower(): 75,
    'Hi Wood Block'.lower(): 76,
    'Low Wood Block'.lower(): 77,
    'Mute Cuica'.lower(): 78,
    'Open Cuica'.lower(): 79,
    'Mute Triangle'.lower(): 80,
    'Open Triangle'.lower(): 81,
}

# ----------------------------------------------------------------------------
# staff   7 violin2         $$ Channel 7 is in a staff and named violin2.

def do_staff(t_args):
    global staff_hint

    if t_args is None or t_args == '':
        print_error("staff does not have an expression to process")
        return
    # fi

    vargs = get_channel_measure_other(t_args, 'staff')
    if vargs is None:
        return
    # fi
    if len(vargs) > 2:
        print_error("staff format is channel numbers followed by staff name")
        return
    # fi
    chn = separate_args(str(vargs[0]))          # Get channel numbers.

    n = vargs[1]                                # staff name
    if n not in staff_hint:
        staff_hint[n] = {}
    # fi

    for ch in chn:
        f1, type_error = is_float(ch, is_float_number, False)
        if type_error is not None:
            print_error(f"bars error - {type_error}")
            return
        # fi
        if f1 is None:
            print_error("bars argument as a calculation did not return a value")
            return
        # fi
        f1 = round(f1)
        staff_hint[n][f1] = True
    # rof
    return
# End of do_staff

# ----------------------------------------------------------------------------
# bars    7                 $$ Group the next 7 bars on one staff line.
# bars    7 10,20,30        $$ Group the 7 bars on one staff line for measures.

def do_bars(t_args):
    global bars_measure

    if t_args is None or t_args == '':
        print_error("bars does not have an expression to process")
        return
    # fi

    vargs = get_channel_measure_other(t_args, 'bars')
    if vargs is None:
        return
    # fi
    if len(vargs) > 2:
        print_error("bars format is number bars printed for staff, then optional measures")
        return
    # fi
    m = vargs[0]

    f1, type_error = is_float(m, is_float_number, False)
    if type_error is not None:
        print_error(f"bars error - {type_error}")
        return
    # fi
    if f1 is None:
        print_error("bars argument as a calculation did not return a value")
        return
    # fi
    f1 = round(f1)

    # See if measures.
    if len(vargs) == 1:
        mn = ( '1' )               # default to measure 1
    else:
        mn = separate_args(str(vargs[1]))     # The measure numbers.
    # fi
    if not mn or len(mn) < 1:
        print_error("no measure argument(s) for bar command")
        return
    # fi
    for w in mn:
        f2, type_error = is_float(w, is_float_number, False)
        if type_error is not None:
            print_error(f"bars channel {w} error - {type_error}")
            return
        # fi
        if f2 is None:
            print_error(f"bars channel {w} is not a number.")
            return
        # fi
        f2 = round(f2)
        bars_measures_hint[f2] = f1
    # rof
    return
# End of do_bars

# ----------------------------------------------------------------------------
# clef 1,2,3 1,10,22,50 treble  # channels 1,2,3 in measures 1,10,22,50 to treble .
# clef 4                alto    # channel 4 to alto

def do_clef(t_args):
    global clef_channel_measures_hint

    vargs = get_channel_measure_other(t_args, 'clef')
    if vargs is None:
        return
    # fi
    if len(vargs) < 2:
        print_error(f"clef does not have at least 2 arguments (has {len(vargs)})")
        return None
    # fi
    if len(vargs) > 3:
        print_error(f"clef has more than 3 arguments (channels measures clef) - has {len(vargs)}")
        return None
    # fi

    chn = separate_args(str(vargs[0]))  # Allow channel numbers.
    if not chn or len(chn) < 1:
        print_error("no channel arguments on clef line")
        return
    # fi

    # See if measures present.
    if len(vargs) == 3:
        mn = separate_args(str(vargs[1]))   # Allow measure numbers.
        if not mn or len(mn) < 1:
            print_error("no measure arguments on clef line")
            return
        # fi
        clf = vargs[2]
    else:
        mn = ( '1' )
        clf = vargs[1]
    # fi

    for ch in chn:
        f1, type_error = is_float(ch, is_float_number, False)
        if type_error is not None:
            print_error(f"clef channel {ch} error - {type_error}")
            return
        # fi
        if f1 is None:
            print_error(f"clef channel {ch} is not a number.")
            return
        # fi
        f1 = round(f1)
        for m in mn:
            f2, type_error = is_float(m, is_float_number, False)
            if type_error is not None:
                print_error(f"clef measure {m} error - {type_error}")
                return
            # fi
            if f2 is None:
                print_error(f"clef measure {m} is not a number.")
                return
            # fi
            f2 = round(f2)
            if f1 not in clef_channel_measures_hint:
                clef_channel_measures_hint[f1] = {}
            # fi
            clef_channel_measures_hint[f1][f2] = clf
        # rof
    # rof
    return
# End of do_clef

# ----------------------------------------------------------------------------
# Get t_args of channel numbers, followed by optional measures, then next.

def get_channel_measure_other(t_args, command):
    if t_args is None or t_args == '':
        print_error(f"{command} command does not have any arguments")
        return None
    # fi

    targs = re.sub(r'\s*,\s*', ',', t_args)
    targs = re.sub(r'\s*\.\.\s*', '..', targs)
    # channel numbers (optional), followed by key name, with major/minor (optional).
    vargs = targs.split()
    return vargs
# End of get_channel_measure_other

# ----------------------------------------------------------------------------
#       key     1..5           g-       $$ six flats, measure 1 onwards.
#       key     1,2            f        $$ one flat, measure 1 onwards.
#       key     1   10,20,30   c        $$ no flats or sharps, channel 1, measures 10,20,30.
#       key     1              c        $$ Measure 1 onwards.
# Changes at start of a measure.

def do_key(t_args):
    global key_channel_measures_hint
    global key_sig

    vargs = get_channel_measure_other(t_args, 'key')
    if vargs is None:
        return
    # fi
    if len(vargs) < 2:
        print_error(f"key does not have at least 2 arguments (has {len(vargs)})")
        return None
    # fi
    if len(vargs) > 3:
        print_error(f"key has more than 3 arguments (channels measures key) - has {len(vargs)}")
        return None
    # fi

    channelnumbers = separate_args(str(vargs[0]))   # Allow channel numbers.
    if not channelnumbers or len(channelnumbers) < 1:
        print_error("no channel arguments on key line")
        return
    # fi

    # See if measures present.
    if len(vargs) == 3:
        mn = separate_args(str(vargs[1]))   # Allow measure numbers.
        if not mn or len(mn) < 1:
            print_error("no measure arguments on key line")
            return
        # fi
        ky = vargs[2].lower()
    else:
        mn = ( '1' )
        ky = vargs[1].lower()
    # fi

    # Validate key argument.
    if ky not in key_sig:
        print_error(f"key '{ky}' not recognized.")
        return
    # fi

    for ch in channelnumbers:
        f1, type_error = is_float(ch, is_float_number, False)
        if type_error is not None:
            print_error(f"key channel {ch} error - {type_error}")
            return
        # fi
        if f1 is None:
            print_error(f"key channel {ch} is not a number.")
            return
        # fi
        f1 = round(f1)
        for m in mn:
            f2, type_error = is_float(m, is_float_number, False)
            if type_error is not None:
                print_error(f"key measure {m} error - {type_error}")
                return
            # fi
            if f2 is None:
                print_error(f"key measure {m} is not a number.")
                return
            # fi
            f2 = round(f2)
            if f1 not in key_channel_measures_hint:
                key_channel_measures_hint[f1] = {}
            # fi
            key_channel_measures_hint[f1][f2] = ky
        # rof
    # rof
    return
# End of do_key

# ----------------------------------------------------------------------------
def check_instr(instr, bank):
    global midi_instruments
    global drum_sounds

    if type(instr) is str:
        instr = instr.lower()
    else:
        instr = str(instr)
    # fi
    if instr in midi_instruments:
        return instr
    # fi
    if instr in drum_sounds:
        return instr
    # fi

    f1, type_error = is_float(instr, is_float_number, False)
    if type_error is not None:
        return None
    # fi
    if f1 is None:
        return None
    # fi
    f1 = round(f1)

    for i in midi_instruments:
        if midi_instruments[i][0] == f1 and midi_instruments[i][1] == bank:
            return i
        # fi
    # rof
    return f1
# End of check_instr

# ----------------------------------------------------------------------------
#   instrument 1,2 flute                $$ channels for an instrument.
#   instrument 1,2 20,30,50 flute       $$ channels, measures for an instrument.
# See source for list of all instruments.

def do_instrument(t_args):
    global instrument_channel_measures_hint

    vargs = get_channel_measure_other(t_args, 'instrument')
    if vargs is None:
        return
    # fi
    if len(vargs) < 2:
        print_error(f"instrument does not have at least 2 arguments (has {len(vargs)})")
        return None
    # fi
    chn = vargs[0]
    if len(vargs) > 3:
        instr = check_instr(' '.join(vargs[2:]), 0)
        mn = vargs[1]
    elif len(vargs) == 3:               # Does 2 and 3 make an instrument.
        instr = check_instr(' '.join(vargs[1:]), 0)
        if instr is None:
            instr = check_instr(vargs[2], 0)
            mn = vargs[1]
        else:
            mn = [ '1' ]
        # fi
    else:
        instr = check_instr(vargs[1], 0)
        mn = [ '1' ]
    # fi
    if instr is None:
        print_error("instrument not found.")
        return
    # fi

    chn = separate_args(str(chn))       # The channel numbers.
    if not chn or len(chn) < 1:
        print_error("no channel arguments on instrument line")
        return
    # fi

    mn = separate_args(str(mn))         # The measure numbers.
    if not mn or len(mn) < 1:
        print_error("no measure arguments on instrument line")
        return
    # fi

    for ch in chn:
        f1, type_error = is_float(ch, is_float_number, False)
        if type_error is not None:
            print_error(f"instrument channel {ch} error - {type_error}")
            return
        # fi
        if f1 is None:
            print_error(f"instrument channel {ch} is not a number.")
            return
        # fi
        f1 = round(f1)
        for m in mn:
            f2, type_error = is_float(m, is_float_number, False)
            if type_error is not None:
                print_error(f"instrument measure {m} error - {type_error}")
                return
            # fi
            if f2 is None:
                print_error(f"instrument measure {m} is not a number.")
                return
            # fi
            f2 = round(f2)
            if f1 not in instrument_channel_measures_hint:
                instrument_channel_measures_hint[f1] = {}
            # fi
            instrument_channel_measures_hint[f1][f2] = instr
        # rof
    # rof
    return
# End of do_instrument

# ----------------------------------------------------------------------------
# The number of notes of second argument note length in a measure.
#               measure     meter-for-measure
#       meter   1,10        1/8
#       meter   2,11        4/4
#       meter   13          3/4

def do_meter(t_args):
    global meters_measures_hint
    global meters_values_hint

    if t_args is None or t_args == '':
        print_error("meter does not have an expression to process")
        return
    # fi

    vargs = get_channel_measure_other(t_args, 'meter')
    if vargs is None:
        return
    # fi
    if len(vargs) > 2:
        print_error("meter format is for all staves, then optional measures")
        return
    # fi

    mn = separate_args(str(vargs[0]))       # The measure numbers.
    # fi
    if not mn or len(mn) < 1:
        print_error("no measure argument(s) for bar command")
        return
    # fi

    # Get meter.
    meter = vargs[1]
    meter = re.sub(r',', r'/', meter)       # Change 3,4 to 3/4.

    f, type_error = is_float(meter, is_float_number, False)
    if type_error is not None:
        print_error(f"meter {meter} error - {type_error}")
        return
    # fi
    if f is None:
        print_error("meter {meter} argument as a calculation did not return a value")
        return
    # fi

    for w in mn:
        f1, type_error = is_float(w, is_float_number, False)
        if type_error is not None:
            print_error(f"meter measure {w} error - {type_error}")
            return
        # fi
        if f1 is None:
            print_error(f"meter measure {w} is not a number.")
            return
        # fi
        f1 = round(f1)
        meters_measures_hint[f1] = meter        # Save text for meter hints.
        meters_values_hint[f1] = f              # Save values for meter hints.
    # rof
    return
# End of do_meter

# ----------------------------------------------------------------------------
# The value for middle_c.
#       middlec 4c
#       middlec 3c
#       middlec 2b-

def do_middle_c(t_args):
    global middle_c
    global note_to_midi_value

    if t_args is None:
        print_error("middlec does not have a note to process")
        return
    # fi
    if t_args == '':
        compute_middle_c(39)                    # Default to 3c (39).
        return
    # fi
    note_to_decode = t_args
    temp3 = 0                                   # character pointer
    if note_to_decode not in note_to_midi_value:
        thenote, type_error = is_float(note_to_decode, is_float_number, False)
        if type_error is not None:
            print_error("middlec does not have a valid number - {note_to_decode}")
            return
        # fi
        if thenote is None:
            print_error(f"middle_c - Note is not legal '{note_to_decode}', computation failed")
            return
        # fi
        note_to_decode = round(thenote)
        note_to_decode = note_to_decode + 12 + 12 - 3     # 3c -> 39 must be 60 for midi.
        if note_to_decode <= 0 or note_to_decode >= 127:
            print_error(f"middle_c - Note number '{thenote}' not in range")
            return
        # fi
        number = round(thenote)
        return
    else:
        number = note_to_midi_value[note_to_decode] - (60 - middle_c)
    # fi
    compute_middle_c(number)
    return
# End of do_middle_c

# ----------------------------------------------------------------------------
# Set page for measure(s).

def do_page(t_args):
    global pages_measure_hint
    global pages_measures_hint_comments
    global commentonline

    if t_args is None or t_args == '':
        print_error("page does not have an expression to process")
        return
    # fi

    vargs = get_channel_measure_other(t_args, 'page')
    if vargs is None:
        return
    # fi
    if len(vargs) > 2:
        print_error("page format is number, then optional measures")
        return
    # fi
    m = vargs[0]

    f1, type_error = is_float(m, is_float_number, False)
    if type_error is not None:
        print_error(f"page {m} error - {type_error}")
        return
    # fi
    if f1 is None:
        print_error("page {m} argument as a calculation did not return a value")
        return
    # fi
    f1 = round(f1)

    # See if measures.
    if len(vargs) == 1:
        mn = ( '1' )               # default to measure 1
    else:
        mn = separate_args(str(vargs[1]))     # The measure numbers.
    # fi
    if not mn or len(mn) < 1:
        print_error("no measure argument(s) for page command")
        return
    # fi
    for w in mn:
        f2, type_error = is_float(w, is_float_number, False)
        if type_error is not None:
            print_error(f"page channel {w} error - {type_error}")
            return
        # fi
        if f2 is None:
            print_error(f"page channel {w} is not a number.")
            return
        # fi
        f2 = round(f2)
        pages_measures_hint[f2] = f1
        pages_measures_hint_comments[f2] = commentonline
    # rof
    return
# End of do_page

# ----------------------------------------------------------------------------
# skip_measures    7        $$ Do not printout measure 7, delete it, continue with 8 printed as 7.
# skip_measures    156-302  $$ Delete measures 156 thru 302, continue with 303 printed as 156.

def do_skip_measures(t_args):
    global skip_measure_hint

    if t_args is None or t_args == '':
        print_error("skip_measure does not have an expression to process")
        return
    # fi

    vargs = get_channel_measure_other(t_args, 'skip_measure')
    if vargs is None:
        return
    # fi
    if len(vargs) > 1:
        print_error("skip_measure format is number measures to skip only.")
        return
    # fi

    mn = separate_args(str(vargs[0]))     # The measure numbers.
    # fi
    if not mn or len(mn) < 1:
        print_error("no measure argument(s) for skip_measure command")
        return
    # fi
    for w in mn:
        f2, type_error = is_float(w, is_float_number, False)
        if type_error is not None:
            print_error(f"skip_measure {w} error - {type_error}")
            return
        # fi
        if f2 is None:
            print_error(f"skip_measure {w} is not a number.")
            return
        # fi
        f2 = round(f2)
        skip_measure_hint[f2] = f2
    # rof
    return
# End of do_skip_measures

# ----------------------------------------------------------------------------
# Give a title to a printed or played song (abcm2ps, or .mid).
#       title   Inventio 15    by Bach
#       title   for plato by Marshall Midden

def do_title(t_args):
    global titles

    if t_args is None or t_args == '':
        titles.append( '' )
        return
    # fi
    titles.append( t_args )
    return
# End of do_title

# ----------------------------------------------------------------------------
# Do to processing immediately with noteon/noteoff - no need for copy to CHORD.
#       xpose   1 -12
#       xpose   2 -1
#       xpose   1 +12
#       xpose   1,3..5,7 +2

def do_xpose(t_args):
    global xpose_channel

    vargs = get_channel_measure_other(t_args, 'xpose')
    if vargs is None:
        return
    # fi
    if len(vargs) != 2:
        print_error(f"xpose does not have at 2 arguments (has {len(vargs)})")
        return None
    # fi

    chn = separate_args(str(vargs[0]))  # Allow channel numbers.
    if not chn or len(chn) < 1:
        print_error("no channel arguments on xpose line")
        return
    # fi

    # xpose number.
    xp = vargs[1]
    f1, type_error = is_float(xp, is_float_number, False)
    if type_error is not None:
        print_error(f"xpose number {xp} error - {type_error}")
        return
    # fi
    if f1 is None:
        print_error(f"xpose number {xp} is not a number.")
        return
    # fi
    xp = round(f1)

    for ch in chn:
        f1, type_error = is_float(ch, is_float_number, False)
        if type_error is not None:
            print_error(f"xpose channel {ch} error - {type_error}")
            return
        # fi
        if f1 is None:
            print_error(f"xpose channel {ch} is not a number.")
            return
        # fi
        f1 = round(f1)
        xpose_channel[f1] = xp
    # rof
    return
# End of do_xpose

# ----------------------------------------------------------------------------
# Following does not do multiple sharps or flats, but that is crazy anyway. Neither naturals.
global key_sig
key_sig = { 'c+':7, 'f+':6, 'b':5, 'bn':5, 'e':4, 'en':4, 'a':3, 'an':3, 'd':2,
            'dn':2, 'g':1, 'gn':1, 'c':0, 'cn':0, 'f':-1, 'b-':-2, 'e-':-3,
            'a-':-4, 'd-':-5, 'g-':-6, 'c-':-7 }

global key_minor_sig
key_minor_sig = { 'a+':7, 'd+':6, 'g+':5, 'c+':4, 'f+':3, 'b':2, 'e':1, 'a':0,
            'd':-1, 'g':-2, 'c':-3, 'f':-4, 'b-':-5, 'e-':-6, 'a-':-7 }

global key_to_accidentals
key_to_accidentals = {
    'c':  ('c', 'd', 'e', 'f', 'g', 'a', 'b'),
    'cn':  ('c', 'd', 'e', 'f', 'g', 'a', 'b'),

    'f':  ('c', 'd', 'e', 'f', 'g', 'a', 'b-'),
    'b-': ('c', 'd', 'e-', 'f', 'g', 'a', 'b-'),
    'e-': ('c', 'd', 'e-', 'f', 'g', 'a-', 'b-'),
    'a-': ('c', 'd-', 'e-', 'f', 'g', 'a-', 'b-'),
    'd-': ('c', 'd-', 'e-', 'f', 'g-', 'a-', 'b-'),
    'g-': ('c-', 'd-', 'e-', 'f', 'g-', 'a-', 'b-'),
    'c-': ('c-', 'd-', 'e-', 'f-', 'g-', 'a-', 'b-'),

    'g':  ('c', 'd', 'e', 'f+', 'g', 'a', 'b'),
    'd':  ('c+', 'd', 'e', 'f+', 'g', 'a', 'b'),
    'a':  ('c+', 'd', 'e', 'f+', 'g+', 'a', 'b'),
    'e':  ('c+', 'd+', 'e', 'f+', 'g+', 'a', 'b'),
    'b':  ('c+', 'd+', 'e', 'f+', 'g+', 'a+', 'b'),
    'f+': ('c+', 'd+', 'e+', 'f+', 'g+', 'a+', 'b'),
    'c+': ('c+', 'd+', 'e+', 'f+', 'g+', 'a+', 'b+')
}

global key_convert
key_convert = { }
for i in key_to_accidentals:
    l = {}
    for o in range(0, 9) :
        m = 0
        for n in ('c', 'd', 'e', 'f', 'g', 'a', 'b'):
            l[str(o) + n + '--'] = str(o) + n + '--'
            l[str(o) + n + '-']  = str(o) + n + '-'
            l[str(o) + n]        = str(o) + key_to_accidentals[i][m]
            l[str(o) + n + 'n']  = str(o) + n + 'n'
            l[str(o) + n + '+']  = str(o) + n + '+'
            l[str(o) + n + '++'] = str(o) + n + '++'
            m = m + 1
        # rof
    # rof
    key_convert[i] = l
# rof

# ----------------------------------------------------------------------------
# dictionary hint_commands : execute routine: globals()['do_cstopnow'](t_args, line)
global hint_commands
hint_commands = {
#            Command           Routine
             'bars'          : do_bars,
             'clef'          : do_clef,
             'instrument'    : do_instrument,
             'key'           : do_key,
             'meter'         : do_meter,
             'middlec'       : do_middle_c,
             'page'          : do_page,
             'skip_measures' : do_skip_measures,
             'staff'         : do_staff,
             'title'         : do_title,
             'transpose'     : do_xpose,
             'xpose'         : do_xpose,
           }

# ----------------------------------------------------------------------------
#    octave  0      1      2      3      4       5       6       7       8
#  c/b+     24     36     48     60     72      84      96     108     120
#  c+/d-    25     37     49     61     73      85      97     109     121
#  d        26     38     50     62     74      86      98     110     122
#  d+/e-    27     39     51     63     75      87      99     111     123
#  e/f-     28     40     52     64     76      88     100     112     124
#  f/e+     29     41     53     65     77      89     101     113     125
#  f+/g-    30     42     54     66     78      90     102     114     126
#  g        31     43     55     67     79      91     103     115     127
#  g+/a-    32     44     56     68     80      92     104     116
#  a        33     45     57     69     81      93     105     117
#  a+/b-    34     46     58     70     82      94     106     118
#  b/c-     35     47     59     71     83      95     107     119

# For octave 3c = 60.
global note_in_octave_value
note_in_octave_value = {
   'c--':58, 'c-':59, 'c':60, 'cn':60, 'c+':61, 'c++':62,
   'd--':60, 'd-':61, 'd':62, 'dn':62, 'd+':63, 'd++':64,
   'e--':62, 'e-':63, 'e':64, 'en':64, 'e+':65, 'e++':66,
   'f--':63, 'f-':64, 'f':65, 'fn':65, 'f+':66, 'f++':67,
   'g--':65, 'g-':66, 'g':67, 'gn':67, 'g+':68, 'g++':69,
   'a--':67, 'a-':68, 'a':69, 'an':69, 'a+':70, 'a++':71,
   'b--':69, 'b-':70, 'b':71, 'bn':71, 'b+':72, 'b++':73
}

global note_to_midi_value
note_to_midi_value = { }
global note_to_midi_value_39
note_to_midi_value_39 = { }

global midi_value_to_note_flat
midi_value_to_note_flat = { }
global midi_value_to_note_flat_39
midi_value_to_note_flat_39 = { }

global midi_value_to_note_sharp
midi_value_to_note_sharp = { }
global midi_value_to_note_sharp_39
midi_value_to_note_sharp_39 = { }

global middle_c
middle_c = 39                   # Default to 60, as per cyber1 (1978 era) musicomp.

def compute_middle_c(f):
    global note_in_octave_value
    global note_to_midi_value
    global note_to_midi_value_39
    global midi_value_to_note_sharp
    global midi_value_to_note_sharp_39
    global midi_value_to_note_flat
    global midi_value_to_note_flat_39
    global middle_c

    middle_c = f
    f = f + 12 + 12 - 3             # 3c -> 39 must be 60 for midi.
    f39 = 39 + 12 + 12 - 3         # 3c -> 39 must be 60 for midi.
    note_to_midi_value = {}
    note_to_midi_value_39 = {}
    midi_value_to_note_sharp = {}
    midi_value_to_note_sharp_39 = {}
    midi_value_to_note_flat = {}
    midi_value_to_note_flat_39 = {}

    for o in range(0, 9):           # 0 thru 8
        for n in note_in_octave_value:
            x = str(o) + n
            v = (note_in_octave_value[n] - (f - 24)) + (12 * o)  # 60-36=24 = '0c'
            v39 = (note_in_octave_value[n] - (f39 - 24)) + (12 * o)  # 60-36=24 = '0c'
            note_to_midi_value[x] = v
            note_to_midi_value_39[x] = v39
            if len(n) >= 3:         # ignore double flat and double sharp
                pass
            elif len(n) == 2:       # accidental
                if n[1] == '+':
                    if v not in midi_value_to_note_sharp:   # Prefer no sharp/flat.
                        midi_value_to_note_sharp[v] = x
                    # fi
                    if v39 not in midi_value_to_note_sharp_39: # Prefer no sharp/flat.
                        midi_value_to_note_sharp_39[v39] = x
                    # fi
                # fi
                if n[1] == '-':
                    if v not in midi_value_to_note_flat:    # Prefer no sharp/flat.
                        midi_value_to_note_flat[v] = x
                    # fi
                    if v39 not in midi_value_to_note_flat_39:  # Prefer no sharp/flat.
                        midi_value_to_note_flat_39[v39] = x
                    # fi
                # Ignore 'n'.
                # fi
            else:
                midi_value_to_note_sharp[v] = x             # Prefer no sharp/flag.
                midi_value_to_note_flat[v] = x
                midi_value_to_note_sharp_39[v39] = x        # Prefer no sharp/flag.
                midi_value_to_note_flat_39[v39] = x
            # fi
        # rof
    # rof
    return
# End of compute_middle_c

compute_middle_c(middle_c)                      # Default to 3c

# ----------------------------------------------------------------------------
def compute_hint_command_args(expand_line):
    if not expand_line:
        return '', '', ''
    # fi
    t0 = re.sub(r'^([a-zA-Z0-9%_*]*).*$', r'\1', expand_line, count=1)   # First token on line.
    t1 = re.sub(r'^[a-zA-Z0-9%_*]*(.*)$', r'\1', expand_line, count=1)   # Rest of line.

    command = t0.lstrip()
    t_args = t1.strip()

    if len(t1) > 0:
        delimiter = t1[0]
    else:
        delimiter = ''
    # fi
    # Note: t0 + t1 = line. :) [Thus know how to do things in character variable substitution.]
    return command, t_args, delimiter
# End of compute_hint_command_args

# ----------------------------------------------------------------------------
# Parse and process hint file line.

def process_hint_line(original_line):
    global hint_commands

    qline = original_line
    command, t_args, delimiter = compute_hint_command_args(qline)

    # Try to process command. If not a command, process notes.
    if command is not None and command in hint_commands:
        try:
            r = hint_commands[command]              # Had an error once ... thus try/expect.
        except:
            print_error(f"Not found processing routine for command '{command}' '{delimiter}' '{t_args}'")
            print('   ', sys.exc_info()[0], sys.exc_info, file=sys.stderr, flush=True)
        # yrt
        r(t_args)
    else:
        print_error(f"Unexpected line in hint file: '{command}' '{t_args}'")
    # fi
    return
# End of process_hint_line

# ----------------------------------------------------------------------------
# Get the next hint file line.
# Return:
#   full_line           - the line without $$ or # comments.
#   commentdollardollar - The $$ or # comment, with the two dollar signs or #.

def read_next_hint_line():
    global line
    global linecount
    global args
    global hint_file
    global errors_happened

    if hint_file is None:
        line = None
        return None, None
    # fi
    full_line = ''
    while True:
        try:
            rline = hint_file.readline()
            if rline is None or rline == '':
                sys.exit(errors_happened)
            # fi
            linecount = linecount + 1
            if rline:
                rline = rline.rstrip()                # trailing spaces gone.
                if rline and rline[-1] == '\\':       # if continued on next line
                    rline = rline[:-1]
                    rline = rline.rstrip()            # trailing spaces gone.
                    full_line += rline
                    continue
                # fi
                full_line += rline
                commentdollardollar = ''
                if '$$' in full_line:
                    # delete anything from $$ onwards.
                    commentdollardollar = re.sub(r'^.*[$][$]', '$$', full_line, count=1)
                    commentdollardollar = commentdollardollar.rstrip()  # trailing spaces gone
                    full_line = re.sub(r'[$][$].*$', '', full_line)
                # fi
                if '#' in full_line:
                    # delete anything from # onwards.
                    commentdollardollar = re.sub(r'^.*[#]', '#', full_line, count=1)
                    commentdollardollar = commentdollardollar.rstrip()  # trailing spaces gone
                    full_line = re.sub(r'[#].*$', '', full_line)
                # fi
#-- need to know continued line ... 8 spaces or start with a tab.
                line = full_line
                return full_line, commentdollardollar
            # fi
        except EOFError:
            if full_line != '':
                line = full_line
                return full_line, commentdollardollar
            # fi
            pass            # print("Read gave EOF", file=sys.stderr, flush=True)
        except SystemExit:
            if full_line != '':
                line = full_line
                return full_line, commentdollardollar
            # fi
            pass            # print("Read gave system exit", file=sys.stderr, flush=True)
        except KeyboardInterrupt:
            print_error("Read got keyboard interrupt")
        except:
            if full_line != '':
                line = full_line
                return full_line, commentdollardollar
            # fi
            print_error("Read got a processing error")
            print('   ', sys.exc_info()[0], sys.exc_info, file=sys.stderr, flush=True)
        # yrt
        break
    # elihw
    line = None
    return None, None
# End of read_next_hint_line

# ----------------------------------------------------------------------------
global commentonline

# ----------------------------------------------------------------------------
def readhintfile():
    global linecount
    global args
    global commentonline

    while True:                                         # Read the file loop.
        line, commentonline = read_next_hint_line()
        if line is None and commentonline is None:      # If end of file.
            break
        elif line is None:                              # Blank line
            continue
        # fi
        if args.lines:
            print_stderr(f"linecount={linecount} line='{line}'")
        # fi
        line = line.strip()
        if line == '':                                  # Blank line
            continue
        # fi
        # If command == '*' ignore.
        if re.match(r'^\s*[#*]', line):                 # Comment line.
            continue
        # fi
        process_hint_line(line)
    # elihw
    return
# End of readhintfile

# ----------------------------------------------------------------------------
def determine_which_staffs():
    global staff_hint
    global channels
    global bufs_notes_channel
    global last_fs_channel

    channels_needed = {}

    cn = 0
    while channels is not None and cn <= channels:
        if cn in bufs_notes and bufs_notes[cn] != []:
            channels_needed[cn] = True
        # fi
        cn = cn + 1
    # elihw

    for s in staff_hint:
        for cn in staff_hint[s]:
            if cn in channels_needed:
                channels_needed[cn] = False         # Good, staff channel in channels_needed.
            # fi
        # rof
    # rof

    # Delete channel from staff_hint.

    # See which channels are NOT in any staffs?
    for cn in channels_needed:
        if channels_needed[cn]:
#--             print_stderr(f"determine_which_staffs - channel {cn} not in any staff, creating staff_{cn + 1}")
#--             print_stderr(f"    - bufs_notes[{cn}]={bufs_notes[cn]}")
            q = []
            for bc in bufs_notes_channel[cn]:
                q.append(bc)
                channels_needed[bc] = False         # Good, staff channel in channels_needed.
            # rof
            staff_hint[f'staff_{cn + 1}'] = q
        # fi
    # elihw
    return
# End of determine_which_staffs

# ----------------------------------------------------------------------------
def output_staves():
    global staff_hint

    for s in staff_hint:
        strg = ''
        for cs in staff_hint[s]:
            if strg != '':
                strg = strg + ','
            # fi
            strg = strg + f'{cs + 1}'
        # rof
        print_output(f'staff   {s}:{strg}')
    # rof
    return
# End of output_staves

# ----------------------------------------------------------------------------
def output_xpose():
    global staff_hint
    global xpose_channel

    for s in staff_hint:
        count = 0
        first = None
        which = None
        for cs in staff_hint[s]:
            if cs in xpose_channel:
                if first is None:
                    first = cs
                    which = xpose_channel[cs]
                elif xpose_channel[cs] != which:
                    print_error(f'xpose for staff {s} has different xpose for channel {cs} ({xpose_channel[cs]}) and {first} ({which})')
                # fi
                count = count + 1
            elif which is not None:
                print_error(f'xpose for staff {s} has no xpose for channel {cs} != channel {first} ({which})')
            # fi
        # rof
        if count == 0:
            pass
        elif count != len(staff_hint[s]):
            print_error(f'xpose for staff {s} does not have enough channels set: {staff_hint[s]} has only {count}')
        elif which is not None:
            print_output(f'xpose   {s} {-which}')
        #
    # rof
    return
# End of output_xpose

# ----------------------------------------------------------------------------
def output_clefs(m):
    global channels
    global clef_channel_measures_hint
    global last_clef
    global staff_hint

    for s in staff_hint:
        count = 0
        first = None
        which = None
        for cs in staff_hint[s]:
            if cs in clef_channel_measures_hint and m in clef_channel_measures_hint[cs]:
                if first is None:
                    first = cs
                    which = clef_channel_measures_hint[cs][m]
                elif clef_channel_measures_hint[cs][m] != which:
                    print_error(f'clef for staff {s} has different clef for channel {cs} measure {m} ({clef_channel_measures_hint[cs][m]}) and {first} ({which})')
                # fi
                count = count + 1
            elif which is not None:
                print_error(f'clef for staff {s} has no clef_channel_measures_hint for channel {cs} measure {m} != channel {first} ({which})')
            # fi
        # rof
        if count == 0:
            pass
        elif count != len(staff_hint[s]):
            print_error(f'clef for staff {s} does not have enough channels set: {staff_hint[s]} has only {count}')
        elif which is not None:
            if cs not in last_clef or which != last_clef[cs]:
                print_output(f'clef    {s} {which}')
            # fi
            last_clef[cs] = which
        #
    # rof
    return
# End of output_clefs

# ----------------------------------------------------------------------------
def output_keys(m):
    global channels
    global measures_key
    global last_key
    global staff_hint

    for s in staff_hint:
        count = 0
        first = None
        which = None
        for cs in staff_hint[s]:
            if cs in measures_key and m in measures_key[cs]:
                if first is None:
                    first = cs
                    which = measures_key[cs][m]
                elif measures_key[cs][m] != which:
                    print_error(f'key for staff {s} has different key for channel {cs} measure {m} ({measures_key[cs][m]}) and {first} ({which})')
                # fi
                count = count + 1
            elif which is not None:
                print_error(f'key for staff {s} has no measures_key for channel {cs} measure {m} != channel {first} ({which})')
            # fi
        # rof
        if count == 0:
            pass
        elif count != len(staff_hint[s]):
            print_error(f'key for staff {s} does not have enough channels set: {staff_hint[s]} has only {count}')
        elif which is not None:
            if cs not in last_key or which != last_key[cs]:
                print_output(f'key     {s} {which}')
            # fi
            last_key[cs] = which
        #
    # rof
    return
# End of output_keys

# ----------------------------------------------------------------------------
def output_instruments(m):
    global channels
    global measures_instrument
    global last_instrument
    global staff_hint

    for s in staff_hint:
        count = 0
        first = None
        which = None
        for cs in staff_hint[s]:
            if cs in measures_instrument and m in measures_instrument[cs]:
                if first is None:
                    first = cs
                    which = measures_instrument[cs][m]
                elif measures_instrument[cs][m] != which:
                    print_error(f'instrument for staff {s} has different instrument for channel {cs} measure {m} ({measures_instrument[cs][m]}) and {first} ({which})')
                # fi
                count = count + 1
            elif which is not None:
                print_error(f'instrument for staff {s} has no measures_instrument for channel {cs} measure {m} != channel {first} ({which})')
            # fi
        # rof
        if count == 0:
            pass
        elif count != len(staff_hint[s]):
            print_error(f'instrument for staff {s} does not have enough channels set: {staff_hint[s]} has only {count}')
        elif which is not None:
            if cs not in last_instrument or which != last_instrument[cs]:
                print_output(f'instrument {s} {which}')
            # fi
            last_instrument[cs] = which
        #
    # rof
    return
# End of output_instruments

# ----------------------------------------------------------------------------
def output_single_channel(m, s, cs, notes):
    global bufs_gcs_note
    global bufs_gcs_length
    global bufs_suffix

    strg = f'{s}: '
    flag = False
    totalline = ''
    space_flag = False
    for n in notes[cs]:
        if len(strg) > 110 - (len(s) + 4):
            totalline = totalline + strg + '\n'
            strg = f'{s}: '
            flag = False
        # fi
        if flag:
            strg = strg + ','
            if space_flag:
                space_flag = False
                strg = strg + ' '
            # fi
        # fi
        l = bufs_gcs_length[cs][n]
        if l != '':
            lth = get_length_fraction(l)
            if lth >= 0.25 and strg != '' and strg[-1] not in ('[', ']'):
                if bufs_gcs_note[cs][n][-1] != ')' and strg[-1] != ' ':
                    strg = strg + ' '
                # fi
                space_flag = True
            else:
                space_flag = False
            # fi
        # fi
        strg = strg + f'{bufs_gcs_note[cs][n]}{l}{bufs_suffix[cs][n]}'
        flag = True
    # rof
    if flag:
        totalline = totalline + strg
    # fi
    if totalline != '':
        print_output(totalline)
    # fi
    return
# End of output_single_channel

# ----------------------------------------------------------------------------
# lth = get_length_fraction(bufs_gcs_length[ch][n])
def get_length_fraction(strg):
    global midi_2_note_lengths
    global midi_2_note_lengths_dotted
    global midi_2_note_lengths_double_dotted

    for ml in midi_2_note_lengths:
        if strg == midi_2_note_lengths[ml][0]:
            return midi_2_note_lengths[ml][1]
        # fi
    # rof
    for ml in midi_2_note_lengths_dotted:
        if strg == midi_2_note_lengths_dotted[ml][0]:
            return midi_2_note_lengths_dotted[ml][1]
        # fi
    # rof
    for ml in midi_2_note_lengths_double_dotted:
        if strg == midi_2_note_lengths_double_dotted[ml][0]:
            return midi_2_note_lengths_double_dotted[ml][1]
        # fi
    # rof
    print_debug(f'get_length_fraction - unexpected length of "{strg}"')
    print_die(f'get_length_fraction - unexpected length of "{strg}"')
    return
# End of get_length_fraction

# ----------------------------------------------------------------------------
# Returns ch_with_notes = array of channels, sorted by highest note first.
#   ch_with_notes - array of channels/voices with notes.
#   notes         - dictionary of note indexes for this measure.
# Cheat. Highest of all notes in a channel. This should be interesting.
# The notes lining up in a chord should fix the trill situation.

def sort_by_first_note(ch_with_notes, notes):
    global bufs_notes

    new_ch_with_notes = ch_with_notes.copy()
    if len(ch_with_notes) <= 1:
        return new_ch_with_notes
    # fi
    max_midi_note_in_channel = {}
    for ch in new_ch_with_notes:
        max_midi_note_in_channel[ch] = 0
        for n in notes[ch]:
            if bufs_notes[ch][n] > max_midi_note_in_channel[ch]:
                max_midi_note_in_channel[ch] = bufs_notes[ch][n]
                break
            # fi
        # rof
    # rof
    # Now sort list by value in max_midi_note_in_channel.
    # Stupid simple bubble list, most are only 2 entries long. A few 3.
    for ch_i in range(0, len(new_ch_with_notes) - 1):      # One less.
        for ch_j in range(ch_i + 1, len(new_ch_with_notes)):
            ii = new_ch_with_notes[ch_i]
            jj = new_ch_with_notes[ch_j]
            if max_midi_note_in_channel[ii] < max_midi_note_in_channel[jj]: # First is less than latter.
                # Swap.
                tmp = new_ch_with_notes[ch_i]
                new_ch_with_notes[ch_i] = new_ch_with_notes[ch_j]
                new_ch_with_notes[ch_j] = tmp
            # fi
        # rof
    # rof
    return new_ch_with_notes
# End of sort_by_first_note

# ----------------------------------------------------------------------------
# s = staff
# ch_with_notes is array of channels with notes in them (i.e. not all rests).
# notes is array of indexes into bufs_notes(etc).

def output_real_chords(m, s, ch_with_notes, notes):
    global bufs_gcs_note
    global bufs_gcs_length
    global bufs_suffix

    # Want to slowly go through ch_with_notes, finding shortest note(s) and outputting them.
    # If only 1, then do not chord them (i.e. no [] around them).
    # If two or more start at same time, then [] around them.
    # Then increment rt (running_time) by shortest note just output, and repeat until none left.

    # sort by first note, highest first.
    ch_with_notes = sort_by_first_note(ch_with_notes, notes)

    # Set which notes are playing now. First of each.
    whereat = {}
    for ch in ch_with_notes:
        whereat[ch] = notes[ch][0]          # Next note for channel/voice to do.
        rt = bufs_notes_start[ch][whereat[ch]]         # Running time is that of first note.
    # rof

    strg = ''
    total_line = ''
    first = True

    space_flag = False

    while True:
        # count notes at current time to start.
        start_these = []
        shortest_time = 8589934592          # rests and notes.
        longest_time = 0                    # rests and notes.
        for ch in ch_with_notes:
            n = whereat[ch]
            if n >= len(bufs_gcs_note[ch]) or n > notes[ch][-1]:
                continue
            # fi
            if whereat[ch] <= notes[ch][-1] and bufs_notes_start[ch][whereat[ch]] <= rt:
                start_these.append(ch)
                l = bufs_notes_end[ch][n] - bufs_notes_start[ch][n]
                if shortest_time > l:       # if rest or note
                    shortest_time = l
                # fi
                if l > longest_time:        # if rest or note
                    longest_time = l
                # fi
            # fi
        # rof
        if len(start_these) == 0:
            break
        # fi

        first = False
        # We need to know if rests matter.
        #   If channel is rest:
        #       is this the same time as the longest note to be started. If so, ignore it.
        #   endif.
        really_do_these = []
        rest = None
        for ch in start_these:
            n = whereat[ch]
            if bufs_notes[ch][n] == 0:      # If a rest
                l = bufs_notes_end[ch][n] - bufs_notes_start[ch][n]
                if l == longest_time:       # Can toss rest if it is the same as longest time.
                    rest = ch               # In case only a rest to put out.
                else:
                    really_do_these.append(ch)
                # fi
            else:
                really_do_these.append(ch)
            # fi
        # rof
        if len(really_do_these) == 0:
            really_do_these = [ rest ]
        # fi

        # Ready to print things out.
        if len(really_do_these) != 1:           # Start chord
            if space_flag:
                space_flag = False
                strg = strg + ' '
            # fi
            strg = strg + '['
            flag = False                    # No comma.
        elif strg == '':
            flag = False                    # No comma.
        elif strg[-1] == ']':
            flag = False                    # No comma.
        else:
            flag = True                     # comma.
        # fi

        for ch in really_do_these:
            if flag:
                strg = strg + ','
            # fi
            # A space if length is 4 or longer (quarter note).
            n = whereat[ch]
            l = bufs_gcs_length[ch][n]
            if l != '' and len(really_do_these) == 1:
                lth = get_length_fraction(l)
                if lth >= 0.25 and strg != '' and strg[-1] not in ('[', ']'):
                    if bufs_gcs_note[ch][n][-1] != ')':
                        strg = strg + ' '
                    # fi
                    space_flag = True
                else:
                    space_flag = False
                # fi
            # fi
            strg = strg + f'{bufs_gcs_note[ch][n]}{l}{bufs_suffix[ch][n]}'
            flag = True
            if len(strg) > 110 - (len(s) + 4):
                if total_line != '':
                    total_line = total_line + '\n'
                # fi
                total_line = total_line + f'{s}: ' + strg
                strg = ''
            # rof
        if len(really_do_these) != 1:           # Start chord
            strg = strg + ']'
        # fi
        rt = rt + shortest_time
        for ch in start_these:
            whereat[ch] = whereat[ch] + 1
        # rof
    # elihw
    if strg != '':
        if total_line != '':
            total_line = total_line + '\n'
        # fi
        total_line = total_line + f'{s}: ' + strg
    # fi
    if total_line != '':
        print_output(total_line)
    # fi
    return
# End of output_real_chords

# ----------------------------------------------------------------------------
def output_chords(m, s, notes):
    global bufs_notes                   # Midi note number. An array indexed by channel.
    global bufs_notes_start             # calculated clicks to start of each note for a channel.
    global bufs_notes_end               # calculated clicks to end of each note for a channel.
    global bufs_notes_velocity          # The intensity of note start. (Typically the total volume. *sigh*)
    global bufs_suffix
    global bufs_gcs_note

    ch_with_notes = []
    for ch in notes:
        for n in notes[ch]:
            if bufs_notes[ch][n] != 0:          # If not a rest in channel/voice.
                ch_with_notes.append(ch)
                break
            # fi
        # rof
    # rof

    # No notes in measure for this staff - make sure at least one channel has a rest for output.
    if len(ch_with_notes) == 0:
        for ch in notes:
            ch_with_notes.append(ch)
            break
        # rof
    # fi

    if len(ch_with_notes) == 1:                 # no chord - single channel.
        output_single_channel(m, s, ch_with_notes[0], notes)
        return
    # fi

    # Do the voices/channels that are not all rests.
    output_real_chords(m, s, ch_with_notes, notes)
    return
# End of output_chords

# ----------------------------------------------------------------------------
def no_output_measure_notes(m):
    global staff_hint
    global last_voice_n
    global bufs_notes
    global bufs_notes_start
    global measures_clicks_start
    global measures_clicks_length
    global bufs_gcs_note

    for s in staff_hint:
        for cs in staff_hint[s]:
            n = last_voice_n[cs]
            while n < len(bufs_notes[cs]) and bufs_notes_start[cs][n] < measures_clicks_start[m] + measures_clicks_length[m]:
                n = n + 1
            # elihw
            last_voice_n[cs] = n
        # rof
    # rof
    return
# End of no_output_measure_notes

# ----------------------------------------------------------------------------
def output_measure_notes(m):
    global staff_hint
    global last_voice_n
    global bufs_notes
    global bufs_notes_start
    global measures_clicks_start
    global measures_clicks_length
    global bufs_gcs_note

    for s in staff_hint:
        totalline = ''
        strg = ''
        notes = {}
        notescount = 0
        for cs in staff_hint[s]:
            notes[cs] = []
            n = last_voice_n[cs]
            while n < len(bufs_notes[cs]) and bufs_notes_start[cs][n] < measures_clicks_start[m] + measures_clicks_length[m]:
                notes[cs].append(n)
                n = n + 1
                notescount = notescount + 1
            # elihw
            last_voice_n[cs] = n
        # rof
        if notescount != 0:
            output_chords(m, s, notes)
        # fi
    # rof
    return
# End of output_measure_notes

# ----------------------------------------------------------------------------
def printout_gcs():
    global which_file_output
    global titles
    global middle_c
    global last_measure
    global pages_measures_hint
    global pages_measures_hint_comments
    global bars_measures_hint
    global channels
    global measures_instrument
    global skip_measure_hint

    global last_clef
    last_clef = {}
    global last_key
    last_key = {}
    global last_instrument
    last_instrument = {}
    global last_voice_n
    last_voice_n = {}
    cn = 0
    while cn < MAXCHANNELS:
        last_voice_n[cn] = 0
        cn = cn + 1
    # rof

#--     last_page = ''
#--     last_bar = ''
    last_meter = ''

    print_output(f'* Start of file {which_file_output}')
    print_output(f'* ----------------------------------------------------------------------------')
    for t in titles:
        print_output(f'title   {t}')
    # rof
    if middle_c != 39:
        print_output(f'middlec {middle_c}')
    # fi

    print_output(f'* ----------------------------------------------------------------------------')
    if channels is None:
        print_output('voice   1')
    else:
        print_output(f'voice   {channels + 1}')
    # fi
    print_output(f'* ----------------------------------------------------------------------------')
    output_staves()
    print_output(f'* ----------------------------------------------------------------------------')
    output_xpose()

    if last_measure is None:
        return
    # fi

    printing_measure = 1
    for m in range(1, last_measure + 1):
        if m in skip_measure_hint:
            no_output_measure_notes(m)
            continue
        # fi
        print_output(f'* ----------------------------------------------------------------------------')
        print_output(f'measure {printing_measure}')
        # Pages are in hints file only.
        if printing_measure in pages_measures_hint:
#--            if pages_measures_hint[printing_measure] != last_page:
            if pages_measures_hint_comments[printing_measure] is None:
                print_output(f'page    {pages_measures_hint[printing_measure]}')
            else:
                print_output(f'page    {pages_measures_hint[printing_measure]}    {pages_measures_hint_comments[printing_measure]}')
            # fi
#--                 last_page = pages_measures_hint[printing_measure]
#--             # fi
        # fi
        # Bars are in hints file only.
        if printing_measure in bars_measures_hint:
#--             if bars_measures_hint[printing_measure] != last_bar:
                print_output(f'bars    {bars_measures_hint[printing_measure]}')
#--                 last_bar = bars_measures_hint[printing_measure]
            # fi
        # fi
        # Clefs are in hints file only.
        output_clefs(printing_measure)

        # Keys are calculated, unlike hints.
        output_keys(m)

        # Meters are calculated, unlike hints.
        # This is kind of a problem - hints verses FS input.
        if m in measures_meter:
            if measures_meter[m] != last_meter:
                print_output(f'meter   {measures_meter[m]}')
                last_meter = measures_meter[m]
            # fi
        # fi

        # This is kind of a problem - hints verses FS input.
        # Instrument locations are positioned in measures.
        output_instruments(m)

        output_measure_notes(m)

        printing_measure = printing_measure + 1
    # rof
    print_output(f'* ----------------------------------------------------------------------------')
    print_output('cstop*')
    print_output(f'* End of file {which_file_output}')
    return
# End of printout_gcs

# ----------------------------------------------------------------------------
# Main program follows.
def main():
    global args
    global input_file                   # File to read for input (default is use tty - stdin).
    global output_file                  # File to print to (default is sys.stdout).
    global hint_file                    # File to print to (default is None).
    global which_file_input
    global which_file_output
    global which_file_hint
    global line_from_file
    global line
    global linecount
    global errors_happened
    global warnings_happened
    global array_of_original_lines

    if args.rest:
        if len(args.rest) >= 1:             # Input.
            which_file_input = args.rest[0]
            input_file = open(which_file_input, mode='r', encoding="utf-8")
        # fi
        if len(args.rest) >= 2:             # Output.
            which_file_output = args.rest[1]
            output_file = open(args.rest[1], mode='w', encoding="utf-8")
        # fi
        if len(args.rest) >= 3:             # Hint.
            which_file_hint = args.rest[2]
            hint_file = open(args.rest[2], mode='r', encoding="utf-8")
        # fi
        if len(args.rest) > 3:              # Too many.
            print_error(f'Too many arguments, input, output, hint only. {args.rest}')
            if errors_happened != 0:
                print_stderr(f'exiting with errors_happened={errors_happened}  warnings_happened={warnings_happened}')
            # fi
            sys.exit(1)
        # fi
    # fi

    linecount = 0
    line_from_file = which_file_hint
    readhintfile()

#--     print_debug_hints()

    linecount = 0
    line = None
    line_from_file = which_file_input
    readthefile()                       # Parse the input fs file into arrays/dictionaries/etc.

    linecount = 0
    line = None

    figure_out_measure_locations()      # Where are the starts of measures - from meter clicks and tempos.
#--     print_debug_internal_1('measures determined')

    set_keys_if_not_specified()         # Set a default key.

#--     print_debug_internal_1('keys determined')

    set_instrument_measures()           # Using instrument_channel_measures_hint and instruments[]

#--     print_debug(f'main - measures_instrument={measures_instrument}')
#--     print_debug(f'main - instrument={instrument}')

#--     print_debug_internal_1('instruments determined')

    notes_fit_into_measures()           # Create ties if notes go over measures. Put in rests.

#--     print_debug_internal_1('notes fit into measures determined')

    check_contiguous_notes()            # Check that start->end-> next_start is okay.

#--     print_debug_internal_1('after check_contiguous_notes')

    determine_note_gcs_lengths()        # Figure out what bufs_gcs_length[ch][n] is like "4" = 1/4 note.

#--     print_debug_internal_1('notes lengths determined')

    determine_note_gcs_notes()          # Figure out what bufs_gcs_notes[ch][n] is "4c" (c, 4th octave).
                                        # NOTE: key for channel and previous +/-/n business.

#--     print_debug_internal_1('printable notes determined')

#--     print_debug_internal_1('NEARLY-DONE')

    printable_measures()                # Fix sequences to be printable - s3(3c,4c,5c)4

    determine_which_staffs()

#--     print_debug_internal_1('DONE')

    printout_gcs()                      # Create the gcs file.

    return
# End of main

# ----------------------------------------------------------------------------
if __name__ == '__main__':
    main()
# fi
# ----------------------------------------------------------------------------
if errors_happened != 0:
    print_stderr(f'exiting with errors_happened={errors_happened}  warnings_happened={warnings_happened}')
# fi
sys.exit(errors_happened)
# ----------------------------------------------------------------------------
# End of program fs2gcs.py
# ----------------------------------------------------------------------------
