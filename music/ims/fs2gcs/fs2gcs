#!/usr/bin/python3 -B
# ----------------------------------------------------------------------------
# vim: tabstop=8 expandtab shiftwidth=4 softtabstop=4
# ----------------------------------------------------------------------------
import argparse
import os
import re
import readline
import shlex
import sys
#-- import pprint
#-- # Usage:   pprint.pprint(v_t_lines, width=110, sort_dicts=False)

from fractions import Fraction
# ----------------------------------------------------------------------------
#++ import inspect
#++ print(inspect.currentframe().f_code.co_name, '#0', file=sys.stderr, flush=True)
# ----------------------------------------------------------------------------
import math
# ----------------------------------------------------------------------------
d = os.path.dirname(__file__)
while d.endswith('/.'):
    d = re.sub(r'/[.]$', r'', d)
# elihw
if d.endswith('/fs2gcs'):
    d = os.path.dirname(d)
    while d.endswith('/.'):
        d = re.sub(r'/[.]$', r'', d)
    # elihw
# fi
sys.path.insert(0, d)                       # for calculate.py

import calculate

calculate.cexp_parser()                     # initialize parser
#  
# ============================================================================
global errors_happened              # Count of number of errors that occurred.
errors_happened = 0
# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
global which_file_in                # Input file name (default to stdin).
which_file_in = 'stdin'
global linecount                    # Line number from input file
linecount = 0
global which_file_out               # Output file name (default to stdout).
which_file_out = 'stdout'
global which_file_hint              # Hint file name.
which_file_hint = 'None'
# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
global input_file                   # File to read for input (default is use tty - stdin).
input_file = None
global output_file                  # File to print to (default is sys.stdout).
output_file = sys.stdout
global hint_file                    # File for hints (default is None).
hint_file = None
# ----------------------------------------------------------------------------
def print_stderr(strg, end="\n"):
    print(strg, file=sys.stderr, flush=True, end=end)
    return
# End of print_stderr

# ----------------------------------------------------------------------------
def print_debug(strg, end="\n"):
    print_stderr('DEBUG - ' + strg, end=end)
    return
# End of print_debug

# ----------------------------------------------------------------------------
def print_error(strg, end="\n"):
    global errors_happened          # Count of number of errors that occurred.

    errors_happened = errors_happened + 1
    print_stderr('ERROR - ' + strg, end=end)
    return
# End of print_error

# ----------------------------------------------------------------------------
def print_warning(strg, end="\n"):
    print_stderr('WARNING - ' + strg, end=end)
    return
# End of print_warning

# ----------------------------------------------------------------------------
def print_output(strg):
    global output_file

    print(strg.rstrip(), file=output_file, flush=True)
    return
# End of print_output

# ----------------------------------------------------------------------------
global args

# ----------------------------------------------------------------------------
def parse_args():
    global args

    parser = argparse.ArgumentParser(
        description=__doc__,
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog='this is the epilog')
    parser.add_argument('--lines', '-lines', action='store_true',
                        help='Print each line as it is read from file or macro or loop.')
    parser.add_argument('rest', nargs='*',
                        help='Optionals: inputfile(stdin) outputfile(stdout) hintfile(none)')
    args = parser.parse_args()
    return
# End of parse_args

# ----------------------------------------------------------------------------
parse_args()

# ----------------------------------------------------------------------------
global voices                       # Number of voices
voices = 0
# ----------------------------------------------------------------------------
MAXVOICES = 256
# ----------------------------------------------------------------------------
global MIDICLICKSPERQUARTER
MIDICLICKSPERQUARTER = 480.0
global tempo_s                      # 60 beats per quarter note.
tempo_s = 60
global tempo_l                      # The quarter note for tempo beats.
tempo_l = 0.25
global first_note_time              # When the first note starts.
first_note_time = 0                 # Nothing yet.
global running_time                 # The running time for 'sleep'. At end, it is the end.
running_time = 0                    # Nothing yet.
# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
global no_notes_yet
no_notes_yet = True
# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
global titles
titles = []
# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
global comments
comments = []
global comments_clicks
comments_clicks = []
# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
global key                          # key[voice] = ... .
key = {}
key[0] = 'c'                        # A default
global key_clicks                   # key_clicks = running_time.
key_clicks = {}
key_clicks[0] = 0                   # Default start of it.
# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
global instrument                   # Indexed by voice number.
instrument = {}                     # Array by voice of: (bank, number, running_time)
# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
global meter                        # Printable meter (text).
meter = []
global meter_fractions              # MIDICLICKSPERQUARTER*4 * meter_fraction (clicks per measure)
meter_fractions = []
global meter_clicks                 # Where in running time clicks the meter occurred.
meter_clicks = []
global last_measure                 # Set in 2nd pass, figuring out measure placements - last measure number.
last_measure = None
global measures_clicks_start        # Dictionary of clicks for when measure starts.
measures_clicks_start = {}
global measures_clicks_length       # Dictionary of clicks in each measure.
measures_clicks_length = {}
global measures_meter               # Dictionary of meters for when measure starts.
measures_meter = {}
# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
global bufs_notes_voices            # Array of Voices for chords on this voice.
bufs_notes_voices = {}
global bufs_notes                   # Midi note number. An array indexed by voice.
bufs_notes = {}                     # bufs_notes[v] = []             Midi note number.
global bufs_notes_start             # calculated clicks to start of each note for a voice.
bufs_notes_start = {}
global bufs_notes_end               # calculated clicks to end of each note for a voice.
bufs_notes_end = {}                 #   Used to recognize 'chords'.
global bufs_notes_velocity          # The intensity of note start. (Typically the total volume. *sigh*)
bufs_notes_velocity = {}
global bufs_cc_start                # [voice][cc#]      time in clicks when CC occurred.
bufs_cc_start = {}
global bufs_cc_end                  # [voice][cc#]      time in clicks when CC occurred.
bufs_cc_end = {}
global last_cc                      # If doing a note, the last_cc. NOTE: defaults for 7,10,11,64,68,91.
last_cc = {}
for v in range(0,MAXVOICES):        # Voices if multiple turned on, run to alternative.
    bufs_notes_voices[v] = [v]      # Start with 1:1 voice to chord voice. Note: voices global set with Header -> max.
    bufs_notes[v] = []              # No notes yet.
    bufs_notes_start[v] = []        # No starting time click time for notes.
    bufs_notes_end[v] = []          # No ending time click time for notes.
    bufs_notes_velocity[v] = []     # No note start intensity volume levels.
    bufs_cc_start[v] = []           # No starting cc values.
    bufs_cc_end[v] = []             # No ending cc values.
    last_cc[v] = []
    for cc in range(0, 127):
        bufs_cc_start[v].append([]) # No starting cc's.
        bufs_cc_end[v].append([])   # No ending cc's.
        last_cc[v].append(0)        # No previous cc's.
        if cc == 7:
            last_cc[v][cc] = 100    # default_volume variable.
        elif cc == 10:
            last_cc[v][cc] = 64     # default_pan variable.
        elif cc == 11:
            last_cc[v][cc] = 100    # default_intensity variable.
        elif cc == 64:
            last_cc[v][cc] = 0      # damper off.
        elif cc == 68:
            last_cc[v][cc] = 0      # legato off.
        elif cc == 91:
            last_cc[v][cc] = 0      # reverb none.
        else:
            last_cc[v][cc] = 0      # Otherwise intialize to 0.
        # fi
    # rof
# rof
# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
global array_of_original_lines      # For input, have an array of the original lines.
array_of_original_lines = []
# ----------------------------------------------------------------------------
# These are from the Hints file, and are for printing out the GCS source.
global bars_measures
bars_measures = {}
global pages_measures
pages_measures = {}
global meters_measures
meters_measures = {}
global clef_voice_measures
clef_voice_measures = {}
global instrument_voice_measures
instrument_voice_measures = {}
global key_voice_measures
key_voice_measures = {}
# ----------------------------------------------------------------------------
#-- # Following does not do multiple sharps or flats, but that is crazy anyway. Neither naturals.
#-- global key_sig
#-- key_sig = { 'c+':7, 'f+':6, 'b':5, 'bn':5, 'e':4, 'en':4, 'a':3, 'an':3, 'd':2,
#--             'dn':2, 'g':1, 'gn':1, 'c':0, 'cn':0, 'f':-1, 'b-':-2, 'e-':-3,
#--             'a-':-4, 'd-':-5, 'g-':-6, 'c-':-7 }
#-- 
#-- global key_sig_int
#-- key_sig_int = {}
#-- for i in key_sig:
#--     if key_sig[i] not in key_sig_int:
#--         key_sig_int[key_sig[i]] = i
#--     # fi
#-- # rof
#-- 
# ----------------------------------------------------------------------------
#--         MIDICLICKSPERQUARTER = int(r[1])
global midi_2_note_lengths
midi_2_note_lengths = {}

def do_note_length_calculate():
    global MIDICLICKSPERQUARTER
    global midi_2_note_lengths

    for nl in (1,2,4,8,16,32,64,128):
        # note length.
        m = (MIDICLICKSPERQUARTER / 0.25) / nl
        if int(m * 1000) != int(m)*1000:
#--             print_debug(f'Note length {nl} does not divide by {nl} nicely into MIDICLICKSPERQUARTER {MIDICLICKSPERQUARTER} ... {m}')
            pass
        else:
            m = int(m)
            if m == 0:
                print_debug(f'Note length {nl} gives midi click value of 0')
            else:
                midi_2_note_lengths[m] = ( str(nl), 1.0 / nl )
            # fi
        # fi

        # dotted note lengths.
        md = ((MIDICLICKSPERQUARTER / 0.25) / nl) * 1.5
        if int(md * 1000) != int(md)*1000:
#--             print_debug(f'Note length {nl}d does not divide nicely into MIDICLICKSPERQUARTER {MIDICLICKSPERQUARTER}  ... {md}')
            pass
        else:
            md = int(md)
            if md == 0:
                print_debug(f'Note length {nl} gives midi click value of 0')
            elif md not in midi_2_note_lengths:
                midi_2_note_lengths[md] = ( str(nl) + 'd', (1.0/nl)*1.5 )
            else:
                print_debug(f'Note length {nl}d has clicks {md} already in array as {midi_2_note_lengths[md]}')
            # fi
        # fi

        # double dotted note lengths.
        mdd = ((MIDICLICKSPERQUARTER / 0.25) / nl) * 1.5 * 1.5
        if int(mdd * 1000) != int(mdd)*1000:
#--             print_debug(f'Note length {nl}dd does not divide nicely into MIDICLICKSPERQUARTER {MIDICLICKSPERQUARTER}  ... {mdd}')
            pass
        else:
            mdd = int(mdd)
            if mdd == 0:
                print_debug(f'Note length {nl} gives midi click value of 0')
            elif mdd not in midi_2_note_lengths:
                midi_2_note_lengths[mdd] = ( str(nl) + 'd' + 'd', (1.0/nl)*1.5*1.5 )
            else:
                print_debug(f'Note length {nl}dd has clicks {mdd} already in array as {midi_2_note_lengths[mdd]}')
            # fi
        # fi
    # rof
#++     ml = list(midi_2_note_lengths.keys())
#++     ml.sort()
#++     for n in ml:
#++         print_debug(f'midi_2_note_lengths - {n} -> {midi_2_note_lengths[n]}')
#++     # rof
# End of do_note_length_calculate

# ----------------------------------------------------------------------------
# For all voices (one at a time), go through notes:
#   a) Use SLOT_CLICKS checks for start of note/end of note.
#   b) Adding any rests before notes.
#   c) Break notes that go over measures into short note with suffix tie.
#   d) End @ running_time ... with rests up to there.
#

def notes_fitted_into_measures():
    print_stderr('\n')
    print_error('NOTDONEYET - notes_fitted_into_measures')
    pass
# End of notes_fitted_into_measures

# ----------------------------------------------------------------------------
#   a) Change note time into: get_time_for_note(XXX) - 
#   b) titles before measure 1.
#   c) key before measure 1.
#   d) instrument before measure 1.  Number -> string.
#   e) Titles within a measure.
#   f) Change note lengths to text.
#   g) Figure out how to do triplets/sequence.
#
# Example of data:
#   measure xyz
#   v1: r4, 3c4, 3d8, 3e(0.333333), r(0.666666)

def printable_measures():
    print_stderr('\n')
    print_error('NOTDONEYET - printable_measures')
    pass
# End of printable_measures

# ----------------------------------------------------------------------------
def set_keys_if_not_specified():
    global key
    global key_clicks
    global voices

    # Set keys if not specified. NOTE: This may be an error.
    for k in key:
        if k == 0:
            for v in range(1, voices):
                if v not in key:
                    key[v] = key[0]
                    key_clicks[v] = key_clicks[0]
                # fi
            # rof
            break
        # fi
    # rof
# End of set_keys_if_not_specified

# ----------------------------------------------------------------------------
def figure_out_measure_locations():
    global no_notes_yet
    global voices
    global bufs_notes_voices
    global bufs_notes
    global bufs_notes_start
    global bufs_notes_end
    global bufs_notes_velocity
    global bufs_cc_start
    global bufs_cc_end

    global running_time
    global first_note_time
    global meter                        # Array of printable meter (text).
    global meter_fractions              # Array of MIDICLICKSPERQUARTER*4 * meter_fraction (clicks per measure).
    global meter_clicks                 # Array of where in running clicks meter occurred.
    global last_measure                 # Number of last measure - set when figuring out measure lengths.
    global measures_clicks_start        # Dictionary of clicks for when measure starts.
    global measures_clicks_length       # Dictionary of clicks in each measure.
    global measures_meter               # Dictionary of meters for when measure starts.

    global key
    global key_clicks

    working_time = first_note_time
    lm = 1                              # Start measure at number 1.
    last_inc = meter_fractions[0]
    last_meter = meter[0]
    for i in range(0, len(meter)):
        while working_time < meter_clicks[i]:
            measures_clicks_start[lm] = working_time
            measures_clicks_length[lm] = last_inc
            measures_meter[lm] = last_meter
            working_time = working_time + last_inc
            lm = lm +1
        # elihw
        last_inc = meter_fractions[i]
        last_meter = meter[i]
    # rof
    # Do to end of song.
    while working_time < running_time:
        measures_clicks_start[lm] = working_time
        measures_clicks_length[lm] = last_inc
        measures_meter[lm] = last_meter
        working_time = working_time + last_inc
        lm = lm +1
    # elihw
    last_measure = lm - 1
    measures_clicks_length[last_measure] = running_time - (working_time - last_inc)


    return
# End of figure_out_measure_locations

# ----------------------------------------------------------------------------
# FF 58 04 nn dd cc bb Time Signature
# The time signature is expressed as four numbers. nn and dd represent the numerator
# and denominator of the time signature as it would be notated. The denominator
# is a negative power of two: 2 represents a quarter-note, 3 represents an eighth-note,
# etc. The cc parameter expresses the number of MIDI clocks in a metronome click.
# The bb parameter expresses the number of notated 32nd-notes in a MIDI quarter-note
# (24 MIDI clocks). This was added because there are already multiple programs which
# allow a user to specify that what MIDI thinks of as a quarter-note (24 clocks) is
# to be notated as, or related to in terms of, something else.
# 
# Therefore, the complete event for 6/8 time, where the metronome clicks every three
# eighth-notes, but there are 24 clocks per quarter-note, 72 to the bar, would be (in hex):
#       FF 58 04 06 03 24 08
#                nn dd cc bb
# That is, 6/8 time (8 is 2 to the 3rd power, so this is 06 03), 36 MIDI clocks per
# dotted-quarter (24 hex!), and eight notated 32nd-notes per quarter-note. 
#    i.e. 2*32=1/16, 4*32=1/8, 8*32=1/4.  And a 1/4 note is 0x24 time deltas long.
# If the 8 was changed to 16, then a 1/2 note is 0x24 long. (0x24=36)

def meter_readable(strg1, strg2):
    s = (strg1 + ' ' + strg2).split()
    if len(s) != 4:
        print_error(f'meter line does not have enough arguments, want 4, not {len(s)}.')
        return None, None
    # fi
    numerator = int(s[0])
    denominator = 2 ** int(s[1])
    return f'{numerator}/{denominator}', float(numerator)/float(denominator)
# End of meter_readable

# ----------------------------------------------------------------------------
def process_echo_lines(q):
    global voices
    global MIDICLICKSPERQUARTER
    global titles
    global running_time
    global meter
    global meter_fractions
    global meter_clicks
    global key
    global key_clicks
    global comments
    global comments_clicks
    global tempo_s
    global tempo_l

    if q[0:8] == '"Header ':
        if q[-1] != '"':
            print_error('Header line expected to end with a double quote')
            return
        # fi
        r = q[8:-1].split()
        voices = int(r[0]) - 1              # Remember 0 is the first one.
        MIDICLICKSPERQUARTER = int(r[1])
        if meter == []:
            meter.append('4/4')
            meter_fractions.append(MIDICLICKSPERQUARTER * 4)
            meter_clicks.append(running_time)
        # fi
        do_note_length_calculate()
        return
    # fi
    if q[0:7] == '"Title ':
        v = q[7:].split(' ', 1)
        titles.append(q[7:])
        return
    # fi
    if q[0:7] == '"meter ':
        if q[-1] != '"':
            print_error('meter line expected to end with a double quote')
            return
        # fi
        vs = q[7:].split(' ', 1)
        meter_new, meter_new_fraction = meter_readable(vs[0], vs[1])
        if meter != [] and meter[-1] != meter_new:
            if running_time == meter_clicks[-1]:
                meter[-1] = meter_new
                meter_fractions[-1] = math.ceil(MIDICLICKSPERQUARTER*4 * meter_new_fraction)
            else:
                meter.append(meter_new)
                meter_fractions.append(math.ceil(MIDICLICKSPERQUARTER*4 * meter_new_fraction))
                meter_clicks.append(running_time)
            # fi
        # fi
        return
    # fi
    if q[0:5] == '"key ':
        vs = q[5:].split(' ', 1)
        v = int(vs[0])
        a = vs[1].split(None)
        if len(a) < 2 or len(a) > 4:
            print_error(f'key line expects key followed by "major" not {a}')
            return
        elif a[1] != "'major'\"":
            print_error(f'key line expects "major" not {a[1]}')
            return
        # fi
        key_previous = q
        if v not in key or key[v] != a[0]:
            key[v] = a[0]
            key_clicks[v] = running_time
        # fi
        return
    # fi
    a = q.split()
    if len(a) == 3 and len(a[1]) > 8 and a[1][0:8] == 'tempo_s=':
# DEBUG - process_echo_lines - q=""tempo_s=150 tempo_l=0.25""
        if q[-1] != '"':
            print_error('tempo_s line expected to end with a double quote')
            return
        # fi
        s = a[1][8:]
        tempo_s = float(s)
        if a[2][0:8] != 'tempo_l=':
            print_error(f'tempo_s line expects tempo_l not {a[2]}')
            return
        # fi
        l = a[2][8:len(a[2]) - 1]
        tempo_l = float(l)
        return
    # fi
    comments.append(q)
    comments_clicks.append(running_time)
    return
# End of process_echo_lines

# ----------------------------------------------------------------------------
global header_commands_ignore
header_commands_ignore = [ 'set', 'unload', 'load', 'reset', 'pitch_bend' ]

def process_header_lines(q):
    global header_commands_ignore
    global instrument
    global running_time

    if q[0] in header_commands_ignore:
        pass
    elif q[0] == 'echo':
        process_echo_lines(q[1])
    elif q[0] == 'sleep':
        process_sleep(q[1])
    elif q[0] == 'prog':
        a = q[1].split()
        ibank = int(a[0])
        instr = int(a[1])
        if instrument == {}:
            instrument[0] = [ [ibank, instr, running_time] ]
        else:
            print_error(f"ignoring prog that isn't before select commands. {q}")
        # fi
    elif q[0] == 'select':
        a = q[1].split()
        if len(a) < 1 or len(a) > 4:
            print_error(f'select line wants 4 arguments not {len(a)} - {q[1]}')
            return
        # fi
        # a[0] = voice #
        # a[1] = timeclicks
        # a[2] = bank
        # a[3] = instrument
        vn = int(a[0])
        ibank = int(a[2])
        instr = int(a[3])
        if vn in instrument:
            if instrument[vn][-1][0] == ibank and instrument[vn][-1][1] == instr:
                pass
            else:
                if instrument[vn][-1][0] == ibank and instrument[vn][-1][2] == running_time:
                    instrument[vn][-1] = [ibank, instr, running_time]
                else:
                    instrument[vn].append( [ibank, instr, running_time] )
                # fi
            # fi
        else:
            instrument[vn] = [ [ibank, instr, running_time] ]
        # fi
    elif q[0] == 'cc':
        process_cc(q[1])
    else:
        print_error(f'Line is unexpected - {q}')
    # fi
    return
# End of process_header_lines

# ----------------------------------------------------------------------------
def get_time_for_note(v4):
    global midi_2_note_lengths

    t = round(v4)
    ml = list(midi_2_note_lengths.keys())
    if t in midi_2_note_lengths:
        print_debug(f'get_time_for_note - {t} is length {midi_2_note_lengths[t]}')
    else:
        ml = list(midi_2_note_lengths.keys())
        ml.sort()
        flagless = None
        foundit = False
        for n in ml:
            if t < n:
                if flagless is None:
                    print_warning(f'get_time_for_note - {t}:[{v4}] less than smallest value {n}->{midi_2_note_lengths[n]}')
                else:
#--                     print_warning(f'get_time_for_note - {flagless}->{midi_2_note_lengths[flagless]} < {t}:[{v4}] < {n}->{midi_2_note_lengths[n]}')
                    low = t - flagless
                    high = n - t
                    if low < high:
                        print_warning(f'#A get_time_for_note - {flagless}->{midi_2_note_lengths[flagless]} less than {t}:[{v4}] by {low}')
                        t = flagless
                    else:
                        print_warning(f'#B get_time_for_note - {n}->{midi_2_note_lengths[n]} greater than {t}:[{v4}] by {high}')
                        t = n
                    # fi
                # fi
                foundit = True
                break
            # fi
            flagless = n
        # rof
        if not foundit:
            print_warning(f'get_time_for_note - {t}:[{v3}] > largest value {flagless}->{midi_2_note_lengths[flagless]}')
        # fi
    # fi
    return t
# End of get_time_for_note

# -----------------------------------------------------------------------------
def process_noteon(r):
    global voices
    global running_time
    global bufs_notes_voices            # Voices for chords on this voice.
    global bufs_notes                   # Midi note number. An array indexed by measure, voice.
    global bufs_notes_start             # calculated clicks to start of each note for a voice.
    global bufs_notes_end               # calculated clicks to end of each note for a voice.
    global bufs_notes_velocity          # The intensity of note start. (Typically the total volume. *sigh*)
    global bufs_cc_start                # [voice][cc#]      time in clicks when CC occurred.
    global bufs_cc_end                  # [voice][cc#]      CC when note stops occurred.
    global last_cc                      # If doing a note, the last_cc. NOTE: defaults for 7,10,11,64,68,91.

    global key                          # key[voice] = ... .
    global key_clicks                   # key_clicks = running_time.
    global instrument                   # Indexed by voice number.

    a = r.split()
    if len(a) != 3:
        print_error(f'noteon line needs 3 arguments, not {len(a)} - {r}.')
        return
    # fi
    v = int(a[0])
    n = int(a[1])
    i = int(a[2])
    if i == 0:
        process_noteoff(r)
        return
    # fi
    if v > voices:
        voices = v
    # fi
    # Okay, we have the voice and the note, and calculated the current 'running_time'.

    # determine which real voice to use... if chords.
    flag = False
    for v2s in bufs_notes_voices[v]:
        if v2s in bufs_notes_end and len(bufs_notes_end[v2s]) > 0 and bufs_notes_end[v2s][-1] == 0:
            continue
        # fi
        flag = v2s
        break
    # rof
    if flag is False:                                   # Need a new voice for chord.
        voices = voices + 1
        bufs_notes_voices[v].append(voices)
        if v in key:
            key[voices] = key[v]
            key_clicks[voices] = key_clicks[v]
        # fi
        if v in instrument:
            instrument[voices] = instrument[v]
        # fi
        v2s = voices
        print_debug(f'process_noteon - New Voice-CHORD: v2s={v2s}  bufs_notes_voices[v]={bufs_notes_voices[v]}')
    # fi

    bufs_notes[v2s].append(n)
    bufs_notes_start[v2s].append(running_time)          # Starting time for note.
    bufs_notes_end[v2s].append(0)                       # No ending time note.
    bufs_notes_velocity[v2s].append(i)                  # Note start intensity volume level.
    for cc in range(0, 127):
        bufs_cc_start[v2s][cc].append(last_cc[v][cc])
        bufs_cc_end[v2s][cc].append(0)
    # rof
# End of process_noteon

# -----------------------------------------------------------------------------
def process_noteoff(r):
    global voices
    global running_time
    global bufs_notes_voices
    global bufs_note
    global bufs_note_end
    global bufs_cc_end
    global last_cc

    a = r.split()
    if len(a) != 3:
        print_error(f'noteoff line needs 3 arguments, not {len(a)} - {r}.')
        return
    # fi
    v = int(a[0])
    n = int(a[1])
    i = int(a[2])
    if v > voices:
        print_error(f'noteoff line for voice not already turned on/defined.')
        return
    # fi
    if i != 0:
        print_error(f'noteoff line for voice does not turn off note?')
        return
    # fi
    # Okay, we have the voice and the note, and calculated the current 'running_time'.
    # determine which real voice to use... if chords.
    flag = False
    for v2s in bufs_notes_voices[v]:
        if n == bufs_notes[v2s][-1]:
            flag = v2s
            break
    # rof
    if flag is False:                                   # Need a new voice for chord.
        print_error(f'noteoff line for voice not already playing.')
        return
    # fi

    bufs_notes_end[v2s][-1] = running_time
    for cc in range(0, 127):
        bufs_cc_end[v2s][cc][-1] = last_cc[v][cc]
    # rof
# End of process_noteoff

# -----------------------------------------------------------------------------
def process_sleep(r):
    global tempo_s
    global tempo_l
    global running_time

# Want note length value.
    v1= float(r) * 1000
    v2 = (v1 * MIDICLICKSPERQUARTER) / 1000
    v3 = v2 * ((tempo_s / 60) * (tempo_l * 4))
    v4 = v3 / 1000
    running_time = running_time + math.ceil(v4)
# End of process_sleep

# -----------------------------------------------------------------------------
def process_cc(r):
    global last_cc                      # If doing a note, the last_cc. NOTE: defaults for 7,10,11,64,68,91.
    global bufs_notes_voices            # Voices for chords on this voice.

    a = r.split()
    if len(a) != 3:
        print_error(f'cc line needs 3 arguments, not {len(a)} - {r}.')
        return
    # fi
    v = int(a[0])
    c = int(a[1])
    i = int(a[2])

    for v2s in bufs_notes_voices[v]:    # Do all voices for possible chords.
        last_cc[v2s][c] = i
    # rof
# End of process_cc

# -----------------------------------------------------------------------------
def process_note_lines(q):
    global voices                       # Number of voices
    global running_time
    global instrument

    if q[0] == 'noteon':
        process_noteon(q[1])
    elif q[0] == 'echo':
        process_echo_lines(q[1])
    elif q[0] == 'noteoff':
        process_noteoff(q[1])
    elif q[0] == 'sleep':
        process_sleep(q[1])
    elif q[0] == 'cc':
        process_cc(q[1])
    elif q[0] == 'select':
        a = q[1].split()
        if len(a) < 1 or len(a) > 4:
            print_error(f'select line wants 4 arguments not {len(a)} - {q[1]}')
            return
        # fi
        # a[0] = voice #
        # a[1] = timeclicks
        # a[2] = bank
        # a[3] = instrument
        vn = int(a[0])
        ibank = int(a[2])
        instr = int(a[3])
        if vn in instrument:
            if instrument[vn][-1][0] == ibank and instrument[vn][-1][1] == instr:
                pass
            else:
                instrument[vn].append( (ibank, instr, running_time) )
            # fi
        else:
            instrument[vn] = (ibank, instr, running_time)
        # fi
    else:
        print_error(f'NOTDONEYET - Unexpected command ({q}) in FS input')
    # fi
# End of process_note_lines

# ----------------------------------------------------------------------------
# Parse and process line.
#
# Need: # voices used.
#   'cc'                # Maximum = total.
#   'select'            # Maximum = total.
#   'prog' decoding.    # Maximum = total.
# Need: Standard header removed.
#   Deleted everything until first select/cc/prog. (Keep echos.)
# Need: meter.
#   echo "meter"  -> meter.
# Need: title.
#   echo "        -> title if before any select/cc/noteon. (Edit down by hand.)
#                 -> comment if after noteon.

def process_line(original_line):
    global array_of_original_lines
    global no_notes_yet
    global first_note_time

    qline = original_line
    array_of_original_lines.append(qline)

    if qline is None:
        print_error('Line is None -- bad input.')
        return True
    elif qline == 'quit':
        return True                     # Done with input file.
    elif qline == 'reset':
        return False                    # Ignore reset command
    elif qline == '':
        print_error('Line is empty -- bad input -- but keep going.')
        return False
    # fi
    q = qline.split(None, 1)            # Command, arguments.
    if len(q) <= 1:
        print_error(f'Line ({original_line}) must have a command and at least one argument, but keep going.')
        return False
    # fi
    if no_notes_yet:
        if q[0] != 'noteon':
            process_header_lines(q)
            return False
        # fi
        no_notes_yet = False
        first_note_time = running_time  # The running time when first note occurs, 1st measure.
    # fi
    process_note_lines(q)
    return False
# End of process_line

# ----------------------------------------------------------------------------
# Get the next line, file, or macro.
# Return:
#   line        - the line without trailing spaces.
#   None        - if End of File.

def read_next_line():
    global args
    global linecount
    global input_file                   # File to read for input (default is use tty - stdin).
    global output_file                  # File to print to (default is sys.stdout).
    global errors_happened

    try:
        if input_file is not None:
            line = input_file.readline()
        else:
            if sys.stdin.isatty():
                if sys.platform == 'darwin':
                    input('input> ')
                    line = readline.get_line_buffer()
                else:
                    line = input('input> ')
                # fi
            else:
                line = sys.stdin.readline()
            # fi
        # fi
        if line is None or line == '':
            if errors_happened != 0:
                print_stderr(f'exiting with errors_happened={errors_happened}')
            # fi
            sys.exit(errors_happened)
        # fi
        linecount = linecount + 1
        if line:
            line = line.rstrip()                # trailing spaces gone.
            return line
        # fi
    except EOFError:
        pass            # print('Read gave EOF', file=sys.stderr, flush=True)
    except SystemExit:
        pass            # print('Read gave system exit', file=sys.stderr, flush=True)
    except KeyboardInterrupt:
        print_error('Read got keyboard interrupt')
    except:
        print_error('Read got a processing error')
        print_stderr('    ' + sys.exc_info()[0] + sys.exc_info)
    # yrt
    return None
# End of read_next_line

# ----------------------------------------------------------------------------
def readthefile():
    global linecount
    global args

    ifdone = False
    while not ifdone:                       # Read the file loop.
        line = read_next_line()
        if args.lines:
            print_stderr(f'linecount={linecount} line="{line}"')
        # fi
        if line is None:  # If end of file.
            return
        elif not line or len(line) <= 0 or line == '':
            continue
        # fi
        line = line.rstrip()
        if not line or len(line) <= 0 or line == '':
            continue
        # fi
        line = line.strip()
        if len(line) == 0:                                  # Ignore empty line.
            continue
        # fi
        ifdone = process_line(line)
    # elihw
    return
# End of readthefile

# ----------------------------------------------------------------------------
def print_debug_internal_1(stg):
    global meter                        # Array of printable meter (text).
    global meter_fractions              # Array of MIDICLICKSPERQUARTER*4 * meter_fraction (clicks per measure).
    global meter_clicks                 # Array of where in running clicks meter occurred.
    global last_measure                 # Number of last measure - set when figuring out measure lengths.
    global measures_clicks_start        # Dictionary of clicks for when measure starts.
    global measures_clicks_length       # Dictionary of clicks in each measure.
    global measures_meter               # Dictionary of meters for when measure starts.

    global key
    global key_clicks

    global voices
    global bufs_notes_voices
    global bufs_notes
    global bufs_notes_start
    global bufs_notes_end
    global bufs_notes_velocity
    global bufs_cc_start
    global bufs_cc_end

    global comments
    global comments_clicks
    global titles

    print_stderr(f'\n{stg}:')
    j = int(last_measure / 10) * 10
    for i in range(1, j + 1, 10):
        print_debug(f'{i:4} - measures_clicks_start: {measures_clicks_start[i]:7} {measures_clicks_start[i + 1]:7} {measures_clicks_start[i + 2]:7} {measures_clicks_start[i + 3]:7} {measures_clicks_start[i + 4]:7} {measures_clicks_start[i + 5]:7} {measures_clicks_start[i + 6]:7} {measures_clicks_start[i + 7]:7} {measures_clicks_start[i + 8]:7} {measures_clicks_start[i + 9]:7}')
        print_debug(f'{i:4} - measures_clicks_length:{measures_clicks_length[i]:7} {measures_clicks_length[i + 1]:7} {measures_clicks_length[i + 2]:7} {measures_clicks_length[i + 3]:7} {measures_clicks_length[i + 4]:7} {measures_clicks_length[i + 5]:7} {measures_clicks_length[i + 6]:7} {measures_clicks_length[i + 7]:7} {measures_clicks_length[i + 8]:7} {measures_clicks_length[i + 9]:7}')
        print_debug(f'{i:4} - measures_meter        :{measures_meter[i]:>7} {measures_meter[i + 1]:>7} {measures_meter[i + 2]:>7} {measures_meter[i + 3]:>7} {measures_meter[i + 4]:>7} {measures_meter[i + 5]:>7} {measures_meter[i + 6]:>7} {measures_meter[i + 7]:>7} {measures_meter[i + 8]:>7} {measures_meter[i + 9]:>7}')
    # rof
    if last_measure - j != 0:
        i = j + 1
        print_debug(f'{i:4} - measures_clicks_start:', end='')
        for k in range(i, last_measure + 1):
            print(f' {measures_clicks_start[k]:7}', file=sys.stderr, end='')
        # rof
        print('', file=sys.stderr)
        print_debug(f'{i:4} - measures_clicks_length:', end='')
        for k in range(i, last_measure + 1):
            print(f'{measures_clicks_length[k]:7} ', file=sys.stderr, end='')
        # rof
        print('', file=sys.stderr)
        print_debug(f'{i:4} - measures_meter        :', end='')
        for k in range(i, last_measure + 1):
            print(f'{measures_meter[k]:>7} ', file=sys.stderr, end='')
        # rof
        print('', file=sys.stderr)
    # fi

    print_stderr(f'\n{stg}: Title - ')
    for t in range(0, len(titles)):
        print_debug(f'    "{titles[t]}"')
    # rof

    print_stderr(f'\n{stg}: Comments - ')
    for c in range(0, len(comments)):
        print_debug(f'    comments_clicks={comments_clicks[c]} - "{comments[c]}"')
    # rof

# b) Print titles[].
# c) Print comments[] & comments_clicks = [].

    print_stderr(f'\n{stg}:')
    for v in range(0, voices+1):
        if v in key:
            print_debug(f'{v:4} - key={key[v]}  key_clicks={key_clicks[v]}')
        # fi
    # rof

    print_stderr(f'\n{stg}:')
    for v in range(0, voices+1):
        if v in instrument:
            for i in range(0,len(instrument[v])):
                print_debug(f'{v:4} - instrument bank={instrument[v][i][0]} number={instrument[v][i][1]} clicks={instrument[v][i][2]}')
            # rof
        # fi
    # rof

    print_stderr(f'\n{stg}:')
    for v in range(0,voices+1):        # Voices if multiple turned on, run to alternative.
        print_debug(f'bufs_notes_voices[{v}]={bufs_notes_voices[v]}')
        print_debug(f'  note vel   clicks-on/off cc7= on/off cc10= on/off cc11= on/off cc64= on/off cc65= on/off cc91= on/off')
        for n in range(0, len(bufs_notes[v])):
            print_debug(f'    {bufs_notes[v][n]:2} {bufs_notes_velocity[v][n]:3} {bufs_notes_start[v][n]:7} {bufs_notes_end[v][n]:7} cc7={bufs_cc_start[v][7][n]:3}-{bufs_cc_end[v][7][n]:3} cc10={bufs_cc_start[v][10][n]:3}-{bufs_cc_end[v][10][n]:3} cc11={bufs_cc_start[v][11][n]:3}-{bufs_cc_end[v][11][n]:3} cc64={bufs_cc_start[v][64][n]:3}-{bufs_cc_end[v][64][n]:3} cc65={bufs_cc_start[v][65][n]:3}-{bufs_cc_end[v][65][n]:3} cc91={bufs_cc_start[v][91][n]:3}-{bufs_cc_end[v][91][n]:3}')
        # rof
    # rof
# End of print_debug_internal_1

# ============================================================================
def print_debug_hints():
    global bars_measure
    global clef_voice_measures
    global instrument_voice_measures
    global pages_measures
    global meters_measures

#--     print_debug(f'pages_measures={pages_measures}')
    for b in pages_measures:
        print_debug(f'pages: measure {b} = {pages_measures[b]}')
    # rof

#--     print_debug(f'bars_measures={bars_measures}')
    for b in bars_measures:
        print_debug(f'bars: measure {b} = {bars_measures[b]}')
    # rof

#--     print_debug(f'clef_voice_measures={clef_voice_measures}')
    for v in clef_voice_measures:
        for m in clef_voice_measures[v]:
            print_debug(f'clefs: voice {v} measure {m} = {clef_voice_measures[v][m]}')
        # rof
    # rof

#--     print_debug(f'instrument_voice_measures={instrument_voice_measures}')
    for v in instrument_voice_measures:
        for m in instrument_voice_measures[v]:
            print_debug(f'instruments: voice {v} measure {m} = {instrument_voice_measures[v][m]}')
        # rof
    # rof

#--     print_debug(f'key_voice_measures={key_voice_measures}')
    for v in key_voice_measures:
        for m in key_voice_measures[v]:
            print_debug(f'keys: voice {v} measure {m} = {key_voice_measures[v][m]}')
        # rof
    # rof

#--     print_debug(f'meters_measures={meters_measures}')
    for m in meters_measures:
        print_debug(f'meters: measure {m} = {meters_measures[m]}')
    # rof
    return
# End of print_debug_hints

# ============================================================================
is_float_number = 0
is_float_string = 1
# ----------------------------------------------------------------------------
# Calculate values here.
# Input:
#   strg            - The string to compute.
#   type_float      - is_float_number if must be integer.
#                     is_float_string if can return a character var.
#   none_means_none = If true, return '' for None (or not set variable).
# Returns:
#   value      = So far computed value
#   type_error = type of error

def is_float(strg, type_float, none_means_none):
    tree = calculate.parse(strg)            # parse the string
    if tree is None or len(tree) != 2:
        return None, None
    elif tree[0] is None and tree[1] == 'error parsing':
        return strg, tree[1]
    elif tree[0] is not None and tree[0].startswith('ERROR'):
        return strg, tree[0]
    elif tree[1] is None:
        if none_means_none:
            return '', None
        # fi
        return strg, f"is_float -- variable '{strg}' is not set"
    # fi
    elif tree[1] == '.':
        return strg, "bad input to calculator#2"
    # fi
    if type_float == is_float_number:
        try:
            sexpr = float(tree[1])
            if sexpr.is_integer():
                sexpr = int(sexpr)
            # fi
            return sexpr, None
        except:
            return strg, "bad input to calculator#3"
        # yrt
    # fi
    recompute_whichchars()
    return tree[1], None
# End of is_float

# ----------------------------------------------------------------------------
# strng = int_range_to_array(strng)

def int_range_to_array(strng):
    a = strng.find('..')
    if a == 0:
        print_error("Range does not start with number.")
        return [str(strng)]
    elif a < 0:                                 # Not a range
        strng, msg = is_float(strng, is_float_number, False)
        if msg is not None or strng is None:
            return [str(strng)]
        # fi
        if type(strng) is float and strng.is_integer():
            strng = int(strng)
        # fi
        return [str(strng)]
    # fi
    first = strng[0:a]
    second = strng[a+2:]
    if second is None or second == '':
        print_error("Second number in range bad.")
        return [str(strng)]
    # fi
    n, msg = is_float(first, is_float_number, False)
    if msg is not None or n is None or n == '':
        print_error(f"Range first number bad. {msg} '{first}'")
        return [str(strng)]
    # fi
    o, msg = is_float(second, is_float_number, False)
    if msg is not None or o is None or o == '':
        print_error(f"Range second number bad. {msg}")
        return [str(strng)]
    # fi
    if type(n) is str:
        n = float(n)
    # fi
    if type(n) is float and n.is_integer():
        first = int(n)
    elif type(n) is not int:
        print_error("Range first number not an integer.")
        return [str(strng)]
    # fi
    if type(o) is str:
        o = float(o)
    # fi
    if type(o) is float and o.is_integer():
        second = int(o)
    elif type(o) is not int:
        print_error("Range second number not an integer.")
        return [str(strng)]
    # fi
    array_args = []
    while n < o + 1:
        array_args.append(str(n))
        n = n + 1
    # rof
    return array_args
# End of int_range_to_array

# ----------------------------------------------------------------------------
# strng         is string where token name is.
# terminator    is the termination character looking for.
# doparens      True if should check parens match.
#
# Returns where in strng termination is. -1 if not found. 0=first character.

nest_terminator = { '(':')', '{':'}', "'":"'", '"':'"' }

def find_terminator_in_string(strng, terminators, doparens):
    w = 0
    e = []
    while w < len(strng):
        c = strng[w]
        if c in terminators:
            return w                                # Terminator immediately - blank argument.,
        # fi
        if c in nest_terminator and doparens:
            endterminator = nest_terminator[c]
        else:
            endterminator = None
        # fi
        e.append(endterminator)
        w = w + 1
        if w > len(strng):
            return -1
        # fi
        while endterminator is not None:
            while w < len(strng):
                c = strng[w]
                w = w + 1
                if c == endterminator:
                    break
                # fi
                if endterminator in ['"', "'"]:     # quotes nest nothing.
                    continue
                elif w >= len(strng):
                    if doparens:
                        print_error(f"nested parenthesis, did not find closing {endterminator}.")
                        return -1
                    # fi
                    break
                elif c in nest_terminator:
                    endterminator = nest_terminator[c]
                    e.append(endterminator)
                # fi
            # elihw
            e.pop()
            if e != []:
                endterminator = e[-1]
            else:
                endterminator = None
                break
            # fi
        # elihw
    # elihw
    return -1
# End of find_terminator_in_string

# ----------------------------------------------------------------------------
#   wline         - string to split

def separate_args(wline):
    def b4it(array_args, b4):
        if b4 == '':
            array_args.append(b4)
        else:
            nums = int_range_to_array(b4)
            array_args = array_args + nums
        # fi
        return array_args
    # End of b4it

    global args

    splitter = [ ',', ";" ]
    strng = wline.strip()
    if len(strng) == 0:
        return []
    # fi
    strng = re.sub(r'\s*]', r' ]', strng, count = 1)
    strng = re.sub(r'\s+', r' ', strng)
    strng = re.sub(r'\s*\[', r' [', strng, count = 1)
    strng = re.sub(r'\[\s*', r'[ ', strng, count = 1)
    strng = re.sub(r'\s+', r' ', strng)
    array_args = []
    w = 0
    b4 = ''
    while w < len(strng):
        s = strng[w:]
        x = find_terminator_in_string(s, splitter, True)
        # x == -1   end of strng.
        if x < 0:                           # End of strng reached before splitter character found.
            b4 = s
            break
        # fi
        b4 = s[0:x]
        array_args = b4it(array_args, b4)
        b4 = ''
        w = w + x + 1
    # elihw
    array_args = b4it(array_args, b4)
    return array_args
# End of separate_args

# ----------------------------------------------------------------------------
global allkeys
allkeys = [ 'c', 'd', 'e', 'f', 'g', 'a', 'b',
            'cn', 'dn', 'en', 'fn', 'gn', 'an', 'bn',
            'c-', 'd-', 'e-', 'f-', 'g-', 'a-', 'b-',
            'c--', 'd--', 'e--', 'f--', 'g--', 'a--', 'b--',
            'c+', 'd+', 'e+', 'f+', 'g+', 'a+', 'b+',
            'c++', 'd++', 'e++', 'f++', 'g++', 'a++', 'b++' ]

global legal_notes
legal_notes =   {
       '1/64': 0.015625,
      '3/128': 0.0234375,
       '1/32': 0.03125,
       '3/64': 0.046875,
      '7/128': 0.0546875,
       '1/16': 0.0625,
       '3/32': 0.09375,
       '7/64': 0.109375,
     '15/128': 0.1171875,
        '1/8': 0.125,
       '3/16': 0.1875,
       '7/32': 0.21875,
      '15/64': 0.234375,
     '31/128': 0.2421875,
        '1/4': 0.25,
        '3/8': 0.375,
       '7/16': 0.4375,
      '15/32': 0.46875,
      '31/64': 0.484375,
     '63/128': 0.4921875,
        '1/2': 0.5,
        '3/4': 0.75,
        '7/8': 0.875,
      '15/16': 0.9375,
      '31/32': 0.96875,
      '63/64': 0.984375,
    '127/128': 0.9921875,
          '1': 1.0,
        '3/2': 1.5,
        '7/4': 1.75,
       '15/8': 1.875,
      '31/16': 1.9375,
      '63/32': 1.96875,
     '127/64': 1.984375,
    '255/128': 1.9921875,
          '2': 2.0,
          '3': 3.0,
        '7/2': 3.5,
       '15/4': 3.75,
       '31/8': 3.875,
      '63/16': 3.9375,
     '127/32': 3.96875,
     '255/64': 3.984375,
    '511/128': 3.9921875,
       }

legal_mc_notes = {
        0.015625 : '64',
       0.0234375 : '64d',
         0.03125 : '32',
        0.046875 : '32d',
          0.0625 : '16',
         0.09375 : '16d',
           0.125 : '8',
          0.1875 : '8d',
            0.25 : '4',
           0.375 : '4d',
             0.5 : '2',
            0.75 : '2d',
             1.0 : '1',
             1.5 : '1d',
}

global legal_floating_times
legal_floating_times = sorted(legal_notes.values())

global vlprint
# 2022-08-12_15-39-03 - allow more space at low range and upper range. (Gives intensity some space.)
vlprint = {  0: 'ppppp',        # Below anything to expect.
            20: 'pppp',
            30: 'ppp',
            40: 'pp',
            50: 'p',
            60: 'mp',
            70: 'mf',
            80: 'f',
            90: 'ff',
            100: 'fff',
            110: 'ffff',
            127: 'fffff',       # Above anything to expect.
          }
global v_name_print
v_name_print = {}
for i in vlprint:
    v_name_print[ vlprint[ i ] ] = i
# rof

# ------------------------------------------------------------------------------
global midi_instruments
# select chan sfont bank prog -      prog, bank.
midi_instruments = {
    'Piano'.lower() : [0, 0],
    'Acoustic Grand Piano'.lower() : [0, 0],
    'Stereo Grand'.lower() : [0, 0],
    'Bright Acoustic Piano'.lower() : [1, 0],
    'Bright Grand'.lower() : [1, 0],
    'Electric Grand Piano'.lower() : [2, 0],
    'Electric Grand'.lower() : [2, 0],
    'Honky-tonk Piano'.lower() : [3, 0],
    'Honky-tonk'.lower() : [3, 0],
    'Electric Piano 1'.lower() : [4, 0],
    'Time Electric Piano 1'.lower() : [4, 0],
    'Electric Piano 2'.lower() : [5, 0],
    'FM Electric Piano'.lower() : [5, 0],
    'Harpsichord'.lower() : [6, 0],
    'Clavi'.lower() : [7, 0],
    'Clavinet'.lower() : [7, 0],
    'Celesta'.lower() : [8, 0],
    'Glockenspiel'.lower() : [9, 0],
    'Music Box'.lower() : [10, 0],
    'Vibraphone'.lower() : [11, 0],
    'Marimba'.lower() : [12, 0],
    'Xylophone'.lower() : [13, 0],
    'Tubular Bells'.lower() : [14, 0],
    'Dulcimer'.lower() : [15, 0],
    'Drawbar Organ'.lower() : [16, 0],
    'Tonewheel Organ'.lower() : [16, 0],
    'Percussive Organ'.lower() : [17, 0],
    'Rock Organ'.lower() : [18, 0],
    'Church Organ'.lower() : [19, 0],
    'Pipe Organ'.lower() : [19, 0],
    'Reed Organ'.lower() : [20, 0],
    'Accordion'.lower() : [21, 0],
    'Harmonica'.lower() : [22, 0],
    'Tango Accordion'.lower() : [23, 0],
    'Bandoneon'.lower() : [23, 0],
    'Acoustic Guitar (nylon)'.lower() : [24, 0],
    'Nylon Guitar'.lower() : [24, 0],
    'Acoustic Guitar (steel)'.lower() : [25, 0],
    'Steel Guitar'.lower() : [25, 0],
    'Electric Guitar (jazz)'.lower() : [26, 0],
    'Jazz Guitar'.lower() : [26, 0],
    'Electric Guitar (clean)'.lower() : [27, 0],
    'Clean Guitar'.lower() : [27, 0],
    'Electric Guitar (muted)'.lower() : [28, 0],
    'Muted Guitar'.lower() : [28, 0],
    'Overdriven Guitar'.lower() : [29, 0],
    'Overdrive Guitar'.lower() : [29, 0],
    'Distortion Guitar'.lower() : [30, 0],
    'Guitar Harmonics'.lower() : [31, 0],
    'Acoustic Bass'.lower() : [32, 0],
    'Electric Bass (finger)'.lower() : [33, 0],
    'Finger Bass'.lower() : [33, 0],
    'Electric Bass (pick)'.lower() : [34, 0],
    'Pick Bass'.lower() : [34, 0],
    'Fretless Bass'.lower() : [35, 0],
    'Slap Bass 1'.lower() : [36, 0],
    'Slap Bass 2'.lower() : [37, 0],
    'Synth Bass 1'.lower() : [38, 0],
    'Synth Bass 2'.lower() : [39, 0],
    'Violin'.lower() : [40, 0],
    'Viola'.lower() : [41, 0],
    'Cello'.lower() : [42, 0],
    'Contrabass'.lower() : [43, 0],
    'Double Bass'.lower() : [43, 0],
    'Tremolo Strings'.lower() : [44, 0],
    'Stero Strings Trem'.lower() : [44, 0],
    'Pizzicato Strings'.lower() : [45, 0],
    'Orchestral Harp'.lower() : [46, 0],
    'Timpani'.lower() : [47, 0],
    'String Ensemble 1'.lower() : [48, 0],
    'Stereo Strings Fast'.lower() : [48, 0],
    'String Ensemble 2'.lower() : [49, 0],
    'Stereo Strings Slow'.lower() : [49, 0],
    'Synth Strings 1'.lower() : [50, 0],
    'Synth Strings 2'.lower() : [51, 0],
    'Choir Aahs'.lower() : [52, 0],
    'Concert Choir'.lower() : [52, 0],
    'Voice Oohs'.lower() : [53, 0],              # NOT RIGHT!
    'Synth Voice'.lower() : [54, 0],             # NOT RIGHT!
    'Orchestra Hit'.lower() : [55, 0],           # ?? strange sound. ??
    'Trumpet'.lower() : [56, 0],
    'Trombone'.lower() : [57, 0],
    'Tuba'.lower() : [58, 0],
    'Muted Trumpet'.lower() : [59, 0],
    'French Horn'.lower() : [60, 0],
    'French Horns'.lower() : [60, 0],
    'Brass Section'.lower() : [61, 0],
    'Synth Brass 1'.lower() : [62, 0],
    'Synth Brass 2'.lower() : [63, 0],
    'Soprano Sax'.lower() : [64, 0],
    'Alto Sax'.lower() : [65, 0],
    'Tenor Sax'.lower() : [66, 0],
    'Baritone Sax'.lower() : [67, 0],
    'Oboe'.lower() : [68, 0],
    'English Horn'.lower() : [69, 0],
    'Bassoon'.lower() : [70, 0],
    'Clarinet'.lower() : [71, 0],
    'Piccolo'.lower() : [72, 0],
    'Flute'.lower() : [73, 0],
    'Recorder'.lower() : [74, 0],
    'Pan Flute'.lower() : [75, 0],
    'Blown bottle'.lower() : [76, 0],
    'Bottle Blow'.lower() : [76, 0],
    'Shakuhachi'.lower() : [77, 0],
    'Whistle'.lower() : [78, 0],
    'Irish Tin Whistle'.lower() : [78, 0],
    'Ocarina'.lower() : [79, 0],
    'Lead 1 (square)'.lower() : [80, 0],
    'Square Lead'.lower() : [80, 0],
    'Lead 2 (sawtooth)'.lower() : [81, 0],
    'Saw Lead'.lower() : [81, 0],
    'Lead 3 (calliope)'.lower() : [82, 0],
    'Synth Calliope'.lower() : [82, 0],
    'Lead 4 (chiff)'.lower() : [83, 0],
    'Chiffer Lead'.lower() : [83, 0],
    'Lead 5 (charang)'.lower() : [84, 0],
    'Charang'.lower() : [84, 0],
    'Lead 6 (voice)'.lower() : [85, 0],
    'Solo Vox'.lower() : [85, 0],
    'Lead 7 (fifths)'.lower() : [86, 0],
    '5th Saw Wave'.lower() : [86, 0],
    'Lead 8 (bass + lead)'.lower() : [87, 0],
    'Bass & lead'.lower() : [87, 0],
    'Pad 1 (new age)'.lower() : [88, 0],
    'Fantasia'.lower() : [88, 0],
    'Pad 2 (warm)'.lower() : [89, 0],
    'Warm Pad'.lower() : [89, 0],
    'Pad 3 (polysynth)'.lower() : [90, 0],
    'Polysynth'.lower() : [90, 0],
    'Pad 4 (choir)'.lower() : [91, 0],
    'Space Voice'.lower() : [91, 0],
    'Pad 5 (bowed)'.lower() : [92, 0],
    'Bowed Glass'.lower() : [92, 0],
    'Pad 6 (metallic)'.lower() : [93, 0],
    'Metal Pad'.lower() : [93, 0],
    'Pad 7 (halo)'.lower() : [94, 0],
    'Halo Pad'.lower() : [94, 0],
    'Pad 8 (sweep)'.lower() : [95, 0],
    'Sweep Pad'.lower() : [95, 0],
    'FX 1 (rain)'.lower() : [96, 0],
    'Ice Rain'.lower() : [96, 0],
    'FX 2 (soundtrack)'.lower() : [97, 0],
    'Soundtrack'.lower() : [97, 0],
    'FX 3 (crystal)'.lower() : [98, 0],
    'Crystal'.lower() : [98, 0],
    'FX 4 (atmosphere)'.lower() : [99, 0],
    'Atmosphere'.lower() : [99, 0],
    'FX 5 (brightness)'.lower() : [100, 0],
    'Brightness'.lower() : [100, 0],
    'FX 6 (goblins)'.lower() : [101, 0],
    'Goblins'.lower() : [101, 0],
    'FX 7 (echoes)'.lower() : [102, 0],
    'Echo Drops'.lower() : [102, 0],
    'FX 8 (sci-fi)'.lower() : [103, 0],
    'Star Theme'.lower() : [103, 0],
    'Sitar'.lower() : [104, 0],
    'Banjo'.lower() : [105, 0],
    'Shamisen'.lower() : [106, 0],
    'Koto'.lower() : [107, 0],
    'Kalimba'.lower() : [108, 0],
    'Bag pipe'.lower() : [109, 0],
    'Bagpipes'.lower() : [109, 0],
    'Fiddle'.lower() : [110, 0],
    'Shanai'.lower() : [111, 0],
    'Shenai'.lower() : [111, 0],
    'Tinkle Bell'.lower() : [112, 0],
    'Tinker Bell'.lower() : [112, 0],
    'Agogo'.lower() : [113, 0],
    'Steel Drums'.lower() : [114, 0],
    'Woodblock'.lower() : [115, 0],
    'Wood Block'.lower() : [115, 0],
    'Taiko Drum'.lower() : [116, 0],
    'Melodic Tom'.lower() : [117, 0],
    'Synth Drum'.lower() : [118, 0],
    'Reverse Cymbal'.lower() : [119, 0],
    'Guitar Fret Noise'.lower() : [120, 0],
    'Fret Noise'.lower() : [120, 0],
    'Breath Noise'.lower() : [121, 0],
    'Seashore'.lower() : [122, 0],
    'Bird Tweet'.lower() : [123, 0],
    'Birds'.lower() : [123, 0],
    'Telephone Ring'.lower() : [124, 0],
    'Telephone 1'.lower() : [124, 0],
    'Helicopter'.lower() : [125, 0],
    'Applause'.lower() : [126, 0],
    'Gunshot'.lower() : [127, 0],
    'Gun Shot'.lower() : [127, 0],
    'Synth Bass 101'.lower() : [38, 1],
    'Mono Strings Trem'.lower() : [44, 1],
    'Mono Strings Fast'.lower() : [48, 1],
    'Mono Strings Slow'.lower() : [49, 1],
    'Concert Choir Mono'.lower() : [52, 1],
    'Trumpet 2'.lower() : [56, 1],
    'Trombone 2'.lower() : [57, 1],
    'Muted Trumpet 2'.lower() : [59, 1],
    'Solo French Horn'.lower() : [60, 1],
    'Brass Section Mono'.lower() : [61, 1],
    'Square Wave'.lower() : [80, 1],
    'Saw Wave'.lower() : [81, 1],
    'Synth Mallet'.lower() : [98, 1],
    'Cut Noise'.lower() : [120, 1],
    'Fl. Key Click'.lower() : [121, 1],
    'Rain'.lower() : [122, 1],
    'Dog'.lower() : [123, 1],
    'Telephone 2'.lower() : [124, 1],
    'Car-Engine'.lower() : [125, 1],
    'Laughing'.lower() : [126, 1],
    'Machine Gun'.lower() : [127, 1],
    'Echo Pan'.lower() : [102, 2],
    'String Slap'.lower() : [120, 2],
    'Thunder'.lower() : [122, 2],
    'Horse Gallop'.lower() : [123, 2],
    'Door Creaking'.lower() : [124, 2],
    'Car-Stop'.lower() : [125, 2],
    'Scream'.lower() : [126, 2],
    'Lasergun'.lower() : [127, 2],
    'Howling Winds'.lower() : [122, 3],
    'Bird 2'.lower() : [123, 3],
    'Door'.lower() : [124, 3],
    'Car-Pass'.lower() : [125, 3],
    'Punch'.lower() : [126, 3],
    'Explosion'.lower() : [127, 3],
    'Stream'.lower() : [122, 4],
    'Scratch'.lower() : [123, 4],
    'Car-Crash'.lower() : [125, 4],
    'Heart Beat'.lower() : [126, 4],
    'Bubbles'.lower() : [122, 5],
    'Windchime'.lower() : [124, 5],
    'Siren'.lower() : [125, 5],
    'Footsteps'.lower() : [126, 5],
    'Train'.lower() : [125, 6],
    'Jet Plane'.lower() : [125, 7],
    'Chorused Tine EP'.lower() : [4, 8],
    'Chorused FM EP'.lower() : [5, 8],
    'Coupled Harpsichord'.lower() : [6, 8],
    'Church Bells'.lower() : [14, 8],
    'Detuned Tnwl. Organ'.lower() : [16, 8],
    'Detuned Perc. Organ'.lower() : [17, 8],
    'Pipe Organ 2'.lower() : [19, 8],
    'Italian Accordian'.lower() : [21, 8],
    'Ukulele'.lower() : [24, 8],
    '12-String Guitar'.lower() : [25, 8],
    'Hawaiian Guitar'.lower() : [26, 8],
    'Chorused Clean Gt.'.lower() : [27, 8],
    'Funk Guitar'.lower() : [28, 8],
    'Feedback Guitar'.lower() : [30, 8],
    'Guitar Feedback'.lower() : [31, 8],
    'Synth Bass 3'.lower() : [38, 8],
    'Synth Bass 4'.lower() : [39, 8],
    'Orchestra Pad'.lower() : [48, 8],
    'Synth Strings 3'.lower() : [50, 8],
    'Brass Section 2'.lower() : [61, 8],
    'Synth Brass 3'.lower() : [62, 8],
    'Synth Brass 4'.lower() : [63, 8],
    'Sine Wave'.lower() : [80, 8],
    'Doctor Solo'.lower() : [81, 8],
    'Taisho Koto'.lower() : [107, 8],
    'Castanets'.lower() : [115, 8],
    'Concert Bass Drum'.lower() : [116, 8],
    'Melodic Tom 2'.lower() : [117, 8],
    '808 Tom'.lower() : [118, 8],
    'Starship'.lower() : [125, 8],
    'Carillon'.lower() : [14, 9],
    'Burst Noise'.lower() : [125, 9],
    'Piano & Str.-Fade'.lower() : [0, 11],
    'Piano & Str.-Sus'.lower() : [1, 11],
    'Tine & FM EPs'.lower() : [4, 11],
    'Piano & FM EP'.lower() : [5, 11],
    'Tinkling Bells'.lower() : [8, 11],
    'Bell Tower'.lower() : [14, 11],
    'Techno Bass'.lower() : [38, 11],
    'Pulse Bass'.lower() : [39, 11],
    'Stereo Strings Velo'.lower() : [49, 11],
    'Synth Strings 4'.lower() : [50, 11],
    'Synth Strings 5'.lower() : [51, 11],
    'Brass Section 3'.lower() : [61, 11],
    'Whistlin'.lower() : [78, 11],
    'Sawtooth Stab'.lower() : [81, 11],
    "Doctor's Solo".lower() : [87, 11],
    'Harpsi Pad'.lower() : [88, 11],
    'Solar Wind'.lower() : [89, 11],
    'Mystery Pad'.lower() : [96, 11],
    'Synth Chime'.lower() : [98, 11],
    'Bright Saw Stack'.lower() : [100, 11],
    'Cymbal Crash'.lower() : [119, 11],
    'Filter Snap'.lower() : [121, 11],
    'Interference'.lower() : [127, 11],
    'Bell Piano'.lower() : [0, 12],
    'Bell Tine EP'.lower() : [4, 12],
    'Christmas Bells'.lower() : [10, 12],
    'Clean Guitar 2'.lower() : [27, 12],
    'Mean Saw Bass'.lower() : [38, 12],
    'Full Orchestra'.lower() : [48, 12],
    'Mono Strings Velo'.lower() : [49, 12],
    'Square Lead 2'.lower() : [80, 12],
    'Saw Lead 2'.lower() : [81, 12],
    'Fantasia 2'.lower() : [88, 12],
    'Solar Wind 2'.lower() : [89, 12],
    'White Noise Wave'.lower() : [122, 12],
    'Shooting Star'.lower() : [127, 12],
    'Woodwind Choir'.lower() : [48, 13],
    'Square Lead 3'.lower() : [80, 13],
    'Saw Lead 3'.lower() : [81, 13],
    'Night Vision'.lower() : [88, 13],
    'Mandolin'.lower() : [25, 16],
    'Standard Drums'.lower() : [0, 120],
    'Standard 2 Drums'.lower() : [1, 120],
    'Room Drums'.lower() : [8, 120],
    'Power Drums'.lower() : [16, 120],
    'Electronic Drums'.lower() : [24, 120],
    '808/909 Drums'.lower() : [25, 120],
    'Dance Drums'.lower() : [26, 120],
    'Jazz Drums'.lower() : [32, 120],
    'Brush Drums'.lower() : [40, 120],
    'Orchestral Perc.'.lower() : [48, 120],
    'SFX Kit'.lower() : [56, 120],
    'Standard'.lower() : [0, 128],
    'Standard 2'.lower() : [1, 128],
    'Room'.lower() : [8, 128],
    'Power'.lower() : [16, 128],
    'Electronic'.lower() : [24, 128],
    '808/909'.lower() : [25, 128],
    'Dance'.lower() : [26, 128],
    'Jazz'.lower() : [32, 128],
    'Brush'.lower() : [40, 128],
    'Orchestral'.lower() : [48, 128],
    'SFX'.lower() : [56, 128],
}

# ------------------------------------------------------------------------------
global drum_sounds
drum_sounds = {
    'Acoustic Bass Drum'.lower(): 35,
    'Bass Drum 1'.lower(): 36,
    'Side Stick'.lower(): 37,
    'Acoustic Snare'.lower(): 38,
    'Hand Clap'.lower(): 39,
    'Electric Snare'.lower(): 40,
    'Low Floor Tom'.lower(): 41,
    'Closed Hi Hat'.lower(): 42,
    'High Floor Tom'.lower(): 43,
    'Pedal Hi-Hat'.lower(): 44,
    'Low Tom'.lower(): 45,
    'Open Hi-Hat'.lower(): 46,
    'Low-Mid Tom'.lower(): 47,
    'Hi Mid Tom'.lower(): 48,
    'Crash Cymbal 1'.lower(): 49,
    'High Tom'.lower(): 50,
    'Ride Cymbal 1'.lower(): 51,
    'Chinese Cymbal'.lower(): 52,
    'Ride Bell'.lower(): 53,
    'Tambourine'.lower(): 54,
    'Splash Cymbal'.lower(): 55,
    'Cowbell'.lower(): 56,
    'Crash Cymbal 2'.lower(): 57,
    'Vibraslap'.lower(): 58,
    'Ride Cymbal 2'.lower(): 59,
    'Hi Bongo'.lower(): 60,
    'Low Bongo'.lower(): 61,
    'Mute Hi Conga'.lower(): 62,
    'Open Hi Conga'.lower(): 63,
    'Low Conga'.lower(): 64,
    'High Timbale'.lower(): 65,
    'Low Timbale'.lower(): 66,
    'High Agogo'.lower(): 67,
    'Low Agogo'.lower(): 68,
    'Cabasa'.lower(): 69,
    'Maracas'.lower(): 70,
    'Short Whistle'.lower(): 71,
    'Long Whistle'.lower(): 72,
    'Short Guiro'.lower(): 73,
    'Long Guiro'.lower(): 74,
    'Claves'.lower(): 75,
    'Hi Wood Block'.lower(): 76,
    'Low Wood Block'.lower(): 77,
    'Mute Cuica'.lower(): 78,
    'Open Cuica'.lower(): 79,
    'Mute Triangle'.lower(): 80,
    'Open Triangle'.lower(): 81,
}

# ----------------------------------------------------------------------------
# bars    7                 $$ Group the next 7 bars on one staff line.
# bars    7 10,20,30        $$ Group the 7 bars on one staff line for measures.

def do_bars(t_args):
    global bars_measure

    if t_args is None or t_args == '':
        print_error("bars does not have an expression to process")
        return
    # fi

    vargs = get_voice_measure_other(t_args, 'bars')
    if vargs is None:
        return
    # fi
    if len(vargs) > 2:
        print_error("bars format is number bars printed for staff, then optional measures")
        return
    # fi
    m = vargs[0]

    f1, type_error = is_float(m, is_float_number, False)
    if type_error is not None:
        print_error(f"bars error - {type_error}")
        return
    # fi
    if f1 is None:
        print_error("bars argument as a calculation did not return a value")
        return
    # fi
    f1 = round(f1)

    # See if measures.
    if len(vargs) == 1:
        mn = ( '1' )               # default to measure 1 
    else:
        mn = separate_args(str(vargs[1]))     # The measure numbers.
    # fi
    if not mn or len(mn) < 1:
        print_error("no measure argument(s) for bar command")
        return
    # fi
    for w in mn:
        f2, type_error = is_float(w, is_float_number, False)
        if type_error is not None:
            print_error(f"bars voice {w} error - {type_error}")
            return
        # fi
        if f2 is None:
            print_error(f"bars voice {w} is not a number.")
            return
        # fi
        f2 = round(f2)
        bars_measures[f2] = f1
    # rof
    return
# End of do_bars

# ----------------------------------------------------------------------------
# clef 1,2,3 1,10,22,50 treble  # voices 1,2,3 in measures 1,10,22,50 to treble .
# clef 4                alto    # voice 4 to alto

def do_clef(t_args):
    global clef_voice_measures

    vargs = get_voice_measure_other(t_args, 'clef')
    if vargs is None:
        return
    # fi
    if len(vargs) < 2:
        print_error(f"clef does not have at least 2 arguments (has {len(vargs)})")
        return None
    # fi
    if len(vargs) > 3:
        print_error(f"clef has more than 3 arguments (voices measures clef) - has {len(vargs)}")
        return None
    # fi

    vn = separate_args(str(vargs[0]))   # Allow voice numbers.
    if not vn or len(vn) < 1:
        print_error("no voice arguments on clef line")
        return
    # fi
    
    # See if measures present.
    if len(vargs) == 3:
        mn = separate_args(str(vargs[1]))   # Allow measure numbers.
        if not mn or len(mn) < 1:
            print_error("no measure arguments on clef line")
            return
        # fi
        clf = vargs[2]
    else:
        mn = ( '1' )
        clf = vargs[1]
    # fi

    for v in vn:
        f1, type_error = is_float(v, is_float_number, False)
        if type_error is not None:
            print_error(f"clef voice {v} error - {type_error}")
            return
        # fi
        if f1 is None:
            print_error(f"clef voice {v} is not a number.")
            return
        # fi
        f1 = round(f1)
        for m in mn:
            f2, type_error = is_float(m, is_float_number, False)
            if type_error is not None:
                print_error(f"clef measure {m} error - {type_error}")
                return
            # fi
            if f2 is None:
                print_error(f"clef measure {m} is not a number.")
                return
            # fi
            f2 = round(f2)
            if f1 not in clef_voice_measures:
                clef_voice_measures[f1] = {}
            # fi
            clef_voice_measures[f1][f2] = clf
        # rof
    # rof
    return
# End of do_clef

# ----------------------------------------------------------------------------
# Get t_args of voice numbers, followed by optional measures, then next.

def get_voice_measure_other(t_args, command):
    if t_args is None or t_args == '':
        print_error(f"{command} command does not have any arguments")
        return None
    # fi

    targs = re.sub(r'\s*,\s*', ',', t_args)
    targs = re.sub(r'\s*\.\.\s*', '..', targs)
    # Voice numbers (optional), followed by key name, with major/minor (optional).
    vargs = targs.split()
    return vargs
# End of get_voice_measure_other

# ----------------------------------------------------------------------------
#       key     1..5           g-       $$ six flats, measure 1 onwards.
#       key     1,2            f        $$ one flat, measure 1 onwards.
#       key     1   10,20,30   c        $$ no flats or sharps, voice 1, measures 10,20,30.
#       key     1              c        $$ Measure 1 onwards.
# Changes at start of a measure.

def do_key(t_args):
    global key_voice_measures

    vargs = get_voice_measure_other(t_args, 'key')
    if vargs is None:
        return
    # fi
    if len(vargs) < 2:
        print_error(f"key does not have at least 2 arguments (has {len(vargs)})")
        return None
    # fi
    if len(vargs) > 3:
        print_error(f"key has more than 3 arguments (voices measures key) - has {len(vargs)}")
        return None
    # fi

    vn = separate_args(str(vargs[0]))   # Allow voice numbers.
    if not vn or len(vn) < 1:
        print_error("no voice arguments on key line")
        return
    # fi
    
    # See if measures present.
    if len(vargs) == 3:
        mn = separate_args(str(vargs[1]))   # Allow measure numbers.
        if not mn or len(mn) < 1:
            print_error("no measure arguments on key line")
            return
        # fi
        ky = vargs[2].lower()
    else:
        mn = ( '1' )
        ky = vargs[1].lower()
    # fi

    # Validate key argument.
    if ky not in key_sig:
        print_error(f"key '{ky}' not recognized.")
        return
    # fi

    for v in vn:
        f1, type_error = is_float(v, is_float_number, False)
        if type_error is not None:
            print_error(f"key voice {v} error - {type_error}")
            return
        # fi
        if f1 is None:
            print_error(f"key voice {v} is not a number.")
            return
        # fi
        f1 = round(f1)
        for m in mn:
            f2, type_error = is_float(m, is_float_number, False)
            if type_error is not None:
                print_error(f"key measure {m} error - {type_error}")
                return
            # fi
            if f2 is None:
                print_error(f"key measure {m} is not a number.")
                return
            # fi
            f2 = round(f2)
            if f1 not in key_voice_measures:
                key_voice_measures[f1] = {}
            # fi
            key_voice_measures[f1][f2] = ky
        # rof
    # rof
    return
# End of do_key

# ----------------------------------------------------------------------------
def check_instr(instr):
    global midi_instruments
    global drum_sounds

    instr = instr.lower()
    if instr in midi_instruments:
        return instr
    # fi
    if instr in drum_sounds:
        return instr
    # fi
    f1, type_error = is_float(instr, is_float_number, False)
    if type_error is not None:
        return None
    # fi
    if f1 is None:
        return None
    # fi
    return round(f1)
# End of check_instr

# ----------------------------------------------------------------------------
#   instrument 1,2 flute                $$ voices for an instrument.
#   instrument 1,2 20,30,50 flute       $$ voices, measures for an instrument.
# See source for list of all instruments.

def do_instrument(t_args):
    global instrument_voice_measures

    vargs = get_voice_measure_other(t_args, 'instrument')
    if vargs is None:
        return
    # fi
    if len(vargs) < 2:
        print_error(f"instrument does not have at least 2 arguments (has {len(vargs)})")
        return None
    # fi
    vn = vargs[0]
    if len(vargs) > 3:
        instr = check_instr(' '.join(vargs[2:]))
        mn = vargs[1]
    elif len(vargs) == 3:               # Does 2 and 3 make an instrument?
        instr = check_instr(' '.join(vargs[1:]))
        if instr is None:
            instr = check_instr(vargs[2])
            mn = vargs[1]
        else:
            mn = [ '1' ]
        # fi
    else:
        instr = check_instr(vargs[1])
        mn = [ '1' ]
    # fi
    if instr is None:
        print_error("instrument not found.")
        return
    # fi

    vn = separate_args(str(vn))         # The voice numbers.
    if not vn or len(vn) < 1:
        print_error("no voice arguments on instrument line")
        return
    # fi
    
    mn = separate_args(str(mn))         # The measure numbers.
    if not mn or len(mn) < 1:
        print_error("no measure arguments on instrument line")
        return
    # fi
    
    for v in vn:
        f1, type_error = is_float(v, is_float_number, False)
        if type_error is not None:
            print_error(f"instrument voice {v} error - {type_error}")
            return
        # fi
        if f1 is None:
            print_error(f"instrument voice {v} is not a number.")
            return
        # fi
        f1 = round(f1)
        for m in mn:
            f2, type_error = is_float(m, is_float_number, False)
            if type_error is not None:
                print_error(f"instrument measure {m} error - {type_error}")
                return
            # fi
            if f2 is None:
                print_error(f"instrument measure {m} is not a number.")
                return
            # fi
            f2 = round(f2)
            if f1 not in instrument_voice_measures:
                instrument_voice_measures[f1] = {}
            # fi
            instrument_voice_measures[f1][f2] = instr
        # rof
    # rof
    return
# End of do_instrument

# ----------------------------------------------------------------------------
# The number of notes of second argument note length in a measure.
#               measure     meter-for-measure
#       meter   1,10        1/8
#       meter   2,11        4/4
#       meter   13          3/4

def do_meter(t_args):
    global meters_measures

    if t_args is None or t_args == '':
        print_error("meter does not have an expression to process")
        return
    # fi

    vargs = get_voice_measure_other(t_args, 'meter')
    if vargs is None:
        return
    # fi
    if len(vargs) > 2:
        print_error("meter format is for all staves, then optional measures")
        return
    # fi

    mn = separate_args(str(vargs[0]))       # The measure numbers.
    # fi
    if not mn or len(mn) < 1:
        print_error("no measure argument(s) for bar command")
        return
    # fi

    # Get meter.
    meter = vargs[1]
    meter = re.sub(r',', r'/', meter)       # Change 3,4 to 3/4.

    f, type_error = is_float(meter, is_float_number, False)
    if type_error is not None:
        print_error(f"meter {meter} error - {type_error}")
        return
    # fi
    if f is None:
        print_error("meter {meter} argument as a calculation did not return a value")
        return
    # fi

    for w in mn:
        f1, type_error = is_float(w, is_float_number, False)
        if type_error is not None:
            print_error(f"bars voice {w} error - {type_error}")
            return
        # fi
        if f1 is None:
            print_error(f"bars voice {w} is not a number.")
            return
        # fi
        f1 = round(f1)
        meters_measures[f1] = meter         # Save text for meter.
    # rof
    return
# End of do_meter

# ----------------------------------------------------------------------------
# The value for middle_c.
#       middlec 4c
#       middlec 3c
#       middlec 2b-

def do_middle_c(t_args):
    global middle_c
    global note_to_midi_value

    if t_args is None:
        print_error("middlec does not have a note to process")
        return
    # fi
    if t_args == '':
        compute_middle_c(39)                    # Default to 3c (39).
        return
    # fi
    note_to_decode = t_args
    temp3 = 0                                   # character pointer
    if note_to_decode not in note_to_midi_value:
        thenote, type_error = is_float(note_to_decode, is_float_number, False)
        if type_error is not None:
            print_error("middlec does not have a valid number - {note_to_decode}")
            return
        # fi
        if thenote is None:
            print_error(f"middle_c - Note is not legal '{note_to_decode}', computation failed")
            return
        # fi
        note_to_decode = round(thenote)
        note_to_decode = note_to_decode + 12 + 12 - 3     # 3c -> 39 must be 60 for midi.
        if note_to_decode <= 0 or note_to_decode >= 127:
            print_error(f"middle_c - Note number '{thenote}' not in range")
            return
        # fi
        number = round(thenote)
        return
    else:
        number = note_to_midi_value[note_to_decode] - (60 - middle_c)
    # fi
    compute_middle_c(number)
    return
# End of do_middle_c

# ----------------------------------------------------------------------------
# Set page for measure(s).

def do_page(t_args):
    global pages_measure

    if t_args is None or t_args == '':
        print_error("page does not have an expression to process")
        return
    # fi

    vargs = get_voice_measure_other(t_args, 'page')
    if vargs is None:
        return
    # fi
    if len(vargs) > 2:
        print_error("page format is number, then optional measures")
        return
    # fi
    m = vargs[0]

    f1, type_error = is_float(m, is_float_number, False)
    if type_error is not None:
        print_error(f"page {m} error - {type_error}")
        return
    # fi
    if f1 is None:
        print_error("page {m} argument as a calculation did not return a value")
        return
    # fi
    f1 = round(f1)

    # See if measures.
    if len(vargs) == 1:
        mn = ( '1' )               # default to measure 1 
    else:
        mn = separate_args(str(vargs[1]))     # The measure numbers.
    # fi
    if not mn or len(mn) < 1:
        print_error("no measure argument(s) for page command")
        return
    # fi
    for w in mn:
        f2, type_error = is_float(w, is_float_number, False)
        if type_error is not None:
            print_error(f"page voice {w} error - {type_error}")
            return
        # fi
        if f2 is None:
            print_error(f"page voice {w} is not a number.")
            return
        # fi
        f2 = round(f2)
        pages_measures[f2] = f1
    # rof
    return
# End of do_page

# ----------------------------------------------------------------------------
# Give a title to a printed or played song (abcm2ps, or .mid).
#       title   Inventio 15    by Bach
#       title   for plato by Marshall Midden

def do_title(t_args):
    global titles

    if t_args is None or t_args == '':
        #-- print_warning("Title does not have any text.")
        titles.append( '' )
        return
    # fi
    titles.append( t_args )
    return
# End of do_title

# ----------------------------------------------------------------------------
# NOTE/WARNING: if you have xpose without a key, it goes to key_default.
# This is UGLY.
#       =xpose  clarinetA..clarinetB -2     $$ clarinett in B ...  C, B-, B  ->  -2
#       xpose   c-                          $$ all voices, from current key to key c-.
#       xpose   1 c-                        $$ voice 1, from current key to key c-.
#       xpose   1 -1 c-                     $$ voice 1, down 1 semi-tone, then to key c-,
# and change to key c- if --vertical/--horizontal.
#       xpose   1 +12                       $$ 4c = 5c
#       xpose   1,2..5,7 +2                 $$ French Horn in D plays 2 semitones higher from what is written
#       xpose   1 -12                       $$ French Horn in C plays 12 semitones lower
#       xpose   1 -7                        $$ 4c = 3f
#       xpose   1 +2                        $$ Trombone in D plays 2 semitones higher from what is written
#       xpose   1 -3                        $$ Clarinet in A ... "C" plays "A" (i.e. C, B, B-, A = -3)
#       =xpose  bassdrumA  -13              $$ 2c (printed) -> 0bn (played)
#       =xpose  cymbalA  -1                 $$ 2e (printed) -> 2d- (played)
# NOTE: the --vertical and --horizontal and key changes ... *sigh* complicated.

def do_xpose(t_args):
    global xpose
    global xpose_new_key
    global key_sig
    global key_sig_int
    global key_default
    global args
    global key_voice
    global minor_key_to_major

    print_error("NOTDONEYET - do_xpose")

    if args.noxpose:
        print_warning("Ignoring xpose parsing due to --noxpose argument.")
        return
    # fi
    if args.abc:
        print_warning("Ignoring xpose parsing for --abc output format. ")
        return
    # fi
    if t_args is None or t_args == '':
        print_error("xpose does not have arguments.")
        return
    # fi
    targs = re.sub(r'\s*,\s*', ',', t_args)
    vargs = targs.split()
    if len(vargs) <= 0 or len(vargs) > 4:
        print_error("xpose does not have correct number of arguments.")
        return
    # fi
    kl = None
    if len(vargs) > 1:
        mm = vargs[len(vargs) - 1].lower()      # Last argument
        kl = vargs[len(vargs) - 2].lower()      # Second to last argument
        if mm == 'minor':
            if kl not in minor_key_to_major:
                print_error(f"xpose command, key does not recognize minor {kl}")
                return
            # fi
            kl = minor_key_to_major[kl].lower()
            vargs.pop()
        elif mm == 'major':
            if kl not in key_sig:
                print_error(f"xpose command, key '{kl}' not recognized.")
                return
            # fi
            vargs.pop()
        else:
            kl = None
        # fi
    # fi
    if len(vargs) > 1:
        if len(vargs) == 4:
            print_error("xpose command only allows 3 arguments.")
            return
        elif len(vargs) == 3:
            if kl is None:
                kl = vargs[2].lower()
            # fi
            x = vargs[1]                # shifting amount
            vs = vargs[0]               # voices to change
        elif len(vargs) == 2:
            vs = vargs[0]               # voices to change
            # Check if key, or a number.
            if kl is None:
                kl = vargs[1].lower()   # new key?
            # fi
            if kl in key_sig:
                x = '0'                 # shifting amount
            else:       # is a number?
                f1, type_error = is_float(kl, is_float_number, False)
                if type_error is not None:
                    print_error(f"xpose error#1 - {type_error}")
                    return
                # fi
                if f1 is None:
                    print_error(f"voice does not have xpose argument {kl} as a number or key.")
                    return
                # fi
                x = str(round(f1))      # Must be an integer as a string.
                kl = None
            # fi
        else:
            print_error("xpose has a problem.")
            return
        # fi
    else:   # Only one argument -- key or number?
        # Check if key, or a number.
        if kl is None:
            kl = vargs[0].lower()       # new key
        # fi
        if kl.lower() in key_sig:
            x = '0'                     # shifting amount
        else:       # is a number?
            x = kl
            kl = None
            f1, type_error = is_float(x, is_float_number, False)
            if type_error is not None:
                print_error(f"xpose error#2 - {type_error}")
                return
            # fi
            if f1 is None:
                print_error(f"voice does not have xpose argument {kl} as a number or key.")
                return
            # fi
            x = str(round(f1)) # Must be an integer as a string..
        # fi
        vs = '{1}..{len(volume)}'       # all voices
    # fi
    if type(kl) is str:
        if kl not in key_sig:
            print_error(f"no key '{kl}' in key_sig({key_sig})")
            return
        # fi
    # fi

    f1, type_error = is_float(x, is_float_number, False)
    if type_error is not None:
        print_error(f"xpose error#3 - {type_error}")
        return
    # fi
    if f1 is None:
        print_error(f"voice does not have xpose argument {x} as a number.")
        return
    # fi
    x = round(f1)              # Must be an integer.

    # kl is used in getnote via xpose_new_key (musicomp text)
    # kl is None means to use current key for voice.

    mn = separate_args(str(vs))   # Allow voice numbers.
    if not mn or len(mn) < 1:
        print_error("no voice arguments on xpose")
        return
    # fi
    # If kl is None, use key_default.
    if args.vertical or args.horizontal:
        kprint_lc = key_default                 # printing and used in xpose are the same.
    else:
        kprint_lc = key_sig_int[key_default]    # Key name extracted.
    # fi
    for w in mn:
        f1, type_error = is_float(w, is_float_number, False)
        if type_error is not None:
            print_error(f"xpose error#4 - {type_error}")
            return
        # fi
        if f1 is None:
            print_error(f"voice {w} is not a number.")
            return
        # fi
        f1 = round(f1)
        if kl is None:
            if f1 in key_voice and measure_on in key_voice[f1]:
                xpose_new_key[f1] = key_voice[f1][measure_on]   # Use current key for voice
            else:
                xpose_new_key[f1] = kprint_lc
            # fi
        else:
            xpose_new_key[f1] = kl
        # fi
        xpose[f1] = x
    # rof
    return
# End of do_xpose

# ----------------------------------------------------------------------------
# Following does not do multiple sharps or flats, but that is crazy anyway. Neither naturals.
global key_sig
key_sig = { 'c+':7, 'f+':6, 'b':5, 'bn':5, 'e':4, 'en':4, 'a':3, 'an':3, 'd':2,
            'dn':2, 'g':1, 'gn':1, 'c':0, 'cn':0, 'f':-1, 'b-':-2, 'e-':-3,
            'a-':-4, 'd-':-5, 'g-':-6, 'c-':-7 }

global key_sig_int
key_sig_int = {}
for i in key_sig:
    if key_sig[i] not in key_sig_int:
        key_sig_int[key_sig[i]] = i
    # fi
# rof

global key_to_accidentals
key_to_accidentals = {
    'c':  ('c', 'd', 'e', 'f', 'g', 'a', 'b'),
    'cn':  ('c', 'd', 'e', 'f', 'g', 'a', 'b'),

    'f':  ('c', 'd', 'e', 'f', 'g', 'a', 'b-'),
    'b-': ('c', 'd', 'e-', 'f', 'g', 'a', 'b-'),
    'e-': ('c', 'd', 'e-', 'f', 'g', 'a-', 'b-'),
    'a-': ('c', 'd-', 'e-', 'f', 'g', 'a-', 'b-'),
    'd-': ('c', 'd-', 'e-', 'f', 'g-', 'a-', 'b-'),
    'g-': ('c-', 'd-', 'e-', 'f', 'g-', 'a-', 'b-'),
    'c-': ('c-', 'd-', 'e-', 'f-', 'g-', 'a-', 'b-'),

    'g':  ('c', 'd', 'e', 'f+', 'g', 'a', 'b'),
    'd':  ('c+', 'd', 'e', 'f+', 'g', 'a', 'b'),
    'a':  ('c+', 'd', 'e', 'f+', 'g+', 'a', 'b'),
    'e':  ('c+', 'd+', 'e', 'f+', 'g+', 'a', 'b'),
    'b':  ('c+', 'd+', 'e', 'f+', 'g+', 'a+', 'b'),
    'f+': ('c+', 'd+', 'e+', 'f+', 'g+', 'a+', 'b'),
    'c+': ('c+', 'd+', 'e+', 'f+', 'g+', 'a+', 'b+')
}

global key_convert
key_convert = { }
for i in key_to_accidentals:
    l = {}
    for o in range(0, 9) :
        m = 0
        for n in ('c', 'd', 'e', 'f', 'g', 'a', 'b'):
            l[str(o) + n + '--'] = str(o) + n + '--'
            l[str(o) + n + '-']  = str(o) + n + '-'
            l[str(o) + n]        = str(o) + key_to_accidentals[i][m]
            l[str(o) + n + 'n']  = str(o) + n + 'n'
            l[str(o) + n + '+']  = str(o) + n + '+'
            l[str(o) + n + '++'] = str(o) + n + '++'
            m = m + 1
        # rof
    # rof
    key_convert[i] = l
# rof

# ----------------------------------------------------------------------------
# dictionary commandname : routine. execute via(?): globals()['do_cstopnow'](t_args, line)
global hint_commands
hint_commands = {
#            Command         Routine
             'bars'       : do_bars,
             'clef'       : do_clef,
             'instrument' : do_instrument,
             'key'        : do_key,
             'meter'      : do_meter,
             'middlec'    : do_middle_c,
             'page'       : do_page,
             'title'      : do_title,
             'transpose'  : do_xpose,
             'xpose'      : do_xpose,
           }

# ----------------------------------------------------------------------------
#    octave  0      1      2      3      4       5       6       7       8
#  c/b+     24     36     48     60     72      84      96     108     120
#  c+/d-    25     37     49     61     73      85      97     109     121
#  d        26     38     50     62     74      86      98     110     122
#  d+/e-    27     39     51     63     75      87      99     111     123
#  e/f-     28     40     52     64     76      88     100     112     124
#  f/e+     29     41     53     65     77      89     101     113     125
#  f+/g-    30     42     54     66     78      90     102     114     126
#  g        31     43     55     67     79      91     103     115     127
#  g+/a-    32     44     56     68     80      92     104     116
#  a        33     45     57     69     81      93     105     117
#  a+/b-    34     46     58     70     82      94     106     118
#  b/c-     35     47     59     71     83      95     107     119

# For octave 3c = 60.
global note_in_octave_value
note_in_octave_value = {
   'c--':58, 'c-':59, 'c':60, 'cn':60, 'c+':61, 'c++':62,
   'd--':60, 'd-':61, 'd':62, 'dn':62, 'd+':63, 'd++':64,
   'e--':62, 'e-':63, 'e':64, 'en':64, 'e+':65, 'e++':66,
   'f--':63, 'f-':64, 'f':65, 'fn':65, 'f+':66, 'f++':67,
   'g--':65, 'g-':66, 'g':67, 'gn':67, 'g+':68, 'g++':69,
   'a--':67, 'a-':68, 'a':69, 'an':69, 'a+':70, 'a++':71,
   'b--':69, 'b-':70, 'b':71, 'bn':71, 'b+':72, 'b++':73
}

global note_to_midi_value
note_to_midi_value = { }
global note_to_midi_value_39
note_to_midi_value_39 = { }

global midi_value_to_note_flat
midi_value_to_note_flat = { }
global midi_value_to_note_flat_39
midi_value_to_note_flat_39 = { }

global midi_value_to_note_sharp
midi_value_to_note_sharp = { }
global midi_value_to_note_sharp_39
midi_value_to_note_sharp_39 = { }

global middle_c
middle_c = 39                   # Default to 60, as per cyber1 (1978 era) musicomp.

def compute_middle_c(f):
    global note_in_octave_value
    global note_to_midi_value
    global note_to_midi_value_39
    global midi_value_to_note_sharp
    global midi_value_to_note_sharp_39
    global midi_value_to_note_flat
    global midi_value_to_note_flat_39
    global middle_c

    middle_c = f
    f = f + 12 + 12 - 3             # 3c -> 39 must be 60 for midi.
    f39 = 39 + 12 + 12 - 3         # 3c -> 39 must be 60 for midi.
    note_to_midi_value = {}
    note_to_midi_value_39 = {}
    midi_value_to_note_sharp = {}
    midi_value_to_note_sharp_39 = {}
    midi_value_to_note_flat = {}
    midi_value_to_note_flat_39 = {}

    for o in range(0, 9):           # 0 thru 8
        for n in note_in_octave_value:
            x = str(o) + n
            v = (note_in_octave_value[n] - (f - 24)) + (12 * o)  # 60-36=24 = '0c'
            v39 = (note_in_octave_value[n] - (f39 - 24)) + (12 * o)  # 60-36=24 = '0c'
            note_to_midi_value[x] = v
            note_to_midi_value_39[x] = v39
            if len(n) >= 3:         # ignore double flat and double sharp
                pass
            elif len(n) == 2:       # accidental
                if n[1] == '+':
                    if v not in midi_value_to_note_sharp:   # Prefer no sharp/flat.
                        midi_value_to_note_sharp[v] = x
                    # fi
                    if v39 not in midi_value_to_note_sharp_39: # Prefer no sharp/flat.
                        midi_value_to_note_sharp_39[v39] = x
                    # fi
                # fi
                if n[1] == '-':
                    if v not in midi_value_to_note_flat:    # Prefer no sharp/flat.
                        midi_value_to_note_flat[v] = x
                    # fi
                    if v39 not in midi_value_to_note_flat_39:  # Prefer no sharp/flat.
                        midi_value_to_note_flat_39[v39] = x
                    # fi
                # Ignore 'n'.
                # fi
            else:
                midi_value_to_note_sharp[v] = x             # Prefer no sharp/flag.
                midi_value_to_note_flat[v] = x
                midi_value_to_note_sharp_39[v39] = x        # Prefer no sharp/flag.
                midi_value_to_note_flat_39[v39] = x
            # fi
        # rof
    # rof
    return
# End of compute_middle_c

compute_middle_c(middle_c)                      # Default to 3c

# ----------------------------------------------------------------------------
def compute_hint_command_args(expand_line):
    if not expand_line:
        return '', '', ''
    # fi
    t0 = re.sub(r'^([a-zA-Z0-9%_*]*).*$', r'\1', expand_line, count=1)   # First token on line.
    t1 = re.sub(r'^[a-zA-Z0-9%_*]*(.*)$', r'\1', expand_line, count=1)   # Rest of line.

    command = t0.lstrip()
    t_args = t1.strip()

    if len(t1) > 0:
        delimiter = t1[0]
    else:
        delimiter = ''
    # fi
    # Note: t0 + t1 = line. :) [Thus know how to do things in character variable substitution.]
    return command, t_args, delimiter
# End of compute_hint_command_args

# ----------------------------------------------------------------------------
# Parse and process hint file line.

def process_hint_line(original_line):
    global hint_commands

    qline = original_line
    command, t_args, delimiter = compute_hint_command_args(qline)

    # Try to process command. If not a command, process notes.
    if command is not None and command in hint_commands:
        try:
            r = hint_commands[command]              # Had an error once ... thus try/expect.
        except:
            print_error(f"Not found processing routine for command '{command}' '{delimiter}' '{t_args}'")
            print_stderr("    " + sys.exc_info()[0] + sys.exc_info)
        # yrt
        print_debug(f'command="{command}" delimiter="{delimiter}" t_args="{t_args}"')
        r(t_args)
    else:
        print_error(f"Unexpected line in hint file: '{command}' '{t_args}'")
    # fi
# End of process_hint_line

# ----------------------------------------------------------------------------
# Get the next hint file line.
# Return:
#   full_line           - the line without $$ or # comments.
#   commentdollardollar - The $$ or # comment, with the two dollar signs or #.

def read_next_hint_line():
    global linecount
    global args
    global hint_file
    global errors_happened

    if hint_file is None:
        return None, None
    # fi
    full_line = ''
    while True:
        try:
            line = hint_file.readline()
            if line is None or line == '':
                sys.exit(errors_happened)
            # fi
            linecount = linecount + 1
            if line:
                line = line.rstrip()                # trailing spaces gone.
                if line and line[-1] == '\\':       # if continued on next line
                    line = line[:-1]
                    line = line.rstrip()            # trailing spaces gone.
                    full_line += line
                    continue
                # fi
                full_line += line
                commentdollardollar = ''
                if '$$' in full_line:
                    # delete anything from $$ onwards.
                    commentdollardollar = re.sub(r'^.*[$][$]', '$$', full_line, count=1)
                    commentdollardollar = commentdollardollar.rstrip()  # trailing spaces gone
                    full_line = re.sub(r'[$][$].*$', '', full_line)
                # fi
                if '#' in full_line:
                    # delete anything from # onwards.
                    commentdollardollar = re.sub(r'^.*[#]', '#', full_line, count=1)
                    commentdollardollar = commentdollardollar.rstrip()  # trailing spaces gone
                    full_line = re.sub(r'[#].*$', '', full_line)
                # fi
#-- need to know continued line ... 8 spaces or start with a tab.
                return full_line, commentdollardollar
            # fi
        except EOFError:
            if full_line != '':
                return full_line, commentdollardollar
            # fi
            pass            # print("Read gave EOF", file=sys.stderr, flush=True)
        except SystemExit:
            if full_line != '':
                return full_line, commentdollardollar
            # fi
            pass            # print("Read gave system exit", file=sys.stderr, flush=True)
        except KeyboardInterrupt:
            print_error("Read got keyboard interrupt")
        except:
            if full_line != '':
                return full_line, commentdollardollar
            # fi
            print_error("Read got a processing error")
            print_stderr("    " + sys.exc_info()[0] + sys.exc_info)
        # yrt
        break
    # elihw
    return None, None
# End of read_next_hint_line

# ----------------------------------------------------------------------------
def readhintfile():
    global linecount
    global args

    while True:                                         # Read the file loop.
        line, commentonline = read_next_hint_line()
        if line is None and commentonline is None:      # If end of file.
            break
        elif line is None:                              # Blank line
            continue
        # fi
        if args.lines:
            print_stderr(f"linecount={linecount} line='{line}'")
        # fi
        line = line.strip()
        if line == '':                                  # Blank line
            continue
        # fi
        # If command == '*' ignore.
        if re.match(r'^\s*[#*]', line):                 # Comment line.
            continue
        # fi
        process_hint_line(line)
    # elihw
    return
# End of readhintfile

# ----------------------------------------------------------------------------
# NOTDONEYET - gcs output.
#--     global array_of_gcs
#-- 
#-- # TO DO: below is wrong.
#--     if len(array_of_gcs) > 0:
#--         last = array_of_gcs[-1]
#--         if last[0:6] == 'sleep ' and strg[0:6] == 'sleep ':
#--             new_time1 = float(last[6:])
#--             new_time2 = float(strg[6:])
#--             array_of_gcs[-1] = f'sleep {(new_time1 + new_time2):.3f}'
#--             return
#--         elif last == strg:                          # Delete duplicates.
#--             return
#--         # fi
#--     # fi
#--     array_of_gcs.append(strg)
#--     return

def printout_gcs():
    print_stderr('\n')
    print_error('NOTDONEYET - printout_gcs')
    pass
# End of printout_gcs

# ----------------------------------------------------------------------------
# Main program follows.
def main():
    global args
    global input_file                   # File to read for input (default is use tty - stdin).
    global output_file                  # File to print to (default is sys.stdout).
    global hint_file                    # File to print to (default is None).
    global array_of_original_lines

    if args.rest:
        if len(args.rest) >= 1:             # Input.
            which_file_in = args.rest[0]
            input_file = open(which_file_in, 'r')
        # fi
        if len(args.rest) >= 2:             # Output.
            which_file_out = args.rest[1]
            output_file = open(args.rest[1], 'w')
        # fi
        if len(args.rest) >= 3:             # Hint.
            which_file_hint = args.rest[2]
            hint_file = open(args.rest[2], 'r')
        # fi
        if len(args.rest) > 3:              # Too many.
            print_error(f'Too many arguments, input, output, hint only. {args.rest}')
            if errors_happened != 0:
                print_stderr(f'exiting with errors_happened={errors_happened}')
            # fi
            sys.exit(1)
        # fi
    # fi

    readhintfile()
    print_debug_hints()

    readthefile()                       # Parse the input fs file into arrays/dictionaries/etc.

    figure_out_measure_locations()      # Where are the starts of measures - from meter clicks and tempos.

    set_keys_if_not_specified()         # Set a default key.

    notes_fitted_into_measures()

    printable_measures()

    print_debug_internal_1('DONE')

#--     for i in array_of_original_lines:
#--         print_output(i)
#--     # rof

    printout_gcs()

    return
# End of main

# ----------------------------------------------------------------------------
if __name__ == '__main__':
    main()
# fi
# ----------------------------------------------------------------------------
if errors_happened != 0:
    print_stderr(f'exiting with errors_happened={errors_happened}')
# fi
sys.exit(errors_happened)
# ----------------------------------------------------------------------------
# End of program mmm.py
# ----------------------------------------------------------------------------
