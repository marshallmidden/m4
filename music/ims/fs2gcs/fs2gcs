#!/usr/bin/python3 -B
# ----------------------------------------------------------------------------
# Need keys to have time clicks. (Put inside measures, after/as those are calculated.)
# Need comments to have time clicks. (Put inside measures, after/as those are calculated.)
# ----------------------------------------------------------------------------
# vim: tabstop=8 expandtab shiftwidth=4 softtabstop=4
# ----------------------------------------------------------------------------
import argparse
import os
import re
import readline
import sys
# ----------------------------------------------------------------------------
global errors_happened              # Count of number of errors that occurred.
errors_happened = 0
# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
global which_file_in                # Input file name (default to stdin).
which_file_in = 'stdin'
global linecount                    # Line number from input file
linecount = 0
global which_file_out               # Output file name (default to stdout).
which_file_out = 'stdout'
global which_file_hint              # Hint file name.                       -- NOTDONEYET
which_file_hint = 'None'
# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
global input_file                   # File to read for input (default is use tty - stdin).
input_file = None
global output_file                  # File to print to (default is sys.stdout).
output_file = sys.stdout
global hint_file                    # File for hints (default is None).     -- NOTDONEYET
hint_file = None
# ----------------------------------------------------------------------------
def print_stderr(strg):
    print(strg, file=sys.stderr, flush=True)
    return
# End of print_stderr

# ----------------------------------------------------------------------------
def print_debug(strg):
    print_stderr('DEBUG - ' + strg)
    return
# End of print_debug

# ----------------------------------------------------------------------------
def print_error(strg):
    global errors_happened          # Count of number of errors that occurred.

    errors_happened = errors_happened + 1
    print_stderr('ERROR - ' + strg)
    return
# End of print_error

# ----------------------------------------------------------------------------
def print_warning(strg):
    print_stderr('WARNING - ' + strg)
    return
# End of print_warning

# ----------------------------------------------------------------------------
def print_output(strg):
    global output_file

    print(strg.rstrip(), file=output_file, flush=True)
    return
# End of print_output

# ----------------------------------------------------------------------------
# NOTDONEYET - gcs output.
#-- def print_gcs(strg):
#--     global array_of_gcs
#-- 
#-- # TO DO: below is wrong.
#--     if len(array_of_gcs) > 0:
#--         last = array_of_gcs[-1]
#--         if last[0:6] == 'sleep ' and strg[0:6] == 'sleep ':
#--             new_time1 = float(last[6:])
#--             new_time2 = float(strg[6:])
#--             array_of_gcs[-1] = f'sleep {(new_time1 + new_time2):.3f}'
#--             return
#--         elif last == strg:                          # Delete duplicates.
#--             return
#--         # fi
#--     # fi
#--     array_of_gcs.append(strg)
#--     return
#-- # End of print_gcs

# ----------------------------------------------------------------------------
global args

# ----------------------------------------------------------------------------
def parse_args():
    global args

    parser = argparse.ArgumentParser(
        description=__doc__,
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog='this is the epilog')
    parser.add_argument('--lines', '-lines', action='store_true',
                        help='Print each line as it is read from file or macro or loop.')
    parser.add_argument('rest', nargs='*',
                        help='Optionals: inputfile(stdin) outputfile(stdout) hintfile(none)')
    args = parser.parse_args()
    return
# End of parse_args

# ----------------------------------------------------------------------------
parse_args()

# ----------------------------------------------------------------------------
global voices                       # Number of voices
voices = 1
global measure
measure = 1                         # Start measure at number 1.
# ----------------------------------------------------------------------------
MAXVOICES = 256
# ----------------------------------------------------------------------------
global MIDICLICKSPERQUARTER
MIDICLICKSPERQUARTER = 480.0
global tempo_s                      # 60 beats per quarter note.
tempo_s = 60
global tempo_l
tempo_l = 0.25
global running_time
running_time = 0                    # Nothing yet.
# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
global no_notes_yet
no_notes_yet = True
# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
global titles
titles = ''
global comments
comments = ''
global key_default
key_default = None
global meter_default
meter_default = None
global key_previous
key_previous = None
global meter_previous
meter_previous = None
global instrument_bank              # Indexed by voice number.
instrument_bank = {}
global instrument_number            # Indexed by voice number.
instrument_number = {}
# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
global measures_length              # The length of measure (by voice).
measures_length = {}                # measures_length[v] = floating_number
# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
global bufs_notes_voices            # Voices for chords on this voice.
bufs_notes_voices = {}
global bufs_notes                   # Midi note number. An array indexed by measure, voice.
bufs_notes = {}                     # bufs_notes[v] = []             Midi note number.
global bufs_notes_start             # calculated clicks to start of each note for a voice.
bufs_notes_start = {}
global bufs_notes_end               # calculated clicks to end of each note for a voice.
bufs_notes_end = {}                 #   Used to recognize 'chords'.
global bufs_notes_velocity          # The intensity of note start. (Typically the total volume. *sigh*)
bufs_notes_velocity = {}
global bufs_cc_start                # [voice][cc#]      time in clicks when CC occurred.
bufs_cc_start = {}
global bufs_cc_end                  # [voice][cc#]      time in clicks when CC occurred.
bufs_cc_end = {}
global last_cc                      # If doing a note, the last_cc. NOTE: defaults for 7,10,11,64,68,91.
last_cc = {}
for v in range(0,MAXVOICES):        # Voices if multiple turned on, run to alternative.
    bufs_notes_voices[v] = [v]      # Start with 1:1 voice to chord voice. Note: voices global set with Header -> max.
    bufs_notes[v] = []              # No notes yet.
    bufs_notes_start[v] = []        # No starting time click time for notes.
    bufs_notes_end[v] = []          # No ending time click time for notes.
    bufs_notes_velocity[v] = []     # No note start intensity volume levels.
    bufs_cc_start[v] = []           # No starting cc values.
    bufs_cc_end[v] = []             # No ending cc values.
    last_cc[v] = []
    for cc in range(0, 127):
        bufs_cc_start[v].append([]) # No starting cc's.
        bufs_cc_end[v].append([])   # No ending cc's.
        last_cc[v].append(0)        # No previous cc's.
        if cc == 7:
            last_cc[v][cc] = 100    # default_volume variable.
        elif cc == 10:
            last_cc[v][cc] = 64     # default_pan variable.
        elif cc == 11:
            last_cc[v][cc] = 100    # default_intensity variable.
        elif cc == 64:
            last_cc[v][cc] = 0      # damper off.
        elif cc == 68:
            last_cc[v][cc] = 0      # legato off.
        elif cc == 91:
            last_cc[v][cc] = 0      # reverb none.
        else:
            last_cc[v][cc] = 0      # Otherwise intialize to 0.
        # fi
    # rof
# rof
# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
global array_of_original_lines      # For input, have an array of the original lines.
array_of_original_lines = []
# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
# ----------------------------------------------------------------------------
#-- # Following does not do multiple sharps or flats, but that is crazy anyway. Neither naturals.
#-- global key_sig
#-- key_sig = { 'c+':7, 'f+':6, 'b':5, 'bn':5, 'e':4, 'en':4, 'a':3, 'an':3, 'd':2,
#--             'dn':2, 'g':1, 'gn':1, 'c':0, 'cn':0, 'f':-1, 'b-':-2, 'e-':-3,
#--             'a-':-4, 'd-':-5, 'g-':-6, 'c-':-7 }
#-- 
#-- global key_sig_int
#-- key_sig_int = {}
#-- for i in key_sig:
#--     if key_sig[i] not in key_sig_int:
#--         key_sig_int[key_sig[i]] = i
#--     # fi
#-- # rof
#-- 
# ----------------------------------------------------------------------------
#--         MIDICLICKSPERQUARTER = int(r[1])
global midi_2_note_lengths
midi_2_note_lengths = {}

def do_note_length_calculate():
    global MIDICLICKSPERQUARTER
    global midi_2_note_lengths

    for nl in (1,2,4,8,16,32,64,128):
        # note length.
        m = (MIDICLICKSPERQUARTER / 0.25) / nl
        if int(m * 1000) != int(m)*1000:
            print_debug(f'Note length {nl} does not divide by {nl} nicely into MIDICLICKSPERQUARTER {MIDICLICKSPERQUARTER} ... {m}')
        else:
            m = int(m)
            if m == 0:
                print_debug(f'Note length {nl} gives midi click value of 0')
            else:
                midi_2_note_lengths[m] = ( str(nl), 1.0 / nl )
            # fi
        # fi

        # dotted note lengths.
        md = ((MIDICLICKSPERQUARTER / 0.25) / nl) * 1.5
        if int(md * 1000) != int(md)*1000:
            print_debug(f'Note length {nl}d does not divide nicely into MIDICLICKSPERQUARTER {MIDICLICKSPERQUARTER}  ... {md}')
        else:
            md = int(md)
            if md == 0:
                print_debug(f'Note length {nl} gives midi click value of 0')
            elif md not in midi_2_note_lengths:
                midi_2_note_lengths[md] = ( str(nl) + 'd', (1.0/nl)*1.5 )
            else:
                print_debug(f'Note length {nl}d has clicks {md} already in array as {midi_2_note_lengths[md]}')
            # fi
        # fi

        # double dotted note lengths.
        mdd = ((MIDICLICKSPERQUARTER / 0.25) / nl) * 1.5 * 1.5
        if int(mdd * 1000) != int(mdd)*1000:
            print_debug(f'Note length {nl}dd does not divide nicely into MIDICLICKSPERQUARTER {MIDICLICKSPERQUARTER}  ... {mdd}')
        else:
            mdd = int(mdd)
            if mdd == 0:
                print_debug(f'Note length {nl} gives midi click value of 0')
            elif mdd not in midi_2_note_lengths:
                midi_2_note_lengths[mdd] = ( str(nl) + 'd' + 'd', (1.0/nl)*1.5*1.5 )
            else:
                print_debug(f'Note length {nl}dd has clicks {mdd} already in array as {midi_2_note_lengths[mdd]}')
            # fi
        # fi
    # rof
#++     ml = list(midi_2_note_lengths.keys())
#++     ml.sort()
#++     for n in ml:
#++         print_debug(f'midi_2_note_lengths - {n} -> {midi_2_note_lengths[n]}')
#++     # rof
# End of do_note_length_calculate

# ----------------------------------------------------------------------------
# FF 58 04 nn dd cc bb Time Signature
# The time signature is expressed as four numbers. nn and dd represent the numerator
# and denominator of the time signature as it would be notated. The denominator
# is a negative power of two: 2 represents a quarter-note, 3 represents an eighth-note,
# etc. The cc parameter expresses the number of MIDI clocks in a metronome click.
# The bb parameter expresses the number of notated 32nd-notes in a MIDI quarter-note
# (24 MIDI clocks). This was added because there are already multiple programs which
# allow a user to specify that what MIDI thinks of as a quarter-note (24 clocks) is
# to be notated as, or related to in terms of, something else.
# 
# Therefore, the complete event for 6/8 time, where the metronome clicks every three
# eighth-notes, but there are 24 clocks per quarter-note, 72 to the bar, would be (in hex):
#       FF 58 04 06 03 24 08
#                nn dd cc bb
# That is, 6/8 time (8 is 2 to the 3rd power, so this is 06 03), 36 MIDI clocks per
# dotted-quarter (24 hex!), and eight notated 32nd-notes per quarter-note. 
#    i.e. 2*32=1/16, 4*32=1/8, 8*32=1/4.  And a 1/4 note is 0x24 time deltas long.
# If the 8 was changed to 16, then a 1/2 note is 0x24 long. (0x24=36)

def meter_readable(strg):
    s = strg.split()
    if len(s) != 4:
        print_error(f'meter line does not have enough arguments, want 4, not {len(s)}.')
        return None
    # fi
    numerator = int(s[0])
    denominator = 2 ** int(s[1])
    return f'{numerator}/{denominator}'
# End of print_out_midi1csv_ts

# ----------------------------------------------------------------------------
def process_echo_lines(q):
    global voices
    global MIDICLICKSPERQUARTER
    global titles
    global meter_default
    global meter_previous
    global key_default
    global key_previous
    global comments
    global tempo_s
    global tempo_l

    print_debug(f'process_echo_lines - q="{q}"')
    if q[0:8] == '"Header ':
        if q[-1] != '"':
            print_error('Header line expected to end with a double quote')
            return
        # fi
        r = q[8:-1].split()
        voices = int(r[0])
        MIDICLICKSPERQUARTER = int(r[1])
        print_debug(f'process_echo_lines - Header: voices="{voices} MIDICLICKSPERQUARTER={MIDICLICKSPERQUARTER}"')
        do_note_length_calculate()
        return
    # fi
    if q[0:7] == '"Title ':
        titles += q[7:]
        print_debug(f'process_echo_lines - Title: titles="{titles}"')
        return
    # fi
    if q[0:7] == '"meter ':
        if meter_default is not None and meter_previous != q:
            print_error(f'Did not expect two meter lines - "{meter_previous}" verses "{q[0]}"')
            return
        # fi
        if q[-1] != '"':
            print_error('meter line expected to end with a double quote')
            return
        # fi
        meter_previous = q
        meter_default = meter_readable(q[7:-1])
        print_debug(f'process_echo_lines - meter: meter_previous="{meter_previous}" meter_default={meter_default}')
        return
    # fi
    if q[0:5] == '"key ':
        if key_default is not None and key_previous != q:
            print_error(f'Did not expect two key lines that did not match - "{key_previous}" verses "{q}"')
            return
        # fi
        a = q[5:].split(None)
        if len(a) < 2 or len(a) > 4:
            print_error(f'key line expects key followed by "major" not {a}')
            return
        elif a[1] != "'major'\"":
            print_error(f'key line expects "major" not {a[1]}')
            return
        # fi
        key_previous = q
        key_default = a[0]
        print_debug(f'process_echo_lines - key: key_previous="{key_previous}" key_default={key_default}')
        return
    # fi
    if q[0:9] == '"tempo_s=':
# DEBUG - process_echo_lines - q=""tempo_s=150 tempo_l=0.25""
        print_debug(f'process_echo_lines - Starting tempo: tempo_s="{tempo_s}" tempo_l={tempo_l}')
        if q[-1] != '"':
            print_error('tempo_s line expected to end with a double quote')
            return
        # fi
        r = q[9:-1].split()
        tempo_s = int(r[0])
        if r[1][0:8] != 'tempo_l=':
            print_error(f'tempo_s line expects tempo_l not {r[1]}')
            return
        # fi
        tempo_l = float(r[1][8:])
        print_debug(f'process_echo_lines - Ending tempo: tempo_s="{tempo_s}" tempo_l={tempo_l}')
        return
    # fi
    if comments == '':
        comments = q
    else:
        comments += "\n" + q
    # fi
    print_debug(f'process_echo_lines - comments: comments="{comments}"')
    return
# End of process_echo_lines

# ----------------------------------------------------------------------------
global header_commands_ignore
header_commands_ignore = [ 'set', 'unload', 'load', 'reset', 'prog', 'pitch_bend' ]

def process_header_lines(q):
    global header_commands_ignore
    global instrument_bank
    global instrument_number

    print_debug(f'process_header_lines - q="{q}"')
    if q[0] in header_commands_ignore:
        return
    elif q[0] == 'echo':
        process_echo_lines(q[1])
    elif q[0] == 'sleep':
        process_sleep(q[1])
    elif q[0] == 'select':
        a = q[1].split()
        if len(a) < 1 or len(a) > 4:
            print_error(f'select line wants 4 arguments not {len(a)} - {q[1]}')
            return
        # fi
        # a[0] = voice #
        # a[1] = timeclicks
        # a[2] = bank
        # a[3] = instrument
        vn = int(a[0])
        ibank = int(a[2])
        instr = int(a[3])
        if vn in instrument_bank:
            if instrument_bank[vn] != ibank or instrument_number[vn] != instr:
                print_error(f'select line for voice {vn} does not match previous bank {instrument_bank[vn]} instrument {instrument_number[vn]}')
                return
            # fi
            return
        # fi
        instrument_bank[vn] = ibank
        instrument_number[vn] = instr
        return
    elif q[0] == 'cc':
        process_cc(q[1])
        return
    else:
        print_error(f'Line is unexpected - {q}')
    # fi
    return
# End of process_header_lines

# ----------------------------------------------------------------------------
def get_time_for_note(v4):
    global midi_2_note_lengths

    t = round(v4)
    ml = list(midi_2_note_lengths.keys())
    if t in midi_2_note_lengths:
        print_debug(f'get_time_for_note - {t} is length {midi_2_note_lengths[t]}')
    else:
        ml = list(midi_2_note_lengths.keys())
        ml.sort()
        flagless = None
        foundit = False
        for n in ml:
            if t < n:
                if flagless is None:
                    print_warning(f'get_time_for_note - {t}:[{v4}] less than smallest value {n}->{midi_2_note_lengths[n]}')
                else:
#--                     print_warning(f'get_time_for_note - {flagless}->{midi_2_note_lengths[flagless]} < {t}:[{v4}] < {n}->{midi_2_note_lengths[n]}')
                    low = t - flagless
                    high = n - t
                    if low < high:
                        print_warning(f'#A get_time_for_note - {flagless}->{midi_2_note_lengths[flagless]} less than {t}:[{v4}] by {low}')
                        t = flagless
                    else:
                        print_warning(f'#B get_time_for_note - {n}->{midi_2_note_lengths[n]} greater than {t}:[{v4}] by {high}')
                        t = n
                    # fi
                # fi
                foundit = True
                break
            # fi
            flagless = n
        # rof
        if not foundit:
            print_warning(f'get_time_for_note - {t}:[{v3}] > largest value {flagless}->{midi_2_note_lengths[flagless]}')
        # fi
    # fi
# End of get_time_for_note

# -----------------------------------------------------------------------------
#++    if not no_notes_yet:
#++        get_time_for_note(v4)
#++    # fi

# ----------------------------------------------------------------------------
def process_noteon(r):
    global voices
    global running_time
    global bufs_notes_voices            # Voices for chords on this voice.
    global bufs_notes                   # Midi note number. An array indexed by measure, voice.
    global bufs_notes_start             # calculated clicks to start of each note for a voice.
    global bufs_notes_end               # calculated clicks to end of each note for a voice.
    global bufs_notes_velocity          # The intensity of note start. (Typically the total volume. *sigh*)
    global bufs_cc_start                # [voice][cc#]      time in clicks when CC occurred.
    global bufs_cc_end                  # [voice][cc#]      CC when note stops occurred.
    global last_cc                      # If doing a note, the last_cc. NOTE: defaults for 7,10,11,64,68,91.

    a = r.split()
    if len(a) != 3:
        print_error(f'noteon line needs 3 arguments, not {len(a)} - {r}.')
        return
    # fi
    v = int(a[0])
    n = int(a[1])
    i = int(a[2])
    if i == 0:
        process_noteoff(r)
        return
    # fi
    if v > voices:
        voices = v
    # fi
    # Okay, we have the voice and the note, and calculated the current 'running_time'.

    # determine which real voice to use... if chords.
    flag = False
    print_debug(f'process_noteon - v={v}  bufs_notes_voices[v]={bufs_notes_voices[v]}')
    for v2s in bufs_notes_voices[v]:
        print_debug(f'process_noteon -    bufs_notes_start[v2s]={bufs_notes_start[v2s]} len()={len(bufs_notes_start[v2s])}')
        print_debug(f'process_noteon -    bufs_notes_end[v2s]={bufs_notes_end[v2s]} len()={len(bufs_notes_end[v2s])}')
        if v2s in bufs_notes_end and len(bufs_notes_end[v2s]) > 0 and bufs_notes_end[v2s][-1] == 0:
            continue
        # fi
        flag = v2s
        break
    # rof
    if flag is False:                                   # Need a new voice for chord.
        voices = voices + 1
        bufs_notes_voices[v].append(voices)
        v2s = voices
        print_debug(f'process_noteon - New Voice-CHORD: v2s={v2s}  bufs_notes_voices[v]={bufs_notes_voices[v]}')
    # fi

    bufs_notes[v2s].append(n)
    bufs_notes_start[v2s].append(running_time)          # Starting time for note.
    bufs_notes_end[v2s].append(0)                       # No ending time note.
    bufs_notes_velocity[v2s].append(i)                  # Note start intensity volume level.
    for cc in range(0, 127):
        bufs_cc_start[v2s][cc].append(last_cc[v][cc])
        bufs_cc_end[v2s][cc].append(0)
    # rof

    print_debug_internal_1(f'{linecount} - after - {array_of_original_lines[-1]}')

# End of process_noteon

# -----------------------------------------------------------------------------
def process_noteoff(r):
    global voices

    a = r.split()
    if len(a) != 3:
        print_error(f'noteoff line needs 3 arguments, not {len(a)} - {r}.')
        return
    # fi
    v = int(a[0])
    n = int(a[1])
    i = int(a[2])
    if v > voices:
        print_error(f'noteoff line for voice not already turned on/defined.')
        return
    # fi
    if i != 0:
        print_error(f'noteoff line for voice does not turn off note?')
        return
    # fi
    # Okay, we have the voice and the note, and calculated the current 'running_time'.
    # determine which real voice to use... if chords.
    flag = False
    for v2s in bufs_notes_voices[v]:
        if n == bufs_notes[v2s][-1]:
            flag = v2s
            break
    # rof
    if flag is False:                                   # Need a new voice for chord.
        print_error(f'noteoff line for voice not already playing.')
        return
    # fi

    bufs_notes_end[v2s][-1] = running_time
    for cc in range(0, 127):
        bufs_cc_end[v2s][cc][-1] = last_cc[v][cc]
    # rof

    print_debug_internal_1(f'{linecount} - after - {array_of_original_lines[-1]}')

# End of process_noteoff

# -----------------------------------------------------------------------------
def process_sleep(r):
    global tempo_s
    global tempo_l
    global running_time

# Want note length value.
    v1= float(r) * 1000
    v2 = (v1 * MIDICLICKSPERQUARTER) / 1000
    v3 = v2 * ((tempo_s / 60) * (tempo_l * 4))
    v4 = v3 / 1000
    running_time = running_time + int(v4)
# End of process_sleep

# -----------------------------------------------------------------------------
def process_cc(r):
    global last_cc                      # If doing a note, the last_cc. NOTE: defaults for 7,10,11,64,68,91.
    global bufs_notes_voices            # Voices for chords on this voice.

    a = r.split()
    if len(a) != 3:
        print_error(f'cc line needs 3 arguments, not {len(a)} - {r}.')
        return
    # fi
    v = int(a[0])
    c = int(a[1])
    i = int(a[2])

    for v2s in bufs_notes_voices[v]:    # Do all voices for possible chords.
        last_cc[v2s][c] = i
    # rof
# End of process_cc

# -----------------------------------------------------------------------------
def process_note_lines(q):
    global voices                       # Number of voices

    print_debug(f'process_note_lines - "{q}"')
    if q[0] == 'noteon':
        process_noteon(q[1])
        return
    elif q[0] == 'echo':
        process_echo_lines(q[1])
        return
    elif q[0] == 'noteoff':
        process_noteoff(q[1])
        return
    elif q[0] == 'sleep':
        process_sleep(q[1])
        return
    elif q[0] == 'cc':
        process_cc(q[1])
        return
    else:
        print_error(f'NOTDONEYET - Unexpected command ({q[0]}) in FS input')
    # fi
    print_debug('NOTDONEYET - process_note_lines')
# End of process_note_lines

# ----------------------------------------------------------------------------
# Parse and process line.
#
# Need: # voices used.
#   'cc'                # Maximum = total.
#   'select'            # Maximum = total.
#   'prog' decoding.    # Maximum = total.
# Need: Standard header removed.
#   Deleted everything until first select/cc/prog. (Keep echos.)
# Need: meter.
#   echo "meter"  -> meter.
# Need: title.
#   echo "        -> title if before any select/cc/noteon. (Edit down by hand.)
#                 -> comment if after noteon.

def process_line(original_line):
    global array_of_original_lines
    global no_notes_yet

    qline = original_line
    array_of_original_lines.append(qline)

    if qline is None:
        print_error('Line is None -- bad input.')
        return True
    elif qline == 'quit':
        return True                     # Done with input file.
    elif qline == 'reset':
        return False                    # Ignore reset command
    elif qline == '':
        print_error('Line is empty -- bad input -- but keep going.')
        return False
    # fi
    q = qline.split(None, 1)            # Command, arguments.
    if len(q) <= 1:
        print_error(f'Line ({original_line}) must have a command and at least one argument, but keep going.')
        return False
    # fi
    if no_notes_yet:
        if q[0] != 'noteon':
            process_header_lines(q)
            return False
        else:
            no_notes_yet = False
        # fi
    # fi
    process_note_lines(q)
    return False
# End of process_line

# ----------------------------------------------------------------------------
# Get the next line, file, or macro.
# Return:
#   line        - the line without trailing spaces.
#   None        - if End of File.

def read_next_line():
    global args
    global linecount
    global which_in_filename
    global which_out_filename
    global input_file                   # File to read for input (default is use tty - stdin).
    global output_file                  # File to print to (default is sys.stdout).
    global errors_happened

    try:
        if input_file is not None:
            line = input_file.readline()
        else:
            if sys.stdin.isatty():
                if sys.platform == 'darwin':
                    input('input> ')
                    line = readline.get_line_buffer()
                else:
                    line = input('input> ')
                # fi
            else:
                line = sys.stdin.readline()
            # fi
        # fi
        if line is None or line == '':
            if errors_happened != 0:
                print_stderr(f'exiting with errors_happened={errors_happened}')
            # fi
            sys.exit(errors_happened)
        # fi
        linecount = linecount + 1
        if line:
            line = line.rstrip()                # trailing spaces gone.
            return line
        # fi
    except EOFError:
        pass            # print('Read gave EOF', file=sys.stderr, flush=True)
    except SystemExit:
        pass            # print('Read gave system exit', file=sys.stderr, flush=True)
    except KeyboardInterrupt:
        print_error('Read got keyboard interrupt')
    except:
        print_error('Read got a processing error')
        print_stderr('    ' + sys.exc_info()[0] + sys.exc_info)
    # yrt
    return None
# End of read_next_line

# ----------------------------------------------------------------------------
def readthefile():
    global linecount
    global args

    ifdone = False
    while not ifdone:                       # Read the file loop.
        line = read_next_line()
        if args.lines:
            print_stderr(f'linecount={linecount} line="{line}"')
        # fi
        if line is None:  # If end of file.
            return
        elif not line or len(line) <= 0 or line == '':
            continue
        # fi
        line = line.rstrip()
        if not line or len(line) <= 0 or line == '':
            continue
        # fi
        line = line.strip()
        if len(line) == 0:                                  # Ignore empty line.
            continue
        # fi
        ifdone = process_line(line)
    # elihw
    return
# End of readthefile

# ----------------------------------------------------------------------------
def print_debug_internal_1(stg):
    global voices
    global bufs_notes_voices
    global bufs_notes
    global bufs_notes_start
    global bufs_notes_end
    global bufs_notes_velocity
    global bufs_cc_start
    global bufs_cc_end

    for v in range(0,voices+1):        # Voices if multiple turned on, run to alternative.
        print_debug(f'{stg}: bufs_notes_voices[{v}]={bufs_notes_voices[v]}')
        # rof
        for n in range(0, len(bufs_notes[v])):
            print_debug(f'    {bufs_notes[v][n]:2} {bufs_notes_velocity[v][n]:3} {bufs_notes_start[v][n]:7} {bufs_notes_end[v][n]:7} cc7={bufs_cc_start[v][7][n]:3}-{bufs_cc_end[v][7][n]:3} cc10={bufs_cc_start[v][10][n]:3}-{bufs_cc_end[v][10][n]:3} cc11={bufs_cc_start[v][11][n]:3}-{bufs_cc_end[v][11][n]:3} cc64={bufs_cc_start[v][64][n]:3}-{bufs_cc_end[v][64][n]:3} cc65={bufs_cc_start[v][65][n]:3}-{bufs_cc_end[v][65][n]:3} cc91={bufs_cc_start[v][91][n]:3}-{bufs_cc_end[v][91][n]:3}')
        # rof
    # rof
# End of print_debug_internal_1

# ----------------------------------------------------------------------------
# Main program follows.
def main():
    global args
    global which_in_filename
    global which_out_filename
    global which_hint_filename
    global input_file                   # File to read for input (default is use tty - stdin).
    global output_file                  # File to print to (default is sys.stdout).
    global hint_file                    # File to print to (default is None).
    global array_of_original_lines

    if args.rest:
        if len(args.rest) >= 1:             # Input.
            which_file_in = args.rest[0]
            input_file = open(which_file_in, 'r')
        # fi
        if len(args.rest) >= 2:             # Output.
            which_file_out = args.rest[1]
            output_file = open(args.rest[1], 'w')
        # fi
        if len(args.rest) >= 3:             # Hint.
            which_file_hint = args.rest[2]
            hint_file = open(args.rest[2], 'r')
        # fi
        if len(args.rest) > 3:              # Too many.
            print_error(f'Too many arguments, input, output, hint only. {args.rest}')
            if errors_happened != 0:
                print_stderr(f'exiting with errors_happened={errors_happened}')
            # fi
            sys.exit(1)
        # fi
    # fi

    readthefile()

    print_debug_internal_1('DONE')

    for i in array_of_original_lines:
        print_output(i)
    # rof

#__     get_fluidsynth_header()
#__     convert_file_to_gcs()

#--     print_out_fluidsynth()
    return
# End of main

# ----------------------------------------------------------------------------
if __name__ == '__main__':
    main()
# fi
# ----------------------------------------------------------------------------
if errors_happened != 0:
    print_stderr(f'exiting with errors_happened={errors_happened}')
# fi
sys.exit(errors_happened)
# ----------------------------------------------------------------------------
# End of program fs2gcs
# ----------------------------------------------------------------------------
