#!/usr/bin/python3 -B
# ----------------------------------------------------------------------------
# vim: tabstop=8 expandtab shiftwidth=4 softtabstop=4
# ----------------------------------------------------------------------------
import argparse
import os
import re
import readline
import sys
# ----------------------------------------------------------------------------
global errors_happened
errors_happened = 0
# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
global which_file_in
which_file_in = 'stdin'
global linecount
linecount = 0
global which_file_out
which_file_out = 'stdout'
global which_file_hint
which_file_hint = 'None'
# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
global input_file                   # File to read for input (default is use tty - stdin).
input_file = None
global output_file                  # File to print to (default is sys.stdout).
output_file = sys.stdout
global hint_file                    # File to print to (default is None).
hint_file = None
# ----------------------------------------------------------------------------
def print_stderr(strg):
    print(strg, file=sys.stderr, flush=True)
    return
# End of print_stderr

# ----------------------------------------------------------------------------
def print_debug(strg):
    print_stderr('DEBUG - ' + strg)
    return
# End of print_debug

# ----------------------------------------------------------------------------
def print_error(strg):
    print_stderr('ERROR - ' + strg)
    return
# End of print_error

# ----------------------------------------------------------------------------
def print_output(strg):
    global output_file

    print(strg.rstrip(), file=output_file, flush=True)
    return
# End of print_output

# ----------------------------------------------------------------------------
# NOTDONEYET - gcs output.
#-- def print_gcs(strg):
#--     global array_of_gcs
#-- 
#-- # TO DO: below is wrong.
#--     if len(array_of_gcs) > 0:
#--         last = array_of_gcs[-1]
#--         if last[0:6] == 'sleep ' and strg[0:6] == 'sleep ':
#--             new_time1 = float(last[6:])
#--             new_time2 = float(strg[6:])
#--             array_of_gcs[-1] = f'sleep {(new_time1 + new_time2):.3f}'
#--             return
#--         elif last == strg:                          # Delete duplicates.
#--             return
#--         # fi
#--     # fi
#--     array_of_gcs.append(strg)
#--     return
#-- # End of print_gcs

# ----------------------------------------------------------------------------
global args

# ----------------------------------------------------------------------------
def parse_args():
    global args

    parser = argparse.ArgumentParser(
        description=__doc__,
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog='this is the epilog')
    parser.add_argument('--lines', '-lines', action='store_true',
                        help='Print each line as it is read from file or macro or loop.')
    parser.add_argument('rest', nargs='*',
                        help='Optionals: inputfile(stdin) outputfile(stdout) hintfile(none)')
    args = parser.parse_args()
    return
# End of parse_args

# ----------------------------------------------------------------------------
parse_args()

# ----------------------------------------------------------------------------
global voices                       # Number of voices
voices = 1
global measure
measure = 1                         # Start measure at number 1.
global MIDICLICKSPERQUARTER
MIDICLICKSPERQUARTER = 480.0
global tempo_s                      # 60 beats per quarter note.
tempo_s = 60
global tempo_l
tempo_l = 0.25
# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
global no_notes_yet
no_notes_yet = True
# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
global titles
titles = ''
global comments
comments = ''
global key_default
key_default = None
global meter_default
meter_default = None
global key_previous
key_previous = None
global meter_previous
meter_previous = None
global instrument_bank          # Indexed by voice number.
instrument_bank = {}
global instrument_number        # Indexed by voice number.
instrument_number = {}
# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
global measures_length              # The length of measure (by voice).
measures_length = {}                # measures_length[m][v] = floating_number
global bufs_notes                   # Midi note number. An array indexed by measure, voice.
bufs_notes = {}                     # bufs_notes[m][v] = []             Midi note number.
global bufs_notes_length            # length of this note. An array indexed by measure.
bufs_notes_length = {}              # bufs_notes_length[m][v] = []      Added to by multiple sleeps.
global bufs_tie                     # If this note is tied to next measure. An array indexed by measure.
bufs_tie = {}                       # bufs_tie[m][v] = []               True/False
global bufs_velocity                # Velocity for this note.
bufs_velocity = {}                  # bufs_velocity[m][v] = []          0-127
global bufs_cc_10                   # Volume for this note.
bufs_cc_10 = {}                     # bufs_cc_10[m][v] = []             0-127
global bufs_cc_10_cresc             # If volume is cresc/dimin for this note.
bufs_cc_10_cresc = {}               # bufs_cc_10_cresc[m][v] = []       True/False
global bufs_cc_7                    # Intensity for this note.
bufs_cc_7 = {}                      # bufs_cc_7[m][v] = []              0-127
global bufs_cc_7_cresc              # If volume is cresc/dimin for this note.
bufs_cc_7_cresc = {}                # bufs_cc_7_cresc[m][v] = []        True/False
# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
global array_of_original_lines      # For input, have an array of the original lines.
array_of_original_lines = []
# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
# NOTDONEYET - gcs output.
#-- global array_of_gcs                 # For gcs first pass output.
#-- array_of_gcs = []
# ----------------------------------------------------------------------------
#-- # Following does not do multiple sharps or flats, but that is crazy anyway. Neither naturals.
#-- global key_sig
#-- key_sig = { 'c+':7, 'f+':6, 'b':5, 'bn':5, 'e':4, 'en':4, 'a':3, 'an':3, 'd':2,
#--             'dn':2, 'g':1, 'gn':1, 'c':0, 'cn':0, 'f':-1, 'b-':-2, 'e-':-3,
#--             'a-':-4, 'd-':-5, 'g-':-6, 'c-':-7 }
#-- 
#-- global key_sig_int
#-- key_sig_int = {}
#-- for i in key_sig:
#--     if key_sig[i] not in key_sig_int:
#--         key_sig_int[key_sig[i]] = i
#--     # fi
#-- # rof
#-- 
# ----------------------------------------------------------------------------
# FF 58 04 nn dd cc bb Time Signature
# The time signature is expressed as four numbers. nn and dd represent the numerator
# and denominator of the time signature as it would be notated. The denominator
# is a negative power of two: 2 represents a quarter-note, 3 represents an eighth-note,
# etc. The cc parameter expresses the number of MIDI clocks in a metronome click.
# The bb parameter expresses the number of notated 32nd-notes in a MIDI quarter-note
# (24 MIDI clocks). This was added because there are already multiple programs which
# allow a user to specify that what MIDI thinks of as a quarter-note (24 clocks) is
# to be notated as, or related to in terms of, something else.
# 
# Therefore, the complete event for 6/8 time, where the metronome clicks every three
# eighth-notes, but there are 24 clocks per quarter-note, 72 to the bar, would be (in hex):
#       FF 58 04 06 03 24 08
#                nn dd cc bb
# That is, 6/8 time (8 is 2 to the 3rd power, so this is 06 03), 36 MIDI clocks per
# dotted-quarter (24 hex!), and eight notated 32nd-notes per quarter-note. 
#    i.e. 2*32=1/16, 4*32=1/8, 8*32=1/4.  And a 1/4 note is 0x24 time deltas long.
# If the 8 was changed to 16, then a 1/2 note is 0x24 long. (0x24=36)

def meter_readable(strg):
    s = strg.split()
    if len(s) != 4:
        print_error(f'meter line does not have enough arguments, want 4, not {len(s)}.')
        return None
    # fi
    numerator = int(s[0])
    denominator = 2 ** int(s[1])
    return f'{numerator}/{denominator}'
# End of print_out_midi1csv_ts

# ----------------------------------------------------------------------------
def process_echo_lines(q):
    global voices
    global MIDICLICKSPERQUARTER
    global titles
    global meter_default
    global meter_previous
    global key_default
    global key_previous
    global comments
    global tempo_s
    global tempo_l

    print_debug(f'process_echo_lines - q="{q}"')
    if q[0:8] == '"Header ':
        if q[-1] != '"':
            print_error('Header line expected to end with a double quote')
            return
        # fi
        r = q[8:-1].split()
        voices = int(r[0])
        MIDICLICKSPERQUARTER = int(r[1])
        print_debug(f'process_echo_lines - Header: voices="{voices} MIDICLICKSPERQUARTER={MIDICLICKSPERQUARTER}"')
        return
    # fi
    if q[0:7] == '"Title ':
        titles += q[7:]
        print_debug(f'process_echo_lines - Title: titles="{titles}"')
        return
    # fi
    if q[0:7] == '"meter ':
        if meter_default is not None and meter_previous != q:
            print_error(f'Did not expect two meter lines - "{meter_previous}" verses "{q[0]}"')
            return
        # fi
        if q[-1] != '"':
            print_error('meter line expected to end with a double quote')
            return
        # fi
        meter_previous = q
        meter_default = meter_readable(q[7:-1])
        print_debug(f'process_echo_lines - meter: meter_previous="{meter_previous}" meter_default={meter_default}')
        return
    # fi
    if q[0:5] == '"key ':
        if key_default is not None and key_previous != q:
            print_error(f'Did not expect two key lines that did not match - "{key_previous}" verses "{q}"')
            return
        # fi
        a = q[5:].split(None)
        if len(a) < 2 or len(a) > 4:
            print_error(f'key line expects key followed by "major" not {a}')
            return
        elif a[1] != "'major'\"":
            print_error(f'key line expects "major" not {a[1]}')
            return
        # fi
        key_previous = q
        key_default = a[0]
        print_debug(f'process_echo_lines - key: key_previous="{key_previous}" key_default={key_default}')
        return
    # fi
    if q[0:9] == '"tempo_s=':
# DEBUG - process_echo_lines - q=""tempo_s=150 tempo_l=0.25""
        print_debug(f'process_echo_lines - Starting tempo: tempo_s="{tempo_s}" tempo_l={tempo_l}')
        if q[-1] != '"':
            print_error('tempo_s line expected to end with a double quote')
            return
        # fi
        r = q[9:-1].split()
        tempo_s = int(r[0])
        if r[1][0:8] != 'tempo_l=':
            print_error(f'tempo_s line expects tempo_l not {r[1]}')
            return
        # fi
        tempo_l = float(r[1][8:])
        print_debug(f'process_echo_lines - Ending tempo: tempo_s="{tempo_s}" tempo_l={tempo_l}')
        return
    # fi
    comments += q
    print_debug(f'process_echo_lines - comments: comments="{comments}"')
    return
# End of process_echo_lines

# ----------------------------------------------------------------------------
global header_commands_ignore
header_commands_ignore = [ 'set', 'unload', 'load', 'reset', 'prog', 'sleep', 'pitch_bend' ]

def process_header_lines(q):
    global header_commands_ignore
    global instrument_bank
    global instrument_number

    print_debug(f'process_header_lines - q="{q}"')
    if q[0] in header_commands_ignore:
        return
    elif q[0] == 'echo':
        process_echo_lines(q[1])
    elif q[0] == 'select':
        a = q[1].split()
        if len(a) < 1 or len(a) > 4:
            print_error(f'select line wants 4 arguments not {len(a)} - {q[1]}')
            return
        # fi
        # a[0] = voice #
        # a[1] = timeclicks
        # a[2] = bank
        # a[3] = instrument
        vn = int(a[0])
        ibank = int(a[2])
        instr = int(a[3])
        if vn in instrument_bank:
            if instrument_bank[vn] != ibank or instrument_number[vn] != instr:
                print_error(f'select line for voice {vn} does not match previous bank {instrument_bank[vn]} instrument {instrument_number[vn]}')
                return
            # fi
            return
        # fi
        instrument_bank[vn] = ibank
        instrument_number[vn] = instr
        return
    else:
        print_error(f'Line is unexpected - {q}')
    # fi
    return
# End of process_header_lines

# ----------------------------------------------------------------------------
#--             elif strg[0:5] == 'echo ':           # echo 'measure xxx'
#--                 if strg[0:6] == 'echo "':
#--                     print_fs(f'{strg}')
#--                 elif strg != fs_other_echo:
#--                     strg1 = strg.replace('"', "'")
#--                     if strg1[0:11] == 'echo meter ':
#-- #--                         print_fs(f'echo "meter {meter_readable(strg1[11:])}"')
#--                         print_fs(f'echo "meter {strg1[11:]}"')
#--                     elif strg1[0:9] == 'echo key ':
#--                         x = strg1[9:]
#--                         y = x.split(' ', 1)          # Key number.
#--                         x = y[1]
#--                         y = int(y[0].replace(',', '').strip())
#--                         if y in key_sig_int:
#--                             y = key_sig_int[y].upper()
#--                         # fi
#--                         print_fs(f'echo "key {y} {x}"')
#--                     elif strg1[0:13] == 'echo Title_t ':
#--                         print_fs(f'echo "Title {strg1[13:]}"')
#--                     elif strg != fs_other_echo:
#--                         print_fs(f'echo "{strg1[5:]}"')
#--                     # fi
#--                     fs_other_echo = strg
#--                 # fi
#--             elif strg[0:3] == 'cc ':
#--                 break
#--             elif strg[0:8] == 'noteoff ':
#--                 h = strg[8:].split(', ')
#--                 break
#--             elif strg[0:7] == 'noteon ':
#--                 h = strg[7:].split(', ')
#--                 break
#--             # fi

# ----------------------------------------------------------------------------
#-- global voices                       # Number of voices
#-- voices = 1
#-- # . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
#-- global measure
#-- measure = 1                         # Start measure at number 1.
#-- # . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
#-- global measures_length              # The length of measure (by voice).
#-- measures_length = {}                # measures_length[m][v] = floating_number
#-- global bufs_notes                   # Midi note number. An array indexed by measure, voice.
#-- bufs_notes = {}                     # bufs_notes[m][v] = []             Midi note number.
#-- global bufs_notes_length            # length of this note. An array indexed by measure.
#-- bufs_notes_length = {}              # bufs_notes_length[m][v] = []      Added to by multiple sleeps.
#-- global bufs_tie                     # If this note is tied to next measure. An array indexed by measure.
#-- bufs_tie = {}                       # bufs_tie[m][v] = []               True/False
#-- global bufs_velocity                # Velocity for this note.
#-- bufs_velocity = {}                  # bufs_velocity[m][v] = []          0-127
#-- global bufs_cc_10                   # Volume for this note.
#-- bufs_cc_10 = {}                     # bufs_cc_10[m][v] = []             0-127
#-- global bufs_cc_10_cresc             # If volume is cresc/dimin for this note.
#-- bufs_cc_10_cresc = {}               # bufs_cc_10_cresc[m][v] = []       True/False
#-- global bufs_cc_7                    # Intensity for this note.
#-- bufs_cc_7 = {}                      # bufs_cc_7[m][v] = []              0-127
#-- global bufs_cc_7_cresc              # If volume is cresc/dimin for this note.
#-- bufs_cc_7_cresc = {}                # bufs_cc_7_cresc[m][v] = []        True/False
# -----------------------------------------------------------------------------
def process_noteon(r):
    global voices

    a = r.split()
    if len(a) != 3:
        print_error(f'noteon line needs 3 arguments, not {len(a)} - {r}.')
        return
    # fi
    if a[2] == 0:
        process_noteoff(r)
        return
    # fi
    if int(a[0]) > voices:
        voices = int(a[0])
    # fi
    # Okay, we have the voice and the note, and somehow calculated the current 'time'.
    # We need the time of various notes.
    # Check if note is already on, if so, then need new voice created for instrument/etc.
    #   and then turn note on. Fun in noteoff. :)
#++    print_die('NOTDONEYET - noteon')
# End of process_noteon

# -----------------------------------------------------------------------------
def process_noteoff(r):
    a = r[1].split()
    if len(a) != 3:
        print_error(f'noteoff line needs 3 arguments, not {len(a)} - {r}.')
        return
    # fi
    if a[0] > voices:
        voices = v[0]
    # fi
    print_die('NOTDONEYET - noteoff')
# End of process_noteoff

# -----------------------------------------------------------------------------
def process_sleep(r):
    global tempo_s
    global tempo_l

#--     if current_time >= 0 and (min_next - current_time) != 0:
#--         ms_1000 = float(min_next - current_time)
#--         if ms_1000 < default_little_time:
#--             ms_1000 = default_little_time
#--         else:
#--             # 480 => 250
#--             ms_1000 = ms_1000 * 1000.0
#--             ms_1000 = ms_1000 / ((float(tempo_s)/60.0) * (float(tempo_l) * 4.0))
#--             ms_1000 = int((ms_1000 / MIDICLICKSPERQUARTER) * 1000)
#--             ms_1000 = float(ms_1000) / 1000.0
#--         # fi
#--         print_fs(f'sleep {ms_1000}')
#--     # fi
#   r = sleep value.
# Want note length value.
    v1= float(r) * 1000
    print_debug(f'v1={v1} = {r}*1000')
    v2 = (v1 * MIDICLICKSPERQUARTER) / 1000
    print_debug(f'v2={v2} = ({v1} * {MIDICLICKSPERQUARTER}) / 1000')
    v3 = v2 * ((tempo_s / 60) * (tempo_l * 4))
    print_debug(f'v3={v3} = {v2} * (({tempo_s} / 60) * ({tempo_l} * 4))')
    v4 = v3 / 1000
    print_debug(f'v4={v4} = {v3} / 1000')

    print_die('NOTDONEYET - sleep')
# End of process_sleep

# DEBUG - process_echo_lines - Header: voices="2 MIDICLICKSPERQUARTER=480"
# DEBUG - process_echo_lines - q=""tempo_s=150 tempo_l=0.25""
# DEBUG - process_echo_lines - comments: comments=""tempo_s=150 tempo_l=0.25""
# DEBUG - process_header_lines - q="['echo', '"meter 1 2 48 8"']"
# DEBUG - process_echo_lines - q=""meter 1 2 48 8""
# DEBUG - process_echo_lines - meter: meter_previous=""meter 1 2 48 8"" meter_default=1/4
# DEBUG - process_header_lines - q="['select', '0 1 0 73']"
# DEBUG - process_note_lines - "['noteon', '0 74 95']"
# DEBUG - process_note_lines - "['sleep', '400.000']"
# DEBUG - v1=400000.0 = 400.000*1000
# DEBUG - v2=192000.0 = (400000.0 * 480) / 1000
# DEBUG - v3=192000.0 = 192000.0 * ((60 / 60) * (0.25 * 4))
# DEBUG - v4=192.0 = 192000.0 / 1000
# -----------------------------------------------------------------------------
def process_cc(r):
    print_die('NOTDONEYET - cc')
# End of process_sleep

# -----------------------------------------------------------------------------
def process_note_lines(q):
    global voices                       # Number of voices

    print_debug(f'process_note_lines - "{q}"')
    if q[0] == 'noteon':
        process_noteon(q[1])
        return
    elif q[0] == 'echo':
        process_noteon(q[1])
        return
    elif q[0] == 'noteoff':
        process_noteoff(q[1])
        return
    elif q[0] == 'sleep':
        process_sleep(q[1])
        return
    elif q[0] == 'cc':
        process_cc(q[1])
        return
    else:
        print_error(f'NOTDONEYET - Unexpected command ({q[0]}) in FS input')
    # fi
    print_die('NOTDONEYET - process_note_lines')
# End of process_note_lines

# ----------------------------------------------------------------------------
# Parse and process line.
#
# Need: # voices used.
#   'cc'                # Maximum = total.
#   'select'            # Maximum = total.
#   'prog' decoding.    # Maximum = total.
# Need: Standard header removed.
#   Deleted everything until first select/cc/prog. (Keep echos.)
# Need: meter.
#   echo "meter"  -> meter.
# Need: title.
#   echo "        -> title if before any select/cc/noteon. (Edit down by hand.)
#                 -> comment if after noteon.

def process_line(original_line):
    global array_of_original_lines
    global no_notes_yet

    qline = original_line
    array_of_original_lines.append(qline)

    if qline is None:
        print_error('Line is None -- bad input.')
        return True
    elif qline == 'quit':
        return True                     # Done with input file.
    elif qline == 'reset':
        return False                    # Ignore reset command
    elif qline == '':
        print_error('Line is empty -- bad input -- but keep going.')
        return False
    # fi
    q = qline.split(None, 1)            # Command, arguments.
    if len(q) <= 1:
        print_error(f'Line ({original_line}) must have a command and at least one argument, but keep going.')
        return False
    # fi
    if no_notes_yet:
        if q[0] != 'noteon':
            process_header_lines(q)
            return False
        else:
            no_notes_yet = False
        # fi
    # fi
    process_note_lines(q)
    return False
# End of process_line

# ----------------------------------------------------------------------------
# Get the next line, file, or macro.
# Return:
#   line        - the line without trailing spaces.
#   None        - if End of File.

def read_next_line():
    global args
    global linecount
    global which_in_filename
    global which_out_filename
    global input_file                   # File to read for input (default is use tty - stdin).
    global output_file                  # File to print to (default is sys.stdout).
    global errors_happened

    try:
        if input_file is not None:
            line = input_file.readline()
        else:
            if sys.stdin.isatty():
                if sys.platform == 'darwin':
                    input('input> ')
                    line = readline.get_line_buffer()
                else:
                    line = input('input> ')
                # fi
            else:
                line = sys.stdin.readline()
            # fi
        # fi
        if line is None or line == '':
            sys.exit(errors_happened)
        # fi
        linecount = linecount + 1
        if line:
            line = line.rstrip()                # trailing spaces gone.
            return line
        # fi
    except EOFError:
        pass            # print('Read gave EOF', file=sys.stderr, flush=True)
    except SystemExit:
        pass            # print('Read gave system exit', file=sys.stderr, flush=True)
    except KeyboardInterrupt:
        print_error('Read got keyboard interrupt')
    except:
        print_error('Read got a processing error')
        print_stderr('    ' + sys.exc_info()[0] + sys.exc_info)
    # yrt
    return None
# End of read_next_line

# ----------------------------------------------------------------------------
def readthefile():
    global linecount
    global args

    ifdone = False
    while not ifdone:                       # Read the file loop.
        line = read_next_line()
        if args.lines:
            print_stderr(f'linecount={linecount} line="{line}"')
        # fi
        if line is None:  # If end of file.
            return
        elif not line or len(line) <= 0 or line == '':
            continue
        # fi
        line = line.rstrip()
        if not line or len(line) <= 0 or line == '':
            continue
        # fi
        line = line.strip()
        if len(line) == 0:                                  # Ignore empty line.
            continue
        # fi
        ifdone = process_line(line)
    # elihw
    return
# End of readthefile

# ----------------------------------------------------------------------------
# Main program follows.
def main():
    global args
    global which_in_filename
    global which_out_filename
    global which_hint_filename
    global input_file                   # File to read for input (default is use tty - stdin).
    global output_file                  # File to print to (default is sys.stdout).
    global hint_file                    # File to print to (default is None).
    global array_of_original_lines

    if args.rest:
        if len(args.rest) >= 1:             # Input.
            which_file_in = args.rest[0]
            input_file = open(which_file_in, 'r')
        # fi
        if len(args.rest) >= 2:             # Output.
            which_file_out = args.rest[1]
            output_file = open(args.rest[1], 'w')
        # fi
        if len(args.rest) >= 3:             # Hint.
            which_file_hint = args.rest[2]
            hint_file = open(args.rest[2], 'r')
        # fi
        if len(args.rest) > 3:              # Too many.
            print_error(f'Too many arguments, input, output, hint only. {args.rest}')
            sys.exit(1)
        # fi
    # fi

    readthefile()

    for i in array_of_original_lines:
        print_output(i)
    # rof

#__     get_fluidsynth_header()
#__     convert_file_to_gcs()

#--     print_out_fluidsynth()
    return
# End of main

# ----------------------------------------------------------------------------
if __name__ == '__main__':
    main()
# fi
# ----------------------------------------------------------------------------
sys.exit(errors_happened)
# ----------------------------------------------------------------------------
# End of program fs2gcs
# ----------------------------------------------------------------------------
