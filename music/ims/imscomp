#!/usr/bin/python3 -B
# ----------------------------------------------------------------------------
# vim: tabstop=8 expandtab shiftwidth=4 softtabstop=4
# ----------------------------------------------------------------------------
# TO DO:            2022-12-31_18-08-00
# Put page into --vertical and --horizontal, and some comments are not printed out.
# Variables to do:
#       accent, aaccent, arp, fermata, ferma, stac, marc
# ----------------------------------------------------------------------------
# TO DO:
# 1) vol(sf,0.25)    -- optional 2nd argument for length of sf.
#    vol(fp,0.25)    -- optional 2nd argument for length of "f" before returning to "p".
# 2) b-6 ... some 1/2 notes that are vol(sf) -- should they be shortened per above?
# 3) --fluidsynth input of a .csv file -- MIDI_port commands -- WTF?
# 4) vol(sfp) -- how long for s and then switching to p? Example tied whole note over 3 measures.
# 5) ppppp and fffff as lilypond.
# 6) lilypond output for printing.
# ----------------------------------------------------------------------------
# TODO:
# 1) Select clef=treble or clef=bass by notes min and max notes on staff(s).
#       # NOTDONEYET - add ' clef=bass'  (after the number)
#       # clef can occur each measure (abc, horizontal, vertical format).
# 2) --vertical and --horizontal: Can save comments on measures? Lines? Like before measures? * ------
# 3) -- accelerando -- basically tempo change over time.
#       My idea is to speed up over time -- perhaps by calculating it each time reference in --fs or --midi.
#       Specify it as 3rd argument to tempo?
#       tempo 150,4,#whole-note...    Like 20.75. (Value used on crescendo.)
#           Note: another pass?  So that volume changes are already done?
#                 Perhaps output fluidsynth intermediate, and with tempo & time. Run through changing sleeps.
#                 --midi ... hmmm. Same thing?
# ----------------------------------------------------------------------------
# TO DO: Need to put out intensity values when they change. (Like cc 11 -> vol(xx).)
#   a) > Accent over a note.
#       ABC notation:   !>!                    accent (> mark)
#                       !accent!               same as !>!
#                       !emphasis!             same as !>!
#       L       accent or emphasis - shorthand for !>!
#   b) ^ Marcato over note.
#       ABC notation:   !^!                    marcato (inverted V)
#                       !marcato!              same as !^!
#   c) _ Tenuto over note.
#       !tenuto!        tenuto (hold note for full duration)
#   d) fermata over note.
#       ABC notation:   !fermata!               Fermata, or hold
#       H       fermata - shorthand for !fermata!
#
# Articulation marks.
#   Staccato    Period (.) over note.
# This indicates that the note should be played shorter than notated, usually half the value,
# leaving the rest of the metric value silent. Staccato marks may appear on notes of any value,
# shortening their performed duration without speeding up the music.
#
#  Filled in v over note -  Staccatissimo or Spiccato
# This indicates that the note should be played even shorter than staccato. It is usually
# applied to quarter notes or shorter notes. In the past this marking's meaning was more
# ambiguous it was sometimes used interchangeably with staccato and sometimes indicated
# an accent and not a shortened note. These usages are now almost defunct but still appear
# in some scores. For string instruments this indicates a bowing technique in which the
# bow bounces lightly upon the string.
#
#   Tenuto              - Line over note.
# This symbol indicates that the note should be played at its full value, or slightly
# longer. It can also indicate a degree of emphasis, especially when combined with dynamic
# markings to indicate a change in loudness, or combined with a staccato dot to indicate a
# slight detachment (portato or mezzo staccato). In percussion notation, this sign
# indicates a slight accent.
#
#   Fermata or Pause    - top 1/2 of circle over a period
# A fermata indicates that a note, chord, or rest is sustained longer than its written
# value. It will usually appear on all parts in an ensemble. The fermata is held for as
# long as the performer or conductor desires.
#
#   Accent              > over note.
# An accent indicates that a note should be played louder, or with a harder attack than
# surrounding unaccented notes. It may appear on notes of any duration.
#
#   Marcato             ^ over note.
# A marcato marking indicates that the note should be played louder or more forcefully than
# a note with a regular accent mark. In organ notation, this sign often does not indicate
# marcato when in the pedal stave otherwise it still does, but instead that a pedal note
# should be played with the toe. When printed above the note it indicates the right foot's
# toe, and below the note indicates the left foot's toe.
# ----------------------------------------------------------------------------
# Document: trills, legato on time means last note is legato.
# If no l on time, last note is unset if legato on note itself.
# i.e. t(3cl,3el,8)4   -> last 3e does not have legato set.
#      t(3cl,3el,8)4l  -> last 3e has legato set (which goes to next note).
# ----------------------------------------------------------------------------
# ./musicomp --midi1csv song.gcs song.csv   # Output midi1csv format.
# ./musicomp song.gcs song.abc              # Output ABC format.
# ./musicomp --vertical song.gcs song.v     # Either v or h (or mixed) input, vertical output.
# ./musicomp --horizontal song.gcs song.h   # Either v or h (or mixed) input, horizontal output.
# ./musicomp --fluidsynth song.gcs song.fs  # Input to fluidsynth.
# ./musicomp --fluidsynth song.csv song.fs  # Input can be CSV file, output can ONLY be fluidsynth.
# ----------------------------------------------------------------------------
# NOTDONEYET - Note processing:
#   print_error("NOTDONEYET - doing gsw_operand type of note", line)    - Not related to MIDI.
#   print_error("NOTDONEYET - do_temper", line)     -- no real need for this?
#   print_error("NOTDONEYET - do_sharp", line)      -- no real need for this?
#   print_error("NOTDONEYET - do_flat", line)       -- no real need for this?
#   print_error("NOTDONEYET - do_natural", line)    -- no real need for this?
# ----------------------------------------------------------------------------
# Note: Do not have blank lines in the file. Somehow python's readline() does
# not return them. Yeah, insanity.
# ----------------------------------------------------------------------------
# --fluidsynth.  2022-06-06
# MIDI channel is limited to 4 bits. 10 is reserved for drums.
# Thus, cannot have more than 0,1,2,3,4,5,6,7,8,9,11,12,13,14,15 (total 15).
# Cannot use the MIDI file format. MIDI 2.0 has no file format yet.
# ----------------------------------------------------------------------------
# A) To import an ABC into musescore, use the plugin "ABC Import".
#    Move "X:1" to the top of the file, before any other lines. The '%' confuses it.
# ----------------------------------------------------------------------------
# B) To export from musescore:
#     1) File->Export as MusicXML compressed (suffix .mxl).
#     2) Then use program 'xml2abc my.mxl > my.abc' to convert it to abc format.
# ----------------------------------------------------------------------------
# For youtube you need a video.
#       You need a .wav first.
#       You cannot get a .wav from fluidsynth input mode.
#       Thus capture audio via soundflower. OR blackhole.
# B) To grab from Blackhole. (Install it already. Reboot not needed.)
#     1) Open Preferences, then select Sound.
#     2) Select Output as BlackHole 2ch.
#     3) Recommend setting Sound Effects through External Headphones or Mac's default speakers.
#     4) Open audacity.
#        a) Audio Setup
#           A) Playback Device -> headphones or internal speakers.
#           B) Recording Device -> Blackhole 2ch.
#           C) Recording Channels -> 2 (Stereo) Recording Channels
#        b) Select Record to start.
#        c) Start fluidsynth playing.
#        d) When finished, press Record again to stop it.
#        e) Trim beginning and end of recording. (Command-X to cut ... if it works...)
#        f) Select everything, Command-A. Menu: Effect->Volume and Compression->Amplify
#           Amplification (dB): 7.042
#           Apply.
#        g) Save project (in case you need it again).
#        h) File -> Export -> Export as WAV.
#        i) Go to iMovie ("Convert .wav file to mp4) - below.
# C) To grab from soundflower:
#     1) Make sure it is downloaded.
#     2) In "sound preferences->Output", select "Soundflower (2ch)".
#        Undo by selecting Headphones or Internal Speakers, etc.
#     3) Capture output via: QuickTime Player (or garageband -- dunno about last :) ).
#     4) New->Audio Audio Recording
#     5) Red record button when ready to record.
#     6) sleep 5; fluidsynth ...
#        Or: Open music playing program, and ready to "Start".
#     7) Click to get into quicktime, then press record.
#     8) click back to window for playing, start it.
#     9) When finished, click on quicktime and press record button again to stop it.
#        The "<<  >  >>" for playing it opens up.
#     10) If you save it, it saves it as a .aifc file. If you "Export as audio" it, it is an .m4a type file.
# Convert to .wav file.
#     1) Start audacity. File->Open ... select file of type: (aifc,m4a,wav, ...).
#     2) Select blank starting to delete. Press sissors to cut away. Same with trailing/end of song.
#     3) Export as ... many types may be chosen.
# Convert .wav (etc.) file to mp4.
#     1) Open imovie. Should/might be on "My Media" (left column, top).
#     2) In lower left column (bottom, or iMovie Library), right click and select 'New Event'.
#     3) Enter name. Click on the name (if not already there).
#     4) Click on down arrow with label "Import Media". Opens new window to find/select media.
#     5) Find the audio to be used.
#     6) Drag and drop the picture to be used during play.
#     7) There will be two icons for audio and picture in the Media section.
#     8) Click on audio icon and drag it to the lower 1/2 of screen where it says to put them there. :)
#     9) Align the audio to the left.
#     10) Click on the picture icon and drag to lower, align to left.
#     11) A "drag bar" on right, drag it to end of audio. (So image displays for all of audio.)
#     12) In the upper right there is an arrow above/through a box -- meaning share if you hover over it.
#     13) Click and select "Export File". The Format should be "Video and Audio".
#     14) Probably reduce Resolution to 540, quality "Best (ProRes)", and Compress "Better Quality".
#     15) Click "Next..." at bottom right. Select name and where to store it. Do so.
#     16) There is a clock timer just to the left of the box with the uparrow. When it is filled in white... .
#     17) Done. Double click on file in Finder and QuickTime player will pop up to play it.
#     18) Can upload to youtube / facebook / dropbox now.
# ----------------------------------------------------------------------------
# measures and gotos may be calculations using "m1" type variables, but not
# any other alphanumeric characters.
# ----------------------------------------------------------------------------
# Accidentals - A tied note doesn't cause the accidental to be carried over so
# much as it indicates the duration of the note rather than the pitch. If a tied
# note is followed by another note on the same staff position the accidental
# will not carry into that note (a courtesy accidental would often be helpful).
#
# In most cases, a sharp raises the pitch of a note one semitone while a flat lowers
# it one semitone. A natural is used to cancel the effect of a flat or sharp. This
# system of accidentals operates in conjunction with the key signature, whose effect
# continues throughout an entire piece, unless canceled by another key signature.
# An accidental can also be used to cancel a previous accidental or reinstate the flats
# or sharps of the key signature.
#
# Accidentals apply to subsequent notes on the same staff position for the remainder
# of the measure where they occur, unless explicitly changed by another accidental.
# Once a barline is passed, the effect of the accidental ends, except when a note
# affected by an accidental is tied to the same note across a barline. Subsequent notes
# at the same staff position in the second or later bars are not affected by the
# accidental carried through with the tied note. NOTE: Octaves are independent.
# ............................................................................
# Courtesy accidentals - In modern scores, a barline cancels an accidental,
# with the exception of tied notes. Courtesy accidentals, also called cautionary
# accidentals or reminder accidentals are used to remind the musician of the
# correct pitch if the same note occurs in the following measure. The rules for
# applying courtesy accidentals (sometimes enclosed in parentheses) vary among
# publishers, though in a few situations they are customary:
#  - When the first note of a measure had an accidental in the previous measure.
#  - After a tie carries an accidental across a barline, and the same note
#    appears in the next measure.
#  - When a chord contains a diminished or augmented octave.
#  - When there is a cross relation with another part.
# ............................................................................
# While ties and phrasing slurs do look very similar, they are not the same thing at all.
# If the curved line is below the noteheads (written closest to the noteheads)
# and opposite the stems (if stems are ascending, the curved tie line is below;
# if stems are descending, the curved tie line is above).
#
# While the bar line cancels an accidental, the "Power of the Tie" is stronger.
#
#  - The composer would put a natural/flat/sharp on the second note of the tie.
#  - The composer would put the curved line above the stems, thus on OPPOSITE
#    side of the noteheads.
# (Remember - a curved line written closest to 2 noteheads in the same space or
# on the same line is a tie!)
# ----------------------------------------------------------------------------
# Additional note processing:
# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
# If the file format is in 'vertical' mode (i.e. 'v4: 3c8,3d8,3e8, 3f8,3g8'),
# Then for --abc format, the comma followed by a space means to separate the
# bars. (i.e. c,d,e have bar lines connected, and then there is a separation
# and lastly f and g have their bar lines connected.)
# This does not affect playing at all.
# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
# If a note's time (which may be optionally missing) is followed by a "l",
# then the note is legato (glided) to the next note. (i.e. there is no note
# attack section done when playing the note -- also considered slurred notes.)
# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
# vol(xxx) before a note sets volume for that note, and following notes ... .
# vol(sfp) before a note sets volume to f for that note only, and following p.
#   vol(p) 3c4, 3d4, vol(sfp) 3e4, 3f4, 3g4
#   (p,p,f,p,p)
# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
# cresc(xxx,yyy) xxx = ending volume. yyy = time (0.75 = three quarter notes).
# dimin(xxx,yyy) xxx = ending volume. yyy = time (0.75 = three quarter notes).
#   Like vol(), but does a volume change from present to xxx over time yyy.
# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
# Macro substitution during note processing.
# A line that looks like notes may use the macro whenever a complete note or
# vol(), cresc(),dimin() may appear. Example follows:
#   macro   abc,A,B,C
#      A4, B4
#      A8, C8
#   endm
#   measure 1
#   voice 2
#   0e4, 0g4
#   vol(ff) abc(1c,1e,1g) abc(2e,2c,2g) 3g4, vol(sf) 3a4
#
# The whole line is processed, left to right -- with the new lines from the
# macro inserted into place. NOTE: The "vol(ff)" refers to the next note in the
# line, but there is none, so it is tossed away. *NOTE*
#
# The first abc macro is done, then the second, then the two trailing notes.
# Correctly formatted line would have put the vol(ff) before the 3g4 (which
# would affect that note and subsequent for voice 1, but not the 2nd voice 3a4.
# vol(sf) affects the 3a4 and puts volume back to what it was before the "sf".
#
# This shows that no deliminators are used in substitution of arguments (all
# macros), and that intermixing of vertical 'v#:' format and horizontal format
# is allowed. Convert all to one type or the other via command line arguments:
# --horizontal or --vertical. (And it deletes macros too..., which may be useful
# when trying to figure out what a macro really did.)
#
#
# The above would then look like either:
#   measure 1
#   voice   2    0,0
#   v1: 0e4, 1c4, 1c8, 2e4, 2e8, 3g4
#   v2: 0g4, 1e4, 1g8, 2c4, 2g8, vol(sf) 3a4
# or:
#   voice   2    0,0
#      0e  4,  0g  4
#      1c  4,  1e  4
#      1c  8,  1g  8
#      2e  4,  2c  4
#      2e  8,  2g  8
#      3g  4,vol(sf) 3a  4
#
# If the second abc macro had been after 3g4, then there would be no second
# note for either 3g4 line (but comma would put in a r4 -- but the 3a4 would
# have been for voice 1 and without a second note for second voice, error!
#
#   vol(ff) abc(1c,1e,1g) 3g4, abc(2e,2c,2g) vol(sf) 3a4
#
# ./musicomp2abc --vert tv
#   ERROR - Not enough arguments on note line - want 2, have ['vol(sf)3a4']
#   Line 8 - vol(sf)3a4
#
# This shows that if not a command, spaces are eliminated for note processing.
# By the way, the arguments on the voice line for for instruments, 0=default.
# ----------------------------------------------------------------------------
# putd substitution lines are done in the order that they are defined. Once
# through the list, but only if '=' at start of line.
# ----------------------------------------------------------------------------
# xpose command is done for --vertical, --horizontal, and --midi1csv, but NOT abc format.
# ABC format thus will "print" right, but not "play" (abc2midi) right.
#       NOTDONEYET - so ABC format can print. NOTDONEYET - abc #
# ----------------------------------------------------------------------------
# instrument 1,2 flute            $$ voice, name or number.
#                                     v-- MIDI control number.
# intensity  1,2 84               $$  7 volume
# pan        1,2 8                $$ 10 pan
# reverb     1,2 52               $$ 91 Reverb level
# ----------------------------------------------------------------------------
#  10   Pan position   64 is center, 0 is hard left, and 127 is hard right.
#  Number: 10 (coarse) 42 (fine)
# Where within the stereo field the device's sound will be placed (assuming that it
# has stereo audio outputs). If a MultiTimbral device, then each Part usually has
# its own pan position. This is generally when Pan becomes useful, because then you
# can use Pan, Volume, and Balance controllers to internally mix all of the Parts to
# the device's stereo outputs. Pan should effect all notes on the channel, including
# notes that were triggered prior to pan message being received, and are still sustaining.
# 14-bit coarse/fine resolution. 16,384 possible positions, 0x0000 to 0x3FFF where 0x2000
# is center position, 0x0000 is hard left, and 0x3FFF is hard right. Some devices only
# respond to coarse adjust (128 positions) where 64 is center, 0 is hard left, and 127 is hard right.
# Note: Most all devices ignore the Fine adjust (#42) for Pan, and just implement Coarse
# adjust (#10) because 14-bit resolution isn't needed for this.
# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
# Expression, number 11 (course)
# Percentage of all playing instruments volume. 100% = all up.
# This is a percentage of Volume (ie, as set by Volume Controller). In other words,
# Expression divides the current volume into 16,384 steps (or 128 if 8-bit instead
# of 14-bit resolution is used). Volume Controller is used to set the overall volume
# of the entire musical part (on a given channel), whereas Expression is used for
# doing crescendos and decrescendos. By having both a master Volume and sub-Volume
# (ie, Expression), it makes possible to do crescendos and decrescendos without
# having to do algebraic calculations to maintain the relative balance between
# instruments. When Expression is at 100% (ie, the maximum of 0x3FFF), then the
# volume represents the true setting of Volume Controller. Lower values of
# Expression begin to subtract from the volume. When Expression is 0% (ie, 0x0000),
# then volume is off. When Expression is 50% (ie, 0x1FFF), then volume is cut in half.
#
# Here's how Expression is typically used. Let's assume only the coarse adjust is
# used (ie, #11) and therefore only 128 steps are possible. Set the Expression for
# every MIDI channel to one initial value, for example 100. This gives you some
# leeway to increase the expression percentage (ie, up to 127 which is 100%) or
# decrease it. Now, set the channel (ie, instrument) "mix" using Volume Controllers.
# Maybe you'll want the drums louder than the piano, so the former has a Volume
# Controller value of 110 whereas the latter has a value of 90, for example. Now if,
# at some point, you want to drop the volumes of both instruments to half of their
# current Main Volumes, then send Expression values of 64 (ie, 64 represents a 50%
# volume percentage since 64 is half of 128 steps). This would result in the drums
# now having an effective volume of 55 and piano having an effective volume of 45.
# If you wanted to drop the volumes to 25% of their current Main Volumes, then send
# Expression values of 32. This would result in the drums now having an effective
# volume of approximately 27 and piano having an effective volume of approximately
# 22. And yet, you haven't had to change their Volume settings, and therefore still
# maintain that relative mix between two instruments. So think of Volume Controllers
# as being the individual faders upon a mixing console. You set up the instrumental
# balance (ie, mix) using these values. Then you use Expression Controllers as
# "group faders", whereby you can increase or decrease the volumes of one or more
# tracks without upsetting the relative balance between them.
# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
# Can use legato for slur between notes -- i.e. no attack.
# Legato Pedal, Number: 68
# When on, this causes a legato effect between notes, which is usually achieved by
# skipping the attack portion of the VCA's envelope. Use of this controller allows
# a keyboard player to better simulate the phrasing of wind and brass players, who
# often play several notes with a single tonguing, or simulate guitar pull-offs and
# hammer-ons (ie, where secondary notes are not picked). If a MultiTimbral device,
# then each Part usually has its own Legato Pedal setting.
# Value Range: 0 (to 63) is off. 127 (to 64) is on.
# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
#  91   Reverb Level - Affects: this is usually the reverb or delay level.
#       If a MultiTimbral device, then each Part usually has its own effects level.
# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
# Tremulo Level, Number: 92
# The tremulo amount (ie, level) for the device. If a MultiTimbral device, then each
# part usually has its own tremulo level.
# Value Range: 0 to 127, with 0 being no tremulo applied at all.
# ----------------------------------------------------------------------------
# Note: New addition: second arguments on "voice" command is MIDI instruments.
# Suggest using instrument command instead.
#   %%MIDI program 6 % Harpsichord
#   %%MIDI program 57 % Trombone
#   %%MIDI program 56 % Trumpet
#   %%MIDI program 40 % Violin
#       voice   4       57,56,40,6
# ----------------------------------------------------------------------------
# clef  bass,treble,treble,treble
# clef  G clef = treble clef. 2nd line to the bottom is G pitch above middle C. 3C=1 line below printed.
# clef  C clef = Alto and Tenor clefs. The B points to the middle 3C line.  (viola)
# clef  F clef = Bass clef. The line between the two dots (?:) is F below middle 3C. 3c=1 line above printed.
# clef  Octave clef. Has a number under the G clef. 8=1 octave, 15=2 octaves higher.
# ----------------------------------------------------------------------------
# flats -> key:     B,E,A,D,G,C,F -- always this order. 2nd to last is Key-flat.
# sharps -> key:    F,C,G,D,A,E,B -- always this order. 2nd to last key Key-sharp.
#             vv - is key to use.
# 7 sharps is C# major or A# minor. f+,c+,g+,d+,a+,e+,b+
# 6 sharps is F# major or D# minor. f+,c+,g+,d+,a+,e+
# 5 sharps is B major or G# minor.  f+,c+,g+,d+,a+
# 4 sharps is E major or C# minor.  f+,c+,g+,d+
# 3 sharps is A major or F# minor.  f+,c+,g+
# 2 sharps is D major or B minor.   f+,c+
# 1 sharp  is G major or E minor.   f+
# None     is C major or A minor.
# 1 flat   is F major or D minor.   b-
# 2 flats  is B- major or G minor.  b-,e-
# 3 flats  is E- major or C minor.  b-,e-,a-
# 4 flats  is A- major or F minor.  b-,e-,a-,d-
# 5 flats  is D- major or B- minor. b-,e-,a-,d-,g-
# 6 flats  is G- major or E- minor. b-,e-,a-,d-,g-,c-
# 7 flats  is C- major or A- minor. b-,e-,a-,d-,g-,c-,f-
# ----------------------------------------------------------------------------
# For volume levels= { 0: 'ppp', 1: 'pp', 2: 'p', 3: 'mp', 4: 'mf', 5: 'f', 6: 'ff', 7: 'fff', 8: 'ffff' }
# can use the numbers or names as above. NOTE: lower than 4 is difficult to hear.
# ----------------------------------------------------------------------------
# ABC header:
#     X: 1
#     ...
#     T: title
#     ...
#     K: C
# Empty lines separate tunes, headers (X: ... K:), and free text
# Line-breaks (new-lines, line feeds, carriage returns, end-of-lines) aids readability and breaks long lines.
#   Music code: end of lines means end of typeset sheet music score (lines). Use backslash to for continuation.
#       It continues through information fields, comments, and stylesheet directives.
# Information fields continue with +: at start of next line.
# ..............................................................................
#         V:1
#         a b cd
#     is the same as:
#         [V:1] a b cd
#     Can use [M:9/8]
# K: Key                K:G, K:Dm, K:AMix
# L: Unit Note Length   L:1/4, L:1/8
# M: Meter              M:3/4, M:4/4        Note present means free - no checking.
# Q: Tempo              Q:1/4=120       Q:1/2 1/4=120  - means dotted half note. (GRUMBLE)
# T: Title              T:Name Of Song, whatever
# V: Voice              V:4 clef=bass               <----
# W: words              W: lyrics printed after the end of the tune
# w: words              w: lyrics printed aligned with the notes of tune
# ..............................................................................
# clef's can be on V: and K: lines
#       treble  Treble          <- normal treble clef.
#       bass    Bass            <- normal bass clef.
#       bass3   Baritone
#       tenor   Tenor           <- middle c on line above alto staff.
#       alto    Alto            <- middle c on middle staff line. (normal)
#       alto2   Mezzosoprano
#       alto1   Soprano
#       perc
#       none
# ----------------------------------------------------------------------------
# Pass 1
# Need the order of the measures.
# In a measure, want everything for that measure -- so that goto it works.
# Start with measure -1, and the default setup?
# Key, volume, note length, tempo
# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
#   Rests are lowercase z. Length follows.
#   Uppercase denote bottom octave (C = middle C on treble stave).
#   Comma after the letter means down an octave.
#   Apostrophe after the letter means up an octave. Multiple ' go up, as ,'s go down.
#   Lowercase letters are next octave above uppercase. four c's: "C, C c c' "
#   ^C = C sharp. _B = B flat. ^^ = double sharp. The equals (=) naturalizes it.
# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
#   Number after note changes duration. Number times default. B2=B twice as long therefore 1/4 because 1/2.
#   / means shorten, default is 2 or "/2".
#   > after a note, multiplying by 3/2 and removing from 2nd note. I.e. c8>c8 -> c8.c16 (dot means 1/16 extra)
#   < after a note, multiplying by 1/2 and adding rest on 2nd note. I.e. c8<c8 -> c16c8. means 1/16th extra
# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
#   print("   C,,     C,   c     c'   c''   z")
#             ++      +    -    --    n     r
#   print("   ^^C,,   ^C,  _c   __c'  =c''  z")
# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
# Have to think about the time ... if using simple ... then make "L: 1/64", and do multiples via:
#   2 = 32, 3 = 32d, 4 = 16, 6 = 16d, 8 = 8, 12 = 8d, 16 = 4, 24 = 4d, 32 = 2, 48 = 2d, 64 = 1, 96 = 1d, 128=2
# Trills, grace notes, staccato, and triplets, and ... *hmmm*
# staccato = .              (3.a.b.c = triplet staccato         (before note
# T = trill
# H = fermata
# . = staccato mark
# The order of abc constructs for a note is:
# <grace notes>, <chord symbols>, <annotations>/<decorations> (e.g. Irish roll, staccato marker or up/downbow),
#    ... <accidentals>, <note>, <octave>, <note length>, i.e. ~^c'3 or even "Gm7"v.=G,2.
#                                                           irish roll, c (down one, up one),
# syntax (p:q:r which means 'put p notes into the time of q for the next r notes'. If q is not given,
# it defaults as above. If r is not given, it defaults to p.
# For example, (3 is equivalent to (3:: or (3:2 , which in turn are equivalent to (3:2:3, whereas (3::2 is
# equivalent to (3:2:2.
# This can be useful to include notes of different lengths within a tuplet, for example (3:2:2 G4c2 or
# (3:2:4 G2A2Bc. It also describes more precisely how the simple syntax works in cases like (3 D2E2F2 or even
# (3 D3EF2. The number written over the tuplet is p.
# Spaces that appear between the tuplet specifier and the following notes are to be ignored.

# tie is minus (-) between two notes.   i.e. C-C3/2
# NOTE: 3 times normal note length divided by 2.  Or C-.C2
# Each tie symbol, -, should come immediately after a note group but may be followed by a space,
# i.e. =G,2- . Open and close chord delimiters, [ and ], should enclose entire note sequences (except for
# chord symbols), e.g.

# NOTE: spaces between notes means to not connect the notes when printed.
# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
# ----------------------------------------------------------------------------
import argparse
import os
import re
import readline
import shlex
import sys
import random
#-- import pprint
#-- # Usage:   pprint.pprint(v_t_lines, width=110, sort_dicts=False)

from fractions import Fraction

# ----------------------------------------------------------------------------
import math
# Log base 2
def Log2(x):
    x = float(x)
    if x == 0:
        return 0
    # fi
    return (math.log10(x) / math.log10(2))
#   End of Log2

# ----------------------------------------------------------------------------
def print_i_line(line):
    global i_line
    global macro_i_line
    global macro_executing_depth

    macrodepth = len(macro_executing_depth)
    k = None
    for i in macro_i_line[macrodepth] + i_line:
        j = i.rstrip()              # In case there are new-lines, etc.
        if j != k:
            print("                  - '{}'".format(j), file=sys.stderr, flush=True)
        # fi
        k = j
    # rof
    line = line.rstrip()
    if k is None or line != k[7:]:
        print("                  - 'line:  {}'".format(line), file=sys.stderr, flush=True)
    # fi
    return
# End of print_i_line

# ----------------------------------------------------------------------------
def print_error(strg, line):
    global linecount
    global which_file_in
    global errors_happened

    errors_happened = 1             # When exiting, do 1 instead of 0

    print("ERROR -", strg, file=sys.stderr, flush=True)
    print("  File {} Line {}".format(which_file_in, linecount, line), file=sys.stderr, flush=True)
    print_i_line(line)
# End of print_error

# ----------------------------------------------------------------------------
def print_warning(strg, line):
    global linecount
    global which_file_in

    print("WARNING -", strg, file=sys.stderr, flush=True)
    print("  File {} Line {}".format(which_file_in, linecount, line), file=sys.stderr, flush=True)
    print_i_line(line)
    return
# End of print_warning

# ----------------------------------------------------------------------------
def print_error_no_line(strg):
    print("ERROR -", strg, file=sys.stderr, flush=True)
    return
# End of print_error_no_line

# ----------------------------------------------------------------------------
def print_warning_no_line(strg):
    print("WARNING -", strg, file=sys.stderr, flush=True)
    return
# End of print_warning_no_line

# ----------------------------------------------------------------------------
def really_print_output(strg):
    global output_name

    print(strg, file=output_name, flush=True)
    return
# End of really_print_output

# ----------------------------------------------------------------------------
def print_debug(strg):
    print("DEBUG -", strg, file=sys.stderr, flush=True)
    return
# End of erint_debug

# ----------------------------------------------------------------------------
def print_output(strg):
    global args
    global array_of_lines
    global fluidsynth_done

    if not args.fluidsynth and not fluidsynth_done:
        really_print_output(strg)
    else:
        if strg == "quit":
            fluidsynth_done = True
        else:
            array_of_lines.append(strg)
        # fi
    # fi
    return
# End of print_output

# ----------------------------------------------------------------------------
def print_output_no_eol(strg):
    global output_name

    print(strg, end='', file=output_name, flush=True)
    return
# End of print_output_no_eol

# ----------------------------------------------------------------------------
import calculate

calculate.cexp_parser()                         # initialize parser

numarry_name        = calculate.numarry_name        # The name of the variable.
numarry_maclevel    = calculate.numarry_maclevel    # The macro level was in effect when created.
numarry_indexes     = calculate.numarry_indexes     # The array indexes. []=value, [3]=1-dimen, [2,4]=2-dimen.
numarry_values      = calculate.numarry_values      # Array of values ([0] for not an array).
numarry_value_type  = calculate.numarry_value_type  # Array of types None=not-set, 0=int/float, 1= character string

# ----------------------------------------------------------------------------
global whichlocalchars
whichlocalchars = []
global whichlocalcharswary
whichlocalcharswary = {}

# ----------------------------------------------------------------------------
def recompute_whichlocalchars():
    global whichlocalchars
    global whichlocalcharswary

    new_which = {}
#--    for wary in calculate.arrays + calculate.local_arrays + calculate.note_arrays:
    for wary in calculate.arrays + calculate.local_arrays:
        if 1 in wary[numarry_value_type]:
            if wary[numarry_name] not in new_which:
                new_which[wary[numarry_name]] = wary
            else:
                a = new_which[wary[numarry_name]]
                if wary[numarry_maclevel] > a[numarry_maclevel]:
                    new_which[wary[numarry_name]] = wary
                # fi
            # fi
        # fi
    # rof
    whichlocalcharswary = new_which
    new_which = sorted(new_which, key=len)
    new_which.reverse()
    whichlocalchars = new_which
# End of recompute_whichlocalchars

# ----------------------------------------------------------------------------
def createvar(arg, val, maclev, typ):
    for wary in calculate.arrays + calculate.local_arrays + calculate.note_arrays:
        if arg == wary[numarry_name]:
            if wary[numarry_maclevel] == maclev:
                return False                    # Already exists.
            # fi
        # fi
    # rof
    wary = [ arg, maclev, [ ], [ val ],    [ typ ] ]
    calculate.arrays.append(wary)
    if typ == 1:
        recompute_whichlocalchars()
    # fi
    return True
# End of createvar

# ----------------------------------------------------------------------------
def createlocalvar(arg, val, maclev, typ):
    for wary in calculate.local_arrays + calculate.arrays + calculate.note_arrays:
        if arg == wary[numarry_name]:
            if wary[numarry_maclevel] == maclev:
                return False                    # Already exists.
            # fi
        # fi
    # rof
    wary = [ arg, maclev, [ ], [ val ],    [ typ ] ]
    calculate.local_arrays.append(wary)
    if typ == 1:
        recompute_whichlocalchars()
    # fi
    return
# End of createlocalvar

# ----------------------------------------------------------------------------
def createnotevar(arg, val, maclev, typ):
    for wary in calculate.local_arrays + calculate.arrays + calculate.note_arrays:
        if arg == wary[numarry_name]:
            if wary[numarry_maclevel] == maclev:
                return False                    # Already exists.
            # fi
        # fi
    # rof
    wary = [ arg, maclev, [ ], [ val ],    [ typ ] ]
    calculate.note_arrays.append(wary)
    if typ == 1:
        recompute_whichlocalchars()
    # fi
    return
# End of createlocalvar

# ----------------------------------------------------------------------------
def chkvar(arg):
    maxmaclev = -1
    maxwary = None
    for wary in calculate.arrays + calculate.local_arrays:
        if arg == wary[numarry_name]:
            if wary[numarry_maclevel] > maxmaclev:
                maxmaclev = wary[numarry_maclevel]
                maxwary = wary
            # fi
        # fi
    # rof
    return maxwary
# End of setvar

# ----------------------------------------------------------------------------
def setvar(arg, val, typ):
    wary = chkvar(arg)
    if wary is None or (len(wary[numarry_indexes]) > 1 and wary[numarry_indexes][0] > 1):
        return False                            # Does not exist.
    # fi
    wary[numarry_values][0] = val
    wary[numarry_value_type][0] = typ
    if typ == 1:
        recompute_whichlocalchars()
    # fi
    return True
# End of setvar

# ----------------------------------------------------------------------------
def getvar(arg):
    wary = chkvar(arg)
    if wary is None or (len(wary[numarry_indexes]) > 1 and wary[numarry_indexes][0] > 1):
        print_error_no_line("getvar - multidimensional array ... without dimensions", 'getvar')
        return None
    # fi
    return wary[numarry_values][0]
# End of getval

# ----------------------------------------------------------------------------
def getvarmaclevel(arg, maclev):
    for wary in calculate.arrays + calculate.local_arrays:
        if arg == wary[numarry_name] and maclev == wary[numarry_maclevel]:
            return wary[numarry_values][0]
        # fi
    # rof
    return None
# End of getvarmaclevel

# ----------------------------------------------------------------------------
#-- # Test character variables
#-- createlocalvar('DEF', 'def0', 0, 1)
#-- createlocalvar('DEFINE', 'debug', 0, 1)
#-- wary = [ 'DEFINE', 0, [2,2], [ 'debug11','debug12','debug21','debug22' ], [ 1,1,1,1 ] ] ; calculate.local_arrays.append(wary) ; recompute_whichlocalchars()
#-- createlocalvar('ABC', 'abc0', 0, 1)
#-- createlocalvar('Hidebug12there', 'debug', 0, 1)
#--createlocalvar('VOICE', 'voiceargument', 0, 1)

# ----------------------------------------------------------------------------
 # Default ancient musicomp values -- not used within this script/program. (For input files.)
createlocalvar('pause', 4, 0, 0)
createlocalvar('grace', 4, 0, 0)
createlocalvar('voice', -1, 0, 0)               # no voices yet.

# IMS variables
# NOTDONEYET - accent
createlocalvar('accent', 10, 0, 0)              # light accent
# NOTDONEYET - aaccent
createlocalvar('aaccent', 20, 0, 0)             # heavy accent
# NOTDONEYET - arp
createlocalvar('arp', 1/32, 0, 0)               # Default arpeggiation length
# NOTDONEYET - fermata
createlocalvar('fermata', 1, 0, 0)              # fermata
# NOTDONEYET - ferma
createlocalvar('lferm', 1, 0, 0)                # No fermata yet.
# NOTDONEYET - stac
createlocalvar('stac', 0.25, 0, 0)              # Staccato length multiplier - used to be 4, but IMS is 1/4.
# NOTDONEYET - marc
createlocalvar('marc', 0.5, 0, 0)               # Marcato length multipliers.
createlocalvar('time', 0, 0, 0)                 # The "time" in measure for current voice. (staff?)

# IMS "if" variables.  -1 is true
createlocalvar('print', 0, 0, 0)                # if compiling for printing - args.abc is true
createlocalvar('play', 0, 0, 0)                 # if compiling for playing  - args.fluidsynth or args.midi1csv
# NOTDONEYET - lime
createlocalvar('lime', 0, 0, 0)                 # if compiling for lime (does not apply)
# NOTDONEYET - include
createlocalvar('include', 0, 0, 0)              # if compiling an include file (does not apply)

# New default musicomp values for debugging, etc.
createlocalvar('page', -1, 0, 0)                # Page number from page command.
createlocalvar('measure', -1, 0, 0)             # measure number from last measure command.

# Default MIDI control values.
createlocalvar('default_reverb', 0, 0, 0)       # No reverb.
createlocalvar('default_pan', 64, 0, 0)         # Center of left<->right balance.
createlocalvar('default_intensity', 100, 0, 0)  # Volume = intensity% * velocity% * vol(ff)%.
createlocalvar('default_velocity', 120, 0, 0)   # Note attack (when played. (Leave 7) Appears to be volume.

#-----------------------------------------------------------------------------
from itertools import permutations

def the_perms(pre, mystr, d):
    for i in range(1,len(mystr)+1):
        for comb in permutations(mystr, i):
            d[pre + ''.join(comb)] = 1
        # rof
    # rof
    return d
# End of the_perms

#-----------------------------------------------------------------------------
# For suffix on time -- many variations, but do not duplicate z's with l's.
#-- NOTDONEYET - add/subtract these easily?
createnotevar('w', 1, 0, 0)                      # w = 1 for whole note time
createnotevar('h', 2, 0, 0)                      # h = 2 for half note time
createnotevar('q', 4, 0, 0)                      # q = 4 for quarter note time
createnotevar('e', 8, 0, 0)                      # e = 8 for eighth note time
createnotevar('d', 1, 0, 0)                      # d = for dotted note.
createnotevar('dd', 1, 0, 0)                     # dd = for double dotted note.
createnotevar('th', 1, 0, 0)                     # th = for 4c8th note type notation.

# This makes each permuation evaluate to '1.
d = {}
d = the_perms('', 'sbtaz', d)
d = the_perms('d', 'sbtaz', d)
d = the_perms('dd', 'sbtaz', d)
d = the_perms('', 'sbtal', d)
d = the_perms('d', 'sbtal', d)
d = the_perms('dd', 'sbtal', d)
for k in d:
    createnotevar(k, 1, 0, 0)                     # Create all the local variables.
# rof
# ----------------------------------------------------------------------------
#++ import inspect
#++ print(inspect.currentframe().f_code.co_name, '#0', file=sys.stderr, flush=True)
# ----------------------------------------------------------------------------
MAXMIDICHANNELS = 16
# MAXABCVOICES = 32
MAXABCVOICES = 128
MAXVOICES = 128
NUMBER_BARS_PER_STAFF = 4
# NUMBER_BARS_PER_STAFF = 1
MIDICLICKSPERQUARTER = 480.0

# Let the notes 'release' after piece finishes.
#?? clicks_at_end_of_piece = 2 * MIDICLICKSPERQUARTER   # Half note.
clicks_at_end_of_piece = MIDICLICKSPERQUARTER   # Quarter note.

# For setperm and randp commands.
global array_of_random_numbers
array_of_random_numbers = [ ]

# When getting note, various things found:
sequence_note = 2
trill_note = 1
normal_note = 0
freqency_note = -1
gsw_operand = -2

# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
global allkeys
allkeys = [ 'c', 'd', 'e', 'f', 'g', 'a', 'b',
            'cn', 'dn', 'en', 'fn', 'gn', 'an', 'bn',
            'c-', 'd-', 'e-', 'f-', 'g-', 'a-', 'b-',
            'c--', 'd--', 'e--', 'f--', 'g--', 'a--', 'b--',
            'c+', 'd+', 'e+', 'f+', 'g+', 'a+', 'b+',
            'c++', 'd++', 'e++', 'f++', 'g++', 'a++', 'b++' ]
global accidentals
accidentals = { '':'', 'n':'=', '-':'_', '+':'^', '--':'__', '++':'^^' }

global legal_notes
legal_notes =   {
       '1/64': 0.015625,
      '3/128': 0.0234375,
       '1/32': 0.03125,
       '3/64': 0.046875,
      '7/128': 0.0546875,
       '1/16': 0.0625,
       '3/32': 0.09375,
       '7/64': 0.109375,
     '15/128': 0.1171875,
        '1/8': 0.125,
       '3/16': 0.1875,
       '7/32': 0.21875,
      '15/64': 0.234375,
     '31/128': 0.2421875,
        '1/4': 0.25,
        '3/8': 0.375,
       '7/16': 0.4375,
      '15/32': 0.46875,
      '31/64': 0.484375,
     '63/128': 0.4921875,
        '1/2': 0.5,
        '3/4': 0.75,
        '7/8': 0.875,
      '15/16': 0.9375,
      '31/32': 0.96875,
      '63/64': 0.984375,
    '127/128': 0.9921875,
          '1': 1.0,
        '3/2': 1.5,
        '7/4': 1.75,
       '15/8': 1.875,
      '31/16': 1.9375,
      '63/32': 1.96875,
     '127/64': 1.984375,
    '255/128': 1.9921875,
          '2': 2.0,
          '3': 3.0,
        '7/2': 3.5,
       '15/4': 3.75,
       '31/8': 3.875,
      '63/16': 3.9375,
     '127/32': 3.96875,
     '255/64': 3.984375,
    '511/128': 3.9921875,
       }

legal_mc_notes = {
        0.015625 : '64',
       0.0234375 : '64d',
         0.03125 : '32',
        0.046875 : '32d',
          0.0625 : '16',
         0.09375 : '16d',
           0.125 : '8',
          0.1875 : '8d',
            0.25 : '4',
           0.375 : '4d',
             0.5 : '2',
            0.75 : '2d',
             1.0 : '1',
             1.5 : '1d',
}

global legal_floating
legal_floating = dict((y, x) for x, y in legal_notes.items())
global legal_floating_times
legal_floating_times = sorted(legal_notes.values())

global DECORATIONS
DECORATIONS = '+'
# - DECORATIONS = '!'

global vlprint
# 2022-08-12_15-39-03 - allow more space at low range and upper range. (Gives intensity some space.)
vlprint = {  0: 'ppppp',        # Below anything to expect.
            20: 'pppp',
            30: 'ppp',
            40: 'pp',
            50: 'p',
            60: 'mp',
            70: 'mf',
            80: 'f',
            90: 'ff',
            100: 'fff',
            110: 'ffff',
            127: 'fffff',       # Above anything to expect.
          }
global v_name_print
v_name_print = {}
for i in vlprint:
    v_name_print[ vlprint[ i ] ] = i
# rof

createlocalvar('vppppp', v_name_print[ 'ppppp' ], 0, 0)
createlocalvar('vpppp', v_name_print[ 'pppp' ], 0, 0)
createlocalvar('vppp', v_name_print[ 'ppp' ], 0, 0)
createlocalvar('vpp', v_name_print[ 'pp' ], 0, 0)
createlocalvar('vp', v_name_print[ 'p' ], 0, 0)
createlocalvar('vmp', v_name_print[ 'mp' ], 0, 0)
createlocalvar('vmf', v_name_print[ 'mf' ], 0, 0)
createlocalvar('vf', v_name_print[ 'f' ], 0, 0)
createlocalvar('vff', v_name_print[ 'ff' ], 0, 0)
createlocalvar('vfff', v_name_print[ 'fff' ], 0, 0)
createlocalvar('vffff', v_name_print[ 'ffff' ], 0, 0)
createlocalvar('vfffff', v_name_print[ 'fffff' ], 0, 0)

global S_vlprint                    # First is this note volume, 2nd is following note volumes.
S_vlprint = { 'ffffp':[ getvar('vffff'), getvar('vp') ],      # ffff for one note, then p.
              'fffp':[ getvar('vfff'), getvar('vp') ],        # fff for one note, then p.
              'ffp':[ getvar('vff'), getvar('vp') ],          # ff for one note, then p.
              'fp':[ getvar('vf'), getvar('vp') ],            # f for one note, then p.
              'ffffpp':[ getvar('vffff'), getvar('vpp') ],    # ffff for one note, then p.
              'fffpp':[ getvar('vfff'), getvar('vpp') ],      # fff for one note, then p.
              'ffpp':[ getvar('vff'), getvar('vpp') ],        # ff for one note, then p.
              'fpp':[ getvar('vf'), getvar('vpp') ],          # f for one note, then p.
              'ffffppp':[ getvar('vffff'), getvar('vppp') ],  # ffff for one note, then p.
              'fffppp':[ getvar('vfff'), getvar('vppp') ],    # fff for one note, then p.
              'ffppp':[ getvar('vff'), getvar('vppp') ],      # ff for one note, then p.
              'fppp':[ getvar('vf'), getvar('vppp') ],        # f for one note, then p.
              'ffffpppp':[ getvar('vffff'), getvar('vpppp') ],  # ffff for one note, then p.
              'fffpppp':[ getvar('vfff'), getvar('vpppp') ],  # fff for one note, then p.
              'ffpppp':[ getvar('vff'), getvar('vpppp') ],    # ff for one note, then p.
              'fpppp':[ getvar('vf'), getvar('vpppp') ],      # f for one note, then p.

              'sffffp':[ -2, getvar('vp') ],       # much much louder for this note, then p.
              'sfffp':[ -2, getvar('vp') ],        # much much louder for this note, then p.
              'sffffpp':[ -2, getvar('vpp') ],     # much much louder for this note, then p.
              'sfffpp':[ -2, getvar('vpp') ],      # much much louder for this note, then p.
              'sffffpppp':[ -2, getvar('vpppp') ], # much much louder for this note, then p.
              'sfffpppp':[ -2, getvar('vpppp') ],  # much much louder for this note, then p.
              'sffffppp':[ -2, getvar('vppp') ],   # much much louder for this note, then p.
              'sfffppp':[ -2, getvar('vppp') ],    # much much louder for this note, then p.
              'sffp':[ -3, getvar('vp') ],         # much louder for one note, then p.
              'sffpp':[ -3, getvar('vpp') ],       # much louder for one note, then p.
              'sffppp':[ -3, getvar('vppp') ],     # much louder for one note, then p.
              'sffpppp':[ -3, getvar('vpppp') ],   # much louder for one note, then p.
              'sfp':[ -4, getvar('vp') ],          # louder for one note, then p.
              'sfpp':[ -4, getvar('vpp') ],        # louder for one note, then p.
              'sfppp':[ -4, getvar('vppp') ],      # much louder for one note, then p.
              'sfpppp':[ -4, getvar('vpppp') ],    # much louder for one note, then p.

              'sffff':[ -2, -1 ],       # much much louder for this note, back to where it was.
              'sfff':[ -2, -1 ],        # much much louder for this note, back to where it was.
              'sff':[ -3, -1 ],         # louder for then note, then back to where it was.
              'fz':[ -4, -1 ],          # getvar('vf'), then back to what it was (like sf, crazy).
              'sf':[ -4, -1 ],          # louder for then note, then back to where it was.
              'sfz':[ -4, -1 ],         # like sf.

              'smf':[ -5, -1 ],         # somewhat louder louder for one note, then back to where it was.
              'smfz':[ -5, -1 ],        # somewhat louder louder for one note, then back to where it was.

              'smp':[ -6, -1 ],         # somewhat louder for one note, then back to where it was.
              'smpz':[ -6, -1 ],        # somewhat louder for one note, then back to where it was.

              'sp':[ -7, -1 ],          # p then back to what it was.
              'spz':[ -7, -1 ],         # p then back to what it was.
              'spp':[ -8, -1 ],         # pp then back to what it was.
              'sppz':[ -8, -1 ],        # pp then back to what it was.
              'sppp':[ -9, -1 ],        # ppp then back to what it was.
              'spppz':[ -9, -1 ],       # ppp then back to what it was.
              'sppppz':[ -10, -1 ],     # pppp then back to what it was.

              'spf':[ -7, getvar('vf') ],          # p then to f.
              'sppf':[ -8, getvar('vf') ],         # pp then to f.
              'spppf':[ -9, getvar('vf') ],        # ppp then to f.
              'sppppf':[ -10, getvar('vf') ],      # pppp then to f.
              'spff':[ -7, getvar('vff') ],        # p then to ff.
              'sppff':[ -8, getvar('vff') ],       # pp then to ff.
              'spppff':[ -9, getvar('vff') ],      # ppp then to ff.
              'sppppff':[ -10, getvar('vff') ],    # pppp then to ff.
              'spffff':[ -7, getvar('vffff') ],    # p then to ffff.
              'spfff':[ -7, getvar('vfff') ],      # p then to fff.
              'sppffff':[ -8, getvar('vffff') ],   # pp then to ffff.
              'sppfff':[ -8, getvar('vfff') ],     # pp then to fff.
              'spppffff':[ -9, getvar('vffff') ],  # ppp then to ffff.
              'spppfff':[ -9, getvar('vfff') ],    # ppp then to fff.
              'sppppffff':[ -10, getvar('vffff') ],  # pppp then to ffff.
              'sppppfff':[ -10, getvar('vfff') ],  # pppp then to fff.
            }

# ----------------------------------------------------------------------------
def vol_to_vlprint_round(j):
    global vlprint

    for i in vlprint:
        if i >= j:
            return i
            break
        # fi
    # rof
    return getvar('vfff')
# End of vol_to_vlprint_round

# ------------------------------------------------------------------------------
global instruments
# select chan sfont bank prog -      prog, bank.
instruments = {
    'Acoustic Grand Piano'.lower() : [0, 0],
    'Stereo Grand'.lower() : [0, 0],
    'Bright Acoustic Piano'.lower() : [1, 0],
    'Bright Grand'.lower() : [1, 0],
    'Electric Grand Piano'.lower() : [2, 0],
    'Electric Grand'.lower() : [2, 0],
    'Honky-tonk Piano'.lower() : [3, 0],
    'Honky-tonk'.lower() : [3, 0],
    'Electric Piano 1'.lower() : [4, 0],
    'Time Electric Piano 1'.lower() : [4, 0],
    'Electric Piano 2'.lower() : [5, 0],
    'FM Electric Piano'.lower() : [5, 0],
    'Harpsichord'.lower() : [6, 0],
    'Clavi'.lower() : [7, 0],
    'Clavinet'.lower() : [7, 0],
    'Celesta'.lower() : [8, 0],
    'Celeste'.lower() : [8, 0],
    'Glockenspiel'.lower() : [9, 0],
    'Music Box'.lower() : [10, 0],
    'Vibraphone'.lower() : [11, 0],
    'Marimba'.lower() : [12, 0],
    'Xylophone'.lower() : [13, 0],
    'Tubular Bells'.lower() : [14, 0],
    'Dulcimer'.lower() : [15, 0],
    'Drawbar Organ'.lower() : [16, 0],
    'Tonewheel Organ'.lower() : [16, 0],
    'Percussive Organ'.lower() : [17, 0],
    'Rock Organ'.lower() : [18, 0],
    'Church Organ'.lower() : [19, 0],
    'Pipe Organ'.lower() : [19, 0],
    'Reed Organ'.lower() : [20, 0],
    'Accordion'.lower() : [21, 0],
    'Harmonica'.lower() : [22, 0],
    'Tango Accordion'.lower() : [23, 0],
    'Bandoneon'.lower() : [23, 0],
    'Acoustic Guitar (nylon)'.lower() : [24, 0],
    'Nylon Guitar'.lower() : [24, 0],
    'Acoustic Guitar (steel)'.lower() : [25, 0],
    'Steel Guitar'.lower() : [25, 0],
    'Electric Guitar (jazz)'.lower() : [26, 0],
    'Jazz Guitar'.lower() : [26, 0],
    'Electric Guitar (clean)'.lower() : [27, 0],
    'Clean Guitar'.lower() : [27, 0],
    'Electric Guitar (muted)'.lower() : [28, 0],
    'Muted Guitar'.lower() : [28, 0],
    'Overdriven Guitar'.lower() : [29, 0],
    'Overdrive Guitar'.lower() : [29, 0],
    'Distortion Guitar'.lower() : [30, 0],
    'Guitar Harmonics'.lower() : [31, 0],
    'Acoustic Bass'.lower() : [32, 0],
    'Electric Bass (finger)'.lower() : [33, 0],
    'Finger Bass'.lower() : [33, 0],
    'Electric Bass (pick)'.lower() : [34, 0],
    'Pick Bass'.lower() : [34, 0],
    'Fretless Bass'.lower() : [35, 0],
    'Slap Bass 1'.lower() : [36, 0],
    'Slap Bass 2'.lower() : [37, 0],
    'Synth Bass 1'.lower() : [38, 0],
    'Synth Bass 2'.lower() : [39, 0],
    'Violin'.lower() : [40, 0],
    'Viola'.lower() : [41, 0],
    'Cello'.lower() : [42, 0],
    'Contrabass'.lower() : [43, 0],
    'Double Bass'.lower() : [43, 0],
    'Tremolo Strings'.lower() : [44, 0],
    'Stero Strings Trem'.lower() : [44, 0],
    'Pizzicato Strings'.lower() : [45, 0],
    'Orchestral Harp'.lower() : [46, 0],
    'Timpani'.lower() : [47, 0],
    'String Ensemble 1'.lower() : [48, 0],
    'Stereo Strings Fast'.lower() : [48, 0],
    'String Ensemble 2'.lower() : [49, 0],
    'Stereo Strings Slow'.lower() : [49, 0],
    'Synth Strings 1'.lower() : [50, 0],
    'Synth Strings 2'.lower() : [51, 0],
    'Choir Aahs'.lower() : [52, 0],
    'Concert Choir'.lower() : [52, 0],
    'Voice Oohs'.lower() : [53, 0],              # NOT RIGHT!
    'Synth Voice'.lower() : [54, 0],             # NOT RIGHT!
    'Orchestra Hit'.lower() : [55, 0],           # ?? strange sound. ??
    'Trumpet'.lower() : [56, 0],
    'Trombone'.lower() : [57, 0],
    'Tuba'.lower() : [58, 0],
    'Muted Trumpet'.lower() : [59, 0],
    'French Horn'.lower() : [60, 0],
    'French Horns'.lower() : [60, 0],
    'Brass Section'.lower() : [61, 0],
    'Synth Brass 1'.lower() : [62, 0],
    'Synth Brass 2'.lower() : [63, 0],
    'Soprano Sax'.lower() : [64, 0],
    'Alto Sax'.lower() : [65, 0],
    'Tenor Sax'.lower() : [66, 0],
    'Baritone Sax'.lower() : [67, 0],
    'Oboe'.lower() : [68, 0],
    'English Horn'.lower() : [69, 0],
    'Bassoon'.lower() : [70, 0],
    'Clarinet'.lower() : [71, 0],
    'Piccolo'.lower() : [72, 0],
    'Flute'.lower() : [73, 0],
    'Recorder'.lower() : [74, 0],
    'Pan Flute'.lower() : [75, 0],
    'Blown bottle'.lower() : [76, 0],
    'Bottle Blow'.lower() : [76, 0],
    'Shakuhachi'.lower() : [77, 0],
    'Whistle'.lower() : [78, 0],
    'Irish Tin Whistle'.lower() : [78, 0],
    'Ocarina'.lower() : [79, 0],
    'Lead 1 (square)'.lower() : [80, 0],
    'Square Lead'.lower() : [80, 0],
    'Lead 2 (sawtooth)'.lower() : [81, 0],
    'Saw Lead'.lower() : [81, 0],
    'Lead 3 (calliope)'.lower() : [82, 0],
    'Synth Calliope'.lower() : [82, 0],
    'Lead 4 (chiff)'.lower() : [83, 0],
    'Chiffer Lead'.lower() : [83, 0],
    'Lead 5 (charang)'.lower() : [84, 0],
    'Charang'.lower() : [84, 0],
    'Lead 6 (voice)'.lower() : [85, 0],
    'Solo Vox'.lower() : [85, 0],
    'Lead 7 (fifths)'.lower() : [86, 0],
    '5th Saw Wave'.lower() : [86, 0],
    'Lead 8 (bass + lead)'.lower() : [87, 0],
    'Bass & lead'.lower() : [87, 0],
    'Pad 1 (new age)'.lower() : [88, 0],
    'Fantasia'.lower() : [88, 0],
    'Pad 2 (warm)'.lower() : [89, 0],
    'Warm Pad'.lower() : [89, 0],
    'Pad 3 (polysynth)'.lower() : [90, 0],
    'Polysynth'.lower() : [90, 0],
    'Pad 4 (choir)'.lower() : [91, 0],
    'Space Voice'.lower() : [91, 0],
    'Pad 5 (bowed)'.lower() : [92, 0],
    'Bowed Glass'.lower() : [92, 0],
    'Pad 6 (metallic)'.lower() : [93, 0],
    'Metal Pad'.lower() : [93, 0],
    'Pad 7 (halo)'.lower() : [94, 0],
    'Halo Pad'.lower() : [94, 0],
    'Pad 8 (sweep)'.lower() : [95, 0],
    'Sweep Pad'.lower() : [95, 0],
    'FX 1 (rain)'.lower() : [96, 0],
    'Ice Rain'.lower() : [96, 0],
    'FX 2 (soundtrack)'.lower() : [97, 0],
    'Soundtrack'.lower() : [97, 0],
    'FX 3 (crystal)'.lower() : [98, 0],
    'Crystal'.lower() : [98, 0],
    'FX 4 (atmosphere)'.lower() : [99, 0],
    'Atmosphere'.lower() : [99, 0],
    'FX 5 (brightness)'.lower() : [100, 0],
    'Brightness'.lower() : [100, 0],
    'FX 6 (goblins)'.lower() : [101, 0],
    'Goblins'.lower() : [101, 0],
    'FX 7 (echoes)'.lower() : [102, 0],
    'Echo Drops'.lower() : [102, 0],
    'FX 8 (sci-fi)'.lower() : [103, 0],
    'Star Theme'.lower() : [103, 0],
    'Sitar'.lower() : [104, 0],
    'Banjo'.lower() : [105, 0],
    'Shamisen'.lower() : [106, 0],
    'Koto'.lower() : [107, 0],
    'Kalimba'.lower() : [108, 0],
    'Bag pipe'.lower() : [109, 0],
    'Bagpipes'.lower() : [109, 0],
    'Fiddle'.lower() : [110, 0],
    'Shanai'.lower() : [111, 0],
    'Shenai'.lower() : [111, 0],
    'Tinkle Bell'.lower() : [112, 0],
    'Tinker Bell'.lower() : [112, 0],
    'Agogo'.lower() : [113, 0],
    'Steel Drums'.lower() : [114, 0],
    'Woodblock'.lower() : [115, 0],
    'Wood Block'.lower() : [115, 0],
    'Taiko Drum'.lower() : [116, 0],
    'Melodic Tom'.lower() : [117, 0],
    'Synth Drum'.lower() : [118, 0],
    'Reverse Cymbal'.lower() : [119, 0],
    'Guitar Fret Noise'.lower() : [120, 0],
    'Fret Noise'.lower() : [120, 0],
    'Breath Noise'.lower() : [121, 0],
    'Seashore'.lower() : [122, 0],
    'Bird Tweet'.lower() : [123, 0],
    'Birds'.lower() : [123, 0],
    'Telephone Ring'.lower() : [124, 0],
    'Telephone 1'.lower() : [124, 0],
    'Helicopter'.lower() : [125, 0],
    'Applause'.lower() : [126, 0],
    'Gunshot'.lower() : [127, 0],
    'Gun Shot'.lower() : [127, 0],
    'Synth Bass 101'.lower() : [38, 1],
    'Mono Strings Trem'.lower() : [44, 1],
    'Mono Strings Fast'.lower() : [48, 1],
    'Mono Strings Slow'.lower() : [49, 1],
    'Concert Choir Mono'.lower() : [52, 1],
    'Trumpet 2'.lower() : [56, 1],
    'Trombone 2'.lower() : [57, 1],
    'Muted Trumpet 2'.lower() : [59, 1],
    'Solo French Horn'.lower() : [60, 1],
    'Brass Section Mono'.lower() : [61, 1],
    'Square Wave'.lower() : [80, 1],
    'Saw Wave'.lower() : [81, 1],
    'Synth Mallet'.lower() : [98, 1],
    'Cut Noise'.lower() : [120, 1],
    'Fl. Key Click'.lower() : [121, 1],
    'Rain'.lower() : [122, 1],
    'Dog'.lower() : [123, 1],
    'Telephone 2'.lower() : [124, 1],
    'Car-Engine'.lower() : [125, 1],
    'Laughing'.lower() : [126, 1],
    'Machine Gun'.lower() : [127, 1],
    'Echo Pan'.lower() : [102, 2],
    'String Slap'.lower() : [120, 2],
    'Thunder'.lower() : [122, 2],
    'Horse Gallop'.lower() : [123, 2],
    'Door Creaking'.lower() : [124, 2],
    'Car-Stop'.lower() : [125, 2],
    'Scream'.lower() : [126, 2],
    'Lasergun'.lower() : [127, 2],
    'Howling Winds'.lower() : [122, 3],
    'Bird 2'.lower() : [123, 3],
    'Door'.lower() : [124, 3],
    'Car-Pass'.lower() : [125, 3],
    'Punch'.lower() : [126, 3],
    'Explosion'.lower() : [127, 3],
    'Stream'.lower() : [122, 4],
    'Scratch'.lower() : [123, 4],
    'Car-Crash'.lower() : [125, 4],
    'Heart Beat'.lower() : [126, 4],
    'Bubbles'.lower() : [122, 5],
    'Windchime'.lower() : [124, 5],
    'Siren'.lower() : [125, 5],
    'Footsteps'.lower() : [126, 5],
    'Train'.lower() : [125, 6],
    'Jet Plane'.lower() : [125, 7],
    'Chorused Tine EP'.lower() : [4, 8],
    'Chorused FM EP'.lower() : [5, 8],
    'Coupled Harpsichord'.lower() : [6, 8],
    'Church Bells'.lower() : [14, 8],
    'Detuned Tnwl. Organ'.lower() : [16, 8],
    'Detuned Perc. Organ'.lower() : [17, 8],
    'Pipe Organ 2'.lower() : [19, 8],
    'Italian Accordian'.lower() : [21, 8],
    'Ukulele'.lower() : [24, 8],
    '12-String Guitar'.lower() : [25, 8],
    'Hawaiian Guitar'.lower() : [26, 8],
    'Chorused Clean Gt.'.lower() : [27, 8],
    'Funk Guitar'.lower() : [28, 8],
    'Feedback Guitar'.lower() : [30, 8],
    'Guitar Feedback'.lower() : [31, 8],
    'Synth Bass 3'.lower() : [38, 8],
    'Synth Bass 4'.lower() : [39, 8],
    'Orchestra Pad'.lower() : [48, 8],
    'Synth Strings 3'.lower() : [50, 8],
    'Brass Section 2'.lower() : [61, 8],
    'Synth Brass 3'.lower() : [62, 8],
    'Synth Brass 4'.lower() : [63, 8],
    'Sine Wave'.lower() : [80, 8],
    'Doctor Solo'.lower() : [81, 8],
    'Taisho Koto'.lower() : [107, 8],
    'Castanets'.lower() : [115, 8],
    'Concert Bass Drum'.lower() : [116, 8],
    'Melodic Tom 2'.lower() : [117, 8],
    '808 Tom'.lower() : [118, 8],
    'Starship'.lower() : [125, 8],
    'Carillon'.lower() : [14, 9],
    'Burst Noise'.lower() : [125, 9],
    'Piano & Str.-Fade'.lower() : [0, 11],
    'Piano & Str.-Sus'.lower() : [1, 11],
    'Tine & FM EPs'.lower() : [4, 11],
    'Piano & FM EP'.lower() : [5, 11],
    'Tinkling Bells'.lower() : [8, 11],
    'Bell Tower'.lower() : [14, 11],
    'Techno Bass'.lower() : [38, 11],
    'Pulse Bass'.lower() : [39, 11],
    'Stereo Strings Velo'.lower() : [49, 11],
    'Synth Strings 4'.lower() : [50, 11],
    'Synth Strings 5'.lower() : [51, 11],
    'Brass Section 3'.lower() : [61, 11],
    'Whistlin'.lower() : [78, 11],
    'Sawtooth Stab'.lower() : [81, 11],
    "Doctor's Solo".lower() : [87, 11],
    'Harpsi Pad'.lower() : [88, 11],
    'Solar Wind'.lower() : [89, 11],
    'Mystery Pad'.lower() : [96, 11],
    'Synth Chime'.lower() : [98, 11],
    'Bright Saw Stack'.lower() : [100, 11],
    'Cymbal Crash'.lower() : [119, 11],
    'Filter Snap'.lower() : [121, 11],
    'Interference'.lower() : [127, 11],
    'Bell Piano'.lower() : [0, 12],
    'Bell Tine EP'.lower() : [4, 12],
    'Christmas Bells'.lower() : [10, 12],
    'Clean Guitar 2'.lower() : [27, 12],
    'Mean Saw Bass'.lower() : [38, 12],
    'Full Orchestra'.lower() : [48, 12],
    'Mono Strings Velo'.lower() : [49, 12],
    'Square Lead 2'.lower() : [80, 12],
    'Saw Lead 2'.lower() : [81, 12],
    'Fantasia 2'.lower() : [88, 12],
    'Solar Wind 2'.lower() : [89, 12],
#--    'Tambourine'.lower() : [119, 12],        # In the drum_sounds section.
    'White Noise Wave'.lower() : [122, 12],
    'Shooting Star'.lower() : [127, 12],
    'Woodwind Choir'.lower() : [48, 13],
    'Square Lead 3'.lower() : [80, 13],
    'Saw Lead 3'.lower() : [81, 13],
    'Night Vision'.lower() : [88, 13],
    'Mandolin'.lower() : [25, 16],
    'Standard Drums'.lower() : [0, 120],
    'Standard 2 Drums'.lower() : [1, 120],
    'Room Drums'.lower() : [8, 120],
    'Power Drums'.lower() : [16, 120],
    'Electronic Drums'.lower() : [24, 120],
    '808/909 Drums'.lower() : [25, 120],
    'Dance Drums'.lower() : [26, 120],
    'Jazz Drums'.lower() : [32, 120],
    'Brush Drums'.lower() : [40, 120],
    'Orchestral Perc.'.lower() : [48, 120],
    'SFX Kit'.lower() : [56, 120],
    'Standard'.lower() : [0, 128],
    'Standard 2'.lower() : [1, 128],
    'Room'.lower() : [8, 128],
    'Power'.lower() : [16, 128],
    'Electronic'.lower() : [24, 128],
    '808/909'.lower() : [25, 128],
    'Dance'.lower() : [26, 128],
    'Jazz'.lower() : [32, 128],
    'Brush'.lower() : [40, 128],
    'Orchestral'.lower() : [48, 128],
    'SFX'.lower() : [56, 128],
}

# ------------------------------------------------------------------------------
global drum_sounds
drum_sounds = {
    'Acoustic Bass Drum'.lower(): 35,
    'Bass Drum 1'.lower(): 36,
    'Side Stick'.lower(): 37,
    'Acoustic Snare'.lower(): 38,
    'Hand Clap'.lower(): 39,
    'Electric Snare'.lower(): 40,
    'Low Floor Tom'.lower(): 41,
    'Closed Hi Hat'.lower(): 42,
    'High Floor Tom'.lower(): 43,
    'Pedal Hi-Hat'.lower(): 44,
    'Low Tom'.lower(): 45,
    'Open Hi-Hat'.lower(): 46,
    'Low-Mid Tom'.lower(): 47,
    'Hi Mid Tom'.lower(): 48,
    'Crash Cymbal 1'.lower(): 49,
    'High Tom'.lower(): 50,
    'Ride Cymbal 1'.lower(): 51,
    'Chinese Cymbal'.lower(): 52,
    'Ride Bell'.lower(): 53,
    'Tambourine'.lower(): 54,
    'Splash Cymbal'.lower(): 55,
    'Cowbell'.lower(): 56,
    'Crash Cymbal 2'.lower(): 57,
    'Vibraslap'.lower(): 58,
    'Ride Cymbal 2'.lower(): 59,
    'Hi Bongo'.lower(): 60,
    'Low Bongo'.lower(): 61,
    'Mute Hi Conga'.lower(): 62,
    'Open Hi Conga'.lower(): 63,
    'Low Conga'.lower(): 64,
    'High Timbale'.lower(): 65,
    'Low Timbale'.lower(): 66,
    'High Agogo'.lower(): 67,
    'Low Agogo'.lower(): 68,
    'Cabasa'.lower(): 69,
    'Maracas'.lower(): 70,
    'Short Whistle'.lower(): 71,
    'Long Whistle'.lower(): 72,
    'Short Guiro'.lower(): 73,
    'Long Guiro'.lower(): 74,
    'Claves'.lower(): 75,
    'Hi Wood Block'.lower(): 76,
    'Low Wood Block'.lower(): 77,
    'Mute Cuica'.lower(): 78,
    'Open Cuica'.lower(): 79,
    'Mute Triangle'.lower(): 80,
    'Open Triangle'.lower(): 81,
}

# ----------------------------------------------------------------------------
global last_command
last_command = 'comment '           # For continuation lines.
global args
global errors_happened
errors_happened = 0                 # system exit, 0 = okay, 1 = errors happened

global which_file_in
which_file_in = 'stdin'
global linecount
linecount = 0
global i_line                       # Array of line as it is changed by macro arguments, putd, char vars, etc.
i_line = []

global putds                        # "micro" and it's replacement/substitution.
putds    = { }                      # dictionary of from:to

global goto_table                   # Goto is ONLY at end of measure. (Put in extra measures.)
global goto_variables               # When processing gotos for output, the count of times hit.
goto_table = { '':[]}               # first index is measure number. Value is array of measures in goto.
goto_variables = { '':0}            # first index is measure number. Value is number of times goto is hit.

global meas                         # measure names.
meas = []
global last_m                       # Previous measure.
last_m = ''                         # Default to none.
global measure_on                   # The measure/unit are we are working on.
measure_on = ''                     # Default to none. This means we are in the header section.
global premeasurecomment            # Collect comments before a new measure for before new measure.
premeasurecomment = {}
premeasurecomment[measure_on] = ''
global measurelinecomment
measurelinecomment = {}
measurelinecomment[measure_on] = ''
global bars                         # number of bars per staff
bars = {}
bars[''] = NUMBER_BARS_PER_STAFF    # for abc notation, put new line in output, which ends staff.

global voices                       # number of voices
voices = 1
global cis                          # If cis active, non-zero. (CIS measure one voice #XX only.)
cis = 0

global vl                           # volume levels
vl = { }                            # vl[voice][m] = volumelevel
vl[1] = { }                         # vl[voice][m] = volumelevel
vl[1][''] = getvar('vfff')                     # vl[voice][m] = volumelevel
global running_vl                   # volume levels changing thru measures. (set vl to running_vl at measure.)
running_vl = { }                    # running_vl[voice][m] = volumelevel
running_vl[1] = { }                 # running_vl[voice][m] = volumelevel
running_vl[1][''] = getvar('vfff')             # running_vl[voice][m] = volumelevel

global xpose                        # The number of semitones to move up/down (positive=up), index by voice.
xpose = {}
global xpose_new_key                # lowercase normal musicomp usage, index by voice.
xpose_new_key = {}

global clef
clef = { }                          # no clef specified [measure][voice].
clef[''] = { }

global vinstrument                  # vinstrument[1234][3] = 'Acoustic Grand Piano'
vinstrument = { }                   # no instruments specified [measure][voice].
vinstrument[''] = {}                # blank measure.
global MIDI_port                    # Which midi port to use for next channel.
MIDI_port = 0
global drums_MIDI_port              # For drums, which midi port to use for next usage.
drums_MIDI_port = 0

global percents
percents = { }                      # no %% passthru commands for start of [measure] (for abc).
percents[''] = []                   # blank measure.

global staves
staves = [ ]

global reverb
reverb = { }                        # Reverb value for voice.
reverb[''] = {}                     # Index by measure then voice.

global pan
pan = { }                           # Pan (balance 0=left, 126=right, 64=center) for voice.
pan[''] = {}                        # Index by measure then voice.

global intensity
intensity = { }                     # Instrument intensity (volume).
intensity[''] = {}                  # Index by measure then voice.

global pitch                        # Pitch change up or down by semitones.
pitch = {}                          # Index by measure.
pitch[''] = 0                       # Before first measure is no pitch.

global cresc_volume
cresc_volume = [ ]
global cresc_time
cresc_time = []
global cresc_direction
cresc_direction = []

global voices_having_notes
voices_having_notes = {}

for i in range(1, MAXVOICES+1):     # This is used as [1] .. [MAXVOICES]
    vinstrument[''][i] = 'Acoustic Grand Piano'.lower()
    reverb[''][i] = getvar('default_reverb')
    pan[''][i] = getvar('default_pan')
    intensity[''][i] = getvar('default_intensity')
    clef[''][i] = {}
    clef[''][i] = 'treble'          # No clef.       (voice, measure)
    xpose[i] = 0
    xpose_new_key[i] = ''           # No new key.   Text!  C for ABC, 0 for fluidsynth.
    cresc_volume.append(0)
    cresc_time.append(0)
    cresc_direction.append(True)
# rof

global inst
inst = { }                          # track using instrument by voice.

global oct                          # default octave
oct = { 1 : 0 }
global acc_v_init                   # Last accidental on a note in measure.
global acc_v_init_v_or_h            # Last accidental on a note in measure.
acc_v_init = { '0C':'', '0D':'', '0E':'', '0F':'', '0G':'', '0A':'', '0B':'',
               '1C':'', '1D':'', '1E':'', '1F':'', '1G':'', '1A':'', '1B':'',
               '2C':'', '2D':'', '2E':'', '2F':'', '2G':'', '2A':'', '2B':'',
               '3C':'', '3D':'', '3E':'', '3F':'', '3G':'', '3A':'', '3B':'',
               '4C':'', '4D':'', '4E':'', '4F':'', '4G':'', '4A':'', '4B':'',
               '5C':'', '5D':'', '5E':'', '5F':'', '5G':'', '5A':'', '5B':'',
               '6C':'', '6D':'', '6E':'', '6F':'', '6G':'', '6A':'', '6B':'',
               '7C':'', '7D':'', '7E':'', '7F':'', '7G':'', '7A':'', '7B':'',
               '8C':'', '8D':'', '8E':'', '8F':'', '8G':'', '8A':'', '8B':''}
acc_v_init_v_or_h = { '0c':'', '0d':'', '0e':'', '0f':'', '0g':'', '0a':'', '0b':'',
                      '1c':'', '1d':'', '1e':'', '1f':'', '1g':'', '1a':'', '1b':'',
                      '2c':'', '2d':'', '2e':'', '2f':'', '2g':'', '2a':'', '2b':'',
                      '3c':'', '3d':'', '3e':'', '3f':'', '3g':'', '3a':'', '3b':'',
                      '4c':'', '4d':'', '4e':'', '4f':'', '4g':'', '4a':'', '4b':'',
                      '5c':'', '5d':'', '5e':'', '5f':'', '5g':'', '5a':'', '5b':'',
                      '6c':'', '6d':'', '6e':'', '6f':'', '6g':'', '6a':'', '6b':'',
                      '7c':'', '7d':'', '7e':'', '7f':'', '7g':'', '7a':'', '7b':'',
                      '8c':'', '8d':'', '8e':'', '8f':'', '8g':'', '8a':'', '8b':''}
global acc_m
acc_m = { '': {''}}                 # voice: {notes:'+'/-/n}    For this measure, index is voice.
#--global last_suffixes_m
#--last_suffixes_m =  { '': {''}}      # ties/legato/etc. on previous measure.
#--                                    # acc_v_init or acc_v_init_v_or_h: note (a-g): last accidental in measure.
global acc_m_xpose
acc_m_xpose = { '': {''}}           # After xpose, the new key ... voice: {notes:'+'/-/n} previous accidental

global time                         # set default note length (time)
time = { 1 : 0 }
global mlth                         # measure length dictionary
mlth = { 1 : { measure_on: 0} }     # nothing in measure working on -- voice 1.
global tlth                         # #or 60ths/voice
tlth = { 1 : 0 }                    # 60ths of a second in a voice -- nothing in measure working on.

global bufs                         # bufs[voice][measure] = text line.
#                                   # ABC format, or musicomp format separated by commas.
bufs = { 1 : {} }

global bufs_length                  # bufs_length[voice][measure][#] ... number= 0..#commas-1 above.
bufs_length = { 1 : {} }

global bufs_velocity                # bufs_velocity[voice][measure][#] ... number= 0..#commas-1 above.
bufs_velocity = { 1 : {} }

# Notes with ties/staccato/legato/etc.
global bufs_suffixes                # bufs_suffixes[voice][measure][#] ... number= 0..#commas-1 above.
bufs_suffixes = { 1: {} }

global bufs_tie_next                # The --horizontal and --verticle have "t" (ties) swapped on where
bufs_tie_next = { 1: '' }           #    the "t" goes on which notes.

global bufs_legato_next
bufs_legato_next = { 1: '' }

global bufs_vol                     # vol(xx) for each note.
bufs_vol = { 1: {} }

global bufs_intensity               # intensity VOICE XXX for each note.
bufs_intensity = { 1: {} }

global pages_to_do
pages_to_do = []                    # argument line limiting which pages to do.
global measures_to_do
measures_to_do = []                 # argument line limiting which measures to do.
global voices_to_do
voices_to_do = []                   # argument line limiting which voices to do.

global iftest                       # check if after if or else.
iftest = { 0:-1 }                   # -1 = processing in if, 0 = skip till else,
#                                   # 1 processing in else, 2 = skip till endif,
#                                   # 3 = skip both if and else.
global ifdepth                      # level of if/else/endif
ifdepth = 0

global cstop_processing
cstop_processing = False            # True if after a cstop.

global macro_internal               # Next internal macro.
macro_internal = 0                  # Number for internal macros (note processing internal macros).
global macro_defining               # If defining macro.
macro_defining = None
global macro_buffer                 # Name of macro, array of lines for macro.
macro_buffer = { '':''}
global macro_arguments              # Name of macro, array of arguments for macro.
macro_arguments = { '':''}
global macro_executing_depth        # If processing macro ... reading from macro buffer.
macro_executing_depth = []          # The macro name currently working on is the last name in the array.
global macro_executing_args         # Depth, array of arguments given to macro.
macro_executing_args = { 0:[] }
global macro_line                   # Depth, line in macro array.
macro_line = { 0:0 }                # Depth, macro name
global macro_i_line                 # Depth, saved i_line in entered macro.
macro_i_line = { 0:[] }             # Depth, i_line when entered macro

global header                       # Header to print at top of file.

global meter
global measure_meter
global measure_meter_value          # Last computed value for above.

global key_default                  # First key applies globally, if not voice number arguments.
key_default = None
global key_voice                    # Running key by measure then voice.
key_voice = { '': {} }

# This should really be 'where it occurs'.
global tempo_speed_default          # beats per minute
tempo_speed_default = 150.0
global default_note_length          # length of a beat (note)
default_note_length = { '': 1.0 / 4.0 } # before a measure.
global tempo_speed_now              # beats per minute for each measure.
tempo_speed_now = { '': tempo_speed_default }
global tempo_now_note_length        # length of a beat (note)
tempo_now_note_length = { '': 1.0 / 4.0 } # before a measure.

global file_name                    # None = use tty.
global output_name                  # File to print to (default is sys.stdout).

global array_of_lines               # For fluidsynth output, have an array of lines.
array_of_lines = []

global fluidsynth_done
fluidsynth_done = False             # Set True if done with midi1csv printing into array and 'quit'.

#-- global first_reset_voice
#-- first_reset_voice = True            # Only do a reset controller with first voice.

# ----------------------------------------------------------------------------
# Returns: lengthl - value given, like 4 for quarter note.
#          lengthf - value in floating, 0.25 for a quarter note.
#          ifokay  - True if everything is okay.
def get_time_stak(timeofnote, line, onvoice):
    global default_note_length          # length of a beat (note)
    global legal_floating_times
    global measure_on
    global args

    if timeofnote <= 0.0:
        print_error("measure={} onvoice={} timeofnote '{}' negative or zero -- cannot play a note backwards.".format(measure_on, onvoice, timeofnote), line)
        return timeofnote, 0, -1    # False
    # fi
    lengthl = []
    lengthf = []
    t = timeofnote
    for i in reversed(range(len(legal_floating_times))):
        f = legal_floating_times[i]
        while True:
            if f > t:
                break
            # fi
            if args.horizontal or args.vertical:
                v = f
                v = 1.0 / v
                if f in legal_mc_notes:
                    vv = legal_mc_notes[f]
                else:
                    vv = str(Fraction(v).limit_denominator(256))
                    if '/' in vv:
                        vv = '(' + str(f) + ')'
                    # fi
                # fi
                v = vv
            elif args.midi1csv or args.fluidsynth:
                v = round((f * 4.0) * MIDICLICKSPERQUARTER)
            else:       # ABC
                v = f / default_note_length[measure_on]
                v = str(Fraction(v).limit_denominator(256))
                if v[0:2] == '1/':
                    v = v[1:]
                # fi
            # fi
            lengthl.append(v)
            lengthf.append(f)
            t = t - f
            if t <= 0:                  # This isn't needed, but makes me more comfortable.
                break
            # fi
        # elihw
    # rof
    if t > 0:
        print_warning("measure={} voice={} timeofnote={} -> {} has left-over of t={}".format(measure_on, onvoice, timeofnote, lengthl, t), line)
        return lengthl, lengthf, 1      # Problems
    # fi
    if not lengthl or len(lengthl) == 0:
        print_error("measure={} voice={} timeofnote '{}' not able to return a usable fraction - min of 1/64".format(measure_on, on_voice, timeofnote), line)
        return timeofnote, 0, -1    # False
    # fi
    return lengthl, lengthf, 0      # True
# End of get_time_stak

# ----------------------------------------------------------------------------
def default_note_text_fraction(m):
    global default_note_length
    global legal_notes

    l = str(Fraction(default_note_length[m]).limit_denominator(256))
    if l not in legal_notes:
        print_warning("#1 Time fraction '{}' is not a printable note. ({})".format(default_note_length[m], l), m)
    # fi
    return(l)
# End of default_note_text_fraction

# ----------------------------------------------------------------------------
def new_voice_initialize(voice, m):
    global vl                           # volume levels
    global vinstrument
    global reverb
    global pan
    global intensity
    global oct                          # default octave
    global time                         # set default note length (time)
    global mlth                         # measure length dictionary
    global tlth                         # #or 60ths/voice
    global bufs
    global bufs_length
    global bufs_velocity
    global bufs_suffixes
    global bufs_tie_next
    global bufs_legato_next
    global bufs_vol
    global bufs_intensity
    global acc_m
    global acc_m_xpose
    global acc_v_init                   # Last accidental on a note in measure.
    global acc_v_init_v_or_h            # Last accidental on a note in measure.
    global args
    global running_vl                   # volume levels changing thru measures.
    global key_default
    global key_voice
    global clef

    if voice not in vl:
        vl[voice] = { }                 # Dictionary
        running_vl[voice] = { }
    if voice not in oct:
        oct[voice] = 0                  # last octave starts at zero
    if voice not in time:
        time[voice] = 0                 # last time starts at zero
    if voice not in mlth:
        mlth[voice] = {}
    if voice not in tlth:
        tlth[voice] = 0                 # #or 60ths/voice
    if voice not in bufs:
        bufs[voice] = {}
        bufs_length[voice] = {}
        bufs_velocity[voice] = {}
        bufs_suffixes[voice] = {}
        bufs_tie_next[voice] = ''
        bufs_legato_next[voice] = ''
        bufs_vol[voice] = {}
        bufs_intensity[voice] = {}
    # fi

    if m not in vl[voice]:
        vl[voice][m] = getvar('vfff')              # start volume out at maximum
        running_vl[voice][m] = getvar('vfff')

    if m not in vinstrument:
        vinstrument[m] = {}
        reverb[m] = {}
        pan[m] = {}
        intensity[m] = {}
    # fi
    if voice not in vinstrument[m]:
        vinstrument[m][voice] = 'Acoustic Grand Piano'.lower()
        reverb[m][voice] = getvar('default_reverb')
        pan[m][voice] = getvar('default_pan')
        intensity[m][voice] = getvar('default_intensity')

    if m not in key_voice:
        key_voice[m] = {}
    # fi
    if voice not in key_voice[m]:
        key_voice[m][voice] = key_default
    # fi

    if m not in mlth[voice]:
        mlth[voice][m] = 0              # measure length dictionary
    # fi
    if voice not in acc_m:
        if args.horizontal or args.vertical:
            acc_m[voice] =  {k: v for k, v in acc_v_init_v_or_h.items()}
            acc_m_xpose[voice] =  {k: v for k, v in acc_v_init_v_or_h.items()}
        elif args.midi1csv or args.fluidsynth:
            acc_m[voice] =  {k: v for k, v in acc_v_init_v_or_h.items()}
            acc_m_xpose[voice] =  {k: v for k, v in acc_v_init_v_or_h.items()}
        else:           # ABC
            acc_m[voice] =  {k: v for k, v in acc_v_init.items()}
            acc_m_xpose[voice] =  {k: v for k, v in acc_v_init.items()}
        # fi
    # fi

    for j in vl:
        if m not in clef:
            clef[m] = {}
        # fi
        if m not in clef or j not in clef[m]:
            for k in reversed(range(0, len(meas)-1)):
                mmm = meas[k]
                if mmm in clef and j in clef[mmm]:
                    nc = clef[mmm][j]
                    break
                # fi
            # rof
        else:
            nc = clef[m][j]
        # fi
        clef[m][j] = nc
    # rof
    return
# End of new_voice_initialize

# ----------------------------------------------------------------------------
# Get volume levels at measures -- the volume(s) commands work at that point..
def get_volume_level(m, voice):
    global vl                           # volume levels
    global vlprint
    global args
    global DECORATIONS

    new_voice_initialize(voice, m)
    j = vl[voice][m]                    # volume level for this voice/measure
    if args.horizontal or args.vertical:
        return j
    # fi
    if args.midi1csv or args.fluidsynth:
        return j
    # fi
    j = vol_to_vlprint_round(j)
    p = vlprint[j]
    return (DECORATIONS + p + DECORATIONS)
# End of get_volume_level

# ----------------------------------------------------------------------------
def rests_in_empty_measure_voices(m, voice):
    global vl                               # volume levels
    global meas
    global mlth
    global bufs
    global bufs_length
    global bufs_velocity
    global bufs_suffixes
    global bufs_tie_next
    global bufs_legato_next
    global bufs_vol
    global bufs_intensity
    global args
    global running_vl

    if m in bufs[voice]:                    # Already present, then of right length.
        return
    # fi
    # No text for this voice, create rests to fill it out.
    l = 0
    for i in range(1, len(vl)+1):
        if m in mlth[i]:
            l = max(mlth[i][m], l)
        # fi
    # rof
    if m in mlth[voice]:
        l = l - mlth[voice][m]              # All measure lengths with voices are the same.
    # fi
    if m not in bufs[voice]:
        bufs_vol[voice][m] = []
        bufs_intensity[voice][m] = []
        if args.horizontal or args.vertical or args.midi1csv or args.fluidsynth:
            bufs[voice][m] = []
            bufs_length[voice][m] = []
            bufs_velocity[voice][m] = []
            bufs_suffixes[voice][m] = []
            bufs_tie_next[voice] = ''
            bufs_legato_next[voice] = ''
        else:       # ABC
            bufs[voice][m] = ''
        # fi
    # fi
    if voice in running_vl and m in running_vl[voice]:
        tt = running_vl[voice][m]
    else:
        tt = 127                            # Probably a rest, put as full volume.
    # fi
    bufs_vol[voice][m].append(tt)
    if m not in intensity or voice not in intensity[m] or voice not in bufs_intensity or m not in bufs_intensity[voice]:
        print_error('I expect voice {} has notes in measure {}, but the "voice" command is less than that.'.format(m,voice), 'pass2')
    # fi
    bufs_intensity[voice][m].append(intensity[m][voice])
    # Put out rests.
    if l <= 0:                              # if nothing to do.
        return
    # fi
    txt = ''
    if args.horizontal or args.vertical or args.midi1csv or args.fluidsynth:
        pass
    else:       # ABC
        lengthl, lengthf, ifokay = get_time_stak(l, 'pass2', voice)
        for i in range(len(lengthl)):
            txt = txt + ' z' + lengthl[i]       # entry in array
        # rof
        if txt == '':
            print_error('no music for voice {} in measure {}'.format(voice, m), 'pass2')
            return
        # fi
    # fi

    bufs_tie_next[voice] = ''
    bufs_legato_next[voice] = ''
    if args.horizontal or args.vertical:
        bufs[voice][m].append('r')
        bufs_length[voice][m].append(l)
        bufs_velocity[voice][m].append(getvar('default_velocity'))
        bufs_suffixes[voice][m].append('')
    elif args.midi1csv or args.fluidsynth:
        bufs[voice][m].append(0)
        bufs_length[voice][m].append(l)
        bufs_velocity[voice][m].append(getvar('default_velocity'))
        bufs_suffixes[voice][m].append('')
    else:       # ABC
        bufs[voice][m] = bufs[voice][m] + txt   # Append the sleeps.
    # fi
    return
# End of rests_in_empty_measure_voices

# ----------------------------------------------------------------------------
def print_measure_abc(m, print_V, voice, l_meter, l_tempo, l_dl, l_clef, l_instrument, l_vl, l_txt, l_ky, l_pitch):
    global bufs
    global measure_meter
    global clef
    global meas
    global vinstrument
    global reverb
    global pan
    global intensity
    global key_voice                        # Running key by voice.
    global tempo_speed_now
    global pitch

    if voice not in bufs:
        return "ERROR - bufs voice dictionary is hosed.", '', '', '', '', '', '', '', ''
    # fi
    pr = l_txt

    # if first measure, and doing voice, output V:# line.
    if m == meas[0] or (m in clef and voice in clef[m] and l_clef != clef[m][voice]):
        if pr != '' and pr[-1] != '\n':
            pr = pr + '\n'
        # fi
        pr = pr + "V:{}".format(print_V)
        if m in clef and voice in clef[m]:
            if clef[m][voice] != l_clef:
                l_clef = clef[m][voice]
                pr = pr + ' clef={}'.format(l_clef)
            # fi
        # fi
        pr = pr + '\n'
    # fi

    if pitch[m] != l_pitch:
        if pr != '' and pr[-1] != '\n':
            pr = pr + '\n'
        # fi
        l_pitch = pitch[m]
        pr = pr + '%% pitch    {}'.format(l_pitch) + '\n'
    # fi

    if voice not in vinstrument[m]:
        vinstrument[m][voice] = 'Acoustic Grand Piano'.lower()
        reverb[m][voice] = getvar('default_reverb')
        pan[m][voice] = getvar('default_pan')
        intensity[m][voice] = getvar('default_intensity')
    # fi

    if len(vinstrument[m]) >= voice and vinstrument[m][voice] != 'Acoustic Grand Piano'.lower():
        if l_instrument != vinstrument[m][voice]:
            l_instrument = vinstrument[m][voice]
            if pr != '' and pr[-1] != '\n':
                pr = pr + '\\\n'
            # fi
            if l_instrument in instruments:
                pr = pr + "%%MIDI program {}\n".format((instruments[l_instrument])[0])
            elif l_instrument in drum_sounds:
                pr = pr + "%%MIDI program {}\n".format((drum_sounds[l_instrument]))
            else:
                print_warning_no_line("print_measure_abc - voice#{} measure#{} instrument {} not acceptable!".format(voice, m, vinstrument[m][voice]))
            # fi
        # fi
    # fi


    if m == meas[0]:
        flag = False
        for M in goto_table:
            for G in goto_table[M]:
                pr = pr + '|:'
                flag = True
                break
            # rof
            if flag:
                break
            # fi
        # rof
    # fi

    # if default note length != last one
    if l_dl != default_note_text_fraction(m):
        l_dl = default_note_text_fraction(m)
        if l_dl == '1':
            l_dl = '1/1'
        else:
            l_dl = l_dl
        # fi
        pr = pr + "[L:{}]".format(l_dl)
    # fi

    if l_tempo != tempo_speed_now[m]:
        l_tempo = tempo_speed_now[m]
        pr = pr + "[Q:{}={}]".format(l_dl, l_tempo)
    # fi

    vvv = voice
    if vvv in key_voice[m]:
        if l_ky != key_voice[m][vvv]:
            ky = key_voice[m][vvv]
            if ky == 'atonal':
                ky = 'C'
            # fi
            pr = pr + "[K:{}]".format(ky)
            l_ky = ky
        # fi
    # fi
    # if meter != last one
    if l_meter != measure_meter[m]:
        l_meter = measure_meter[m]
        pr = pr + "[M:{}]".format(l_meter)
    # fi
    j = get_volume_level(m, voice)
    v_vl = j

    if v_vl != l_vl:
        pr = pr + v_vl
        l_vl = v_vl
    # fi
    pr = pr + bufs[voice][m] + ' |'
    return pr, l_meter, l_tempo, l_dl, l_clef, l_instrument, l_vl, l_ky, l_pitch
# End of print_measure_abc

# ----------------------------------------------------------------------------
def print_out_abc():
    global vl                               # volume levels
    global meas                             # measures
    global bars                             # number of bars per staff
    global key_default
    global voices_to_do
    global args

    printed_V = 0

    #-- for voice in reversed(range(1, len(vl)+1)):
    for voice in range(1, len(vl)+1):
        if args.voices and args.voices != '':
            if str(voice) not in voices_to_do:
                continue
            # fi
        # fi
        printed_V += 1
        if printed_V > MAXABCVOICES:
            print_error_no_line("voice ({}) - printed_V ({}) > {} abc voices".format(voice,printed_V,MAXABCVOICES))
        # fi
        print_output("% --- voice " + str(voice) + '  ---')
        l_meter = l_dl = l_clef = l_instrument = l_vl = ''
        l_ky = key_default
        l_tempo = ''
        l_pitch = ''
        print_line = ''

        bar = 0
        bar_print = 0
        last_bar = bars['']
        print_output(print_line + "%abc %%barsperstaff {}".format(last_bar))
        first_goto = True
        for i in range(0, len(meas)):
            bar = bar + 1
            m = meas[i]
            if (bar > int(last_bar) + bar_print):                # Zero-th one is ''.
                if print_line != '' and print_line[-1] != '\n':
                    print_line = print_line + '\n'
                # fi
                print_output(print_line + "% measure {}".format(m))
                print_line = ''
                bar_print = i
            # fi
            if last_bar != bars[m]:            # Zero-th one is ''.
                if print_line != '' and print_line[-1] != '\n':
                    print_line = print_line + '\n'
                # fi
                last_bar = bars[m]
                print_line = print_line + "%abc %%barsperstaff {}\n".format(last_bar)
            # fi

            if m in percents:
                if print_line != '' and print_line[-1] != '\n':
                    print_line = print_line + '\\n'
                # fi
                for p in percents[m]:
                    print_line = print_line + p + '\n'
                # rof
            # fi

            print_line, l_meter, l_tempo, l_dl, l_clef, l_instrument, l_vl, l_ky, l_pitch = print_measure_abc(m,
                        printed_V, voice, l_meter, l_tempo, l_dl, l_clef, l_instrument, l_vl, print_line, l_ky, l_pitch)

            if m in goto_table and goto_table[m] != '':
                print_warning_no_line("goto in measure {} not handled.".format(m))
                if print_line != '' and print_line[-1] != '\n' and print_line[-1] == '|' and first_goto:
                    print_line = print_line[:-1] + ':|'
                    first_goto = False
                # fi
            # fi

        # rof
        if print_line != '':
            print_line = print_line + ']'
            print_output(print_line)
        # fi
    # fi
    return
# End of print_out_abc

# ----------------------------------------------------------------------------
# input:
#   m               The measure.
#   l_meter         Last meter.
#   l_clef          Last clef for voices.
#   l_instrument    Last Instrument for voices.
#   l_vl            Last volume array for voices.
#   l_txt           (print_line entry)
#   l_ky            Last key for this voice.
#   l_tempo         Last tempo
#   l_t_n_l         Last tempo note length.
# returns:
#   print_line
#   l_meter
#   l_dl
#   l_clef
#   l_instrument
#   l_vl
#   l_ky
#   l_tempo
#   l_t_n_l

#   measure xyz
#   meter   x/y
#   clef    abc,def,ghi,jkl,mno,pqr
#   volume  4,5,6,7,6,5
#   tempo   100,4
#   voice   6   30,40,50,60,70,80           $$ needed if volume changes.
#   v1: 3c4, ...
#   vX: 3e4, ...

def print_measure_vh_header(m, l_meter, l_clef, l_instrument, l_vl, l_txt, l_ky, l_tempo, l_t_n_l, l_pitch):
    global vl
    global measure_meter
    global clef
    global vinstrument
    global key_voice
    global tempo_speed_now
    global tempo_now_note_length
    global pitch
    global args
    global voices_to_do

    pr = ''
    n_meter = ''
    n_clef = ''
    n_instrument = []
    n_vl = ''

    if premeasurecomment[m] != '':
        pr = pr + premeasurecomment[m]
    # fi
    pr = pr + "measure {}".format(m)
    if measurelinecomment[m] != '':
        pr = pr + '     ' + measurelinecomment[m]
    # fi
    pr = pr + "\n"

    n_meter = measure_meter[m]
    if l_meter != n_meter:
        pr = pr + 'meter   {}\n'.format(n_meter)
    # fi

    n_clef = ''
    for voice in range(1, len(vl)+1):
        if args.voices and args.voices != '':
            if str(voice) not in voices_to_do:
                continue
            # fi
        # fi
        if m in clef and voice in clef[m]:
            t = str(clef[m][voice])
            if n_clef == '':
                n_clef = t
            else:
                n_clef = n_clef + ',' + t
            # fi
        # fi
    # rof
    if l_clef != n_clef:
        pr = pr + 'clef    {}\n'.format(n_clef)
    # fi

    pv = False

    for voice in range(1, len(vl)+1):
        if args.voices and args.voices != '':
            if str(voice) not in voices_to_do:
                continue
            # fi
        # fi
        new_voice_initialize(voice, m)
        t = str(get_volume_level(m, voice))
        for j in vlprint:
            if t == str(j):
                t = vlprint[j]
                break
            # fi
        # rof
        if n_vl == '':
            n_vl = t
        else:
            n_vl = n_vl + ',' + t
        # fi
    # rof
    if l_vl != n_vl:
        p_vl = n_vl
        for j in vlprint:
            if n_vl == j:
                p_vl = vlprint[j]
                break
            # fi
        # rof
        pr = pr + 'volumes {}\n'.format(p_vl)
        pv = True
    # fi

    for voice in range(1, len(vl)+1):
        if args.voices and args.voices != '':
            if str(voice) not in voices_to_do:
                continue
            # fi
        # fi
        if voice in vinstrument[m]:
            stri = ''
            if vinstrument[m][voice] in instruments.values():
                for x in instruments:
                    if vinstrument[m][voice] == instruments[x]:
                        stri = x
                        break
                    # fi
                # rof
            # fi
            if stri == '':
                for x in drum_sounds:
                    if vinstrument[m][voice] == x:
                        stri = x
                        break
                    # fi
                # rof
            # fi
            n_instrument.append('instrument {} {}'.format(voice, vinstrument[m][voice]))
        else:
            n_instrument.append('instrument {} Acoustic Grand Piano'.format(voice))
        # fi
    # rof

    if l_instrument != n_instrument or pv:
        if n_instrument != []:
            pr = pr + 'voice   {}\n'.format(len(vl))
            for x in range(0, len(vl)):
                if (x >= len(l_instrument) or l_instrument[x] != n_instrument[x]) and x < len(n_instrument):
                    pr = pr + '{}\n'.format(n_instrument[x])
                # fi
            # rof
        else:
            pr = pr + 'voice   {}\n'.format(len(vl))
        # fi
    # fi

    for voice in range(1, len(vl)+1):
        if args.voices and args.voices != '':
            if str(voice) not in voices_to_do:
                continue
            # fi
        # fi
        if voice in key_voice[m]:
            if l_ky[voice] != key_voice[m][voice]:
                l_ky[voice] = key_voice[m][voice]
                pr = pr + "key     {}  {}\n".format(voice, l_ky[voice])
                # NOTE: key printed out does not reflect new one of xpose. WARNING!
            # fi
        # fi
    # rof

    if l_pitch != pitch[m]:
        l_pitch = pitch[m]
        pr = pr + "pitch   {}\n".format(l_pitch)
    # fi

    if l_tempo != tempo_speed_now[m] or l_t_n_l != tempo_now_note_length[m]:
        l_tempo = tempo_speed_now[m]
        l_t_n_l = tempo_now_note_length[m]
        l = str(Fraction(1.0 / l_t_n_l).limit_denominator(256))
        j = l_tempo
        k = int(l_tempo)
        if (j - float(k)) * 1000 == 0:
            p = str(k)
        else:
            p = l_tempo
        # fi
        pr = pr + "tempo   {},{}\n".format(p, l)
    # fi

    pr = l_txt + pr
    return pr, n_meter, n_clef, n_instrument, n_vl, l_ky, l_tempo, l_t_n_l, l_pitch
# End of print_measure_vh_header

# ----------------------------------------------------------------------------
def print_out_notes_v_or_h(m, print_line):
    global args
    global vl
    global bufs
    global bufs_length
    global bufs_velocity
    global bufs_suffixes
    global args
    global voices_to_do

    if args.vertical:
        txt = ''
        for voice in range(1, len(vl)+1):
            if args.voices and args.voices != '':
                if str(voice) not in voices_to_do:
                    continue
                # fi
            # fi
            if len(bufs[voice][m]) == 0:
                continue
            # fi
            txt = txt + "v{}: ".format(voice)
            for i in range(0, len(bufs[voice][m])):
                if i != 0:
                    txt = txt + ','
                # fi
                l =  bufs_length[voice][m][i]
                # NOTDONEYET - bufs_velocity[voice][m][i]
                if l in legal_mc_notes:
                    lth = legal_mc_notes[l]
                else:
                    lth = str(Fraction(l).limit_denominator(256))
                    if '/' in lth:
                        lth = '(' + str(l) + ')'
                    # fi
                # fi
                txt = txt + bufs[voice][m][i] + lth + bufs_suffixes[voice][m][i].replace('c','')
            # rof
            txt = txt + '\n'
        # rof
        print_line = print_line + txt
        return print_line
    # fi
    # else - horizontal

    ml = mlth[1][m]
    for i in range(1, len(vl)+1):
        if args.voices and args.voices != '':
            if str(i) not in voices_to_do:
                continue
            # fi
        # fi
        if m in mlth[i]:
            if mlth[i][m] != ml:
                print_error_no_line("voice#{} measure#{} not same length({}) as 1st({})".format(i, m, mlth[i][m], ml))
            # fi
            ml = max(mlth[i][m], ml)
        else:
            print_error_no_line("voice#{} not in measure#{}".format(i, m))
        # fi
    # rof
    workingtime = [ 0 ]                         # Zero is ignored.
    working= [ 0 ]
    for voice in range(1, len(vl)+1):
        working.append(0)
        workingtime.append(0)
    # rof

    now = 0
    txt = ''
    while now < ml:
        for voice in range(1, len(vl)+1):
            if args.voices and args.voices != '':
                if str(voice) not in voices_to_do:
                    continue
                # fi
            # fi
            if txt != '':
                txt = txt + ','
            # fi
            i = workingtime[voice]
            if i <= now:
                j = working[voice]
                l =  bufs_length[voice][m][j]
                # NOTDONEYET - bufs_velocity[voice][m][j]

                if l in legal_mc_notes:
                    lth = legal_mc_notes[l] + bufs_suffixes[voice][m][j].replace('c','')
                else:
                    lth = str(Fraction(l).limit_denominator(256))
                    if '/' in lth:
                        lth = '(' + str(l) + ')'
                    # fi
                    lth = lth + bufs_suffixes[voice][m][j].replace('c','')
                # fi
                txt = txt + bufs[voice][m][j] + lth
                workingtime[voice] = workingtime[voice] + l
                working[voice] = working[voice] + 1
            # fi
        # rof
        print_line = print_line + txt + '\n'
        txt = ''
        nextmin = 999999
        for voice in range(1, len(vl)+1):
            if args.voices and args.voices != '':
                if str(voice) not in voices_to_do:
                    continue
                # fi
            # fi
            if workingtime[voice] < nextmin:
                nextmin = workingtime[voice]
            # fi
        # rof
        now = nextmin
    # elihw
    return print_line
#   End of print_out_notes_v_or_h

# ----------------------------------------------------------------------------
# Vertical and horizontal have:
#   A header (meter, key, title, etc.)
#   voice   #
#   measure xyz
#   meter   x/y
#   clef    abc,def,ghi,jkl,mno,pqr
#   #-- volume  4,5,6,7,6,5
#   tempo   100,4
#   voice   6   30,40,50,60,70,80           $$ needed if volume changes.
#   v1: 3c4, ...
#   vX: ...
#
# NOTE: --voices does not affect this, otherwise it don't work.
def print_out_v_or_h():
    global vl                               # volume levels
    global meas                             # measures
    global args
    global key_default
    global tempo_speed_default
    global default_note_length
    global pitch

    print_output('voice   {}'.format(len(vl)))

    l_meter = ''
    l_clef = []
    l_vl = []
    l_instrument = []
    l_ky = [ '' ]
    for voice in range(1, len(vl)+1):
        l_ky.append(key_default)
    # fi
    l_tempo = tempo_speed_default
    l_t_n_l = default_note_length['']
    print_line = ''
    l_pitch = pitch['']

    bar_print = bars['']

    for i in range(0, len(meas)):
        m = meas[i]
        if args.horizontal and m == meas[0] and len(vl) > 1:
            print_line = print_line + "* 1"
            for j in range(2, len(vl)+1):
                print_line = print_line + ",{:>3s}".format(str(j))
            # rof
            print_line = print_line + '\n'
        # fi

        if m in percents:
            print_line = print_line + '\n'
            for p in percents[m]:
                print_line = print_line + p + '\n'
            # rof
        # fi

        print_line, l_meter, l_clef, l_instrument, l_vl, l_ky, l_tempo, l_t_n_l, l_pitch = print_measure_vh_header(m,
                    l_meter, l_clef, l_instrument, l_vl, print_line, l_ky, l_tempo, l_t_n_l, l_pitch)

        if bar_print != bars[m]:            # Zero-th one is ''.
            print_line = print_line + "bars    {}\n".format(bars[m])
            bar_print = bars[m]
        # fi

        # Print out notes for measure.
        print_line = print_out_notes_v_or_h(m, print_line)

        if m in goto_table and goto_table[m] != '':
            print_line = print_line + 'goto    ' + ','.join(goto_table[m]) + '\n'
        # fi
    # rof
    if print_line != '':
        print_output_no_eol(print_line)
    # fi
    return
# End of print_out_v_or_h

# ----------------------------------------------------------------------------
def print_out_midi1csv_start(voiceon):
#--    global first_reset_voice
    print_output('{}, 0, Start_track'.format(voiceon+1))
#--    if first_reset_voice:
        # 121   Reset all Controllers.
#--        print_output('{}, 0, Control_c, 0, 121, 0'.format(voiceon+1))
#--        first_reset_voice = False
#--    # fi
    print_output('{}, 0, Control_c, 0, 121, 0'.format(voiceon+1))
#   End of print_out_midi1csv_start

# ----------------------------------------------------------------------------
def print_out_midi1csv_end(voiceon, lthworkingmeasures):
    print_output('{}, {}, End_track'.format(voiceon+1, lthworkingmeasures + int(clicks_at_end_of_piece)))
#   End of print_out_midi1csv_end

# ----------------------------------------------------------------------------
# Time Signature / meter.
# returns lastmeter printed (which this routine may update).
def print_out_midi1csv_ts(m, voiceon, lthworkingmeasure, last_bar_meter):
    global meas
    global measure_meter

    if last_bar_meter != measure_meter[m]:
        last_bar_meter = measure_meter[m]
        l = last_bar_meter.split('/', 1)
        numerator = l[0]
        denominator = Log2(l[1])
        if denominator.is_integer():
            denominator = int(denominator)
        else:
            denominator = l[1]
            print_error_no_line("meter denominator is not a power of two, leave as {}".format(denominator))
        # fi
        print_output("{}, {}, Time_signature, {}, {}, 48, 8".format(
                voiceon+1, int(round(lthworkingmeasure)), numerator, denominator))
    # fi
    return last_bar_meter
# End of print_out_midi1csv_ts

# ----------------------------------------------------------------------------
# input   m_number, voiceon, lthworkingmeasure, last_instrument, channel, chan
# returns last_instrument_on printed (which this routine may update).
#         channel (which may be updated).
#         chan (which may be updated).
def print_out_midi1csv_instrument(m, voiceon, lthworkingmeasure, last_instrument_on, channel, chan):
    global vinstrument
    global reverb
    global pan
    global intensity
    global meas
    global inst
    global mlth
    global args
    global MIDI_port
    global drums_MIDI_port
    global drum_sounds

    if voiceon not in vinstrument[m]:
        vinstrument[m][voiceon] = 'Acoustic Grand Piano'.lower()
        reverb[m][voiceon] = getvar('default_reverb')
        pan[m][voiceon] = getvar('default_pan')
        intensity[m][voiceon] = getvar('default_intensity')
    # fi
    if len(vinstrument[m]) >= voiceon:
        if last_instrument_on != vinstrument[m][voiceon]:
            last_instrument_on = vinstrument[m][voiceon]
            this_drum_on = False
            lit = None
            for q in instruments:
                if q == last_instrument_on:
                    lit = instruments[last_instrument_on]
                    break
                # fi
            # rof
            if lit is None:
                for q in drum_sounds:
                    if q == last_instrument_on:
                        lit = drum_sounds[last_instrument_on]
                        this_drum_on = True
                        break
                    # fi
            # rof
            if lit is None:
                print_error_no_line("Instrument {} not found.".format(last_instrument_on))
                return
            # fi
            if voiceon not in inst:
                inst[voiceon] = {}
            # fi
            if last_instrument_on not in inst[voiceon]:
                if this_drum_on:
                    # MIDI_port -- channel = 9, get note to play from instruments[last_instrument_on].
                    inst[voiceon][last_instrument_on] = [drums_MIDI_port, 9]
                    drums_MIDI_port = drums_MIDI_port + 1
                    chan = 9
                else:
                    chan = channel
                    # MIDI_port, channel to use for notes. (chan != 9 to play note as it is.)
                    inst[voiceon][last_instrument_on] = [MIDI_port, chan]
                    channel = channel + 1
                    if channel == 9:
                        channel = 10
                    elif channel >= MAXMIDICHANNELS and args.midi1csv:
                        print_error_no_line("Voice {} Instrument {} puts midi channels {} > {}.".format(voiceon, last_instrument_on, channel, MAXMIDICHANNELS))
# There are only 16 channels. No more can be fudged. You can have more instruments, but not channels.
                        MIDI_port = MIDI_port + 1
#--                        channel = 0
                    # fi
                # fi
            # fi
            q = mlth[voiceon][m]
            [midiport, chan] = inst[voiceon][last_instrument_on]    # previously on this voice.
            if last_instrument_on in instruments:
                lit = instruments[last_instrument_on]
                print_output('{}, {}, Control_c, {}, 0, {}'.format(voiceon+1, lthworkingmeasure, chan, lit[1] >> 5))
                print_output('{}, {}, Control_c, {}, 32, {}'.format(voiceon+1, lthworkingmeasure, chan, lit[1] & 0x1f))
                if not args.fluidsynth:
                    print_output('{}, {}, Title_t, "{}"'.format(voiceon+1, lthworkingmeasure, last_instrument_on))
                    print_output('{}, {}, MIDI_port, {}'.format(voiceon+1, lthworkingmeasure, midiport))
                    print_output('{}, {}, Program_c, {}, {}'.format(voiceon+1, lthworkingmeasure, chan, lit[0]))
                else:
                    print_output('{}, {}, Program_c, {}, {}, {}'.format(voiceon+1, lthworkingmeasure, chan, lit[0], lit[1]))
                # fi
            elif last_instrument_on in drum_sounds:
                if not args.fluidsynth:
                    print_output('{}, {}, MIDI_port, {}'.format(voiceon+1, lthworkingmeasure, midiport))
                    print_output('{}, {}, Program_c, {}, {}'.format(voiceon+1, lthworkingmeasure, 9, 0))
                else:
                    print_output('{}, {}, Program_c, {}, {}, {}'.format(voiceon+1, lthworkingmeasure, 9, 0, 0))
                # fi
            else:
                print_error_no_line("instrument not in instruments nor drum_sounds.")
            # fi
#????            # 125   Omni Mode On (and all notes off).
#????            print_output('{}, {}, Control_c, {}, 125, 0'.format(voiceon+1, lthworkingmeasure, chan))
#????            # 127   Set device mode to Polyphonic.
#????            print_output('{}, {}, Control_c, {}, 127, 0'.format(voiceon+1, lthworkingmeasure, chan))
            # 121   Reset all Controllers.
            # print_output('{}, {}, Control_c, {}, 121, 0'.format(voiceon+1, lthworkingmeasure, chan))
            #   7   Volume
            print_output('{}, {}, Control_c, {}, {}, {}'.format(voiceon+1, lthworkingmeasure, chan, 7,
                                                    intensity[m][voiceon]))
            #   5   Portamento Time to 0. (No slide between two notes subsequently, without off between.)
            print_output('{}, {}, Control_c, {}, 5, 0'.format(voiceon+1, lthworkingmeasure, chan))
            #  65   Portamento Off. Note: can still portamento - stupid standard.
            print_output('{}, {}, Control_c, {}, 65, 0'.format(voiceon+1, lthworkingmeasure, chan))
            #  68   Legato Off.
            print_output('{}, {}, Control_c, {}, 68, 0'.format(voiceon+1, lthworkingmeasure, chan))
            #  64   Hold Pedal Off
            print_output('{}, {}, Control_c, {}, {}, {}'.format(voiceon+1, lthworkingmeasure, chan, 64, 0))
            #  10   Pan position   64 is center, 0 is hard left, and 127 is hard right.
            print_output('{}, {}, Control_c, {}, {}, {}'.format(voiceon+1, lthworkingmeasure, chan, 10,
                                                    pan[m][voiceon]))
            #  91   Reverb Level
            print_output('{}, {}, Control_c, {}, {}, {}'.format(voiceon+1, lthworkingmeasure, chan, 91,
                                                    reverb[m][voiceon]))
        # fi
    # fi
    return last_instrument_on, channel, chan
# End of print_out_midi1csv_instrument

# ----------------------------------------------------------------------------
def print_out_midi1csv_tempo(m, voiceon, lthworkingmeasure, t, l):
    global tempo_speed_default
    global default_note_length
    global tempo_speed_now
    global tempo_now_note_length

    if (m in tempo_speed_now and t != tempo_speed_now[m]) or (m in tempo_now_note_length and l != tempo_now_note_length[m]):
        t = tempo_speed_now[m]
        l = tempo_now_note_length[m]
    else:
        return t, l
    # fi
    if args.fluidsynth:
        print_output("{}, {}, Tempo, {} {}".format(voiceon+1, lthworkingmeasure, t, l))
    else:
        X = int(round((60.0 * 1000000.0) / ((4.0 * l)) / t))
        print_output("{}, {}, Tempo, {}".format(voiceon+1, lthworkingmeasure, X))
    # fi
    return  t, l
# End of print_out_midi1csv_tempo

# ----------------------------------------------------------------------------
def print_out_midi1csv_keysignature(m, voiceon, lthworkingmeasure, last_keysig):
    global key_default
    global key_voice

    if lthworkingmeasure == 0 and m == '':
        if key_default is None or key_default == 'atonal':
            key_default = 0
        # fi
        last_keysig = key_default
        print_output('{}, {}, Key_signature, {}, "major"'.format(voiceon+1, lthworkingmeasure, last_keysig))
    else:
        if m in key_voice and voiceon in key_voice[m] and last_keysig != key_voice[m][voiceon]:
            if key_voice[m][voiceon] is None or key_voice[m][voiceon] == 'atonal':
                key_voice[m][voiceon] = 0
            # fi
            last_keysig = key_voice[m][voiceon]
            print_output('{}, {}, Key_signature, {}, "major"'.format(voiceon+1, lthworkingmeasure, last_keysig))
        # fi
    # fi
    return  last_keysig
# End of print_out_midi1csv_keysignature

# ----------------------------------------------------------------------------
def print_header():
    global header
    global tempo_speed_default
    global default_note_length          # length of a beat (note)
    global args
    global vl
    global bars
    global key_voice
    global key_default
    global measure_meter
    global mlth

    if args.vertical or args.horizontal:
        l = str(Fraction(1.0 / default_note_length['']).limit_denominator(256))
        header = header + "bars    {}\n".format(bars[''])

        j = tempo_speed_default
        k = int(tempo_speed_default)
        if (j - float(k)) * 1000 == 0:
            p = str(k)
        else:
            p = tempo_speed_default
        # fi
        header = header + "tempo   {},{}\n".format(p, l)
        header = header + "key     {}".format(key_default)       # no \n, added when printed.
        for ve in range(1, len(vl) + 1):
            if ve in key_voice[''] and key_voice[''][ve] != key_default:
                header = header + "\nkey     {}  {}".format(ve, key_voice[''][ve]) # No terminating \n.
            # fi
        # rof
    elif args.midi1csv:
# 0, 0, Header, 1, 7, 480               # 480 = midi ticks per quarter note.
        print_output("0, 0, Header, 1, {}, {}".format(len(vl)+1, int(round(MIDICLICKSPERQUARTER))))
# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
# First track does all tempo's, time and key signatures, and titles.
        print_out_midi1csv_start(0)
# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
# 1, 0, Title_t, "promenade"
        for t in header:
            print_output('1, 0, Title_t, "{}"'.format(t))
        # rof
# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
# 1, 0, Key_signature, -2, "major"
        last_keysig = print_out_midi1csv_keysignature('' , 0, 0, '')
# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
        # Get the voice with the most notes.
        # Does not do goto's, but that's okay enough -- all voices should be filled.
        maxtimelth = 0
        voice = 1
        for i in tlth:
            if maxtimelth < tlth[i]:
                maxtimelth = tlth[i]
                voice = i
            # fi
        # rof
# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
# 1, 0, Time_signature, 4, 2, 48, 8
# 2, 0, Time_signature, 5, 2, 30, 8
# 2, 2400, Time_signature, 6, 2, 72, 8
#           FF 58 04 nn dd cc bb Time Signature
#       The time signature is expressed as four numbers. nn and dd represent the
#       numerator and denominator of the time signature as it would be notated.
#       The denominator is a negative power of two: 2 represents a quarter-note,
#       3 represents an eighth-note, etc.
#       The cc parameter expresses the number of MIDI clocks in a metronome click.
#       The bb parameter expresses the number of notated 32nd-notes in what MIDI
#       thinks of as a quarter-note (24 MIDI Clocks). This was added because there
#       are already multiple programs which allow the user to specify that what
#       MIDI thinks of as a quarter-note (24 clocks) is to be notated as, or
#       related to in terms of, something else. Therefore, the complete event for
#       6/8 time, where the metronome clicks every three eighth-notes, but there
#       are 24 clocks per quarter-note, 72 to the bar, would be (in hex):
#           FF 58 04 06 03 24 08
#    4/(2^2)   72
# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
        # length of each measure. Index via [voice][measure].
        lthworkingmeasure = 0
        lastmeter = ''
        lasttempospeed = ''
        lasttempo_n_l = ''
        last_keysig = ''

        for v in goto_table:
            goto_variables[v] = 0           # This voice hasn't done any goto's yet.
        # rof

        m_number = 0
        while m_number < len(meas):
            m = meas[m_number]

            lastmeter = print_out_midi1csv_ts(m, 0, lthworkingmeasure, lastmeter)
            lasttempospeed, lasttempo_n_l = print_out_midi1csv_tempo(m , 0, lthworkingmeasure, lasttempospeed, lasttempo_n_l)
            # Do not do instruments here.
            lthworkingmeasure = lthworkingmeasure + mlth[voice][m]

            if m in goto_table:             # If goto exists, process it.
                f = goto_variables[m]
                g = goto_table[m][f]
#++                print_warning_no_line("goto at end measure={} value={} new_measure={}".format(m, f, g))
                if f+1 >= len(goto_table[m]): # If should start over.
                    f = 0
                else:
                    f = f + 1
                # fi
                goto_variables[m] = f
                if g == 'x':
                    m_number = m_number + 1
                else:
                    m_number = meas.index(g)
                # fi
            else:
                m_number = m_number + 1
            # fi
        # elihw
# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
        print_out_midi1csv_end(0, lthworkingmeasure)
        return
    elif args.fluidsynth:
        # set audio.coreaudio.device coreaudio
        print_output("0, 0, FS, set audio.driver coreaudio")
        print_output("0, 0, FS, set midi.driver coremidi")
        # set synth.chorus.active off
        # set synth.cpu-cores 2
        if not args.two:
            print_output("0, 0, FS, set synth.default-soundfont /Users/m4/src/GeneralUser_GS/GeneralUser_GS.sf2")
        else:
            print_output("0, 0, FS, set synth.default-soundfont /Users/m4/src/GeneralUser/GeneralUser.sf2")
        # fi
        #-- print_output("0, 0, FS, set synth.gain 0.5")
        print_output("0, 0, FS, set synth.midi-channels 128")
        print_output("0, 0, FS, set synth.verbose 0")
        print_output("0, 0, FS, reset")
        if not args.two:
            print_output("0, 0, FS, load /Users/m4/src/GeneralUser_GS/GeneralUser_GS.sf2")
        else:
            print_output("0, 0, FS, load /Users/m4/src/GeneralUser/GeneralUser.sf2")
        # fi
        print_output("0, 0, FS, prog 00 000")

        for t in header:
            print_output('0, 0, FS, echo {}'.format(t))
        # rof
        return
# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
    else:                                   # ABC format
        header = "%abc\n" + header

        header += "%abc2mtex: yes\n"

        if '' in percents:
            for p in percents['']:
                header = header + p + '\n'
            # rof
        else:
            # Default printing stuff.
            header += "%%pageheight 10.5in\n"
            header += "%%staffwidth 7.0in\n"
            # header += "%%stretchlast no\n"
            header += "%%leftmargin .25in\n"
            header += "%%rightmargin .25in\n"
            header += "%%scale 0.42\n"
            header += "%%vocalfont Times-BoldItalic 13.0\n"
            header += "%%combinevoices 1\n"
        # fi
        # Must be a fraction.
        fdnl = default_note_text_fraction('')
        if fdnl == '1':
            fdnl = '1/1'
        # fi
        header = header + "L:{}\n".format(fdnl)
        header = header + "Q:{}={}\n".format(fdnl, tempo_speed_default)
        if key_default is None or key_default == 'atonal':
            key_default = 'C'
        # fi
        header = header + "K:{}".format(key_default)       # no \n, added when printed.
    # fi
    print_output(header)
    return
# End of print_header

# ----------------------------------------------------------------------------
def print_out_midi1csv_notes():
    global vl                                   # volume levels
    global meas                                 # measures
    global inst
    global tempo_speed_default
    global default_note_length                  # Default note length.
    global tempo_speed_now                      # Beats per minute for each measure.
    global tempo_now_note_length                # Note length for a beat.

    global bufs                                 # Notes.
    global bufs_length                          # Lengths for notes.
    global bufs_suffixes                        # Ties/legato/etc. for notes.
    global bufs_vol                             # Volumes for notes.
    global bufs_intensity

    global goto_table
    global goto_variables

    global pitch                                # Offset note by this amount.

    global args
    global voices_to_do
    global voices_having_notes

    channel = 0                                 # Next midi instrument channel to use.
    chan = 0                                    # The midi channel using now (allows for repeated use).

    for voice in range(1, len(vl) + 1):
        if args.voices and args.voices != '':
            if str(voice) not in voices_to_do:
                continue
            # fi
        # fi
        if voice not in bufs:
            print_error_no_line("bufs voice dictionary is hosed (m={}, voice={}, lthworkingmeasures={})".format(m, voice, lthworkingmeasures))
            sys.exit(1)
        # fi

        # Nothing yet ...
        lastmeter = ''                          # Last meter put out.
        l_instrument = None                     # Last instrument for this voice.
        lt = ''                                 # Last tempo number of beats per minute.
        ll = ''                                 # Last tempo note type (whole,half,quarter,...).
        last_keysig = ''                        # Last key signature put out.

        print_out_midi1csv_start(voice)

        # A comment as to which musicomp voice being done.
        print_output('{}, 0, Text_t, "voice {}"'.format(voice+1, voice))

        m_number = 0                            # Start from absolute first (pre-first) measure.
        if m_number >= len(meas):
            print_error_no_line("No measures in song.")
            sys.exit(1)
        # fi
        lthworkingmeasures = 0                  # The time for event to occur.

        for v in goto_table:                    # All goto's in song.
            goto_variables[v] = 0               # This voice hasn't done any goto's yet.
        # rof

        legato_on = False                       # Legato is not on yet.
        last_note_on = ''                       # There is no note that is currently on.
        last_cc11 = 0                           # The last control 11 volume put out for voice.
        last_cc7 = 0                            # The last control 7 volume put out for "channel".
        note_playing = 0                        # There is no note length to '4c4s' rest (staccato/portamento).
        note_length = 0                         # The length of the last note (4c4).
        last_suffixes = ''                      # No ties/legaot/etc. to start with.

        l_instrument, channel, chan = print_out_midi1csv_instrument(meas[m_number], voice, lthworkingmeasures, l_instrument, channel, chan)
        lastmeter = print_out_midi1csv_ts(meas[m_number], voice, lthworkingmeasures, lastmeter)
        last_keysig = print_out_midi1csv_keysignature(meas[m_number], voice, lthworkingmeasures, last_keysig)
        lt, ll = print_out_midi1csv_tempo(meas[m_number], voice, lthworkingmeasures, lt, ll)

#-        # A comment as to which musicomp measure being done.
        print_output('{}, {}, Text_t, "measure {}"'.format(voice+1, lthworkingmeasures, meas[m_number]))
        while m_number < len(meas):             # While there are measures left to do.
            m = meas[m_number]

            if voice in vl and m in vl[voice]:
                v_vl = vl[voice][m]             # volume level for this voice/measure
            else:
                v_vl = 127                      # Probably a rest, put as full volume.
            # fi
            if m in intensity and voice in intensity[m]:
                v_intens = intensity[m][voice]  # "channel" volume level for this voice/measure
            else:
                v_intens = [127]                  # Probably a rest, put as full volume.
            # fi

            # Starting with first note in measure (i).
            i = 0
            while i < len(bufs[voice][m]):      # while there are notes in measure
                n = bufs[voice][m][i]           # note number
                v = bufs_vol[voice][m][i]       # volume for the next note.
                v_intens = bufs_intensity[voice][m][i]       # "channel" volume for the next note.
                if note_length > 0:             # If there is a previous note to update length, or ...
                    # Crescendo needs current volume and next notes starting volume.
                    if 'c' in last_suffixes:
                        # Do crescendo between lthworkingmeasures and lthworkingmeasures+note_playing.
                        fvol = float(v_vl)      # Previous volume
                        dv = fvol - float(v)    # New volume
                        dinc = dv / float(note_length)
                        for T in range(lthworkingmeasures, lthworkingmeasures + note_playing):
                            # calculate crescendo number. If same as last, continue.
                            fvol = fvol - dinc
                            ivol = int(fvol)
                            if last_cc11 != ivol:
                                if last_note_on != '':
                                    print_output("{}, {}, Control_c, {}, 11, {}".format(voice+1, T, chan, ivol))
                                # fi
                                last_cc11 = ivol
                            # fi
                        # rof
                        if note_playing < note_length:
                            # Must turn off stacatto note before moving lthworkingmeasures.
                            if last_note_on != '':
                                print_output("{}, {}, Note_off_c, {}, {}, {}".format(voice+1, lthworkingmeasures + note_playing, chan, last_note_on, 0))
                            # fi
                            last_note_on = ''
                        # fi
                    # fi
                    lthworkingmeasures = lthworkingmeasures + note_length
                # fi

                if i == 0:
                    l_instrument, channel, chan = print_out_midi1csv_instrument(m, voice, lthworkingmeasures, l_instrument, channel, chan)
                    lastmeter = print_out_midi1csv_ts(m, voice, lthworkingmeasures, lastmeter)
                    last_keysig = print_out_midi1csv_keysignature(m, voice, lthworkingmeasures, last_keysig)
                    lt, ll = print_out_midi1csv_tempo(m, voice, lthworkingmeasures, lt, ll)
                # fi

                # If a rest - no suffixes/volumes/ can be on it.
                last_suffixes = bufs_suffixes[voice][m][i]    # ties/legato/etc. for the next note.
                note_length = bufs_length[voice][m][i]
                note_velocity = bufs_velocity[voice][m][i]

                if n == '0' or n == 0:
                    # If a note is turned on, turn it off.
                    if last_note_on != '':
                        print_output("{}, {}, Note_off_c, {}, {}, {}".format(voice+1, lthworkingmeasures, chan, last_note_on, 0))
                        last_note_on = ''
                    # fi
                    if legato_on:
                        print_output("{}, {}, Control_c, {}, 68, {}".format(voice+1, lthworkingmeasures, chan, 0))
                        legato_on = False
                    # fi
                    # To next note. While loop checks for end of measure.
                    v_vl = bufs_vol[voice][m][i]
                    v_intens = bufs_intensity[voice][m][i]
                    i = i + 1
                    continue
                # fi

                # The note to be turned on then off later.
                try:
                    n = int(n) + pitch[m]
                except:
                    print_error_no_line("v:{} m:{} Not integer: n={} pitch={}".format(voice, m, n, pitch[m]))
                    break
                # yrt

                if 't' in last_suffixes:    # This note is tied to previous.
                    if legato_on:
                        print_error_no_line("voice {} measure {} - tied note #{} ({}, {}) coming from a legato playing note ({}, {}).".format(voice, m, i+1, n, midi_value_to_note_sharp[n], last_note_on, midi_value_to_note_sharp[last_note_on]))
                        print_output("{}, {}, Control_c, {}, 68, {}".format(voice+1, lthworkingmeasures, chan, 0))
                        legato_on = False
                    # fi
                    if n != last_note_on:
                        if last_note_on == '':
                            print_error_no_line("voice {} measure {} - tied note #{} ({}, {}) is not same as '' note?.".format(voice, m, i+1, n, midi_value_to_note_sharp[n]))
                        else:
                            print_error_no_line("voice {} measure {} - tied note #{} ({}, {}) is not same as previous playing note ({}, {}).".format(voice, m, i+1, n, midi_value_to_note_sharp[n], last_note_on, midi_value_to_note_sharp[last_note_on]))
                            print_output("{}, {}, Note_off_c, {}, {}, {}".format(voice+1, lthworkingmeasures, chan, last_note_on, 0))
                        # fi
                        voices_having_notes[voice] = True
                        if l_instrument in instruments:
                            last_note_on = n
                        else:
                            last_note_on = drum_sounds[l_instrument]
                        # fi
                        print_output("{}, {}, Note_on_c, {}, {}, {}".format(voice+1, lthworkingmeasures, chan, last_note_on, note_velocity))
                    # fi
                    # Already on, good.
                else:
                    # We want a note-on here.
                    if legato_on:
                        voices_having_notes[voice] = True
                        if l_instrument in instruments:
                            pass
                        else:
                            n = drum_sounds[l_instrument]
                        # fi
                        print_output("{}, {}, Note_on_c, {}, {}, {}".format(voice+1, lthworkingmeasures, chan, n, note_velocity))
                    # fi
                    if last_note_on != '':                  # If not a rest, or note off.
                        print_output("{}, {}, Note_off_c, {}, {}, {}".format(voice+1, lthworkingmeasures, chan, last_note_on, 0))
                    # fi
                    if not legato_on:
                        voices_having_notes[voice] = True
                        if l_instrument in instruments:
                            last_note_on = n
                        else:
                            last_note_on = drum_sounds[l_instrument]
                        # fi
                        print_output("{}, {}, Note_on_c, {}, {}, {}".format(voice+1, lthworkingmeasures, chan, last_note_on, note_velocity))
                    # fi
                    last_note_on = n
                    # fi
                # fi

                # If legato, turn it on, if not already on.
                if 'l' in last_suffixes:
                    if not legato_on:
                        print_output("{}, {}, Control_c, {}, 68, {}".format(voice+1, lthworkingmeasures, chan, 127))
                        legato_on = True
                    # fi
                else:
                    if legato_on:
                        print_output("{}, {}, Control_c, {}, 68, {}".format(voice+1, lthworkingmeasures, chan, 0))
                        legato_on = False
                    # fi
                # fi

                v_vl = bufs_vol[voice][m][i]
                v_intens = bufs_intensity[voice][m][i]
                if last_cc11 !=  v_vl:
                    if last_note_on != '':
                        print_output("{}, {}, Control_c, {}, 11, {}".format(voice+1, lthworkingmeasures, chan, v_vl))
                    # fi
                    last_cc11 = v_vl
                # fi
                if last_cc7 !=  v_intens:
                    if last_note_on != '':
                        print_output("{}, {}, Control_c, {}, 7, {}".format(voice+1, lthworkingmeasures, chan, v_intens))
                    # fi
                    last_cc7 = v_intens
                # fi

                # note_playing will eventually be when to turn note off.
                note_playing = note_length
                if 's' in last_suffixes:
                    if 'l' in last_suffixes:
                        # Really should be a fixed length from end of note? Might just work without?
                        # note_playing = int(round(29.0 * (note_playing / 30.0)))
                        # note_playing = note_playing - 8
                        note_playing = note_playing - 4
                        legato_on = False
                    else:
                        note_playing = int(note_playing / 2.0)
                    # fi
                # fi

                i = i + 1
            # elihw

            # Go to next measure (or wherever a goto says, if it exists).
            if m in goto_table:
                f = goto_variables[m]
                g = goto_table[m][f]
                f = f + 1
                if f >= len(goto_table[m]):         # If should start over.
                    f = 0
                # fi
                goto_variables[m] = f
                if g == 'x':
                    m_number = m_number + 1
                else:
                    m_number = meas.index(g)
                # fi
            else:
                m_number = m_number + 1
            # fi
            if m_number < len(meas):
                m = meas[m_number]
            else:
                m = 'EOF'
            # fi
#-            # A comment as to which musicomp measure being done.
            print_output('{}, {}, Text_t, "measure {}"'.format(voice+1, lthworkingmeasures, m))
        # elihw

        # No more notes to turn on -- might be one already on.
        if note_length > 0:             # If there is a previous note to update length, or ...
            # Cannot crescendo to last note - don't have volume -- or do we?
            # Crescendo needs current volume and next notes starting volume.
            if 'c' in last_suffixes:
                # Do crescendo between lthworkingmeasures and lthworkingmeasures+note_playing.
                fvol = float(v_vl)      # Previous volume
                # Use previous values for this one.
                for T in range(lthworkingmeasures, lthworkingmeasures + note_playing):
                    # calculate crescendo number. If same as last, continue.
                    fvol = fvol - dinc
                    if fvol < 1:
                        fvol = 0
                    elif fvol > 126.49:
                        fvol = 127
                    # fi
                    ivol = int(fvol)
                    if last_cc11 !=  ivol:
                        if last_note_on != '':
                            print_output("{}, {}, Control_c, {}, 11, {}".format(voice+1, T, chan, ivol))
                        # fi
                        last_cc11 = ivol
                    # fi
                # rof
                if note_playing < note_length:
                    # Must turn off stacatto note before moving lthworkingmeasures.
                    if last_note_on != '':
                        print_output("{}, {}, Note_off_c, {}, {}, {}".format(voice+1, lthworkingmeasures + note_playing, chan, last_note_on, 0))
                    # fi
                    last_note_on = ''
                # fi
            # fi
        # fi
        lthworkingmeasures = lthworkingmeasures + note_length

        if legato_on:
            legato_on = False
            print_output("{}, {}, Control_c, {}, 68, {}".format(voice+1, lthworkingmeasures, chan, 0))
        # fi
        if last_note_on != '':
            print_output("{}, {}, Note_off_c, {}, {}, {}".format(voice+1, lthworkingmeasures, chan, last_note_on, 0))
            last_note_on = ''
        # fi
        print_out_midi1csv_end(voice, lthworkingmeasures)
    # rof   voice in range
    return
#   End of print_out_midi1csv_notes

# ----------------------------------------------------------------------------
global default_little_time
default_little_time = 0.1
global this_time
this_time = []
# ----------------------------------------------------------------------------
global measure_1st_only, fs_other_echo
measure_1st_only = []
fs_other_echo = ''
# ----------------------------------------------------------------------------
def process_fs_check(what, lth, min_next, vtlines, tempo_s, tempo_l):
    global this_time
    global measure_1st_only
    global fs_other_echo

    for voice, lines in vtlines.items():
        v = int(voice)
        if this_time[v] >= len(lines):
            continue
        # fi
        t = lines[this_time[v]].split(' ', 1) # 2 elements
        time = float(t[0])
        while time <= min_next:
            strg = t[1]
            if strg == 'End_track ':
                pass
            elif strg[0:lth] == what:
                really_print_output("{}".format(strg))
            elif strg[0:5] == 'echo ':           # echo "measure xxx"
                if strg[0:14] == 'echo "measure ':
                    if strg not in measure_1st_only:
                        really_print_output("{}".format(strg))
                        measure_1st_only.append(strg)
                    # fi
                elif strg != fs_other_echo:
                    really_print_output("{}".format(strg))
                    fs_other_echo = strg
                # fi
            elif strg[0:7] == 'select ':
                really_print_output("{}".format(strg))
            elif strg[0:4] == 'set ':
                really_print_output("{}".format(strg))
            elif strg[0:6] == 'reset ':
                really_print_output("{}".format(strg))
            elif strg[0:5] == 'load ':
                really_print_output("{}".format(strg))
            elif strg[0:5] == 'prog ':
                really_print_output("{}".format(strg))
            elif strg[0:6] == 'tempo ':
                x = strg[6:].split()
                if len(x) < 1 or len(x) > 2:
                    print_error_no_line("Tempo needs a speed - line={}".format(t))
                elif len(x) == 1:
                    #    1/(### / (60.0 * 1000000.0)) = 60.02400 = t              for l = 4 (quarter note).
                    tempo_s = int(1/(int(x[0]) / (60.0 * 1000000.0)))
                    tempo_l = 4
                else:
                    tempo_s, tempo_l = strg[6:].split()
                # fi
#--                really_print_output("echo tempo {} {}".format(tempo_s, tempo_l))
            elif strg[0:3] == 'cc ':
                break
            elif strg[0:8] == 'noteoff ':
                break
            elif strg[0:7] == 'noteon ':
                break
            else:
                print_error_no_line("Unrecognized - line={}".format(t))
                error_now = error_now + 1
                break
            # fi
            this_time[v] += 1
            if this_time[v] >= len(lines):
                break
            # fi
            t = lines[this_time[v]].split(' ', 1) # 2 elements
            time = float(t[0])
        # elihw
    # rof
    return tempo_s, tempo_l
#   End of process_fs_check

# ----------------------------------------------------------------------------
# Thinking if we get each of the tracks in csvmidi format, in array, then go
# through them and order by:
    # track, time: In array order for each track.
    #       controls
    #       noteoff
    #       noteon
    # ... is that all that is needed? (And obvious format change.)

def print_out_fluidsynth():
    global array_of_lines
    global this_time
    global default_little_time

    change_name = {
        'Text_t': 'echo',
        'Note_on_c': 'noteon',
        'Note_off_c': 'noteoff',
        'Tempo': 'tempo',
        'Time_signature': 'echo meter',
        'Key_signature': 'echo key',
        'Control_c': 'cc',
        'End_of_file': 'echo End_of_file',
        'Title_t': 'echo Title_t',
        # Track, Time, MIDI_port, Number This meta-event specifies that subsequent events in
        # the Track should be sent to MIDI port (bus) Number, between 0 and 255. This meta-event
        # usually appears at the start of a track with Time zero, but may appear within a track
        # should the need arise to change the port while the track is being played.
#--        'MIDI_port': 'echo MIDI_port',
    }

    v_t_lines = { }
    tempo_s = 60
    tempo_l = 0.5

    max_midi_time = 0

    voices = 0
    for i in array_of_lines:
        # "2, 5280, Note_on_c, 0, 43, 127"
        t = i.split(', ', 3)        # 4 elements.
        t[0] = t[0].strip()
        if t[0] not in v_t_lines:
            v_t_lines[t[0]] = []
        # fi
        if 2 > len(t) or t[2] == "Start_track":
            continue
        # fi
        t[1] = t[1].strip()
        t[2] = t[2].strip()
        if t[2] in change_name:
            t[2] = change_name[t[2]]
#-            if t[2][0:4] == 'echo' or t[3][0:9] == '"measure ' or t[3][0:7] == '"voice ':
#-                continue
#-            # fi
            t[3] = t[3].strip()
        elif t[2] == 'FS':
            t[3] = t[3].strip()
            t[2] = t[3]
            t[3] = ''
        elif t[2] == 'Program_c':
# select chan sfont bank prog
            t[2] = 'select'
            t[3] = t[3].strip()
            s = t[3].split(", ", 2)     # 3 elements - channel, bank, program.
            if s[0] != '9':
                if args.two:
                    t[3] = '{} 2 {} {}'.format(s[0], s[2], s[1])
                else:
                    t[3] = '{} 1 {} {}'.format(s[0], s[2], s[1])
                # fi
            else:
#               select 9 2 128 0  Combination of bank-select and program-change
                if args.two:
                    t[3] = '{} 2 128 0'.format(s[0])
                else:
                    t[3] = '{} 1 128 0'.format(s[0])
                # fi
            # fi
            t[2] = 'select'
        elif t[2] == 'End_track':
            if max_midi_time < float(t[1]):
                max_midi_time = float(t[1])
            # fi
            t.append('')
        else:
            print_error_no_line("Unexpected midi command - t={}".format(t))
        # fi
        if voices < int(t[0]):
            voices = int(t[0])
        # fi
        t[3] = t[3].replace(',', '').strip()
        v_t_lines[t[0]].append(t[1] + ' ' + t[2] + ' ' + t[3])
    # rof
    current_time = -1
    this_time = []
    for v in range(0, voices+1):
        this_time.append(0)
    # rof
    while current_time < max_midi_time:
        # Find smallest time difference.
        min_next = max_midi_time + 1
        for voice, lines in v_t_lines.items():
            v = int(voice)
            if this_time[v] >= len(lines):
                continue
            # fi
            t = lines[this_time[v]].split(' ', 1) # 2 elements
            time = float(t[0])
            if min_next > time:
                min_next = time
            # fi
        # rof
        if current_time >= 0 and (min_next - current_time) != 0:
            ms_1000 = float(min_next - current_time)
            if ms_1000 < default_little_time:
                ms_1000 = default_little_time
            else:
                # 480 => 250
                ms_1000 = ms_1000 * 1000.0
                ms_1000 = ms_1000 / ((float(tempo_s)/60.0) * (float(tempo_l) * 4.0))
                ms_1000 = int((ms_1000 / 480.0) * 1000)
                ms_1000 = float(ms_1000) / 1000.0
            # fi
            really_print_output("sleep {}".format(ms_1000))
        # fi
        current_time = min_next
        # Move all this_time voices forward past min_next.
# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
        tempo_s, tempo_l = process_fs_check('cc ', 3, min_next, v_t_lines, tempo_s, tempo_l)
        tempo_s, tempo_l = process_fs_check('noteoff ', 8, min_next, v_t_lines, tempo_s, tempo_l)
        tempo_s, tempo_l = process_fs_check('noteon ', 7, min_next, v_t_lines, tempo_s, tempo_l)
    # elihw

    really_print_output("quit")
    return
#   End of print_out_fluidsynth

# ----------------------------------------------------------------------------
def pre_move_note_before(prev_m, m, voice, l, vel, intens, n, a, v):
    global bufs
    global bufs_length
    global bufs_velocity
    global bufs_vol
    global bufs_intensity
    global bufs_suffixes
    global mlth                         # measure length dictionary
    global tlth

    bufs[voice][prev_m].append(n)
    bufs_length[voice][prev_m].append(l)
    bufs_velocity[voice][prev_m].append(vel)
    bufs_suffixes[voice][prev_m].append(a)
    bufs_vol[voice][prev_m].append(v)
    bufs_intensity[voice][m].append(intens)

    tlth[voice] = tlth[voice] + l
    if prev_m not in mlth[voice]:
        mlth[voice][prev_m] = 0
    # fi
    mlth[voice][prev_m] = mlth[voice][prev_m] + l
    if args.midi1csv or args.fluidsynth:
        setvar('time', mlth[voice][prev_m] / (MIDICLICKSPERQUARTER * 4), 0)
    else:
        setvar('time', mlth[voice][prev_m], 0)
    # fi
    return
#   End of pre_move_note_before

# ----------------------------------------------------------------------------
def pre_shift_measure(prev_m, m):
    global args
    global vl
    global bufs
    global bufs_length
    global bufs_velocity
    global bufs_vol
    global bufs_intensity
    global bufs_suffixes
    global mlth                         # measure length dictionary
    global tlth

    for voice in range(1, len(vl)+1):
        s = args.shift
        if len(bufs[voice][m]) == 0:
            # If nothing in voice for this measure, go to next voice.
            continue
        # fi
        while s > 0:
            l =  bufs_length[voice][m][0]       # Length of note.
            vel =  bufs_velocity[voice][m][0]   # Velocity of note.
            n =  bufs[voice][m][0]              # Note (plus pre and post?).
            a = bufs_suffixes[voice][m][0]      # Ties/legato/etc. -- oh my ...
            v = bufs_vol[voice][m][0]
            intens = bufs_intensity[voice][m][0]
            if l <= s:
                if prev_m is not None:
                    # Move to previous measure.
                    pre_move_note_before(prev_m, m, voice, l, vel, intens, n, a, v)
                else:
                    print_warning("pre_shift_measure - tossing voice={} m={} n={} l={} a={} v={}".  format(voice, m, n, l, a, v), 'pass2')
                # fi
                # Remove from current measure.
                bufs[voice][m].pop(0)
                bufs_length[voice][m].pop(0)
                bufs_velocity[voice][m].pop(0)
                bufs_suffixes[voice][m].pop(0)
                bufs_vol[voice][m].pop(0)
                bufs_intensity[voice][m].pop(0)
                tlth[voice] = tlth[voice] - l
                mlth[voice][m] = mlth[voice][m] - l
                if args.midi1csv or args.fluidsynth:
                    setvar('time', mlth[voice][m] / (MIDICLICKSPERQUARTER * 4), 0)
                else:
                    setvar('time', mlth[voice][m], 0)
                # fi
                s = s - l
                if s > 0:
                    continue
                # fi
                break
            # fi
            # l > s   : Need to break the note into two with a tie -- staccato? Trill? Sequence? *yuck*
            if 's' in a or 'b' in a:
                print_error("pre_shift_measure - cannot break up a staccato note: voice={} m={} n={} l={} a={} v={}".format(voice, m, n, l, a, v), 'pass2')
                return
            # fi
            if n[0] == 's' or n[0] == 't':
                print_error("pre_shift_measure - cannot break up a trill or sequence: voice={} m={} n={} l={} a={} v={}".format(voice, m, n, l, a, v), 'pass2')
                return
            # fi
            if n[0] == 'v' or n[0] == 'c' or n[0] == 'd':
                print_error("pre_shift_measure - cannot break up a vol(), cresc(), or dimin(): voice={} m={} n={} l={} a={} v={}".format(voice, m, n, l, a, v), 'pass2')
                return
            # fi
            if args.vertical:
                if 't' not in a:                    # if not tied, tie this one.
                    a = a + 't'
                # fi
            # fi
            pre_move_note_before(prev_m, m, voice, s, vel, n, a, v)
            # Reduce length in current measure.
            # bufs[voice][m][0]                     # note remains the same.
            bufs_length[voice][m][0] = l - s        # Reduce note length.
# NOTDONEYET - bufs_velocity -- think it is just duplicate... .
            bufs_velocity[voice][m][0] = vel        # velocity remains the same?
            if args.horizontal:
                if 't' not in a:                    # if not tied, tie this one.
                    bufs_suffixes[voice][m][0] = a + 't'
                # fi
            # fi
            # bufs_vol[voice][m][0]                 # volume remains the same.
# NOTDONEYET - bufs_intensity[voice][m][i]
            tlth[voice] = tlth[voice] - s           # Length reduced.
            mlth[voice][m] = mlth[voice][m] - s
            setvar('time', mlth[voice][m], 0)
            if args.midi1csv or args.fluidsynth:
                setvar('time', mlth[voice][m] / (MIDICLICKSPERQUARTER * 4), 0)
            else:
                setvar('time', mlth[voice][m], 0)
            # fi
            return
        # elihw
    # rof
    return
#   End of pre_shift_measure

# ----------------------------------------------------------------------------
def pre_shift():
    '''
    This routine will shift measures forward (add rest at beginning of song),
    or remove notes/rests from beginning of song -- by args.shift value (float).
    '''
    global vl                               # volume levels
    global meas                             # measures
    global args
    global pitch

    if not args.vertical and not args.horizontal:
        return
    # fi
    if args.shift < 0:
        print_error('Shifting to left (upwards) not done yet -- args.shift={}'.format(args.shift), 'pass2')
    # fi
    # Only for outputting vertical and horizontal format.

    prev_m = None
    for i in range(0, len(meas)):
        m = meas[i]
        pre_shift_measure(prev_m, m)
        prev_m = m
    # rof
    return
#   End of pre_shift

# ----------------------------------------------------------------------------
def check_staves_notes_order():
    global staves
    global meas
    global mlth
    global vl
    global bufs_length
    global bufs
    global bufs_suffixes
    global key_voice
    global key_sig
    global args

    # The idea is to go through the voices in array staves, checking that the
    # first listed one(s) are higher notes than the latter listed ones.
    # This needs to occur something like with the --horizontal option.
    # Perhaps the --midi can be done.
    # I don't know if the --abc can be done.

    for i in range(0, len(meas)):
        m = meas[i]
        ml = mlth[1][m]
        for voice in range(1, len(vl)+1):
            if m in mlth[voice]:
                if mlth[voice][m] != ml:
                    print_error_no_line("staves -- voice#{} measure#{} not same length({}) as 1st({})".format(voice, m, mlth[voice][m], ml))
                # fi
                ml = max(mlth[voice][m], ml)
            else:
                print_error_no_line("staves -- voice#{} not in measure#{}".format(voice, m))
            # fi
        # rof

        workingtime = [ 0 ]                         # Zero is ignored.
        working= [ 0 ]
        for voice in range(1, len(vl)+1):
            working.append(0)
            workingtime.append(0)
        # rof

        now = 0
        while now < ml:
            notes = [ ]
            for voice in range(1, len(vl)+1):
                i = workingtime[voice]
                m4_note = ''
                if i <= now:
                    j = working[voice]
                    l =  bufs_length[voice][m][j]

                    if l in legal_mc_notes:
                        lth = legal_mc_notes[l] + bufs_suffixes[voice][m][j]
                    else:
                        lth = str(Fraction(l).limit_denominator(256))
                        if '/' in lth:
                            lth = '(' + str(l) + ')'
                        # fi
                        lth = lth + bufs_suffixes[voice][m][j]
                    # fi

                    m4_note = bufs[voice][m][j].strip()
# NOTDONEYET - something does not change volumes ... or No idea what problem is.
#//                    if args.vertical or args.horizontal:
#//                        saveargsh = args.horizontal
#//                        saveargsv = args.vertical
#//                        saveargsm = args.midi1csv
#//                        saveargfluidsynth = args.fluidsynth
#//                        saveargabc = args.abc
#//                        savekeyvoice = key_voice[measure_on][1]
#//                        k = key_sig[savekeyvoice]      # Convert to number.
#//                        # Set to midi format -- so we have a value.
#//                        args.horizontal = False
#//                        args.vertical = False
#//                        args.midi1csv = True
#//                        args.fluidsynth = False
#//                        args.abc = False
#//                        key_voice[measure_on][1] = k
#//                        prenote = ''
#//                        postnote = ''
#//                        onenotevolume = None
#//                        m4_note, onenotevolume, prenote, postnote = do_vol_cresc(m4_note, voice, 'check_staves_notes_order', prenote, postnote, onenotevolume)
#//                        m4_therest, m4_thenote, m4_typenote = getnote(m4_note, 1, 'check_staves_notes_order', True)
#//                        args.horizontal = saveargsh
#//                        args.vertical = saveargsv
#//                        args.midi1csv = saveargsm
#//                        args.abc = saveargabc
#//                        args.fluidsynth = saveargfluidsynth
#//#                        if onenotevolume is None:
#//#                            return
#//#                        # fi
#//                        key_voice[measure_on][1] = savekeyvoice
#//                        if m4_typenote == normal_note:
#//                            m4_note = m4_thenote
#//                        else:
#//                            m4_note = ''
#//                        # fi
#//                    #-- elif args.midi1csv or args.fluidsynth:
#//                    #-- else:       # ABC
#//                    #--     pass
#//                    # fi

                    workingtime[voice] = workingtime[voice] + l
                    working[voice] = working[voice] + 1
                # fi
                if m4_note == '0' or m4_note == 0:
                    m4_note = ''
                # fi
                notes.append(m4_note)
            # rof

            if not (args.vertical or args.horizontal):
                for l in range(0, len(staves)):
                    first = -1
                    for n in range(0, len(staves[l])):
                        try:
                            o = int(staves[l][n]) -1
                        except:
                            print_error_no_line("staves -- m:{} voice='{}' is not an integer.".format(m, staves[l][n]))
                            continue
                        # yrt
                        if o >= len(notes):
                            print_error_no_line("staves -- m:{} voice={} not in notes.".format(m, o+1))
                            continue
                        # fi
                        if notes[o] != '' and notes[o] != 0:
                            if first < 0:
                                try:
                                    first_note = int(notes[o]) - xpose[o+1]
                                except:
                                    print_error_no_line("staves -- m:{} Not midi note integer -- note='{}' xpose={} ".format(m, notes[o], xpose[o+1]))
                                    break
                                # yrt
                                if first_note not in midi_value_to_note_sharp:
                                    print_error_no_line("staves -- m:{} v{} {} not in midi_value_to_note_sharp".format(m, o+1, first_note))
                                    break
                                # fi
                                n1 = midi_value_to_note_sharp[first_note]
                                first = o
                                continue
                            # fi
                            tn = int(notes[o]) - xpose[o+1]
                            if tn > first_note:
                                n2 = midi_value_to_note_sharp[tn]
                                print_warning_no_line("staves -- m:{} v{} note {}({}) is greater than v{} note {}({})".format(m, o+1, tn, n2, first+1, first_note, n1))
                                break
                        # fi
                    # rof
                # rof
            # fi

            nextmin = 999999
            for voice in range(1, len(vl)+1):
                if workingtime[voice] < nextmin:
                    nextmin = workingtime[voice]
                # fi
            # rof
            now = nextmin
        # elihw
    # rof
#   End of check_staves_notes_order

# ----------------------------------------------------------------------------
def check_voices_without_notes():
    global vl
    global voices_having_notes

    for v in vl:
        if v not in voices_having_notes:
            print_warning_no_line("voice {} does not have any notes.".format(v))
        # fi
    # rof
#   End of check_voices_without_notes

# ----------------------------------------------------------------------------
def do_pass2():
    global meas                             # measures
    global args
    global bufs_tie_next
    global bufs_legato_next
    global vl
    global ifdepth
    global macro_defining
    global macro_executing_depth
    global errors_happened
    global goto_table
    global staves

    # Check that song finishes 'reasonably'.
    if ifdepth > 0:
        print_warning_no_line("Inside an if block (depth={}) when end of file or cstop* reached".format(ifdepth))
    # fi
    if macro_defining is not None:
        print_error_no_line("Inside defining macro {}, no endm reached.".format(macro_defining))
    # fi
    if len(macro_executing_depth) > 0:
        print_error_no_line("Processing macro depth is {}.".format(macro_executing_depth))
    # fi

    e = False
    for m in goto_table:                # The measures with a goto in it.
        for g in goto_table[m]:         # The goto measures as arguments.
            if g != 'x':                # "x" is okay, goto next measure.
                if g not in meas:       # unknown measure ...
                    print_error_no_line("Checking goto's values, '{}' not in measures.".format(g))
                    e = True            # Error occurred.
                    errors_happened = errors_happened + 1
                # fi
            # fi
        # rof
    # rof
    if e:
        sys.exit(errors_happened)
    # fi

    # Fix other voices before continuing to process.
    fill_voice_mlth(True, "do_pass2")             # Need to make measure for other voices up to here "mlth".

    # First get the empty measures to have rests of appropriate length.
    # All measures have all voices with same length -- even if some are rests.
    for i in range(0, len(meas)):
        m = meas[i]
        for voice in range(1, len(vl) +1):
            rests_in_empty_measure_voices(m, voice)
            if bufs_tie_next[voice] != '':
                print_error_no_line("voice {} ends with a tie".format(voice))
                bufs_tie_next[voice] = ''
            # fi
            bufs_legato_next[voice] = ''
        # rof
    # rof

    if len(staves) != 0:
        if args.vertical or args.horizontal:
            check_staves_notes_order()
        elif args.midi1csv or args.fluidsynth:
            check_staves_notes_order()
        else:       # ABC
            pass
        # fi
    # fi

    if args.shift and args.shift != 0:
        pre_shift()
    # fi

    # Now print out the file.
    print_header()

    if args.vertical or args.horizontal:
        print_out_v_or_h()
    elif args.midi1csv or args.fluidsynth:
        print_out_midi1csv_notes()
        check_voices_without_notes()
    else:       # ABC
        print_out_abc()
        print_output("")
    # fi

    # End of song processing.
    if args.vertical or args.horizontal:
        print_output("cstop*")
    elif args.midi1csv:
        print_output("0, 0, End_of_file")
    elif args.fluidsynth:
        print_output("quit")
        print_out_fluidsynth()
    # else:     # ABC
    # fi
    sys.exit(errors_happened)
# End of do_pass2

# ----------------------------------------------------------------------------
# Get a line. Put it in "line" and return it.
def read_next_line():
    global i_line
    global linecount
    global args
    global file_name
    global macro_executing_depth
    global macro_executing_args
    global macro_line
    global macro_buffer                 # Name of macro, array of lines for macro.
    global macro_arguments              # Name of macro, array of arguments for macro.
    global errors_happened

    if macro_executing_depth != []:
        l = len(macro_executing_depth)
        the_macro = macro_executing_depth[-1]
        macrodepth = len(macro_executing_depth)
        linenumber = macro_line[macrodepth]
        lines = macro_buffer[the_macro]
        if linenumber >= len(lines):
            p = macro_executing_depth.pop()
            del macro_line[l]
            del macro_executing_args[l]
            return '', ''
        # fi
        line = macro_buffer[the_macro][linenumber]
        i_line = [ 'macro: ' + line ]                           # Line as given from macro text buffer
        def_args = macro_arguments[the_macro]
        rep_args = macro_executing_args[l]
        for j in range(0, len(def_args)):
            line = line.replace(def_args[j], rep_args[j])
        # rof
        i_line.append('margs: ' + line)                         # Line after argument processing done
        macro_line[macrodepth] = linenumber + 1
#-- need to know continued line ... 8 spaces or start with a tab.
#--        line = line.replace("\t", ' ')              # tabs to spaces
        return line, ''
    # fi

    full_line = ''
    i_line = []
    while True:
        try:
            if args.rest and len(args.rest) >= 1:
                line = file_name.readline()
            else:
                if sys.stdin.isatty():
                    if sys.platform == 'darwin':
                        input('input> ')
                        line = readline.get_line_buffer()
                    else:
                        line = input('input> ')
                    # fi
                else:
                    line = sys.stdin.readline()
                # fi
            # fi
            if line is None or line == '':
                sys.exit(errors_happened)
            # fi
            linecount = linecount + 1
            i_line.append('input: ' + line)         # Line as given from input file.
            if line:
                line = line.rstrip()                # trailing spaces gone.
                if line and line[-1] == '\\':       # if continued on next line
                    line = line[:-1]
                    line = line.rstrip()            # trailing spaces gone.
                    full_line += line
                    continue
                # fi
                full_line += line
                commentdollardollar = ''
                if '$$' in full_line:
                    # delete anything from $$ onwards.
                    commentdollardollar = re.sub(r'^.*[$][$]', '$$', full_line, count=1)
                    commentdollardollar = commentdollardollar.rstrip()  # trailing spaces gone
                    full_line = re.sub(r'[$][$].*$', '', full_line)
                # fi
#-- need to know continued line ... 8 spaces or start with a tab.
#--                # Convert tabs to spaces.
#--                full_line = full_line.replace("\t", ' ')
                full_line = full_line.rstrip()      # trailing spaces gone.
                i_line.append('input: ' + full_line)            # Line as fixed.
                return full_line, commentdollardollar
            # fi
        except EOFError:
            if full_line != '':
                i_line.append('input: ' + full_line)            # Line as fixed or whatever.
                return full_line, commentdollardollar
            # fi
            pass            # print("Read gave EOF", file=sys.stderr, flush=True)
        except SystemExit:
            if full_line != '':
                i_line.append('input: ' + full_line)            # Line as fixed or whatever.
                return full_line, commentdollardollar
            # fi
            pass            # print("Read gave system exit", file=sys.stderr, flush=True)
        except KeyboardInterrupt:
            print_error_no_line("Read got keyboard interrupt")
        except:
            if full_line != '':
                i_line.append('input: ' + full_line)            # Line as fixed or whatever.
                return full_line, commentdollardollar
            # fi
            print_error_no_line("Read got a processing error")
            print("    ", sys.exc_info()[0], sys.exc_info, file=sys.stderr, flush=True)
        # yrt
        break
    # elihw
    do_pass2()
    sys.exit(errors_happened)
# End of read_next_line

# ----------------------------------------------------------------------------
def split_line(line):
    t = None
    if line:
        # Split line on spaces, then process line.
        while True:
#--            t = line.split(' ', 1)
            t = re.split(r'[ \t]', line, 1)
            if t and t[0] and len(t) == 2 and t[1]:
                t[1] = t[1].strip()
            # fi
            if t and t[0] == '.':
                # If command == '.' toss '.'
                if len(t) == 2 and t[1]:
                    line = t[1]
                else:
                    t = None
                    line = None
                    break
                # fi
                continue
            # fi
            break
        # elihw
    # fi
    return(t, line)
# End of split_line

# ----------------------------------------------------------------------------
def get_list_sep_rem(string):
    strg = sep = rem = ''
    for i in range(0, len(string)):
        c = string[i]                       # Character in string
        if c.isalpha():                     # [a-zA-Z]
            if i != 0 and strg.replace('.', '', 1).isdigit():    # number followed by letter, stop.
                sep = None
                rem = string[i:]            # the rest of the string, including this character.
                break
            # fi
            strg = strg + c
        elif c.isdigit() or c == '.':       # current is a digit, see if rest are.
            if strg or strg == '':
                strg = strg + c
                continue
            elif strg.isdigit():             # number followed by number, good.
                strg = strg + c
                continue
            elif strg.replace('.', '', 1).isdigit() and c.isdigit():   # floating number followed by number, good.
                strg = strg + c
                continue
            else:
                print_error("Two periods in a number not allowed", string)
                return None, None, None
            # fi
        else:
            sep = c
            rem = string[i+1:]              # the rest of the string, including this character.
            break
        # fi
    # rof
    return(strg, sep, rem)
# End of get_list_sep_rem

# ----------------------------------------------------------------------------
# Calculate values here.
# Returns:
#   value   -- So far computed value
#   type_error -- type of error

def is_float(strg, type_float):
    tree = calculate.parse(strg)            # parse the string
    if tree is None or len(tree) != 2:
        return None, None
    elif tree[0] is not None and tree[0].startswith('ERROR'):
        sexpr = tree[0]
        return strg, sexpr
    elif tree[1] == '.':
        return strg, "bad input to calculator#1"
    # fi
    if type_float:
        try:
            sexpr = float(tree[1])
            return sexpr, None
        except:
            return strg, "bad input to calculator#2"
        # yrt
    # fi
    return tree[1], None
# End of is_float

# ----------------------------------------------------------------------------
def put_on_bufs(onvoice, p_meas, prenote, abc_note, timeofnote, append_tie, onetimevolume, postnote, line):
    global tlth
    global mlth
    global bufs
    global bufs_length
    global bufs_velocity
    global bufs_suffixes
    global bufs_tie_next
    global bufs_legato_next
    global running_vl
    global DECORATIONS
    global args
    global bufs_vol
    global bufs_intensity
    global cresc_direction
    global cresc_time
    global cresc_volume
    global vlprint

    if type(abc_note) is int:
        abc_note = str(abc_note)
    # fi
    if abc_note == 'r' and append_tie != '':
        print_warning("put_on_bufs - voice {} measure {} rest and suffixes={}".format(onvoice, p_meas, append_tie), line)
        append_tie = ''
    # fi
    tlth[onvoice] = tlth[onvoice] + timeofnote
    if p_meas not in mlth[onvoice]:
        mlth[onvoice][p_meas] = 0
    # fi
    mlth[onvoice][p_meas] = mlth[onvoice][p_meas] + timeofnote
    if args.midi1csv or args.fluidsynth:
        setvar('time', mlth[onvoice][p_meas] / (MIDICLICKSPERQUARTER * 4), 0)
    else:
        setvar('time', mlth[onvoice][p_meas], 0)
    # fi

    if onvoice not in bufs:
        bufs[onvoice] = {}
        bufs_length[onvoice] = {}
        bufs_velocity[onvoice] = {}
        bufs_suffixes[onvoice] = {}
        bufs_tie_next[onvoice] = ''
        bufs_legato_next[onvoice] = ''
        bufs_vol[onvoice] = {}
        bufs_intensity[onvoice] = {}
    # fi
    if onetimevolume is None:
        if onvoice in running_vl and p_meas in running_vl[onvoice]:
            onetimevolume = running_vl[onvoice][p_meas]
        else:
            onetimevolume = 127                 # Probably a rest, put as full volume.
        # fi
    # fi
    if p_meas not in bufs[onvoice]:
        bufs_vol[onvoice][p_meas] = [ onetimevolume ]
        if onvoice in intensity[p_meas]:
            bufs_intensity[onvoice][p_meas] = [ intensity[p_meas][onvoice] ]
        else:
            bufs_intensity[onvoice][p_meas] = [ getvar('default_intensity')]
        # fi
        if args.horizontal or args.vertical:
            bufs[onvoice][p_meas] = [prenote + abc_note]
            bufs_length[onvoice][p_meas] = [timeofnote]
            bufs_velocity[onvoice][p_meas] = [ int(getvar('default_velocity')) ]
            bufs_suffixes[onvoice][p_meas] = [append_tie]
        elif args.midi1csv or args.fluidsynth:
            bufs[onvoice][p_meas] = [abc_note]
            bufs_length[onvoice][p_meas] = [timeofnote]
            bufs_velocity[onvoice][p_meas] = [ int(getvar('default_velocity')) ]
            if cresc_time[onvoice] != 0:
                append_tie = append_tie + 'c'
            # fi
            bufs_suffixes[onvoice][p_meas] = [append_tie]
        else:           # ABC
            bufs[onvoice][p_meas] = prenote + abc_note + postnote
        # fi
    else:
        bufs_vol[onvoice][p_meas].append(onetimevolume)
        bufs_intensity[onvoice][p_meas].append(intensity[p_meas][onvoice])
        if args.vertical or args.horizontal:
            bufs[onvoice][p_meas].append(prenote + abc_note)
            bufs_length[onvoice][p_meas].append(timeofnote)
            bufs_velocity[onvoice][p_meas].append(int(getvar('default_velocity')))
            bufs_suffixes[onvoice][p_meas].append(append_tie)
        elif args.midi1csv or args.fluidsynth:
            bufs[onvoice][p_meas].append(abc_note)
            bufs_length[onvoice][p_meas].append(timeofnote)
            bufs_velocity[onvoice][p_meas].append(int(getvar('default_velocity')))
            if cresc_time[onvoice] != 0:
                append_tie = append_tie + 'c'
            # fi
            bufs_suffixes[onvoice][p_meas].append(append_tie)
        else:           # ABC
            bufs[onvoice][p_meas] = bufs[onvoice][p_meas] + prenote + abc_note + postnote
# NOTDONEYET - bufs_velocity
        # fi
    # fi

    # If crescendo happening, do it.
    if cresc_time[onvoice] == 0:
        return
    # fi

    if cresc_time[onvoice] <= timeofnote:
        running_vl[onvoice][p_meas] = cresc_volume[onvoice]
        cresc_time[onvoice] = 0
        if args.vertical or args.horizontal or args.midi1csv or args.fluidsynth:
            pass
        else:
            j = vol_to_vlprint_round(cresc_volume[onvoice])
            if cresc_direction[onvoice]:
                k = 'crescendo)'
            else:
                k = 'diminuendo)'
            # fi
            bufs[onvoice][p_meas] = bufs[onvoice][p_meas] + \
                                    DECORATIONS + vlprint[j] + DECORATIONS + \
                                    DECORATIONS + k + DECORATIONS
        # fi
        return
    # fi

    dt = cresc_time[onvoice] + 0.0
    if not args.vertical and not args.horizontal:
        v =  cresc_volume[onvoice] - running_vl[onvoice][p_meas] + 0.0
        x1 = v / dt                         # total  1920/48 = 4
        x2 = x1 * timeofnote                # x2 = x1 * timeofnote
        running_vl[onvoice][p_meas] = running_vl[onvoice][p_meas] + int(x2)
    # fi
    cresc_time[onvoice] = cresc_time[onvoice] - timeofnote

    return
# End of put_on_bufs

# ----------------------------------------------------------------------------
def instak(onvoice, p_meas, prenote, thenote, timeofnote, append_tie, line, onenotevolume, postnote):
    global args

    if args.midi1csv or args.fluidsynth:
        put_on_bufs(onvoice, p_meas, prenote, thenote,
                    int(round(timeofnote * MIDICLICKSPERQUARTER * 4)), append_tie, onenotevolume,
                    postnote, line)
        return
    # fi

    lengthl, lengthf, ifokay = get_time_stak(timeofnote, line, onvoice)
    if ifokay == -1:                    # if time is error
        return
    # fi

    j = 1
    q = 0
    if args.horizontal or args.vertical:
        if thenote == 'r':
            append_tie = ''
        # fi
        if ifokay == 1:                 # Did not fit properly.
            q = timeofnote
            put_on_bufs(onvoice, p_meas, prenote, thenote, q, append_tie, onenotevolume, postnote, line)
            return
        # fi
    # fi

    for l in lengthl:
        if args.horizontal:
            # Length done elsewise, and suffixes elsewise too.
            q = lengthf[j-1]
            if thenote == 'r':
                append_tie = ''
            # fi
            put_on_bufs(onvoice, p_meas, prenote, thenote, q, append_tie, onenotevolume, postnote, line)
            if thenote == 'r':
                append_tie = ''
            else:
                append_tie = 't'
            # fi
            j = j + 1
        elif args.vertical:
            q = lengthf[j-1]
            # tie goes on one before
            if j == len(lengthl):           # last one gets passed in append_tie note.
                put_on_bufs(onvoice, p_meas, prenote, thenote, q, append_tie, onenotevolume, postnote, line)
            elif j < len(lengthl):
                if thenote == 'r':
                    append_tie = ''
                else:
                    append_tie = 't'
                # fi
                put_on_bufs(onvoice, p_meas, prenote, thenote, q, append_tie, onenotevolume, postnote, line)
            # fi
            if thenote == 'r':
                append_tie = ''
            else:
                append_tie = 't'
            # fi
            j = j + 1
        else:           # ABC
            if j != len(lengthl) and thenote != 'z':
                abc_note = thenote + l + '-'
            else:
                abc_note = thenote + l + append_tie
            # fi
            q = lengthf[j-1]
            put_on_bufs(onvoice, p_meas, prenote, abc_note, q, append_tie, onenotevolume, postnote, line)
            j = j + 1
        # fi
        prenote = ''
    # rof
    return
# End of instak

# ----------------------------------------------------------------------------
# Make all voices match with rests, etc. The ones we have are now to be processed.
# Need to make measure for all known voices up to here "mlth". (Add rests.)
def fill_voice_mlth(meter_check, line):
    global measure_meter_value
    global measure_on
    global vl
    global mlth
    global tlth
    global args
    global meas
    global cis

    maxvoice = len(vl) + 1
    for p_meas in meas:
        m = 0
        for i in range(1, maxvoice):
            if p_meas not in mlth[i]:
                mlth[i][p_meas] = 0
            # fi
            m = max(mlth[i][p_meas], m)
        # rof
        # Put out rests for smaller in measure.
        for i in range(1, maxvoice):
            x =  mlth[i][p_meas]            # time short
            l = m - x                       # time short
            nl = x / (MIDICLICKSPERQUARTER * 4.0)
            if meter_check and measure_on == p_meas and measure_meter_value != nl and x != 0 and (args.midi1csv or args.fluidsynth):
                print_warning("fill_voice_mlth - measure={} voice={} measure_meter_value={} nl={} x={}".format(measure_on, i, measure_meter_value, nl, x), line)
            # fi
            if l > 0 :                      # if short, need a rest.
                if cis == 0 and (args.midi1csv or args.fluidsynth):
                    nl = (MIDICLICKSPERQUARTER * 4) / l
                    print_warning("fill_voice_mlth - l={} ({}) voice={} measure={} cis={}".format(l, nl, i, p_meas, cis), line)
                # fi
                if args.horizontal or args.vertical:
                    instak(i, p_meas, '', 'r', l , '', line, None, '')
                elif args.midi1csv or args.fluidsynth:
                    instak(i, p_meas, '', 0, l / (MIDICLICKSPERQUARTER * 4) , '', line, None, '')
                else:           # ABC
                    instak(i, p_meas, '', 'z', l , '', line, None, '')
                # fi
            # fi
        # rof
    # rof
    # Set total for voice to max of all.
    t = 0
    for i in range(1, maxvoice):
        t = max(tlth[i], t)
    # rof
    for i in range(1, maxvoice):
        tlth[i] = t                     # Total for all voices is now max of all.
    # rof
    return
# End of fill_voice_mlth

# ----------------------------------------------------------------------------
# wline = 2..4
#          l
#           l+1
#            l+2
# Separate arguments for argument.
def arglist(wline, line, integers):
    newline = []
    splitter = [ ',' ]
    firstcolon = 0
    # break into arguments.
    newstr = ''
    np = 0                              # ()
    nb = 0                              # []
    nc = 0                              # {}
    lth = len(wline)
    l = 0
    while (l < lth):
        c = wline[l]
        if c == ':' and firstcolon == 0:
            firstcolon = 1
        elif firstcolon == 1 and (c != ' ' and c != "\t"):
            firstcolon = 2
        elif firstcolon == 2:
            if args.spaces:
                splitter.append(' ')
                splitter.append("\t")
            # fi
            firstcolon = 3
        # fi
        if c in splitter and np == 0 and nb == 0 and nc == 0:    # we want to split on commas
            if integers:
                n, msg = is_float(newstr, True)
                if msg is not None or n is None:
                    print_error("Range first number bad. {}".format(msg), line)
                    return ''
                # fi
                if type(n) is float and n.is_integer():
                    n = int(n)
                # fi
                newline.append(str(n))
            else:
                newline.append(newstr)
            # fi
            l = l + 1
            if l < lth:
                newstr = ''
            else:
                newstr = None
            # fi
        elif c == '.' and integers:
            if (l+2) < lth and wline[l+1] == '.':
                # Range
                if newstr == '':
                    print_error("Range needs number before 'STARTING..ENDING'", line)
                    return ''
                # fi
                first, msg = is_float(newstr, True)
                if msg is not None or first is None:
                    print_error("Range first number bad. {}".format(msg), line)
                    return ''
                # fi
                # NOTE: comma looked for, not parenthesis/brackets/braces.
                try:
                    comma = wline.find(',', l+2)
                    if comma >= 0:
                        last = wline[l+2:comma]
                        l = comma + 1
                    else:
                        last = wline[l+2:]
                        l = lth + 1
                    # fi
                except:
                    last = wline[l+2:]
                    l = lth + 1
                # yrt
                last, msg = is_float(last, True)
                if last is None or last == '' or msg is not None:
                    print_error("Range last number bad. {}".format(msg), line)
                    return ''
                # fi
                if type(first) is float and first.is_integer():
                    first = int(first)
                # fi
                if type(last) is float and last.is_integer():
                    last = int(last)
                # fi
                n = first
                while n < last + 1:
                    o = n
                    if type(o) is float and o.is_integer:
                        o = int(n)
                    # fi
                    newline.append(str(o))
                    n = n + 1
                # rof
                newstr = ''
                continue
            # fi
            print_error("Range needs number after 'STARTING..ENDING'", line)
            return ''
        #-- elif c == ' ' or c == "\t":
        #--     pass
        else:
            newstr = newstr + c
            if c == '(':
                np = np + 1
            elif c == ')':
                if np == 0:
                    print_error("too many right parenthesis", line)
                    return ''
                # fi
                np = np - 1
            elif c == '[':
                nb = nb + 1
            elif c == ']':
                if nb == 0:
                    print_error("too many right brackets", line)
                    return ''
                # fi
                nb = nb - 1
            elif c == '{':
                nc = nc + 1
            elif c == '}':
                if nc == 0:
                    print_error("too many right curly braces", line)
                    return ''
                # fi
                nc = nc - 1
            # fi
            l = l + 1
        # fi
    # elihw
    if np != 0:
        print_error("too many left (by {}) parenthesis".format(np), line)
        return ''
    # fi
    if nb != 0:
        print_error("too many left (by {}) brackets".format(nb), line)
        return ''
    # fi
    if nc != 0:
        print_error("too many left (by {}) curly braces".format(nc), line)
        return ''
    # fi
    if newstr is None:
        newline.append('')
    elif newstr != '':
        if integers:
            n, msg = is_float(newstr, True)
            if msg is not None or n is None:
                print_error("Range first number bad. {}".format(msg), line)
                return ''
            # fi
            n = int(n)
            newline.append(str(n))
        else:
            newline.append(newstr)
        # fi
    # elif not integers:
    #     newline.append(newstr)
    # fi

    return newline
# End of arglist

# ----------------------------------------------------------------------------
# change -- rename existing command or copy.
#         change  measure to unit   $$ or:
#         change  command measure to unit

def do_change(t_args, line):
    global macro_buffer
    global commands

    if t_args is None or t_args == '':
        print_error("change does not have three or four arguments.", line)
        return
    # fi
    wargs = re.split(r'[ \t]', t_args)
    if wargs is None or len(wargs) < 3 or len(wargs) > 4:
        print_error("change -- there is not three or four arguments.", line)
        return
    # fi
    if len(wargs) == 4:
        if wargs[0] != 'command' or wargs[2] != 'to':
            print_error("change -- command is not first argument of four and to is not third.", line)
            return
        # fi
        wargs = wargs[1:]
    elif len(wargs) == 3:
        if wargs[1] != 'to':
            print_error("change -- to is not second argument.", line)
            return
        # fi
    # fi
    old = wargs[0]
    new = wargs[2]
    # make sure new name does not exist already. -- error
    if new in commands:
        if commands[new] == commands[old]:
            return
        # fi
        print_error("copy new name already exists as different command.", line)
    elif new in macro_buffer:
        print_error("change new name already exists as macro.", line)
        return
    if old not in commands:
        print_error("change old name does not exist.", line)
        return
    # fi
    commands[new] = commands[old]
    del commands[old]
    return
# End of do_change

# ----------------------------------------------------------------------------
# Do nothing for a comment.
#         comment Anything What-so-ever to ignore.
#         comment This is a comment $$ really!

def do_comment(t_args, line):
    return
# End of do_comment

# ----------------------------------------------------------------------------
# For spaces command, set argument --spaces.
#       spaces
#   Use spaces instead of commas for note separators.
#       4c8 d e f g a b 5c
# Normal is: 4c8,d,e,f, g,a,b,c
# The "space" after a comma is used for printing to group first 4 eighth notes,
# and the second four 8th notes -- their heads.

def do_spaces(t_args, line):
    global args

    args.spaces = True
    return
# End of do_spaces

# ----------------------------------------------------------------------------
# copy -- make another name for existing name/copy, replace existing with warning.
#         copy    measure to unit   $$ or:
#         copy    command measure to unit

def do_copy(t_args, line):
    global macro_buffer
    global commands

    if t_args is None or t_args == '':
        print_error("copy does not have three or four arguments.", line)
        return
    # fi
    wargs = re.split(r'[ \t]', t_args)
    if wargs is None or len(wargs) < 3 or len(wargs) > 4:
        print_error("copy - there is not three or four arguments.", line)
        return
    # fi
    if len(wargs) == 4:
        if wargs[0] != 'command' or wargs[2] != 'to':
            print_error("copy - command is not first argument of four and to is not third.", line)
            return
        # fi
        wargs = wargs[1:]
    elif len(wargs) == 3:
        if wargs[1] != 'to':
            print_error("copy - to is not second argument.", line)
            return
        # fi
    # fi
    old = wargs[0]
    new = wargs[2]
    # make sure new name does not exist already. -- error
    if new in commands and old in commands:
        if commands[new] == commands[old]:
            return
        # fi
        print_error("copy new name already exists as different command.", line)
    elif new in macro_buffer:
        print_error("copy new name already exists as macro.", line)
        return
    # fi
    if old == '*' or old == '#':
        old = 'comment'
    # fi
    if old not in commands:
        print_error("copy old name does not exist.", line)
        return
    # fi
    commands[new] = commands[old]
    return
# End of do_copy

# ----------------------------------------------------------------------------
# Give a title to a printed or played song (abcm2ps, or .mid).
#       title   Inventio 15    by Bach
#       title   for plato by Marshall Midden

def do_title(t_args, line):
    global header
    global args

    if t_args is None or t_args == '':
        #-- print_warning("Title does not have any text.", line)
        if args.vertical or args.horizontal:
            header = header + "title   \n"
        elif args.midi1csv or args.fluidsynth:
            pass
        else:           # ABC
            header = header + "T:\n"
        # fi
        return
    # fi
    # T: Title of tune        (can have multiple)
#--     t = line.split(' ', 1)
    if args.vertical or args.horizontal:
        header = header + "title   {}\n".format(t_args)
    elif args.midi1csv or args.fluidsynth:
        header.append(t_args)
    else:           # ABC
        header = header + "T:{}\n".format(t_args)
    # fi
    return
# End of do_title

# ----------------------------------------------------------------------------
# tempo is measured according to beats per minute (bpm) and is divided into:
#       Grave ( <30 bpm)
#       largo (40-50 bpm)
#       larghetto (51-60 bpm)
#       adagio (61-76 bpm)
#       andantino (77-83 bpm)
#       andante (84-90 bpm)
#       andante moderato (90-100 bpm)
#       moderato (100-115 bpm)
#       allegretto (117-119 bpm)
#       allegro (120-160 bpm)
#       allegro con Brio (139 bpm)
#       molto allegro (140-160 bpm)
#       allegro vivace (161-170 bpm)
#       vivace (171-179 bpm)
#       presto (180-199 bpm)
#       prestissimo (>=200 bpm)
# Music types:
#       hip hop (80-115 bpm)
#       triphop (90-110 bpm)
#       concert marches (12- bpm)
#       house (118-135 bpm)
#           UK garage/2-step (130-135 bpm)
#           UK funky (130 bpm)
#       Techno (120-160 bpm)
#           Usually (120-135 bpm)
#           Acid Techno (135-150 bpm)
#           Schranz (150 bpm)
#       Dubstep (70-100 bpm)
#           *Dubstep (70-75 bpm) -- equivalent to 140-150 bpm (if you count on 2 and 4, or 3)
#       Screamers (130-150 bpm)
#       Hardstyle (150 bpm)
#       Juke/Footwork (160 bpm)
#       Drum and Bass (160-180 bpm)
#           Oldschool jungle 160-170 bpm)
#           Drum & Bass and Drumstep and Neurofunk (170-180 bpm)
#       Grime (140 bpm)
#
#   tempo  150,4        $$ Number of notes of given length in a minute.
#   tempo  30           $$ Number of frames (1/57.1429 seconds) per whole note.
#   tempo  200,8        $$ So fast you won't recognize individual notes (:-)>[=<
# NOTDONEYET (below) tempo - accel and rit.
#   tempo  accel        $$ accelerate from current tempo to next tempo command.             NOTDONEYET
#   tempo  120,4,accel  $$ Change to current tempo, and accelerate to next tempo command    NOTDONEYET
#   tempo  120,4,rit    $$ Change to current tempo, and decelerate to next tempo command.   NOTDONEYET

def do_tempo(t_args, line):
    global tempo_speed_default          # beats per minute
    global default_note_length          # length of a beat (note)
    global tempo_speed_now
    global tempo_now_note_length
    global measure_on
    global mlth
    global vl

    if t_args is None or t_args == '':
        print_error("tempo does not have one or two arguments.", line)
        return
    # fi
    wargs = t_args.split(',')
    if wargs is None or len(wargs) == 0 or len(wargs) > 2:
        print_error("tempo - there is not one or two arguments.", line)
        return
    # fi

    fill_voice_mlth(False, line)                   # Need to make measure for other voices up to here "mlth".

    for ve in range(1, len(vl)+1):
        if mlth[ve][measure_on] != 0:
            print_error("tempo in the middle of a measure not allowed", line)
            return
        # fi
    # rof

    #   f1 is value   -- So far computed value
    #   type_error -- type of error
    f1, type_error = is_float(wargs[0], True)
    if type_error is not None:
        print_error("tempo does not have first argument as a floating number. {}".format(type_error), line)
        return
    # fi
    if f1 is None:
        print_error("tempo does not have first argument as a floating number.", line)
        return
    # fi
    if len(wargs) == 1:
        x = f1 / 60.0
        if measure_on == '':
            tempo_speed_default = x
        # fi
        default_note_length[measure_on] = 1.0               # whole note
        tempo_speed_now[measure_on] = x
        tempo_now_note_length[measure_on] = 1.0
        return
    # fi
    xxx = wargs[1].replace('d', '*1.5')
    # f2, type_error = is_float(wargs[1], True)
    f2, type_error = is_float(xxx, True)
    if type_error is not None:
        print_error("Tempo error - {}".format(type_error), line)
        return
    # fi
    if f2 is None:
        print_error("tempo does not have second argument as a floating number.", line)
        return
    # fi
    if measure_on == '':
        tempo_speed_default = f1
    # fi
    default_note_length[measure_on] = (1.0 / f2)
    tempo_speed_now[measure_on] = f1
    tempo_now_note_length[measure_on] = (1.0 / f2)
    return
# End of do_tempo

# ----------------------------------------------------------------------------
#       cstop*      $$ Do not go beyond this line. Start second pass.

def do_cstopnow(t_args, line):
    global errors_happened

    do_pass2()
    sys.exit(errors_happened)
# End of do_cstopnow

# ----------------------------------------------------------------------------
#       cstart              $$ restart compiling after cstop.
# In the C language, (like #if 0 ... #endif // 0)

def do_cstart(t_args, line):
    global cstop_processing

    if not cstop_processing:
        print_error("Not in cstop processing and got a cstart", line)
    # fi
    cstop_processing = False
    return
# End of do_cstart

# ----------------------------------------------------------------------------
#       cstop               $$ stop till cstart or cstop* found.
def do_cstop(t_args, line):
    global cstop_processing

    cstop_processing = True
    return
# End of do_cstop

# ----------------------------------------------------------------------------
#       macro   ABC,First,Second
#       v1: First
#       v2: Second
#       endm                $$ End of a macro definition.
# Usage: ABC    3c4,3e4
# Expands to:
#       v1: 3c4
#       v2: 3e4

def do_endm(t_args, line):
    global macro_defining

    if macro_defining is None:
        print_error("endm command while not defining a macro", line)
        return
    # fi
    macro_defining = None
    return
# End of do_endm

# ----------------------------------------------------------------------------
def replace_macro(command, t_args, line):
    global macro_arguments              # Name of macro, array of arguments for macro.
    global macro_executing_depth        # If processing macro ... reading from macro buffer.
    global macro_executing_args         # Depth, array of arguments given to macro.
    global macro_line                   # Depth, line in macro array.
    global i_line
    global macro_i_line

    if t_args is None or t_args == '':
        if macro_arguments[command] != []:
            print_error("macro command does not have any arguments, but needs {}.".format(macro_arguments[command]), line)
            return
        # fi
        wargs = None
    else:
        wargs = arglist(t_args, line, False)
        if len(wargs) != len(macro_arguments[command]):
            print_error("macro command has {} arguments, but needs {}.".format(wargs, macro_arguments[command]), line)
            return
        # fi
    # fi
    macro_executing_depth.append(command)
    macrodepth = len(macro_executing_depth)
    macro_executing_args[macrodepth] = wargs
    macro_line[macrodepth] = 0             # First line in buffer.
    t_line = i_line
    for i in range(0,len(t_line)):       # Save current depth of line.
       t_line[i] = 'rmacr: ' + t_line[i][7:]
    # rof
    macro_i_line[macrodepth] = t_line       # Save current depth of line.
# End of replace_macro

# ----------------------------------------------------------------------------
#   macro name,arg1,arg2,...,argn
#     body of macro
#   endm
#         Changes arg1 to passed in usage.
#   name  first,second arg,something    # example 3 arguments - spaces allowed.
# See "endm" above for trivial example.
#
# Macros must not be existing commands -- replace existing macro with warning.

def do_macro(t_args, line):
    global commands
    global macro_defining               # If defining macro.
    global macro_buffer                 # Name of macro, array of lines for macro.
    global macro_arguments              # Name of macro, array of arguments for macro.

    if t_args is None or t_args == '':
        print_error("macro command does not have any arguments.", line)
        return
    # fi

    wargs = arglist(t_args, line, False)
    if not wargs or len(wargs) < 1:
        print_error("no macro name.", line)
        return
    # fi

    name = wargs[0]
    args = wargs[1:]
    if name in commands:
        print_error("macro ({}) would replace existing command".format(name), line)
        return
    # fi
    if name in macro_buffer:
        print_warning("macro ({}) will replace existing macro".format(name), line)
    # fi

    macro_buffer[name] = []             # No lines in buffer.
    macro_arguments[name] = args
    macro_defining = name
    return
# End of do_macro

# ----------------------------------------------------------------------------
def macro_define(command, t_args, line):
    global macro_defining               # If defining macro.
    global macro_buffer                 # Name of macro, array of lines for macro.

    if t_args and t_args != '':
        macro_buffer[macro_defining].append(command + ' ' + t_args)
    else:
        macro_buffer[macro_defining].append(command)
    # fi
    return
# End of macro_define

# ----------------------------------------------------------------------------
# putd ... if already existing, replace with warning.
#     putd   /cmajor/c,e,g/
#     =cmajor,b           # c,e,g,b       Note: do multiple putd's on this line.
# Stop when no change occurs, or 100 tries. (Catches A -> B -> A loops.)

def do_putd(t_args, line):
    if t_args is None or t_args == '':
        print_error("putd does not have an argument.", line)
        return
    # fi
    c = t_args[0]                    # The separation character.
    two = t_args.split(c)
    if len(two) != 4 or two[0] != '' or two[3] != '':
        print_error("putd should look like '/zzz/a,b,c/' - not right number of separators ({}).".format(c), line)
        return
    # fi
    putds[two[1]] = two[2]
    return
# End of do_putd

# ----------------------------------------------------------------------------
def process_putd(line):
    global putds

    newline = line[1:]                  # Toss '=' (putd) character.
    for a in putds:
        newline = newline.replace(a, putds[a])
    # rof
    return newline
# End of process_putd

# ----------------------------------------------------------------------------
#       endif           $$ end of an "if else endif" sequence.

def do_endif(t_args, line):
    global ifdepth

    if ifdepth == 0:
        print_error("endif command while not in an if command", line)
        return
    # fi
    # if iftest[ifdepth] == -1:           # already processing, handle as normal if.
    # if iftest[ifdepth] == 0:            # skipping if, want to do else.
    # if iftest[ifdepth] == 1:            # processing in else, want to do as normal if.
    # if iftest[ifdepth] == 2:            # skipping in else, ignore if and else processing, want endif.
    # if iftest[ifdepth] == 3:            # skip both if and else, want endif
    ifdepth = ifdepth - 1
    return
# End of do_endif

# ----------------------------------------------------------------------------
#       else            $$ else clause of an "if else endif" sequence.

def do_else(t_args, line):
    global ifdepth
    global iftest

    if ifdepth == 0 or iftest[ifdepth] == 1 or iftest[ifdepth] == 2:
        print_error("else command while not in an if command", line)
        return
    # fi

    if iftest[ifdepth] == -1:           # already processing, handle as normal if.
        iftest[ifdepth] = 2             # Switch to skipping else.
        return
    # fi
    if iftest[ifdepth] == 0:            # skipping if, want to do else.
        iftest[ifdepth] = 1             # Switch to processing else.
        return
    # fi
    # if iftest[ifdepth] == 3:            # skip both if and else, want endif
    # NOTE: do not test for if/else/endif ... second else.
    return
# End of do_else

# ----------------------------------------------------------------------------
#       if      -1      $$ Start of an "if else endif" sequence.
#       if      0       $$ False
#       if      1       $$ Non-zero is true.
#       else            $$ if if was false, do the else clause. (optional)
#       endif           $$ end of the if else.

def do_if(t_args, line):
    global iftest                       # check if after if or else.
    global ifdepth                      # level of if/else/endif

    if t_args is None or t_args == '':
        print_error("if command does not have exactly one argument.", line)
        return
    # fi
    # if iftest[ifdepth] == -1:           # already processing, handle as normal if.
    # if iftest[ifdepth] == 0:            # skipping if, want to do else.
    # if iftest[ifdepth] == 1:            # processing in else, want to do as normal if.
    # if iftest[ifdepth] == 2:            # skipping in else, ignore if and else processing, want endif.
    # if iftest[ifdepth] == 3:            # skip both if and else, want endif
    if iftest[ifdepth] == -1 or iftest[ifdepth] == 1:   # process this if normally.
        wargs = arglist(t_args, line, False)
        if not wargs or len(wargs) < 1:
            print_error("no if argument.", line)
            return
        # fi
        value, type_error = is_float(wargs[0], True)
        if type_error is not None or value is None:
            print_error("if unable to determine if value ({}).".format(wargs[0]), line)
            return
        # fi
        value =  -1 if value < 0 or value > 0 else 0   # 0 is false, otherwise everything is true.
    else:
        value = 3                           # Skip both if and else.
    # fi
    ifdepth = ifdepth + 1
    iftest[ifdepth] =  value
    return
# End of do_if

# ----------------------------------------------------------------------------
#  Halt input and requst user input.
#       marker  5                       $$ Printout "5" and prompt for input to continue.
# Allows output to be printed as compiling is occuring -- for debugging.
# Think "macros", "putd", or "calc".

def do_marker(t_args, line):
    global args

    fill_voice_mlth(False, line)                   # Need to make measure for other voices up to here "mlth".

    if t_args is None or t_args == '':
        value = '0'
    else:
        value, type_error = is_float(t_args, False)
        if type_error is not None or value is None:
            print_warning("marker unable to compute value({}) - using text string.".format(t_args), line)
            value = str(t_args)
        else:
            value = str(int(round(value)))      # Stupid python language upgrade incompatibility.
        # fi
    # fi

    if args.rest and len(args.rest) >= 2:
        outf = sys.stdout
    else:
        outf = sys.stderr
    # fi
    if args.rest and len(args.rest) >= 1:
        # Can get input from terminal.
        if sys.stdin.isatty():
            if sys.platform == 'darwin':
                input('marker ' + value + ' > ')
                line = readline.get_line_buffer()
            else:
                line = input('marker ' + value + ' > ')
            # fi
        else:
            print('marker ' + value + ' > ', file=outf, flush=True)
            line = sys.stdin.readline()
        # fi
    # fi
    return
# End of do_marker

# ----------------------------------------------------------------------------
# Print out a line for debugging.
#   debug                               - Print out a count of debug commands..
#   debug   page                        - Current value of page variable.
#   debug   measure                     - Current value of measure variable.
#   debug   m1*2+7                      - A calculation.
#   debug   we are here                 - A message (not a calculation).

global debug_count
debug_count = 0

def do_debug(t_args, line):
    global args
    global debug_count

    debug_count = debug_count + 1

    if t_args is None or t_args == '':
        value = 'count: ' + str(debug_count)
    else:
        wargs = arglist(t_args, line, False)
        if not wargs or len(wargs) < 1:
            value = 'count: ' + str(debug_count)
        else:
            value, type_error = is_float(wargs[0], False)
            if type_error is not None or value is None or value == 'error parsing':
                value = 'message: ' + ' '.join(wargs) + ' -- ' + t_args
            else:
                value = 'value: ' + str(value) + ' -- ' + t_args
            # fi
        # fi
    # fi
    print('DEBUG ' + value, file=sys.stderr, flush=True)
    return
# End of do_debug

# ----------------------------------------------------------------------------
#   randp   m1          $$ Assigned unduplicated random numbers from last setperm.

def do_randp(t_args, line):
    global array_of_random_numbers

    if t_args is None or t_args == '':
        print_error("randp command does not have exactly one argument.", line)
        return
    # fi
    wargs = arglist(t_args, line, False)
    if not wargs or len(wargs) < 1:
        print_error("no randp argument.", line)
        return
    # fi
    if len(array_of_random_numbers) <= 0:
        # print_error("randp needs a setperm before it runs.".format(wargs[0], value), line)
        ran = 0
    else:
        ran = array_of_random_numbers.pop()
    # fi
    computeit = wargs[0] + '=' + str(ran)       # Do the assignment.
    value, type_error = is_float(computeit, True)
    if type_error is not None or value is None:
        print_error("randp unable to assign value({}) to first argument({}).".format(wargs[0], value), line)
        return
    # fi
    return
# End of do_randp

# ----------------------------------------------------------------------------
#   setperm 44          $$ Semi random numbers between 1 and 44, without duplication.

def do_setperm(t_args, line):
    global array_of_random_numbers

    if t_args is None or t_args == '':
        print_error("setperm command does not have any arguments.", line)
        return
    # fi
    wargs = arglist(t_args, line, False)
    if not wargs or len(wargs) != 1:
        print_error("Need exactly one setperm argument", line)
        return
    # fi

    value, type_error = is_float(wargs[0], True)     # From 1 to value.
    if type_error is not None or value is None or value < 1:
        print_error("setperm unable to compute reasonable value({}) for number of unique random numbers.".format(wargs[0]), line)
        return
    # fi
    value = int(round(value))                   # So, python2 and python3 do round differently. *SCREAM*
    array_of_random_numbers = random.sample(range(1, value+1), value)
    return
# End of do_setperm

# ----------------------------------------------------------------------------
#   randu   m1,10       $$ random number between 1 and 10 put into variable m1.

def do_randu(t_args, line):
    if t_args is None or t_args == '':
        print_error("randu command does not have any arguments.", line)
        return
    # fi
    wargs = arglist(t_args, line, False)
    if not wargs or len(wargs) < 1:
        print_error("no randu arguments", line)
        return
    # fi

    value, type_error = is_float(wargs[1], True)     # From 1 to value.
    if type_error is not None or value is None or value < 1:
        print_error("randu unable to compute reasonable value({}) to store in ({}).".format(wargs[1], wargs[0]), line)
        return
    # fi
    ran = random.randint(1, int(round(value)))  # Random value.
    computeit = wargs[0] + '=' + str(ran)       # Do the assignment.
    value, type_error = is_float(computeit, True)
    if type_error is not None or value is None:
        print_error("randu unable to assign value({}) to first argument({}).".format(wargs[0], value), line)
        return
    # fi
    return
# End of do_randu

# ----------------------------------------------------------------------------
# Not likely to ever do.
#   percus              does things with slide projector.

def do_percus(t_args, line):
    print_error("percus command makes no sense for python or MIDI.", line)
    return
# End of do_percus

# ----------------------------------------------------------------------------
# Not likely to ever do. Would do it differently for MIDI.
#   delay 15            delay in 1/60ths of a second. Like a fermate.  15=1/4th of a second

def do_delay(t_args, line):
    global voices                       # number of voices
    global cis                          # if cis active, non-zero.
    global tempo_speed_default
    global default_note_length
    global measure_on
    global tempo_speed_now
    global tempo_now_note_length

    fill_voice_mlth(False, line)               # Need to make measure for other voices up to here "mlth".

    if t_args is None or t_args == '':
        print_error("delay command does not have any arguments.", line)
        return
    # fi
    wargs = arglist(t_args, line, False)
    if not wargs or len(wargs) < 1:
        print_error("no delay arguments", line)
        return
    # fi
    value, type_error = is_float(wargs[0], True)
    if type_error is not None or value is None:
        print_error("delay unable to compute value({}).".format(wargs[0]), line)
        return
    # fi

    # Convert value/60.0 to note_beats/minute (tempo).
    # tempo_speed_default = 120.0                 # beats per minute.
    # default_note_length[measure_on]     # length of a beat (note)
    # (tempo beats/minute) * (1/60.0 minutes/sec)
    #  (tempo/60.0  beats/sec) * (1/default_note_length[measure_on] = ?_note/beats)
    #  (tempo/(60.0*default_note_length[measure_on]) ?_note/sec)  * seconds
    if measure_on == '':
        rvalue = value * tempo_speed_default / (60.0*default_note_length[measure_on])
    else:
        rvalue = value * tempo_speed_now[measure_on] / (60.0*tempo_now_note_length[measure_on])
    # fi

    loopstart = 1 if cis == 0 else cis
    r = 'r({}/60.0)'.format(rvalue)
    for onvoice in range(loopstart+1, voices + 1):
        r = r + ',r({}/60.0)'.format(rvalue)
    # rof
    process_notes(r)
    return
# End of do_delay

# ----------------------------------------------------------------------------
# Not likely to ever do.
#   slide  from,to,length     $$ Glissando - only can be used after voice 1 or cis n command.

def do_slide(t_args, line):
    print_error("slide command makes no sense for python or MIDI.", line)
    return
# End of do_slide

# ----------------------------------------------------------------------------
# This command raises or lowers the note pitch by the specified number of
# semitones. A semitone is one of the 12 notes in a scale from
#       c,c+,d,d+,e,f,f+,g,g+,a,a+,b,b+ and back to c one octave higher.
#   pitch -2            $$ sets semitones lower

def do_pitch(t_args, line):
    global pitch
    global measure_on
    global mlth

    if t_args is None or t_args == '':
        print_error("pitch does not have an expression to process", line)
        return
    # fi

    for ve in range(1, len(vl)+1):
        if mlth[ve][measure_on] != 0:
            print_error("pitch in the middle of a measure not allowed", line)
            return
        # fi
    # rof

    m = t_args

    f, type_error = is_float(m, True)
    if type_error is not None:
        print_error("Tempo error - {}".format(type_error), line)
        return
    # fi
    if f is None:
        print_error("pitch argument as a calculation did not return a value", line)
        return
    # fi
    pitch[measure_on] = int(round(f))
    return
# End of do_pitch

# ----------------------------------------------------------------------------
# Not likely to do. No idea what this does.
#   temper a            $$ sets just intonation in the key.

def do_temper(t_args, line):
    print_error("NOTDONEYET - do_temper", line)
    return
# End of do_temper

# ----------------------------------------------------------------------------
# Not likely to do.
#   tuning ??            $$

def do_tuning(t_args, line):
    print_error("NOTDONEYET - do_tuning", line)
    return
# End of do_tuning

# ----------------------------------------------------------------------------
# Not likely to do. No nameset processing ... use "instrument" instead.
#   instr ??            $$

def do_instr(t_args, line):
    print_error("NOTDONEYET - do_instr", line)
    return
# End of do_instr

# ----------------------------------------------------------------------------
# Not likely to do. Use "cpp" or similar preprocessors instead.
#   include ??            $$

def do_include(t_args, line):
    print_error("NOTDONEYET - do_include", line)
    return
# End of do_include

# ----------------------------------------------------------------------------
# Not likely to do. Doesn't make sense until other IMS processing is done.
#   format ??            $$

def do_format(t_args, line):
    print_error("NOTDONEYET - do_format", line)
    return
# End of do_format

# ----------------------------------------------------------------------------
# Not likely to do. Doesn't make sense until other IMS processing is done.
#   print ??            $$

def do_print(t_args, line):
    print_error("NOTDONEYET - do_print", line)
    return
# End of do_print

# ----------------------------------------------------------------------------
# Not likely to ever do. Use key command.
#   sharp   f

def do_sharp(t_args, line):
    print_error("NOTDONEYET - do_sharp", line)
    return
# End of do_sharp

# ----------------------------------------------------------------------------
# Not likely to ever do. Use key command.
#   flat    b,e         flat/sharp are cumulative -- double flats, etc.

def do_flat(t_args, line):
    print_error("NOTDONEYET - do_flat", line)
    return
# End of do_flat

# ----------------------------------------------------------------------------
# Not likely to ever do. Use key command.
#   natural c           undo any flat/sharp.

def do_natural(t_args, line):
    print_error("NOTDONEYET - do_natural", line)
    return
# End of do_natural

# ----------------------------------------------------------------------------
#   goto    6.5,x,8,2,... $$ repeat and/or skip.  "x" = continue, forwards, backwards. No Max arguments?
#                       counter is number of times reached.
#   measure 78
#   goto    80
#   measure 79
#   goto    99
#   measure 80
#   goto    78,79
#   measure 99          $$ Executes: 78 -> 80 -> 78 -> 80 -> 79 -> 99
# Note: Wraps when counter reaches end of arguments.
# "goto 78,79" would repeat at 78, then 79 again, then 78 ...

def do_goto(t_args, line):
    global measure_on
    global goto_table
    global goto_variables

    if args.nogoto:
        print_warning("Ignoring goto parsing.", line)
        return
    # fi

    if measure_on in goto_table:
        print_error("Second goto in measure note allowed.", line)
        return
    # fi

    if t_args is None or t_args == '':
        print_error("goto needs at least one argument", line)
        return
    # fi
    wline = t_args
    # Get rid of all white spoce.
    wline = ''.join(wline.split())
    wargs = arglist(wline, line, False)

    if len(wargs) == 0:
        print_error("goto needs at least one argument", line)
        return
    # fi

    g = []
    for i in range(1, len(wargs)+1):
        v = wargs[i - 1]

        if v is None:
            print_error("goto does not have argument as a measure.", line)
            return
        # fi

        f1 = None
        for a in v:
            if a in "abcdefghijklnopqrstuvwxyz_ABCDEFGHIJKLMNOPQRSTUVWXYZ":
                f1 = v
                break
            # fi
        # rof
        if f1 is None:
            f1, type_error = is_float(v, True)
            if type_error is not None or f1 is None:
                # Error, use it as string instead.
                f1 = str(v)
            else:
                tmp = int(round(f1))
                if (f1 - tmp) == 0:
                    f1 = tmp
                # fi
            # fi
        # fi
        v = str(f1)

        g.append(v)
    # rof
    fill_voice_mlth(True, line)               # Need to make measure for other voices up to here "mlth".
    goto_table[measure_on] = g
    return
# End of do_goto

# ----------------------------------------------------------------------------
def to_abc_note(note_number):
    if note_number <= 0 or note_number == '0':
        return 'z'
    # fi
    o = int(note_number / 12)                           # get octave
    n = note_number - (o * 12)                          # note is remainder
    octaves = { 0:',,,', 1:',,', 2:',', 3:'', 4:'', 5:"'", 6:"''", 7:"'''", 8:"''''" }
    notes = { 0:'a', 1:'^a', 2:'b', 3:'c', 4:'^c', 5:'d', 6:'^d', 7:'e', 8:'f', 9:'^f', 10:'g', 11:'^g' }
    if o not in octaves:
        print_debug("to_abc_note({}) bad octave ({})".format(note_number,o))
        return 'z'
    # fi
    if n not in notes:
        print_debug("to_abc_note({}) bad note ({})".format(note_number,n))
        return 'z'
    # fi
    n = notes[n]
    if o <= 3:                                          # uppercase letter
        n = n.upper()
    else:                                               # lowercase letter
        n = n.lower()
    # fi
    o = octaves[o]
    thenote = n + o
    return thenote
# End of to_abc_note

# ----------------------------------------------------------------------------
#   decode  m1,3c+          $$ note number for 3c+ into m1
#   decode  m1,m2,3c+4      $$ note number for 3c+ into m1, note length (4) in m2.
#   decode  m1,m2,m3,3c+4l  $$ note number for 3c+ into m1, note length (4) in m2, 16 into m3.
# NOTE: Values are as follows:
#   suffix_emphasis = 32        # Emphasis
#   suffix_legato = 16          # glide to next note - no note attack on start of next note.
#   suffix_broken = 8           # broken - ignored - break between notes ... because gsw didn't have it.
#   suffix_marcato = 4          # ignored   -- use vol(sf), etc.
#   suffix_tied = 2             # tied
#   suffix_staccato = 1         # staccato
#   suffix_normal = 0           # No suffix.

def do_decode(t_args, line):
    global args
    global measure_on
    global key_sig
    global key_voice

    if t_args is None or t_args == '':
        print_error("decode command does not have any arguments.", line)
        return
    # fi
    wargs = arglist(t_args, line, False)

    if not wargs or len(wargs) < 1:
        print_error("no decode arguments", line)
        return
    # fi
    if len(wargs) > 4 or len(wargs) == 1:
        print_error("Not correct number of arguments for decode commmand", line)
        return
    # fi
    # Save what type of processing we are doing.
    saveargsh = args.horizontal
    saveargsv = args.vertical
    saveargsm = args.midi1csv
    saveargsf = args.fluidsynth
    saveargabc = args.abc
    savekeyvoice = key_voice[measure_on][1]
    # ------------------------------------------------------------------------------
    if args.vertical or args.horizontal:
        k = key_sig[savekeyvoice]           # Convert to number.
    elif args.midi1csv or args.fluidsynth:
        k = savekeyvoice
    else:                                   # ABC
        # Convert to normal format.
        k = savekeyvoice.lower()
        k = k.replace('b', '-')             # Does multiple flats
        k = k.replace('#', '+')             # Does multiple sharps.
        k = k.replace('=', 'n')             # Does multiple naturals.
        k = key_sig[k]                      # Convert to number.
    # fi
    # ------------------------------------------------------------------------------
    # Set to midi format -- so we have a value.
    args.horizontal = False
    args.vertical = False
    args.midi1csv = True
    args.fluidsynth = False
    args.abc = False
    key_voice[measure_on][1] = k

    if len(wargs) == 2:         # decode m1,3c4
        w_note = wargs[1]
    elif len(wargs) == 3:       # decode m1,m2,3c4
        w_note = wargs[2]
    else:                   # 4
        w_note = wargs[3]       # decode m1,m2,m3,3c4
    # fi
    # Ignore leading space.
    therest, thenote, typenote = getnote(w_note, 1, line, False)

    # Restore type of processing we are doing.
    args.horizontal = saveargsh
    args.vertical = saveargsv
    args.midi1csv = saveargsm
    args.fluidsynth = saveargsf
    args.abc = saveargabc
    key_voice[measure_on][1] = savekeyvoice

    if therest is None or thenote is None:
        print_warning("decode note had error with note {}".format(w_note), line)
        return
    # fi
    if therest and len(therest) > 0 and len(wargs) == 2:
        print_warning("decode note has information ({}) after the note {}".format(therest, w_note), line)
    # fi
    if typenote != normal_note:
        print_warning("decode note is not of type normal_note -- ({})".format(typenote), line)
        return
    # fi
    if thenote <= 12 + 12 - 3:
        computeit = wargs[0] + '=' + '0'                       # rest = 0
    else:
        computeit = wargs[0] + '=' + str(thenote) + '+3-12-12'  # Convert from midi note to musicomp value.
    # fi
    value, type_error = is_float(computeit, True)
    if type_error is not None or value is None:
        print_error("decode note unable to assign value({}) to first argument({}).".format(thenote, wargs[0]), line)
        return
    # fi
    if len(wargs) < 3:      # 3 or 4 arguments continue.
        return
    # fi

    # Get the time value for the note.
    timeofnote, r_suffixes, number_dots = get_time(therest, line)

    if r_suffixes is None or number_dots is None:
        print_error("decode - Error getting time for note", line)
        return
    # fi
    # suffix_legato = 16            -- glide to next note.
    # suffix_tied = 2               -- tied
    # suffix_staccato = 1           -- staccato
    # suffix_dotted = -1
    # suffix_normal = 0
    # bits are $union$'ed together for multiple modifiers.
    # number_dots are how many "d" (dotted) were found.
    if timeofnote is None or timeofnote == 0:
        if number_dots != 0:
            print_error("cannot have dotted syntax on a default note length.", line)
            return
        # fi
        timeofnote = time[getvar('voice')]      # Interesting - get last time used. :)
    # fi
    if number_dots != 0:
        p = timeofnote / 2.0
        for i in range(1, number_dots+1):
            timeofnote = timeofnote + p
            p = p / 2.0
        # rof
    # fi
#--     if typenote == gsw_operand:
#--         print_error("NOTDONEYET - doing decode of gsw operand type of note", line)
#--         return
#--     # fi
#--     if typenote == freqency_note:
#--         print_error("NOTDONEYET - doing decode of freqency type of note", line)
#--         return
#--     # fi
#--     if typenote == trill_note:
#--         print_error("NOTDONEYET - doing decode of trill of notes", line)
#--         return
#--     # fi
#--     if typenote == sequence_note:
#--         print_error("NOTDONEYET - doing decode of sequence of notes", line)
#--         return
#--     # fi

    computeit = wargs[1] + '=' + str(timeofnote)    # Should be floating number.
    value, type_error = is_float(computeit, True)
    if type_error is not None or value is None:
        print_error("decode note unable to assign value({}) to second argument({}).".format(timeofnote, wargs[1]), line)
        return
    # fi

    if len(wargs) == 3:      # 4 arguments, get suffixes after the note.
        if r_suffixes != 0:
            print_warning("decode note has information after the time, suffixes={}".format(r_suffixes), line)
        # fi
        return
    # fi

    computeit = wargs[2] + '=' + str(r_suffixes)
    value, type_error = is_float(computeit, True)
    if type_error is not None or value is None:
        print_error("decode note unable to assign value({}) to third argument({}).".format(r_suffixes, wargs[2]), line)
        return
    # fi
    return
# End of do_decode

# ----------------------------------------------------------------------------
#       clef    1,2,3   treble          $$ Set voices 1,2,3 to treble.
#       clef    4       alto
#       clef    treble,bass,alto,tenor  $$ A different way to do it.
# NOTE: The argument is put into the .abc file, and NOT checked in any way.

def do_clef(t_args, line):
    global clef
    global measure_on

    if t_args is None or t_args == '':
        print_error("clef does not have arguments.", line)
        return
    # fi

    targs = re.sub(r'\s*,\s*', ',', t_args)

    vargs = targs.split()
    if len(vargs) <= 0 or len(vargs) > 2:
        print_error("clef does not have correct number of arguments.", line)
        return
    # fi
    if len(vargs) == 1:
        wargs = arglist(targs, line, False)
        if not wargs or len(wargs) < 1:
            print_error("no clef selection arguments", line)
            return
        # fi
        for i in range(1, len(wargs)+1):
            clef[measure_on][i] = wargs[i-1].strip()   # No checking.
        # rof
        return
    # fi
    clf = vargs[1]

    jkl = "".join(vargs[0])
    wargs = arglist(jkl, line, True)
    if not wargs or len(wargs) < 1:
        print_error("no voice arguments on clef line", line)
        return
    # fi
    for w in wargs:
        f1, type_error = is_float(w, True)
        if type_error is not None:
            print_error("clef error - {}".format(type_error), line)
            return
        # fi
        if f1 is None:
            print_error("voice {} is not a number.".format(w), line)
            return
        # fi
        f1 = int(round(f1))
        clef[measure_on][f1] = clf
    # rof
    return
# End of do_clef

# ----------------------------------------------------------------------------
#       bars    7+1             $$ The first one must be one more than wanted -- due to "measure 0"
#                               $$ setting things line meter up. Dunno, it works.
#       bars    7               $$ Group the next 7 bars on one staff line -- .abc file.

def do_bars(t_args, line):
    global bars
    global measure_on

    if t_args is None or t_args == '':
        print_error("bars does not have an expression to process", line)
        return
    # fi

    m = t_args

    f, type_error = is_float(m, True)
    if type_error is not None:
        print_error("bars error - {}".format(type_error), line)
        return
    # fi
    if f is None:
        print_error("bars argument as a calculation did not return a value", line)
        return
    # fi
    bars[measure_on] = int(round(f))
    # fi
    return
# End of do_bars

# ----------------------------------------------------------------------------
# The value for middle_c.
#       middlec 4c
#       middlec 3c
#       middlec 2b-

def do_middle_c(t_args, line):
    global middle_c
    global measure_on

    if t_args is None:
        print_error("middlec does not have a note to process", line)
        return
    # fi
    if t_args == '':
        compute_middle_c(39)
        return
    # fi
    note_to_decode = targs
    temp3 = 0                                   # character pointer
    if note_to_decode[0] == '(':
        thenote, type_error = is_float(note_to_decode, True)
        if type_error is not None:
            print_error("middlec does not have a valid number in parenthesis", line)
            return
        # fi
        if thenote is None:
            print_error("middle_c - m:{} Note is not legal '{}', computation failed".format(measure_on, note_to_decode), line)
            return
        # fi
        note_to_decode = int(round(thenote))
        note_to_decode = note_to_decode + 12 + 12 - 3     # 3c -> 39 must be 60 for midi.
        if note_to_decode <= 0 or note_to_decode >= 127:
            print_error("middle_c - m:{} Note number '{}' not in range".format(measure_on, thenote), line)
            return
        # fi
        compute_middle_c(int(round(thenote)))
        return
     # fi

    if note_to_decode not in note_to_midi_value:
        print_error("middle_c - m:{} note_to_decode '{}' legal note".format(measure_on, note_to_decode), line)
        return
    # fi
    number = note_to_midi_value[note_to_decode] - (60 - middle_c)
    compute_middle_c(number)
    return
# End of do_middle_c

# ----------------------------------------------------------------------------
# The number of notes of second argument note length in a measure.
#       meter   1/4             $$ 1 quarter note per measure.
#       meter   12/8            $$ 12 eighth notes per measure.
#       meter   4,4             $$ 4 quarter notes per measure.
# Note: the comma allows for IMS format "time" command.

def do_meter(t_args, line):
    global meter
    global measure_meter
    global measure_meter_value
    global measure_on
    global args
    global mlth

    if t_args is None or t_args == '':
        print_error("meter does not have an expression to process", line)
        return
    # fi

    for ve in range(1, len(vl)+1):
        if mlth[ve][measure_on] != 0:
            print_error("meter in the middle of a measure not allowed", line)
            return
        # fi
    # rof

    m = t_args
    m = re.sub(r',', r'/', m)

    f, type_error = is_float(m, True)
    if type_error is not None:
        print_error("meter error - {}".format(type_error), line)
        return
    # fi
    if f is None:
        print_error("meter argument as a calculation did not return a value", line)
        return
    # fi
    meter = m
    measure_meter[measure_on] = m                       # Save text for meter.

    f, type_error = is_float(m, True)
    if type_error is not None:
        print_error("meter error - {}".format(type_error), line)
        return
    # fi
    if f is None:
        print_error("calculating meter did not return a value", line)
        return
    # fi
    measure_meter_value = f
    return
# End of do_meter

# ----------------------------------------------------------------------------
#   calc m1=10          $$ variables m1 to m50.  m(m2)=m9/5   # floating point.
#               Note: special variables stac, grace, frames, pause - don't really mean anything.
#   calc this=m1 * 5 + 6 ** 3 / 19      $$ Define variable "this", m1 is 10, so 266/9 gives 74.
# Note: m(10) is the same as m10.
# Functions:  freq(), neareast(), abs(), arctan(), cos(), exp(), frac(), int(),
#             log(), ln(), round(), sign(), sin(), sqrt(), not()
# Values:     pi, e, tau.
# Priority: =,                                      $$ Assignment.
#           $or$, $and$,                            $$ Logical or / and. (true/false $and$ true/false)
#           >,>=,<,<=,==,!=,                        $$ less than, equal, greater, etc.
#           $union$,$mask$,$diff$,$cls$,$ars$,      $$ bitwise operations.
#           +,-,                                    $$ addition/subtraction
#           /                                       $$ divide
#           *                                       $$ multiply
#           **                                      $$ exponent
#           +,-                                     $$ leading + or -
#           (,[,{, },],)                            $$ Parenthesis

def do_calc(t_args, line):
    if t_args is None or t_args == '':
        print_error("calc does not have an expression to process", line)
        return
    # fi
    f, type_error = is_float(t_args, False)
    if type_error is not None:
        print_error("calc error - {}".format(type_error), line)
        return
    # fi
    if f is None:
        print_error("calculate did not return a value", line)
        return
    # fi
    return
# End of do_calc

# ----------------------------------------------------------------------------
# Following does not do multiple sharps or flats, but that is crazy anyway. Neither naturals.
global key_sig
key_sig = { 'c+':7, 'f+':6, 'b':5, 'bn':5, 'e':4, 'en':4, 'a':3, 'an':3, 'd':2, 'dn':2, 'g':1, 'gn':1, 'c':0, 'cn':0,
            'f':-1, 'b-':-2, 'e-':-3, 'a-':-4, 'd-':-5, 'g-':-6, 'c-':-7 }

global key_sig_int
key_sig_int = {}
for i in key_sig:
    if key_sig[i] not in key_sig_int:
        key_sig_int[key_sig[i]] = i
    # fi
# rof

global key_to_accidentals
key_to_accidentals = {
    'c':  ('c', 'd', 'e', 'f', 'g', 'a', 'b'),
    'cn':  ('c', 'd', 'e', 'f', 'g', 'a', 'b'),

    'f':  ('c', 'd', 'e', 'f', 'g', 'a', 'b-'),
    'b-': ('c', 'd', 'e-', 'f', 'g', 'a', 'b-'),
    'e-': ('c', 'd', 'e-', 'f', 'g', 'a-', 'b-'),
    'a-': ('c', 'd-', 'e-', 'f', 'g', 'a-', 'b-'),
    'd-': ('c', 'd-', 'e-', 'f', 'g-', 'a-', 'b-'),
    'g-': ('c-', 'd-', 'e-', 'f', 'g-', 'a-', 'b-'),
    'c-': ('c-', 'd-', 'e-', 'f-', 'g-', 'a-', 'b-'),

    'g':  ('c', 'd', 'e', 'f+', 'g', 'a', 'b'),
    'd':  ('c+', 'd', 'e', 'f+', 'g', 'a', 'b'),
    'a':  ('c+', 'd', 'e', 'f+', 'g+', 'a', 'b'),
    'e':  ('c+', 'd+', 'e', 'f+', 'g+', 'a', 'b'),
    'b':  ('c+', 'd+', 'e', 'f+', 'g+', 'a+', 'b'),
    'f+': ('c+', 'd+', 'e+', 'f+', 'g+', 'a+', 'b'),
    'c+': ('c+', 'd+', 'e+', 'f+', 'g+', 'a+', 'b+')
}

global key_convert
key_convert = { }
for i in key_to_accidentals:
    l = {}
    for o in range(0,9) :
        m = 0
        for n in ('c', 'd', 'e', 'f', 'g', 'a', 'b'):
            l[str(o) + n + '--'] = str(o) + n + '--'
            l[str(o) + n + '-']  = str(o) + n + '-'
            l[str(o) + n]        = str(o) + key_to_accidentals[i][m]
            l[str(o) + n + 'n']  = str(o) + n + 'n'
            l[str(o) + n + '+']  = str(o) + n + '+'
            l[str(o) + n + '++'] = str(o) + n + '++'
            m = m + 1
        # rof
    # rof
    key_convert[i] = l
# rof

global minor_key_to_major
minor_key_to_major = {
    'a+': 'c+',
    'd+': 'f+',
    'g+': 'b',
    'c+': 'e',
    'f+': 'c+',
    'b':  'd',
    'e':  'g',

    'a':  'c',

    'd':  'f',
    'g':  'b-',
    'c':  'e-',
    'f':  'a-',
    'b-': 'd-',
    'e-': 'g-',
    'a-': 'c-'
}

#-----------------------------------------------------------------------------
#       key     a                   $$ key of a major for all voices. f+,c+,g+
#       =key    violaA..violaB g-   $$ viola - six flats
#       key     1,2 c major         $$ If "major" is present ...
#       key     1, 2  c minor       $$ b-,e-,a-  same as key e- or key e- major.
#       key     1, 2  atonal        $$ Each note is stand-alone.
#       key     atonal              $$ Each note is stand-alone.
# Changes at start of a measure.

def do_key(t_args, line):
    global args
    global measure_on
    global key_sig
    global key_default
    global key_voice
    global mlth
    global vl
    global minor_key_to_major

    if t_args is None or t_args == '':
        print_error("key command does not have arguments", line)
        return
    # fi

    targs = re.sub(r'\s*,\s*', ',', t_args)
    targs = re.sub(r'\s*\.\.\s*', '..', targs)
    # Voice numbers (optional), followed by key name, with major/minor (optional).
    vargs = targs.split()

    if len(vargs) <= 0 or len(vargs) > 3:
        print_error("key command does not have correct number of arguments", line)
        return
    # fi

    if len(vargs) == 3:                     # Handle major or minor.
        k = vargs[1].lower()
        mm = vargs[2].lower()
        vs = vargs[0]
        if mm == "minor":
            if k not in minor_key_to_major:
                print_error("key command does not recognize minor {}".format(k), line)
                return
            # fi
            k = minor_key_to_major[k]
        elif mm == "major":
            if k not in key_sig:
                print_error("key '{}' not recognized.".format(k), line)
                return
            # fi
        else:
            print_error("key command does not recognize {} as major or minor".format(vargs[2]), line)
            return
        # fi
    elif len(vargs) == 2:
        k = vargs[0].lower()
        mm = vargs[1].lower()
        vs = None
        if mm == "minor":
            if k not in minor_key_to_major:
                print_error("key command does not recognize minor {}".format(k), line)
                return
            # fi
            k = minor_key_to_major[k]
        elif mm == "major":
            if k not in key_sig:
                print_error("key '{}' not recognized.".format(k), line)
                return
            # fi
        else:                               # No major or minor, so "key 1,2 c-" format.
            vs = vargs[0]
            k = mm
            if k not in key_sig and k not in ['none', 'atonal']:
                print_error("key '{}' not recognized.".format(k), line)
                return
            # fi
        # fi
    else:
        vs = None
        k = vargs[0].lower()
        if k not in key_sig and k not in ['none', 'atonal']:
            print_error("key '{}' not recognized.".format(k), line)
            return
        # fi
    # fi

    if k in ('none', 'atonal'):
        k = 'atonal'
    elif args.vertical or args.horizontal:
        pass                                # printing and used are the same.
    elif args.midi1csv or args.fluidsynth:
        k = key_sig[k]                      # Key number extracted.
    else:                   # ABC
        k = k.upper()
        k = k.replace('-', 'b')             # Does multiple flats
        k = k.replace('+', '#')             # Does multiple sharps.
        k = k.replace('n', '=')             # Does multiple naturals.
    # fi
    # k = value to store in key_voice, key_default, etc. -- used for printing, etc.

    #-- fill_voice_mlth(line)                   # Need to make measure for other voices up to here "mlth".
    # By not doing this, we allow vertical format to specify keys for voices in the first measure (or any).

    if vs is None:                          # One argument, all voices change.
        for ve in range(1, len(vl)+1):
            if mlth[ve][measure_on] != 0:
                print_error("key with one argument not allowed in the middle of a measure", line)
                return
            # fi
        # rof
        if measure_on == '':
            key_default = k                 # Used in xpose, and when printing midicsv output.
        # fi
        for ve in range(1, MAXVOICES+1):
            key_voice[measure_on][ve] = k   # Running key by voice.
        # rof
        return
    # fi                # multiple arguments, voices first.

    wargs = arglist(vs, line, True)
    if not wargs or len(wargs) < 1:
        print_error("no voice arguments on key line", line)
        return
    # fi
    for w in wargs:
        f1, type_error = is_float(w, True)
        if type_error is not None:
            print_error("key error - {}".format(type_error), line)
            return
        # fi
        if f1 is None:
            print_error("voice {} is not a number.".format(w), line)
            return
        # fi
        f1 = int(round(f1))
        if f1 not in mlth:
            print_error("key with too many voices not allowed, voice {} is too many".format(f1), line)
            return
        # fi
        if mlth[f1][measure_on] != 0:
            for ve in range(1, len(vl)+1):
                print_error_no_line("mlth[{}][{}]={}".format(ve, measure_on, mlth[ve][measure_on]))
            # rof
            print_error("key with two arguments not allowed in the middle of a measure, voice {}".format(f1), line)
            return
        # fi
        key_voice[measure_on][f1] = k       # key by measure and voice.
    # rof
    return
# End of do_key

# ----------------------------------------------------------------------------
#   cis   2             $$ only voice 2 follows. sets volume too.
# Probably do not want to use this.

def do_cis(t_args, line):
    global voices               # number of voices
    global cis                  # cis ...
    global vinstrument
    global reverb
    global pan
    global intensity
    global measure_on
    global instruments

    if t_args is None or t_args == '':
        print_error("cis does not have one or two arguments.", line)
        return
    # fi

    targs = re.sub(r'\s*,\s*', ',', t_args)

    vargs = targs.split()

    f1, type_error = is_float(vargs[0], True)
    if type_error is not None:
        print_error("cis error - {}".format(type_error), line)
        return
    # fi
    if f1 is None:
        print_error("cis does not have first argument as a number.", line)
        return
    # fi
    f1 = int(round(f1))
    if f1 < 1  or f1 > MAXVOICES:       # If out of range.
        print_error("number of cis must between 1 and {} inclusive. Not ({})".format(MAXVOICES, f1), line)
        return
    # fi

    voices = f1                         # Max voices.
    cis = f1                            # Doing just one voice from now on.

    for i in range(1, cis + 1):
        new_voice_initialize(i, measure_on)
    # rof

    # If there is a second argument, choose instrument for the voice.
    if len(vargs) > 1:
        i = str(vargs[1]).lower()
# NOTDONEYET - Not tested cis and instrument.
#--        print_debug("#1 i={}".format(i))
# NOTDONEYET - Do drum_sounds here.
# NOTDONEYET - Need to loop through instruments here, then drum_sounds.
        flg = False
        for q in instruments:
            if i == q:
                flg = True
                break
            # fi
        # rof
        if not flg:
            for q in drum_sounds:
                if i == q:
                    flg = True
                    break
                # fi
            # rof
        # fi
        if flg:
# NOTDONEYET - Not tested cis and instrument.
            vinstrument[measure_on][cis] = i
            reverb[measure_on][cis] = int(getvar('default_reverb'))
            pan[measure_on][cis] = int(getvar('default_pan'))
            intensity[measure_on][cis] = int(getvar('default_intensity'))
        else:
            f1, type_error = is_float(i, True)
            if type_error is not None:
                print_error("cis error - {}".format(type_error), line)
                return
            # fi
            if f1 is None:
                print_error("cis does not have instrument argument as a number.", line)
                return
            # fi
            f1 = int(round(f1))
# NOTDONEYET - Not tested cis and instrument.
#--            print_debug("#2 f1={}".format(f1))
#--            print_debug("#2 instruments[{}][0]={}".format(f1,instruments[f1][0]))
# NOTDONEYET - Cannot do drum_sounds here.
            flg = False
            for q in instruments:
                if instruments[q] == [f1, 0]:
                    flg = True
                    break
                # fi
            # rof
            if not flg:
                print_error("instrument value {} not in instrument table.".format(f1), line)
                return
            # fi
            vinstrument[measure_on][cis] = q
            reverb[measure_on][cis] = int(getvar('default_reverb'))
            pan[measure_on][cis] = int(getvar('default_pan'))
            intensity[measure_on][cis] = int(getvar('default_intensity'))
        # fi
    # fi
    fill_voice_mlth(False, line)               # Need to make measure for all voices up to here "mlth".
    return
# End of do_cis

# ----------------------------------------------------------------------------
def get_volume_number(name, line, command_name):
    global vlprint

    v, type_error = is_float(name, True)
    if type_error is not None:
        for j in vlprint:
            if name == vlprint[j]:
                v = j
                type_error = None
                break
            # fi
        # rof
        if type_error is not None:
            print_error(command_name + " did not get have a number or volume name. {}".format(type_error), line)
            return None
        # fi
        # Fall through, because we found it via letters.
    # fi
    if v is None:
        print_error(command_name + " does not have argument as a number.", line)
        return None
    # fi
    v = int(round(v))
    if v < 0:                       # If error or bad value
        print_error(command_name + " for voice {} not good {}, making it zero.".format(i, v), line)
        v = 0
    # fi
    if command_name == 'volumes':
        if v > 127:                 # If error or bad value
            print_error(command_name + " {} ({}) not good, making it 127.".format(name,v), line)
            v = 127
        # fi
    elif command_name == 'volume' and v > 7:    # If error or bad value
        print_error(command_name + " {} ({}) not good, making it 7 (127 for midi).".format(name,v), line)
        v = 127
    else:
#--        v = int((v * 16) + 15)      # Convert to 0 to 127.
        if v >= 7:
            v = getvar('vffff')               # 110: 'ffff',
        elif v ==6:
            v = getvar('vfff')                # 100: 'fff',
        elif v ==5:
            v = getvar('vff')                 # 90: 'ff',
        elif v ==4:
            v = getvar('vmf')                  # 70: 'mf',
        elif v ==3:
            v = getvar('vmp')                  # 60: 'mp',
        elif v ==2:
            v = getvar('vpp')                 # 40: 'pp',
        elif v ==1:
            v = getvar('vppp')                # 30: 'ppp',
        else:
            v = getvar('vpppp')
        # fi
    # fi
    return v
#   End of get_volume_number

# ----------------------------------------------------------------------------
#   volume  4,7,5                       $$ for 3 voices; mf and fff, and a touch louder.
#       The volume is a number between 0 and 7, inclusive.
#       Caution: you should use only volumes 5 through 7
#   volumes mf,fff,f                    $$ for 3 voices; mf and fff, and a touch louder.
#       The volumes are a number between 0 and 127, inclusive.

def do_volume_both(t_args, line, command_name):
    global vl                           # volume levels
    global measure_on
    global vlprint
    global args
    global cresc_direction
    global cresc_time
    global cresc_volume
    global running_vl

    if t_args is None or len(t_args) == 0:
        print_error(command_name + " needs at least one argument", line)
        return
    # fi
    # All spaces before or after commas is gone.
    targs = re.sub(r'\s*,\s*', ',', t_args)
    vargs = targs.split()
    if len(vargs) <= 0 or len(vargs) > 2:
        print_error("{} does not have correct number of arguments.".format(command_name), line)
        return
    # fi
    # . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
    if len(vargs) == 1:
        # 1 or 1,2,3 ... .
        wargs = arglist(vargs[0], line, False)
        if len(wargs) == 0 or len(wargs) > MAXVOICES:
            print_error(command_name + " needs from one to {} arguments".format(MAXVOICES), line)
            return
        # fi
        for i in range(1, len(wargs)+1):
            v = get_volume_number(wargs[i - 1], line, command_name)
            if v is None:
                return
            # fi
            if not i in vl:
                new_voice_initialize(i, measure_on)
            # fi
            vl[i][measure_on] = v           # Change volume for voice.
            running_vl[i][measure_on] = v   # Force running change - also stop crescendo.
            cresc_volume[i] = 0
            cresc_time[i] = 0
            cresc_direction[i] = True
        # rof
    else:
    # . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
        wargs = arglist(vargs[0], line, True)
        v = get_volume_number(vargs[1], line, command_name)
        for i in range(1, len(wargs)+1):
            f1, type_error = is_float(wargs[i-1], True)
            if type_error is not None:
                print_error("volume error - {}".format(type_error), line)
                return
            # fi
            if f1 is None:
                print_error("voice {} is not a number.".format(wargs[i-1]), line)
                return
            # fi
            f1 = int(round(f1))

            vl[f1][measure_on] = v           # Change volume for voice.
            running_vl[f1][measure_on] = v   # Force running change - also stop crescendo.
            cresc_volume[f1] = 0
            cresc_time[f1] = 0
            cresc_direction[f1] = True
        # rof
    # fi

    fill_voice_mlth(False, line)               # Need to make measure for other voices up to here "mlth".
    return
# End of do_volume_both

# ----------------------------------------------------------------------------
#       volume  3,6                         $$ Voice 1 volume at 3, 2 at 6 (out of 7).
#       volume  4,4,4,4                     $$ volume 4 on all four voices.

def do_volume(t_args, line):
    do_volume_both(t_args, line, "volume")
    return
# End of do_volume

# ----------------------------------------------------------------------------
# This allows numbers 1 to 128.
#      =volumes fluteA..contrabassA f       $$ Set lots of voices to volume "f".
#       volumes mf, f, fff                  $$ Voice 1 at mf, 2 at f and 3 at fff.

def do_volumes(t_args, line):
    do_volume_both(t_args, line, "volumes")
    return
# End of do_volumes

# ----------------------------------------------------------------------------
def do_set_voices(f1, line):
    global voices                       # number of voices
    global measure_on

    for i in range(1, f1+1):
        new_voice_initialize(i, measure_on)
    # rof
    voices = f1                         # Max voices.
    return
# End of do_set_voices

# ----------------------------------------------------------------------------
#   voice 4                             $$ number of voices from now onwards.   sets volume too. Default 4?
#   voice 4   50,60,70,80               $$ Set the instruments %%MIDI program 50 ...
# NOTE: use "instrument" command instead. :)

def do_voice(t_args, line):
    global cis                          # non-zero if doing one voice only.
    global vinstrument
    global reverb
    global pan
    global intensity
    global measure_on
    global instruments
    global drum_sounds

    if t_args is None or t_args == '':
        print_error("voice does not have one argument.", line)
        return
    # fi

    for ve in range(1, len(vl)+1):
        if mlth[ve][measure_on] != 0:
            print_error("voice in the middle of a measure not allowed", line)
            return
        # fi
    # rof

    targs = re.sub(r'\s*,\s*', ',', t_args)

    vargs = targs.split()
    f1, type_error = is_float(vargs[0], True)
    if type_error is not None:
        print_error("voice error - {}".format(type_error), line)
        return
    # fi
    if f1 is None:
        print_error("voice does not have first argument as a number.", line)
        return
    # fi
    f1 = int(round(f1))
    if f1 < 1  or f1 > MAXVOICES:       # If out of range.
        print_error("number of voices must between 1 and {} inclusive. Not ({})".format(MAXVOICES, f1), line)
        return
    # fi

    do_set_voices(f1, line)

    fill_voice_mlth(False, line)               # Need to make measure for other voices up to here "mlth".

    # If there are more arguments, choose instruments for the voices.
    if len(vargs) > 1:
        jkl = "".join(vargs[1:])
        wargs = arglist(jkl, line, False)
        if not wargs or len(wargs) < 1:
            print_error("no instrument selection arguments on voice line", line)
            return
        # fi
        if len(wargs) > f1:
            print_error("number instruments ({}) greater than voices ({})".format(len(wargs), f1), line)
        # fi
        for i in range(0, len(wargs)):
            j = str(wargs[i])    # No checking.
            j = str(j).lower()
            if j in instruments:
                vinstrument[measure_on][i+1] = j
                reverb[measure_on][i+1] = int(getvar('default_reverb'))
                pan[measure_on][i+1] = int(getvar('default_pan'))
                intensity[measure_on][i+1] = int(getvar('default_intensity'))
            elif j in drum_sounds:
                vinstrument[measure_on][i+1] = j
                reverb[measure_on][i+1] = int(getvar('default_reverb'))
                pan[measure_on][i+1] = int(getvar('default_pan'))
                intensity[measure_on][i+1] = int(getvar('default_intensity'))
            else:
                f1, type_error = is_float(j, True)
                if type_error is not None:
                    print_error("voice error - {}".format(type_error), line)
                    return
                # fi
                if f1 is None:
                    print_error("voice does not have instrument argument {} as a number.".format(j), line)
                    return
                # fi
                f1 = int(round(f1))
                flg = False
                for q in instruments:
                    if [f1, 0] == instruments[q]:
                        flg = True
                        break
                    # fi
                # rof

                if not flg:
                    print_error("instrument value {} not in instrument table.".format(f1), line)
                    return
                # fi
                vinstrument[measure_on][i+1] = q
                reverb[measure_on][i+1] = int(getvar('default_reverb'))
                pan[measure_on][i+1] = int(getvar('default_pan'))
                intensity[measure_on][i+1] = int(getvar('default_intensity'))
            # fi
        # rof
    # fi

    cis = 0                             # No longer doing just one voice.
    return
# End of do_voice

# ----------------------------------------------------------------------------
# Set page. This is only used for --pages argument to musicomp2abc command to
# limit which pages to do output for (.fs, .mid, .csv, .abc, .v, .h).

def do_page(t_args, line):
    global cstop_processing
    global pages_to_do
    global args

    if t_args is None or t_args == '':
        print_error("Page missing argument.", line)
        return
    # fi

    vargs = t_args
    n, mesg = is_float(vargs, False)
    if mesg is not None or n is None:
        setvar('page', vargs, 1)        # Character string
        n = vargs
    elif type(n) is float:
        if n.is_integer():
            n = int(n)
        # fi
        setvar('page', n, 0)            # integer/floating value
    else:
        setvar('page', n, 1)            # Character string returned from is_float.
    # fi

    if args.pages == None or args.pages == '':
        return
    # fi
    if n not in pages_to_do:
        cstop_processing = True
        return
    # fi
    # Do cstart.
    cstop_processing = False
    return
# End of do_page

# ----------------------------------------------------------------------------
#       measure 6.5             $$ need not be integers
#       measure 0               $$ usually first measure before any notes -- meter, etc.
#       measure 1               $$ put notes after this one.
#       calc    m10 = 2
#       measure m10 = m10 + 1   $$ can be calculated.
#       measure                 $$ auto-increment from last (if it was a number).

def do_measure(t_args, line):
    global measure_on
    global last_m
    global meas
    global vl
    global running_vl
    global default_note_length
    global vinstrument
    global reverb
    global pan
    global intensity
    global acc_m                            # Last accidental on a note in measure.
#--    global last_suffixes_m                  # Last ties/legato/etc. on a note in previous measure.
    global acc_m_xpose
    global acc_v_init                       # Last accidental on a note in measure.
    global acc_v_init_v_or_h                # Last accidental on a note in measure.
    global meter
    global measure_meter
    global clef
    global bars
    global mlth                             # measure length dictionary
    global args
    global key_voice
    global tempo_now_note_length
    global tempo_speed_now
    global pitch
    global premeasurecomment                # Collected comments before a new measure for before new measure.
    global measurelinecomment               # Collected comments before a new measure for before new measure.
    global precomment
    global commentonline
    global measures_to_do
    global cstop_processing

    # Process possible --xpose argument as xpose command before first measure.
    if args.xpose != '':
        do_xpose([args.xpose], "Argument --xpose present, processing:{}".format(args.xpose))
        args.xpose = ''
    # fi

    if t_args is None or t_args == '':  # Auto-incement from last measure if it was a number.
        if measure_on == '':
            print_error("Measure missing argument, auto-increment can only work after one is a number.", line)
            return
        # fi
        if not measure_on.isnumeric():
            print_error("Blank measure can only occur after measure is a number - was {}".format(measure_on), line)
            return
        # fi
        t_args = [str(int(measure_on) + 1)]
    # fi

    vargs = t_args
    # Starts with number and has letters in the middle.
    # NOTE: character variable in middle of string problem. But, want "12a" as string.  notes_array NOTDONEYET
    if vargs[0].isnumeric() and not vargs.isnumeric() and vargs.isalnum():
        f1 = str(vargs)
        setvar('measure', f1, 1)         # Variable cannot be a string.
    else:
        f1, type_error = is_float(vargs, False)
        if type_error is not None or f1 is None or 'a' in vargs:
            # Error, use it as string instead.
            f1 = str(vargs)
            setvar('measure', f1, 1)     # Variable cannot be a string.
        elif type(f1) is float:
            if f1.is_integer():
                f1 = int(f1)
            # fi
            setvar('measure', f1, 0)
            f1 = str(f1)
        else:
            setvar('measure', f1, 1)    # Character string.
        # fi
    # fi

    # Check if in measures_to_do
    if args.measures and args.measures != '':
        if f1 not in measures_to_do:
            cstop_processing = True
        else:
            # Do cstart.
            cstop_processing = False
        # fi
    # fi


    # Last note length ... continue to this measure, until it changes.
    last_m = measure_on
#--    # save accidentals left over from previous -- for ties, etc.
#--    for i in range(1, len(vl)+1):
#--        last_suffixes_m[i] = acc_m[i]
#--    # rof

    if not args.multiplemeasures:
        fill_voice_mlth(True, line)     # Rests needed to make measure for other voices up to here "mlth".
    # fi

    if f1 in meas:
        if not args.multiplemeasures:
            print_warning("Measure {} already exists. Want --multiplemeasures?".format(f1), line)
        # fi
        measure_on = str(f1)
        # Initialize the accidental for each note in measure.
        # NOTE: EVERYTHING ELSE SHOULD ALREADY BE INITIALIZED. "voice 25" at start of song.
        for i in range(1, len(vl)+1):
            if args.horizontal or args.vertical:
                acc_m[i] =  {k: v for k, v in acc_v_init_v_or_h.items()}
                acc_m_xpose[i] =  {k: v for k, v in acc_v_init_v_or_h.items()}
            elif args.midi1csv or args.fluidsynth:
                acc_m[i] =  {k: v for k, v in acc_v_init_v_or_h.items()}
                acc_m_xpose[i] =  {k: v for k, v in acc_v_init_v_or_h.items()}
            else:           # ABC
                acc_m[i] =  {k: v for k, v in acc_v_init.items()}
                acc_m_xpose[i] =  {k: v for k, v in acc_v_init.items()}
            # fi
        # rof
        return
    # fi

    measure_on = str(f1)
    meas.append(measure_on)
    for i in range(1, len(vl)+1):
        if measure_on not in vinstrument:
            vinstrument[measure_on] = {}
            reverb[measure_on] = {}
            pan[measure_on] = {}
            intensity[measure_on] = {}
            key_voice[measure_on] = {}
        # fi
        if i not in vl:
            vl[i] = {}
            running_vl[i] = {}
        # fi
        for j in vl:
            if measure_on not in clef:
                clef[measure_on] = {}
            # fi
            if j not in clef[measure_on]:
                clef[measure_on][j] = {}
            # fi
            if last_m not in clef or j not in clef[last_m]:
                for k in reversed(range(0, len(meas)-1)):
                    mmm = meas[k]
                    if mmm in clef and j in clef[mmm]:
                        nc = clef[mmm][j]
                        break
                    # fi
                # rof
            else:
                nc = clef[last_m][j]
            # fi
            clef[measure_on][j] = nc
        # rof
        new_voice_initialize(i, measure_on)
        mlth[i][measure_on] = 0
        # last instrument continues - might change shortly.
        vinstrument[measure_on][i] = vinstrument[last_m][i]
        pan[measure_on][i] = pan[last_m][i]
        reverb[measure_on][i] = reverb[last_m][i]
        intensity[measure_on][i] = intensity[last_m][i]
        key_voice[measure_on][i] = key_voice[last_m][i]

        # Carry forward.
        vl[i][measure_on] = vl[i][last_m]
        running_vl[i][measure_on] = running_vl[i][last_m]

        # Initialize the accidental for each note in measure.
        if args.horizontal or args.vertical:
            acc_m[i] =  {k: v for k, v in acc_v_init_v_or_h.items()}
            acc_m_xpose[i] =  {k: v for k, v in acc_v_init_v_or_h.items()}
        elif args.midi1csv or args.fluidsynth:
            acc_m[i] =  {k: v for k, v in acc_v_init_v_or_h.items()}
            acc_m_xpose[i] =  {k: v for k, v in acc_v_init_v_or_h.items()}
        else:           # ABC
            acc_m[i] =  {k: v for k, v in acc_v_init.items()}
            acc_m_xpose[i] =  {k: v for k, v in acc_v_init.items()}
        # fi
    # rof
    premeasurecomment[measure_on] = precomment
    measurelinecomment[measure_on] = commentonline
    # default note length continues with current - might change shortly.
    default_note_length[measure_on] = default_note_length[last_m]
    bars[measure_on] = bars[last_m]
    tempo_speed_now[measure_on] = tempo_speed_now[last_m]
    tempo_now_note_length[measure_on] = tempo_now_note_length[last_m]
    measure_meter[measure_on] = meter       # Each measure change can have a different meter.
    pitch[measure_on] = pitch[last_m]       # continue pitch from measure before.
    return
# End of do_measure

# ----------------------------------------------------------------------------
#   instrument 1,2 flute                $$ voices for an instrument.
# See source for list of all instruments.

def do_instrument(t_args, line):
    global vinstrument
    global reverb
    global pan
    global intensity
    global measure_on
    global instruments
    global drum_sound
    global mlth

    if t_args is None or t_args == '':
        print_error("instrument does not have arguments.", line)
        return
    # fi

    # Want a list of number separated by commas, followed by a space and an instrument name/number.
    targs = re.sub(r'\s*,\s*', ',', t_args)
    targs = re.sub(r'\s*\.\.\s*', '..', targs)
    # Voice numbers, followed by instrument name.
    vargs = targs.split()

    INST = " ".join(vargs[1:]).lower()
    foundinstrument = None
    for i in instruments:
        if i.lower() == INST:
            foundinstrument = i
            break
        # fi
    # rof
    if foundinstrument is None:
        for i in drum_sounds:
            if i.lower() == INST:
                foundinstrument = i
                break
            # fi
        # rof
    # fi
    if foundinstrument is None:
        print_warning("do_instrument - instruments does not have INST={}".format(INST), line)
        f1, type_error = is_float(INST, True)
        if type_error is not None:
            print_error("instrument error - {}".format(type_error), line)
            return
        # fi
        if f1 is None:
            print_error("voice does not have instrument argument {} as a number.".format(INST), line)
            return
        # fi
        f1 = int(round(f1))
        for i in instruments:
            if instruments[i] == [f1,0]:
                foundinstrument = i
                break
            # fi
        # rof
        if foundinstrument is None:
            print_error("instrument value {} not in instrument table.".format(f1), line)
            return
        # fi
        INST = foundinstrument
    # fi

    jkl = "".join(vargs[0])
    wargs = arglist(jkl, line, True)
    if not wargs or len(wargs) < 1:
        print_error("no voice arguments on instrument line", line)
        return
    # fi
    for w in wargs:
        f1, type_error = is_float(w, True)
        if type_error is not None:
            print_error("instrument error - {}".format(type_error), line)
            return
        # fi
        if f1 is None:
            print_error("voice {} is not a number.".format(w), line)
            return
        # fi
        f1 = int(round(f1))
        if f1 not in mlth:
            print_error("instrument with too many voices not allowed, voice {} is too many".format(f1), line)
            return
        # fi
        if mlth[f1][measure_on] != 0:
            print_error("instrument in the middle of measure '{}' not allowed, voice '{}'".format(measure_on, f1), line)
            return
        # fi
        vinstrument[measure_on][f1] = foundinstrument
    # rof

    return
# End of do_instrument

# ----------------------------------------------------------------------------
# Set MIDI reverb value for voice.
#       reverb  1..4  90        $$ MIDI value 0 to 127.

def do_reverb(t_args, line):
    global reverb
    global measure_on

    if t_args is None or t_args == '':
        print_error("reverb does not have arguments.", line)
        return
    # fi

    targs = re.sub(r'\s*,\s*', ',', t_args)

    vargs = targs.split()
    if len(vargs) <= 0 or len(vargs) > 2:
        print_error("reverb does not have correct number of arguments.", line)
        return
    # fi
    if len(vargs) == 1:
        r = 0
    else:
        r = vargs[1]
        f1, type_error = is_float(r, True)
        if type_error is not None:
            print_error("reverb error - {}".format(type_error), line)
            return
        # fi
        if f1 is None:
            print_error("voice does not have reverb argument {} as a number.".format(r), line)
            return
        # fi
        r = int(round(f1))
    # fi
    if r < 0 or r > 127:
        print_error("reverb value {} not in range 0to 127.".format(r), line)
        return
    # fi

    jkl = "".join(vargs[0])
    wargs = arglist(jkl, line, True)

    if not wargs or len(wargs) < 1:
        print_error("no voice arguments on reverb line", line)
        return
    # fi
    for w in wargs:
        f1, type_error = is_float(w, True)
        if type_error is not None:
            print_error("reverb error - {}".format(type_error), line)
            return
        # fi
        if f1 is None:
            print_error("voice {} is not a number.".format(w), line)
            return
        # fi
        f1 = int(round(f1))

        reverb[measure_on][f1] = r
    # rof
    return
# End of do_reverb

# ----------------------------------------------------------------------------
#       intensity  1..4  90        $$ MIDI value 0 to 127.
# MIDI has 3 values that add together to create volume. "channel/note_on/intensity"
# *Blech*

def do_intensity(t_args, line):
    global intensity
    global measure_on

    if t_args is None or t_args == '':
        print_error("intensity does not have arguments.", line)
        return
    # fi

    targs = re.sub(r'\s*,\s*', ',', t_args)

    vargs = targs.split()
    if len(vargs) <= 0 or len(vargs) > 2:
        print_error("intensity does not have correct number of arguments.", line)
        return
    # fi
    if len(vargs) == 1:
        intens = 0
    else:
        intens = vargs[1]
        f1, type_error = is_float(intens, True)
        if type_error is not None:
            print_error("intensity error - {}".format(type_error), line)
            return
        # fi
        if f1 is None:
            print_error("voice does not have intensity argument {} as a number.".format(intens), line)
            return
        # fi
        intens = int(round(f1))
    # fi
    if intens < 0 or intens > 127:
        print_error("intensity value {} not in range 0 to 127".format(intens), line)
        return
    # fi

    jkl = "".join(vargs[0])
    wargs = arglist(jkl, line, True)
    if not wargs or len(wargs) < 1:
        print_error("no voice arguments on intensity line", line)
        return
    # fi
    for w in wargs:
        f1, type_error = is_float(w, True)
        if type_error is not None:
            print_error("intensity error - {}".format(type_error), line)
            return
        # fi
        if f1 is None:
            print_error("voice {} is not a number.".format(w), line)
            return
        # fi
        f1 = int(round(f1))
        if f1 not in mlth:
            print_error("intensity with too many voices not allowed, voice {} is too many".format(f1), line)
            return
        # fi
        intensity[measure_on][f1] = intens
    # rof
    return
# End of do_intensity

# ----------------------------------------------------------------------------
#       pan     1..4  90        $$ MIDI value 0 to 64 to 127.
# This is the left/right positioning of the audio sound. 64=straight ahead.

def do_pan(t_args, line):
    global pan
    global measure_on

    if t_args is None or t_args == '':
        print_error("pan does not have arguments.", line)
        return
    # fi

    targs = re.sub(r'\s*,\s*', ',', t_args)

    vargs = targs.split()
    if len(vargs) <= 0 or len(vargs) > 2:
        print_error("pan does not have correct number of arguments.", line)
        return
    # fi
    if len(vargs) == 1:
        p = 0
    else:
        p = vargs[1]
        f1, type_error = is_float(p, True)
        if type_error is not None:
            print_error("pan error - {}".format(type_error), line)
            return
        # fi
        if f1 is None:
            print_error("voice does not have pan argument {} as a number.".format(p), line)
            return
        # fi
        p = int(round(f1))
        if p < 0 or p > 127:
            print_error("pan value {} not in range 0 to 127.".format(p), line)
            return
        # fi
    # fi
    jkl = "".join(vargs[0])
    wargs = arglist(jkl, line, True)
    if not wargs or len(wargs) < 1:
        print_error("no voice arguments on pan line", line)
        return
    # fi
    for w in wargs:
        f1, type_error = is_float(w, True)
        if type_error is not None:
            print_error("pan error - {}".format(type_error), line)
            return
        # fi
        if f1 is None:
            print_error("voice {} is not a number.".format(w), line)
            return
        # fi
        f1 = int(round(f1))

        pan[measure_on][f1] = p
    # rof
    return
# End of do_pan

# ----------------------------------------------------------------------------
# NOTE/WARNING: if you have xpose without a key, it goes to key_default.
# This is UGLY.
#       =xpose  clarinetA..clarinetB -2     $$ clarinett in B ...  C, B-, B  ->  -2
#       xpose   c-                          $$ all voices, from current key to key c-.
#       xpose   1 c-                        $$ voice 1, from current key to key c-.
#       xpose   1 -1 c-                     $$ voice 1, down 1 semi-tone, then to key c-,
# and change to key c- if --vertical/--horizontal.
#       xpose   1 +12                       $$ 4c = 5c
#       xpose   1,2..5,7 +2                 $$ French Horn in D plays 2 semitones higher from what is written
#       xpose   1 -12                       $$ French Horn in C plays 12 semitones lower
#       xpose   1 -7                        $$ 4c = 3f
#       xpose   1 +2                        $$ Trombone in D plays 2 semitones higher from what is written
#       xpose   1 -3                        $$ Clarinet in A ... "C" plays "A" (i.e. C, B, B-, A = -3)
#       =xpose  bassdrumA  -13              $$ 2c (printed) -> 0bn (played)
#       =xpose  cymbalA  -1                 $$ 2e (printed) -> 2d- (played)
# NOTE: the --vertical and --horizontal and key changes ... *sigh* complicated.

def do_xpose(t_args, line):
    global xpose
    global xpose_new_key
    global measure_on
    global key_sig
    global key_sig_int
    global key_default
    global args
    global key_voice

    if args.noxpose:
        print_warning("Ignoring xpose parsing due to --noxpose argument.", line)
        return
    # fi
    if args.abc:
        print_warning("Ignoring xpose parsing for --abc output format. ", line)
        return
    # fi
    if t_args is None or t_args == '':
        print_error("xpose does not have arguments.", line)
        return
    # fi
    targs = re.sub(r'\s*,\s*', ',', t_args)
    vargs = targs.split()
    if len(vargs) <= 0 or len(vargs) > 4:
        print_error("xpose does not have correct number of arguments.", line)
        return
    # fi
    kl = None
    if len(vargs) > 1:
        mm = vargs[len(vargs) - 1].lower()      # Last argument
        kl = vargs[len(vargs) - 2].lower()      # Second to last argument
        if mm == 'minor':
            if kl not in minor_key_to_major:
                print_error("xpose command, key does not recognize minor {}".format(kl), line)
                return
            # fi
            kl = minor_key_to_major[kl].lower()
            vargs.pop()
        elif mm == 'major':
            if kl not in key_sig:
                print_error("xpose command, key '{}' not recognized.".format(kl), line)
                return
            # fi
            vargs.pop()
        else:
            kl = None
        # fi
    #fi
    if len(vargs) > 1:
        if len(vargs) == 4:
            print_error("xpose command only allows 3 arguments.".format(kl), line)
            return
        elif len(vargs) == 3:
            if kl is None:
                kl = vargs[2].lower()
            # fi
            x = vargs[1]                # shifting amount
            vs = vargs[0]               # voices to change
        elif len(vargs) == 2:
            vs = vargs[0]               # voices to change
            # Check if key, or a number.
            if kl is None:
                kl = vargs[1].lower()       # new key?
            # fi
            if kl in key_sig:
                x = '0'                 # shifting amount
            else:       # is a number?
                f1, type_error = is_float(kl, True)
                if type_error is not None:
                    print_error("xpose error#1 - {}".format(type_error), line)
                    return
                # fi
                if f1 is None:
                    print_error("voice does not have xpose argument {} as a number or key.".format(kl), line)
                    return
                # fi
                x = str(int(round(f1))) # Must be an integer as a string.
                kl = None
            # fi
        else:
            print_error("xpose has a problem.", line)
            return
        # fi
    else:   # Only one argument -- key or number?
        # Check if key, or a number.
        if kl is None:
            kl = vargs[0].lower()       # new key
        # fi
        if kl.lower() in key_sig:
            x = '0'                 # shifting amount
        else:       # is a number?
            x = kl
            kl = None
            f1, type_error = is_float(x, True)
            if type_error is not None:
                print_error("xpose error#2 - {}".format(type_error), line)
                return
            # fi
            if f1 is None:
                print_error("voice does not have xpose argument {} as a number or key.".format(kl), line)
                return
            # fi
            x = str(int(round(f1))) # Must be an integer as a string..
        # fi
        vs = '{}..{}'.format(1, len(vl))    # all voices
    # fi
    if type(kl) is str:
        if kl not in key_sig:
            print_error("no key '{}' in key_sig({})".format(kl, key_sig), line)
            return
        # fi
    # fi

    f1, type_error = is_float(x, True)
    if type_error is not None:
        print_error("xpose error#3 - {}".format(type_error), line)
        return
    # fi
    if f1 is None:
        print_error("voice does not have xpose argument {} as a number.".format(x), line)
        return
    # fi
    x = int(round(f1))              # Must be an integer.

    # kl is used in getnote via xpose_new_key (musicomp text)
    # kl is None means to use current key for voice.

    jkl = "".join(vs)
    wargs = arglist(jkl, line, True)
    if not wargs or len(wargs) < 1:
        print_error("no voice arguments on xpose", line)
        return
    # fi
    # If kl is None, use key_default.
    if args.vertical or args.horizontal:
        kprint_lc = key_default                 # printing and used in xpose are the same.
    else:
        kprint_lc = key_sig_int[key_default]    # Key name extracted.
    # fi
    for w in wargs:
        f1, type_error = is_float(w, True)
        if type_error is not None:
            print_error("xpose error#4 - {}".format(type_error), line)
            return
        # fi
        if f1 is None:
            print_error("voice {} is not a number.".format(w), line)
            return
        # fi
        f1 = int(round(f1))
        if kl is None:
            if measure_on in key_voice and f1 in key_voice[measure_on]:
                xpose_new_key[f1] = key_voice[measure_on][f1]   # Use current key for voice
            else:
                xpose_new_key[f1] = kprint_lc
            # fi
        else:
            xpose_new_key[f1] = kl
        # fi
        xpose[f1] = x
    # rof
    return
# End of do_xpose

# ----------------------------------------------------------------------------
def do_encode(t_args, line):
    if t_args is None or t_args == '':
        print_error("encode does not have a variable, nor string to assign to it.", line)
        return
    # fi
    assign = t_args.find('=')
    if assign <= 0:
        print_error("encode does not have a name followed by an assignment character.", line)
        return
    # fi
    strng = t_args[assign+1:].strip()            # Toss spaces before and after.
    token = t_args[0:assign].strip()             # Toss spaces before and after.

    # Are there any Parenthesis?
    a = token.find('(')
    if a >= 0:
        wary, h = do_vars_parens(token, a, line, False)
    else:
        a = token.find('[')
        if a >= 0:
            wary, h = do_vars_parens(token, a, line, False)
        else:
            chk = setvar(token, strng, 1)
            if not chk:
                print_error("variable name {} does not exist.".format(token), line)
            # fi
            return
        # fi
    # fi
    wary[numarry_values][h] = strng
    wary[numarry_value_type][h] = 1         # Character string
# End of do_encore

# ----------------------------------------------------------------------------
# arg       - string with variable name with parens in it.
# a         - where the first parenthesis is located.
# line      - for error messages, original line.
# create_it - True if should create variable. False means it must exist correctly.

def do_vars_parens(arg, a, line, create_it):
    global macro_executing_depth

    if a == 0:
        print_error("variable definition {} does not have a name before parenthesis.".format(arg), line)
        return
    # fi
    token = arg[0:a]
    if not token[0].isalnum():
        print_error("variable name {} does not start with a alphabetic character.".format(arg))
        return
    # fi
    for t in token[1:]:
        if not t.isalnum() and t != '_':
            print_error("variable name {} does not have all alphanumeric characters or '_'.".format(arg))
            return
        # fi
    # rof
    if create_it:                       # Creating, must not exist at this level.
        wary = getvarmaclevel(token, len(macro_executing_depth))
        if wary is not None:
            print_error("variable name {} redefined at current macro depth level {}".format(token, macro_executing_depth), line)
            return
        # fi
    else:                               # Fetching variable, it must exist.
        wary = chkvar(token)
        if wary is None:
            print_error("variable name {} does not exist.".format(token), line)
            return
        # fi
    # fi
    aftertoken = arg[a:]
    w = 0
    e = []
    c = aftertoken[w]
    if c == '(':
        enddelim = ')'
    elif c == '[':
        enddelim = ']'
    else:
        print_warning("Internal problem? variable {}, but no parenthesis for dimension.".format(arg), line)
        return
    # fi
    e.append(enddelim)
    w = w + 1
    if w >= len(aftertoken):
        print_warning("Found character variable {}, but no closing {}.".format(wary, enddelim), line)
        return
    # fi
    dimensions = []
    before_comma = 1
    while True:
        while w < len(aftertoken):
            c = aftertoken[w]
            w = w + 1
#--            print_debug("do_vars_parens - w={} c={} aftertoken={} dimensions={}".format(w,c,aftertoken,dimensions))
            if c == enddelim:
                break
            # fi
            if w >= len(aftertoken):
                print_error("variable {}, but no closing {} -- {}.".format(token, enddelim, arg), line)
                return
            elif c == '(':
                enddelim = ')'
                e.append(enddelim)
            elif c == '[':
                enddelim = ']'
                e.append(enddelim)
            elif len(e) == 1 and c == ',':
                f1 = aftertoken[before_comma:w-1]
                f, type_error = is_float(f1, True)
                if type_error is not None:
                    print_error("dimension '{}' does not have argument as an integer. {}".format(f1,type_error), line)
                    return
                # fi
                if type(f) is not float:
                    print_error("dimension '{}' is not an integer. {}".format(f1,type_error), line)
                    return
                # fi
                if f.is_integer():
                    f = int(f)
                # fi
                if f is None:
                    print_error("dimension does not have first argument as an integer.", line)
                    return
                # fi
                dimensions.append(f)
                before_comma = w
            # fi
        # elihw
        enddelim = e.pop()
        if e == []:
            f1 = aftertoken[before_comma:w-1]
            f, type_error = is_float(f1, True)
            if type_error is not None:
                print_error("dimension '{}' does not have argument as an integer. {}".format(f1,type_error), line)
                return
            # fi
            if type(f) is not float:
                print_error("dimension value '{}' is not an integer. {}".format(f1,type_error), line)
                return
            # fi
            if f.is_integer():
                f = int(f)
            # fi
            if f is None:
                print_error("dimension does not have {} argument as an integer.".format(len(dimensions)+1), line)
                return
            # fi
            dimensions.append(f)
            break
        # fi
    # elihw
    if w < len(aftertoken):
        print_error("variable {}, characters after closing dimensional delimiter '{}' -- {}.".format(token, enddelim, arg), line)
        return
    # fi
    if wary is not None:                                # It exists already. :)
        if len(wary[numarry_indexes]) != len(dimensions):
            print_error("variable {} with {} dimensions does not match dimensions {}.".format(token, len(wary[numarry_indexes]), len(dimensions)), line)
            return None
        # fi
        l = len(dimensions)
        x = mult = wary[numarry_indexes][0]             # Max dimension of first.
        h = dimensions[0] - 1                           # array index into numarry_values & numarry_value_type
        for a in range(1, l):
            d = dimensions[a]
            x = wary[numarry_indexes][a]
            if d < 1 or d > x:
                print_error("variable {} dimension#{} {} not in range 1 thru {}".format(token, a+1, d, x), line)
                return None, None
            # fi
            h = h + (d-1) * mult
            mult = mult * x
        # rof
        return wary, h                                  # variable array, and index into values.
    # fi
    num = 1
    for w in dimensions:
        num = num * w
    # rof
    values = []
    typevalues = []
    for i in range(0,num):
        values.append(None)
        typevalues.append(None)
    # rof
    wary = [ token, len(macro_executing_depth), dimensions, values, typevalues ]
    calculate.local_arrays.append(wary)
# End of do_vars_parens
        
# ----------------------------------------------------------------------------
# do_vars    cows, EAT, grass(2,10), TOO(2,2)
#
# Define numeric or character variables.
#
# Above, "cows" is a single numeric variable. "grass" is a 2 by 10 array of
# numeric variables. One and two dimensional arrays are allowed.
#
# "EAT" is a character variable. TOO is a two dimensional character variable.
#
# Variables defined within a macro are local to that macro and any macros it
# calls. Newly defined variables are initialized to zero.

def do_vars(t_args, line):
    global macro_executing_depth

    if t_args is None or t_args == '':
        print_error("vars needs at least one argument", line)
        return
    # fi
    # Get rid of all white spoce.
    wline = ''.join(t_args.split())
    wargs = arglist(wline, line, False)
    if len(wargs) == 0:
        print_error("var needs at least one argument", line)
        return
    # fi
    # Process each variable name.
    for token in wargs:
        # Are there any Parenthesis?
        a = token.find('(')
        if a >= 0:
            do_vars_parens(token, a, line, True)
            continue
        # fi
        a = token.find('[')
        if a >= 0:
            do_vars_parens(token, a, line, True)
            continue
        # fi
        if not token[0].isalnum():
            print_error("variable name {} does not start with a alphabetic character.".format(arg))
            return
        # fi
        okay = True
        for t in token[1:]:
            if not t.isalnum() and t != '_':
                print_error("variable name {} does not start with a alphabetic character.".format(arg))
                okay = False
                break
            # fi
        # rof
        if not okay:
            continue
        # fi
        # Normal variable name here.
        wary = getvarmaclevel(token, len(macro_executing_depth))
        if wary is not None:
            print_error("variable name {} redefined at current macro depth level {}".format(token, macro_executing_depth, line))
            continue
        # fi
        createlocalvar(token, None, len(macro_executing_depth), None)       # Not set, nor any type yet.
        wary = getvarmaclevel(token, len(macro_executing_depth))
    # elihw
    return
#   End of do_vars

# ----------------------------------------------------------------------------
# See abc notation for format of %%staves command for printing.
#       %%staves [(1 2) 3 (4 5)]
#       =%%staves [(fluteA fluteB) (oboeA oboeB) (clarinetA clarinetB) \
#                  (bassoonA bassoonB) (french_hornA french_hornB)] \
#                 [(violin1A violin1B violin1C) (violin2A violin2B violin2C)] \
#                 [(violaA violaB violaC) celloA contrabassA]
# ( ) groups together on a staff.
# [...] puts all within "together" with bar on left.

def do_staves(line):
    global staves

    line = line.strip()
    line = ' '.join(line.split())
    line = line.replace('[', '')
    line = line.replace(']', '')
    line = line.replace(' )', ')')
    line = line.replace(' (', '(')
    line = line.replace(') ', ')')
    z = line.split(')')
    # Now, any array entry that starts with ( is a list of voices to order.
    #     Check for more than 1 number.
    # else ignore the numbers -- they are on separate staves.
    for x in z:
        if x == '' or x[0] != '(':
            continue
        # fi
        x = x[1:]
        y = x.split()
        if len(y) <= 1:
            continue
        # fi
        staves.append(y)
    # rof
# End of do_staves

# ----------------------------------------------------------------------------
# '%%'      : do_percents,
def do_percents(t_args, line):
    global measure_on
    global percents

    if line[0:9] == '%%staves ':
        do_staves(line[9:])
    # fi
    if measure_on not in percents:
        percents[measure_on] = []
    # fi
    percents[measure_on].append(line)
    return
# End of do_percents

# ----------------------------------------------------------------------------
# dictionary commandname : routine. execute via(?): globals()['do_cstopnow'](t_args, line)
global commands
commands = {
#            Command      Routine       Process-in-cstop
             'bars'    : (do_bars,      True),
             'calc'    : (do_calc,      False),
             'change'  : (do_change,    False),
             'cis'     : (do_cis,       False),
             'clef'    : (do_clef,      True),
             'comment' : (do_comment,   False),
             'copy'    : (do_copy,      False),
             'cstart'  : (do_cstart,    True),
             'cstop'   : (do_cstop,     True),
             'cstop*'  : (do_cstopnow,  True),
             'debug'   : (do_debug,     False),
             'decode'  : (do_decode,    False),
             'delay'   : (do_delay,     False),
             'else'    : (do_else,      False),
             'encode'  : (do_encode,     False),
             'end'     : (do_cstopnow,  True),          # cstop* alternative
             'endif'   : (do_endif,     False),
             'endm'    : (do_endm,      False),
             'endmacro': (do_endm,      False),         # endm alternative
             'exit'    : (do_cstopnow,  True),          # cstop* alternative
             'flat'    : (do_flat,      False),
             'format'  : (do_format,    False),         # IMS - will not do
             'goto'    : (do_goto,      False),
             'if'      : (do_if,        False),
             'intensity': (do_intensity, False),
             'include' : (do_include,   False),         # IMS - will not do
             'instr'   : (do_instr,     False),         # IMS - will not do
             'instrument' : (do_instrument, False),
             'key'     : (do_key,       False),
             'macro'   : (do_macro,     False),
             'marker'  : (do_marker,    False),
             'measure' : (do_measure,   True),
             'meter'   : (do_meter,     True),
             'middlec' : (do_middle_c,  True),
             'mytitle' : (do_title,     False),         # title alternative
             'natural' : (do_natural,   False),
             'page'    : (do_page,      True),
             'pan'     : (do_pan,       False),
             'percus'  : (do_percus,    False),
             'pitch'   : (do_pitch,     False),
             'print'   : (do_print,     False),         # IMS - will not do
             'putd'    : (do_putd,      False),
             'quit'    : (do_cstopnow,  True),          # cstop* alternative
             'randu'   : (do_randu,     False),
             'randp'   : (do_randp,     False),
             'repeat'  : (do_goto,      False),         # goto alternative
             'reverb'  : (do_reverb,    False),
             'setperm' : (do_setperm,   False),
             'sharp'   : (do_sharp,     False),
             'slide'   : (do_slide,     False),
             'spaces'  : (do_spaces,    False),
             'start'   : (do_cstart,    True),          # cstart alternative
             'stop'    : (do_cstop,     True),          # cstop alternative
             'stop*'   : (do_cstopnow,  True),          # cstop* alternative
             'tempo'   : (do_tempo,     True),
             'temper'  : (do_temper,    False),
             'time'    : (do_meter,     True),          # meter alternative
             'title'   : (do_title,     False),
             'transpose' : (do_xpose,   True),          # xpose alternative
             'tuning'  : (do_tuning,    False),         # IMS - will not do
             'unit'    : (do_measure,   True),          # measure alternative
             'vars'    : (do_vars,      False),
             'voice'   : (do_voice,     True),
             'volume'  : (do_volume,    True),
             'volumes' : (do_volumes,   True),
             'xpose'   : (do_xpose,     True),
             '%%'      : (do_percents,  True),
             # '.' -- handled specially.
           }

# ----------------------------------------------------------------------------
# For plato calc command processing :)
# w=1,h=2,q=4,e=8,th=+0k        # for plato calc command
# s=(1),d=(1),b=(1),t=(1)       # for plato calc command
# m1, m2, m3, m4, m5, m6, m7, m8, m9
# freq(A) = 968000/A
# nearest(A)      = int(round(ln(A/27.5)*12/0.693147))
# framlth = 60*(20/21)          # frames per second
# tempo(a,b)      = 60*framlth*b*[1./a]
# min2(a,b)       = (a+b-abs(a-b))/2      $$ by Dan Sleator
# min4(l,a,b,d)   = min2(min2(l,a),min2(b,d))
# max2(a,b)       = (a+b+abs(a-b))/2      $$ note, no < or > ops
# max4(l,a,b,d)   = max2(max2(l,a),max2(b,d))
# ----------------------------------------------------------------------------
# Notes and comma for separating voices.
# Length of note in 1/60ths of a second.   r[1]    = 1/57.1429 frames per second
# Length of notes as floating number.      (0.25)  = 1/4 = quarter note.
# variable: pause = break between two identical notes, or "broken notes".
# Note: variables in () and [].
# ----------------------------------------------------------------------------
# rests
# Notes: 3c4,4c4,r2     $$ 3 voices, last is a rest.
#        3a8,,4c8       $$ voice 2 is still playing
# ONALM
# O = octave. default to most recently used for this voice. from 1 to 8.  Middle C = octave 3.
# N = note itself a through g. Probably allow upper or lower case. :) "r" = rest.
# A = Default to normal key value. accidental -> +, -, ++, --, n. Do not carry to next note. (n=natural)
# L = Default to most recently used for this voice. note length. Like 16 for sixteenth note. Can do 16th.
#       w, h, q -> whole, half, quarter.
#       3(4) -> 3 notes in the time of a quarter note. (triplets)
#       (.25) -> 1/4 note.
#       [12] -> number of output frames ... 1/57.1429 of a second.
#   Example:    4b-3(4)         $$ beginning of a triplet
# M = modifier. Normal note. Any combination: d = dotted, s=staccato, b = broken by pause from next, t = tie.
#   3a16t           $$ lengthens previous by 1/16th ... must be same note.

# Special note forms (replace O and N):  (13) - note number. [440] = frequency in Hz. {317} GSW - ignore.
#     t(3a,3g,7)4  = ON,ON,number,LM   - example, 7 notes, quarter note length.
#        NOTE: in 60ths of a second, be careful using it.
#     s4(4a,b,a,g) = sLM(ONA,ONA,...)  - play all notes as grace notes, length of staccato, LM=length
#               last note lasts until LM (quarter note in example) is reached.
# ----------------------------------------------------------------------------
#    octave  0      1      2      3      4       5       6       7       8
#  c/b+     24     36     48     60     72      84      96     108     120
#  c+/d-    25     37     49     61     73      85      97     109     121
#  d        26     38     50     62     74      86      98     110     122
#  d+/e-    27     39     51     63     75      87      99     111     123
#  e/f-     28     40     52     64     76      88     100     112     124
#  f/e+     29     41     53     65     77      89     101     113     125
#  f+/g-    30     42     54     66     78      90     102     114     126
#  g        31     43     55     67     79      91     103     115     127
#  g+/a-    32     44     56     68     80      92     104     116
#  a        33     45     57     69     81      93     105     117
#  a+/b-    34     46     58     70     82      94     106     118
#  b/c-     35     47     59     71     83      95     107     119

# For octave 3c = 60.
note_in_octave_value = {
   'c--':58, 'c-':59, 'c':60, 'cn':60, 'c+':61, 'c++':62,
   'd--':60, 'd-':61, 'd':62, 'dn':62, 'd+':63, 'd++':64,
   'e--':62, 'e-':63, 'e':64, 'en':64, 'e+':65, 'e++':66,
   'f--':63, 'f-':64, 'f':65, 'fn':65, 'f+':66, 'f++':67,
   'g--':65, 'g-':66, 'g':67, 'gn':67, 'g+':68, 'g++':69,
   'a--':67, 'a-':68, 'a':69, 'an':69, 'a+':70, 'a++':71,
   'b--':69, 'b-':70, 'b':71, 'bn':71, 'b+':72, 'b++':73
}

global note_to_midi_value
note_to_midi_value = { }
global midi_value_to_note_flat
midi_value_to_note_flat = { }
global midi_value_to_note_sharp
midi_value_to_note_sharp = { }

global middle_c
middle_c = 39                   # Default to 60, as per cyber1 (1978 era) musicomp.

def compute_middle_c(f):
    global note_in_octave_value
    global note_to_midi_value
    global midi_value_to_note_sharp
    global midi_value_to_note_flat
    global midi_value_to_note_flat
    global midi_value_to_note_sharp
    global midi_value_to_note_flat
    global middle_c

    middle_c = f
    f = f + 12 + 12 - 3         # 3c -> 39 must be 60 for midi.

    for o in range(0, 9):        # 0 thru 8
        for n in note_in_octave_value:
            x = str(o) + n
            v = (note_in_octave_value[n] - (f - 24)) + (12 * o)  # 60-36=24 = '0c'
            note_to_midi_value[x] = v
            if len(n) >= 3:     # ignore double flat and double sharp
                pass
            elif len(n) == 2:     # accidental
                if n[1] == '+':
                    if v not in midi_value_to_note_sharp:   # Prefer no sharp/flat.
                        midi_value_to_note_sharp[v] = x
                    # fi
                # fi
                if n[1] == '-':
                    if v not in midi_value_to_note_flat:    # Prefer no sharp/flat.
                        midi_value_to_note_flat[v] = x
                    # fi
                # Ignore 'n'.
                # fi
            else:
                midi_value_to_note_sharp[v] = x             # Prefer no sharp/flag.
                midi_value_to_note_flat[v] = x
            # fi
        # rof
    # rof
#   End of compute_middle_c

compute_middle_c(middle_c)          # Default to 3c

# ----------------------------------------------------------------------------
# return:
#       therest (for time)
#       thenote         Convert to abc format for note, octave.
#       typenote:       -2 gsw oprnd, -1 freq, 0 note, 1 trill, 2 sequence

def getnote(note_to_decode, voice, line, update_defaults):
    global oct                                  # default octave
    global accidentals
    global allkeys
    global acc_m                                # Last accidental on a note in measure.
    global measure_on
    global args
    global note_to_midi_value
    global midi_value_to_note_flat
    global midi_value_to_note_sharp
    global key_sig
    global key_sig_int
    global key_convert
    global key_voice
    global xpose
    global xpose_new_key
    global acc_m_xpose

    leading_space = False
    if note_to_decode and len(note_to_decode) > 0:
        while note_to_decode[0] == '\t' or note_to_decode[0] == ' ':
            note_to_decode = note_to_decode[1:]
            leading_space = True
        # fi
    # fi
    temp3 = 0                                   # character pointer
    if note_to_decode == '0':
        return '', 0, normal_note
    # fi
    if not note_to_decode or note_to_decode == '':
        return '', '', normal_note
    # fi
    if note_to_decode[0] == '{' or note_to_decode[0] == '[' or note_to_decode[0] == '(':
        if note_to_decode[0] == '{':            # gsw oprnd     { }
            print_error("m:{} gsw_operand {...} is not handled".format(measure_on), line)
            return '', '', gsw_operand
        elif note_to_decode[0] == '[':          # frequency     [ ]
            print_error("m:{} frequency_note [...] is not handled".format(measure_on), line)
            return '', '', freqency_note
        else:
            typenote = normal_note              # return normal note
        # fi
        work3 = 1
        #  must balance parens since note is followed by time
        #  [440]4
        # balance parens
        for temp2 in range(temp3 + 1, len(note_to_decode)):
            work4 = note_to_decode[temp2]
            if work4 == '(' or work4 == '[' or work4 == '{':
                work3 = work3 + 1               # count ('s
            elif work4 == ')' or work4 == ']' or work4 == '}':
                work3 = work3 - 1               # subtract  )'s
                if work3 < 1:
                    temp3 = temp2 + 1           # temp2 has last matched )
                    therest = note_to_decode[temp3:]
                    note_to_decode = note_to_decode[0:temp3]
                    thenote, type_error = is_float(note_to_decode, True)
                    if type_error is not None:
                        return therest, thenote, type_error
                    # fi
                    if thenote is None:
                        print_error("m:{} v{} Note is not legal '{}', computation failed".format(measure_on, voice, note_to_decode), line)
                        return therest, thenote, type_error
                    # fi
                    thenote = int(round(thenote))
                    if typenote == freqency_note:  # if freq calculate it
                        #-- thenote = freq(thenote)
                        thenote = 968000/thenote    # NOT handled anywhere.
                    elif typenote == normal_note:
                        if thenote != 0 and (args.midi1csv or args.fluidsynth):
                            thenote = thenote + 12 + 12 - 3     # 3c -> 39 must be 60 for midi.
                        # fi
                        if thenote != 0:
                            thenote = thenote + xpose[voice]
                        # fi
                    # fi
                    # get ready for time computation
                    return therest, thenote, typenote
                # fi
            # fi
        # rof
        print_error("m:{} v{} Note is not legal '{}', unbalanced parenthesis".format(measure_on, voice, note_to_decode), line)
        return '', None, normal_note
    # fi
    if note_to_decode[0] in [ '0', '1', '2', '3', '4', '5', '6', '7', '8' ]:    # check octave
        oct_voice = int(note_to_decode[0])
        if not update_defaults:
            oct[voice] = oct_voice                                              # save octave
        # fi
        temp3 = temp3 + 1
    else:
        oct_voice = oct[voice]
    # fi
    oct[voice] = oct_voice
    if len(note_to_decode) <= temp3 or note_to_decode[temp3] is None:
        print_error("m:{} v{} no note_to_decode '{}' temp3={} len(note_to_decode)={}".format(measure_on, voice, note_to_decode, temp3, len(note_to_decode)), line)
        return '', None, normal_note
    # fi
    thenote = note_to_decode[temp3]
    if thenote not in [ 'a', 'b', 'c', 'd', 'e', 'f', 'g' ]:      # if not note -- reset, etc.
        if temp3 != 0:
            print_error("m:{} v{} Not a note (sequence/trill?) has an octave before it".format(measure_on, voice), line)
            return '', None, None                # ???
        # fi
        if note_to_decode[0] == 's':            # check for sequence
            if note_to_decode[1] == '(':        # if time given
                print_error("m:{} v{} sequence does not have the number of notes before parenthesis".format(measure_on, voice), line)
                return '', None, None                # ???
            # fi
            #       from, from_character, to, to_character, optionallength
            note_to_decode = note_to_decode[1:]
            sc = note_to_decode.find('(')
            if sc < 0:
                print_error("m:{} v{} Sequence is not legal '{}' no parenthesis found.".format(measure_on, voice, note_to_decode), line)
                return '', None, normal_note
            # fi
            number_in_sequence = note_to_decode[0:sc]
            number_in_sequence, type_error = is_float(number_in_sequence, True)
            if type_error is not None:
                print_error(type_error, line)
                return '', None, None                # ???
            # fi
            if number_in_sequence is None:
                print_error("m:{} v{} sequence does not have a number of notes before parenthesis".format(measure_on, voice), line)
                return '', None, None                # ???
            # fi
            number_in_sequence = int(round(number_in_sequence))
            therest = note_to_decode[sc:]
            if leading_space:
                therest = ' ' + therest             # Flag for later processing.
            # fi
            return therest, number_in_sequence, sequence_note
        # fi
        if note_to_decode[0] == 't':            # check for trill
            if len(note_to_decode) > 1:
                if note_to_decode[1] != '(':    # check for parenthesis
                    print_error("m:{} v{} Note is not legal '{}', no parenthesis for trill.".format(measure_on, voice, note_to_decode), line)
                    return '', None, normal_note
                # fi
            else:
                print_error("m:{} v{} Note is not legal '{}'".format(measure_on, voice, note_to_decode), line)
                return '', None, normal_note
            # fi
            #-- if typenote == trill_note:
            #--     print_error("Note is not legal '{}' double trill".format(note_to_decode), line)
            #--     return '', None, normal_note
            #-- # fi
            therest = note_to_decode[2:]
            if leading_space:
                therest = ' ' + therest         # Flag for later processing.
            # fi
            return therest, 't(', trill_note
        # fi
        if note_to_decode[0] == 'r':            # check for rest
            # Rest follows.
            if args.horizontal or args.vertical:
                thenote = 'r'
            elif args.midi1csv or args.fluidsynth:
                thenote = 0
            else:       # ABC
                thenote = 'z'                   # Convert to abc format rest.
            # fi
            temp3 = temp3 + 1
            # get ready for time computation
            therest = note_to_decode[temp3:]
            if leading_space:
                therest = ' ' + therest         # Flag for later processing.
            # fi
            return therest, thenote, normal_note
        # fi
        print_error("m:{} v{} Note is not legal '{}' unknown".format(measure_on, voice, note_to_decode), line)
        return '', None, normal_note
    # fi
    temp3 = temp3 + 1
    if len(note_to_decode) <= temp3:
        temp4 = ''
    else:
        temp4 = note_to_decode[temp3]
    # fi
    if temp4 == 'n':                            # natural special
        temp3 = temp3 + 1
        thenote = thenote + temp4               # construct  dn
        if thenote not in allkeys:
            print_error("m:{} v{} Note is not legal '{}' not good decode={}  n".format(measure_on, voice, note_to_decode, thenote), line)
            return '', None, normal_note
        # fi
        therest = note_to_decode[temp3:]
    elif temp4 == '+' or temp4 == '-':          # check special note
        thenote = thenote + temp4               # construct  d+ or d-
        temp3 = temp3 + 1
        if len(note_to_decode) <= temp3:
            temp4 = ''
        else:
            temp4 = note_to_decode[temp3]
        # fi
        if temp4 == '+' or temp4 == '-':        # check special note
            thenote = thenote + temp4           # construct  d++ or d--
            temp3 = temp3 + 1
        # fi
        if thenote not in allkeys:
            print_error("m:{} v{} Note is not legal '{}' not good decode={} +/-".format(measure_on, voice, note_to_decode, thenote), line)
            return '', None, normal_note
        # fi
#--        therest = note_to_decode[temp3:]
    else:
        if thenote not in allkeys:
            print_error("m:{} v{} Note is not legal '{}' uh-ish {}".format(measure_on, voice, note_to_decode, thenote), line)
            return '', None, normal_note
        # fi
    # fi

    #   thenote             Convert to abc format for note, octave.
    n = thenote[0].lower()
    if args.horizontal or args.vertical or args.midi1csv or args.fluidsynth:
        N = n.lower()
    else:               # ABC format
        N = n.upper()
    # fi
    if len(thenote) > 1:
        a = thenote[1:]
        if a not in accidentals:
            print_error("m:{} v{} sharp/flat/natural is not legal '{}'".format(measure_on, voice, a), line)
            return '', None, normal_note
        # fi
        if args.horizontal or args.vertical:
            A = a
        elif args.midi1csv or args.fluidsynth:
            A = a
        else:       # ABC
            A = accidentals[a]
        # fi
    else:
        A = a = ''
    # fi
    #-- octaves = { 0:',,,', 1:',,', 2:',', 3:'', 4:'', 5:"'", 6:"''", 7:"'''", 8:"'''" }
    octaves = { 0:',,,', 1:',,', 2:',', 3:'', 4:'', 5:"'", 6:"''", 7:"'''" }
    o = oct_voice
    if o not in octaves:
        print_error("m:{} v{} Note is not legal '{}' oct strange {}".format(measure_on, voice, note_to_decode, o), line)
        return '', None, normal_note
    # fi
    if a not in accidentals:
        print_error("m:{} v{} Note is not legal '{}' accidentals strange {}".format(measure_on, voice, note_to_decode, a), line)
        return '', None, normal_note
    # fi

    ky = key_voice[measure_on][voice]
    if update_defaults and ky != 'atonal':
        if a == '' and voice in acc_m and (str(o) + N) in acc_m[voice] and acc_m[voice][str(o) + N] != '' and line != 'check_staves_notes_order':
            # Check if default from last potential problem.
            print_warning("previous note '{}' voice {} in measure {} was '{}' and this note is default - FIXING".format(n, voice, measure_on, acc_m[voice][str(o) + N]), line)
            a = acc_m[voice][str(o) + N]
            if args.horizontal or args.vertical:
                A = a
            elif args.midi1csv or args.fluidsynth:
                A = a
            else:       # ABC
                A = accidentals[a]          # Convert to abc format.
            # fi
        # fi
        if args.warn_octave_accidental and a != '' and line != 'check_staves_notes_order':
            # Check if note in other octave was set.
            for O in octaves:
                if str(o) != str(O):
                    if acc_m[voice][str(O) + N] != '':
                        print_warning("m:{} v:{} octave/note {}{} accidental {} and this note {}{} is {}".format(measure_on,voice, O,N, acc_m[voice][str(O) + N], o,n, a), line)
                    # fi
                # fi
            # rof
        # fi
        acc_m[voice][str(o) + N] = a             # Save for next note for voice.
    # fi
    # . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
    #-- print_debug("getnote#0 - o={} n={} a={} key_voice[{}][{}]={} xpose[{}]={} xpose_new_key[{}]={}".format(o, n, a, measure_on, voice, key_voice[measure_on][voice], voice,xpose[voice], voice,xpose_new_key[voice]))
    # . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
    # Have o(ctave), a(ccidental), and n(ote).
    # Convert for key.
    if args.horizontal or args.vertical or args.midi1csv or args.fluidsynth:
        if args.horizontal or args.vertical:
            k_check = ky
            if k_check in ['none', 'atonal']:
                k_check = 'c'
            # fi
            if k_check not in key_sig:
                print_error("m:{} v{} key name='{}' not in key_sig.".format(measure_on, voice, ky), line)
                sys.exit(1)
            # fi
        else:
            k_check = ky
            if k_check in ['none', 'atonal']:
                k_check = 0
            # fi
            if k_check not in key_sig_int:
                print_error("m:{} v{} key number='{}' not in key_sig_int={}".format(measure_on, voice, ky, key_sig_int.keys()), line)
                sys.exit(1)
            else:
                k_check = key_sig_int[k_check]
            # fi
        # fi

        thenote = "{}".format(o) + n + a
        thenote = thenote.lower()
        if thenote not in key_convert[k_check]:
            print_error("m:{} v{} thenote='{}' not in key_convert[{}] dictionary.".format(measure_on, voice, thenote, ky), line)
            sys.exit(1)
        # fi
        if key_convert[k_check][thenote] is None:
            print_error("m:{} v{} note {} is not legal for musicomp2abc".format(measure_on, voice, thenote), line)
            return '', None, normal_note
        # fi
        if (args.midi1csv or args.fluidsynth) or xpose_new_key[voice] != '':      # So can print transpose.
            thenote = key_convert[k_check][thenote]
        # fi
        o = thenote[0]
        n = thenote[1].lower()
        if len(thenote) > 2:
            A = a = thenote[2:]
        else:
            A = a = ''
        # fi
    else:           # ABC
        # ky = ky.lower()
        # ky = ky.replace('b', '-')           # Does multiple flats
        # ky = ky.replace('#', '+')           # Does multiple sharps.
        # ky = ky.replace('=', 'n')           # Does multiple naturals.
        # if ky not in key_sig:
        #     print_error("key name='{}' not in key_sig.".format(ky.lower()), line)
        #     sys.exit(1)
        # # fi
        # Do not convert it, already in ABC format.
        if ky == 'atonal':
            ky = 'C'
        # fi
        pass
    # fi
    # . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
    # Have translated key of o(ctave),a(ccidental),and n(ote). -- Original for ABC.
    # 1) xpose added to the note.
    # 2) xpose_new_key converted back to o/n/a

    if (args.midi1csv or args.fluidsynth) and (xpose[voice] != 0 or xpose_new_key[voice] != ''):      # So can print.
        jkl = str(o) + str(n) + a
        if jkl not in note_to_midi_value:
            print_error("m:{} v{} note {} for xpose is not in note_to_midi_value".format(measure_on, voice, jkl), line)
            return '', None, normal_note
        # fi
        lkj = note_to_midi_value[jkl] + xpose[voice]
        if lkj not in midi_value_to_note_flat or lkj not in midi_value_to_note_sharp:
            print_error("note jkl={} lkj='{}' for m:{} voice {} not in midi_value_to_note_flat array".format(jkl,lkj, measure_on, voice), line)
            return '', None, normal_note
        # fi
        lkj = midi_value_to_note_flat[lkj]
        o = int(lkj[0])
        n = lkj[1].lower()
        if len(lkj) > 2:
            A = a = lkj[2:]
        else:
            A = a = ''
        # fi
    elif (args.horizontal or args.vertical) and (xpose[voice] != 0 or xpose_new_key[voice] != ''):

        jkl = str(o) + str(n) + a
        if jkl not in note_to_midi_value:
            print_error("m:{} v{} note {} for xpose is not in note_to_midi_value".format(measure_on, voice, jkl), line)
            return '', None, normal_note
        # fi
        lkj = note_to_midi_value[jkl] + xpose[voice]
        if lkj not in midi_value_to_note_flat or lkj not in midi_value_to_note_sharp:
            print_error("note jkl={} lkj='{}' for m:{} voice {} not in midi_value_to_note_flat array".format(jkl,lkj, measure_on, voice), line)
            return '', None, normal_note
        # fi
        ksxnk = xpose_new_key[voice]
        if ksxnk == '':
            ksxnk = ky                              # Convert back to key it was in.
        # fi
        if type(ksxnk) is str:
            nksxnk = key_sig[ksxnk]
        else:
            nksxnk = ksxnk
            ksxnk = key_sig_int[ksxnk]
        # fi
        # ksxnk is text for xpose new key.  nksxnk is numeric sharp/flat toggle (negative = flats).

        if xpose_new_key[voice] == 'cn':            # Special case "cn" to mean use sharps. 'c' uses flats.
            lkj = midi_value_to_note_sharp[lkj]
        elif nksxnk <= 0:                            # If flat's on stave for key.
            lkj = midi_value_to_note_flat[lkj]
        else:                                       # If sharps's on stave for key.
            lkj = midi_value_to_note_sharp[lkj]
        # fi

        # Convert lkj to playing_o, playing_n, playing_a.
        playing_o = int(lkj[0])
        playing_n = lkj[1].lower()
        if len(lkj) > 2:
            playing_a = lkj[2:]
        else:
            playing_a = ''
        # fi

        # Here with playing:o/n/a set for note after midi up/down semi-tone change.
        playing_on = str(playing_o) + playing_n
        # See if this note in measure already has +/-/n.
        xposed_key_acc_note = acc_m_xpose[voice][playing_on]
        if xposed_key_acc_note != '':               # This note already has sharp/flat/nature
            if playing_a == '':                     # Set to n.
                xposed_key_acc_note = 'n'
            else:
                xposed_key_acc_note = playing_a
            # fi
        else:                                       # Default not set.
            # The default note played for a space/line on staff will be kc.
            kc = key_convert[ksxnk][playing_on]         # What does default note give for this new key?
            if kc == lkj:                               # The Default is this note.
                playing_a = ''
                # leave xposed_key_acc_note alone.
            else:
                if playing_a == '':                     # Set to n.
                    xposed_key_acc_note = 'n'
                else:
                    xposed_key_acc_note = playing_a
                # fi
            # fi
        # fi
        o = playing_o
        n = playing_n
        if update_defaults:
            acc_m_xpose[voice][playing_on] = xposed_key_acc_note
        # fi
        A = a = xposed_key_acc_note
    else:             # ABC format - do nothing.
        pass
    # fi
# .............................................................................
    # Convert to right format.
    if args.horizontal or args.vertical:
        n = n.lower()
        thenote = "{}".format(o) + n + a
        if leading_space:
            thenote = ' ' + thenote
        # fi
    elif args.midi1csv or args.fluidsynth:
        n = n.lower()
        thenote = "{}".format(o) + n + a
        abc = note_to_midi_value[thenote]
        thenote = abc
    else:           # ABC
        # Do not convert it in ABC format.
        if o <= 3:                                      # uppercase letter
            n = n.upper()
        else:                                           # lowercase letter
            n = n.lower()
        # fi
        thenote = A + n + octaves[o]
        if leading_space:
            thenote = ' ' + thenote
        # fi
    # fi
    therest = note_to_decode[temp3:]
    return therest, thenote, normal_note
# End of getnote

# ----------------------------------------------------------------------------
# compute time
# Returns:
#   timeofnote      computed length in 60ths
#   suffixes        Union of bits for suffixes.
#   number_dots     Number of "dots".

global suffix_emphasis
global suffix_legato
global suffix_broken
global suffix_marcato
global suffix_tied
global suffix_staccato
global suffix_dotted        # NOTE: can others be set if this is?
global suffix_normal
suffix_emphasis = 32        # Emphasis
suffix_legato = 16          # glide to next note - no note attack on start of next note.
suffix_broken = 8           # broken - ignored - break between notes ... because gsw didn't have it.
suffix_marcato = 4          # ignored   -- use vol(sf), etc.
suffix_tied = 2             # tied
suffix_staccato = 1         # staccato
suffix_dotted = -1          # dotted
suffix_normal = 0           # No suffix.

# Staccato, tied, break, dotted.
global bit_from_character
bit_from_character = {
   'a': suffix_emphasis,
   'z': suffix_legato,      # 'z' is also slur.
   'l': suffix_legato,      # 'l' is also slur.
   'b': suffix_broken,
   'm': suffix_marcato,
   't': suffix_tied,
   's': suffix_staccato,
   'd': suffix_dotted
   #-- hidden for crescendo ... 'c'.
}

def get_time(therest, line):
    whqe = { 'w':'1', 'h':'2', 'q':'4', 'e':'8' }
    global bit_from_character
    global measure_on

    vwork = 0
    # Must exist. If not alphanumeric or if "whqe".
    if therest and therest[0] in whqe:          # convert whqe to 1,2,4,8.
        w_t = whqe[therest[0]]
        therest = therest[:0] + w_t + therest[1:]
    # fi
    if not therest:
        pass
    elif not therest[0].isalpha():    # if not a note or modifier (computable)
        vwork, type_error = is_float(therest, True)
        # errorrest = everything after value -- if error occurs.
        # vwork = value calculated before error (even if not error).
        # type_error = message of error type.
        if type_error is not None:
            print_error(type_error, line)
            return 0, None, None                # ???
        # fi
        if vwork is None:
            vwork = 0
        # fi
    else:
        for i in therest:
            if i not in bit_from_character:
                print_error("m:{} time field has unrecognizable character ({})".format(measure_on, i), line)
                return 0, None, None                # ???
            # fi
        # rof
    # fi
    if vwork == 0:
        work = 0                                # No time given
    else:
        if therest[0]  == "[":                  # number of 1/60ths
            work = (1.0/64.0) * vwork           # Number of 64th notes
        elif therest[0]  == "(":                # (.25) = 1/4 note (or like "4")
            work = vwork
        else:
            work = 1.0 / vwork
        # fi
    # fi
    work4 = suffix_normal                   # No incidentals yet.
    number_dots = 0
    if therest and therest != '':
        for i in reversed(range(0, len(therest))):
            temp4 = therest[i]
            if temp4 not in bit_from_character:
                break
            # fi
            temp4 = bit_from_character[temp4]
            if temp4 == suffix_dotted:
                number_dots = number_dots + 1
            else:
                work4 = work4 | temp4
            # fi
        # rof
    # fi
    if ((work4 & suffix_legato) != 0 and (
         (work4 & suffix_tied) != 0)):
        print_error("m:{} b) Multiple suffixes that cannot occur together, work4=({})".format(measure_on, work4), line)
        return 0, None, None
    # fi
    return work, work4, number_dots
    if ((work4 & suffix_tied) != 0 and (
         (work4 & suffix_staccato) != 0)):
        print_error("m:{} c) Multiple suffixes that cannot occur together, work4=({})".format(measure_on, work4), line)
        return 0, None, None
    # fi
    return work, work4, number_dots
# End of get_time

# ----------------------------------------------------------------------------
def do_tie_on_previous_note(onvoice, line, what):
    global measure_on                   # The measure we are on.
    global meas                         # volume levels
    global bufs
    global bufs_suffixes

    m = measure_on
    if m not in bufs[onvoice] or bufs[onvoice][m] == '':
        # Do measure before.
        w = len(meas) - 1               # current measure number in array.
        if w == 0:
            print_error("m:{} v{} no previous measure to tie note to.".format(measure_on, onvoice), line)
            return ''
        else:
            m = meas[w-1]
        # fi
    # fi
    if args.horizontal or args.vertical:
        bufs_suffixes[onvoice][m][-1] += what
    elif args.midi1csv or args.fluidsynth:
        bufs_suffixes[onvoice][m].append(what)
    else:                   # abc format
        bufs[onvoice][m] = bufs[onvoice][m] + '-'
    # fi
    return
# End of do_tie_on_previous_note

# ----------------------------------------------------------------------------
def do_tie_abc(onvoice, vnumber, line):
    if vnumber is not None:             # If vertical input format.
        return '-'
    # fi
    do_tie_on_previous_note(onvoice, line, '-')
    return ''
# End of do_tie_abc

# ----------------------------------------------------------------------------
def determine_s_vol(f1, onvoice, line):
    global running_vl
    global measure_on

    if f1 == -1:                        # -1 for getvar('vffff')
        return getvar('vffff')                    # Cannot get any louder.
    elif f1 == -2:                      # -2 for getvar('vff')
        if running_vl[onvoice][measure_on] >= getvar('vfff') :
            return getvar('vffff')
        # fi
        return getvar('vfff')
    elif f1 == -3:                      # -3 for getvar('vff')
        if running_vl[onvoice][measure_on] >= getvar('vff') :
            if running_vl[onvoice][measure_on] >= getvar('vfff') :
                return getvar('vffff')
            # fi
            return getvar('vfff')
        # fi
        return getvar('vff')
    elif f1 == -4:                      # -4 for getvar('vf')
        if running_vl[onvoice][measure_on] >= getvar('vf') :
            if running_vl[onvoice][measure_on] >= getvar('vff') :
                if running_vl[onvoice][measure_on] >= getvar('vfff') :
                    return getvar('vffff')
                # fi
                return getvar('vfff')
            # fi
            return getvar('vff')
        # fi
        return getvar('vf')
    elif f1 == -5:                      # -5 for mf
        if running_vl[onvoice][measure_on] >= getvar('vmf') :
            if running_vl[onvoice][measure_on] >= getvar('vf') :
                if running_vl[onvoice][measure_on] >= getvar('vff') :
                    if running_vl[onvoice][measure_on] >= getvar('vfff') :
                        return getvar('vffff')
                    # fi
                    return getvar('vfff')
                # fi
                return getvar('vff')
            # fi
            return getvar('vf')
        # fi
        return getvar('vmf')
    elif f1 == -6:                      # -6 for mp
        if running_vl[onvoice][measure_on] >= getvar('vmp') :
            if running_vl[onvoice][measure_on] >= getvar('vmf') :
                if running_vl[onvoice][measure_on] >= getvar('vf') :
                    if running_vl[onvoice][measure_on] >= getvar('vff') :
                        if running_vl[onvoice][measure_on] >= getvar('vfff') :
                            return getvar('vffff')
                        # fi
                        return getvar('vfff')
                    # fi
                    return getvar('vff')
                # fi
                return getvar('vf')
            # fi
            return getvar('vmf')
        # fi
        return getvar('vmp')
    elif f1 == -7:                      # -7 for getvar('vp')
        if running_vl[onvoice][measure_on] >= getvar('vp') :
            if running_vl[onvoice][measure_on] >= getvar('vmp') :
                if running_vl[onvoice][measure_on] >= getvar('vmf') :
                    if running_vl[onvoice][measure_on] >= getvar('vf') :
                        if running_vl[onvoice][measure_on] >= getvar('vff') :
                            if running_vl[onvoice][measure_on] >= getvar('vfff') :
                                return getvar('vffff')
                            # fi
                            return getvar('vfff')
                        # fi
                        return getvar('vff')
                    # fi
                    return getvar('vf')
                # fi
                return getvar('vmf')
            # fi
            return getvar('vmp')
        # fi
        return getvar('vp')
    elif f1 == -8:                      # -8 for getvar('vpp')
        return getvar('vpp')                       # Not really something you'll see.
    elif f1 == -9:                      # -9 for getvar('vppp')
        return getvar('vppp')                      # Cannot get much quieter.
    elif f1 == -10:                     # -10 for getvar('vpppp')
        return getvar('vpppp')                     # Cannot 'really' get any quieter.
    else:
        print_error("m:{} v{} determine_s_vol - volume with 's' out of range. ({})".format(measure_on, onvoice, f1), line)
        return getvar('vffff')
    # fi
# End of determine_s_vol

# ----------------------------------------------------------------------------
# therest,new_one_note_volume,newvolume,text_str = get_vol_note(temp1, line)
#       vol(f)
#       vol(sfp)
#       vol(sf)
# See volumes command for more volumes. And "s" for this note only,
# and like "sfp" after it to go to "f" for this note, and "p" for following notes.

def get_vol_note(temp1, onvoice, line):
    global S_vlprint
    global vlprint
    global measure_on

    while temp1[0] == ' ' or temp1[0] == "\t":
        temp1 = temp1[1:]
    # elihw
    therest = temp1[4:]         # get rid of vol()
    sc = therest.find(')')
    if sc < 0 or sc == 0:
        print_error("m:{} v{} A 'vol(' needs a number followed by a ')' -- ')' or number is missing".format(measure_on, onvoice), line)
        return '', None, None, None
    # fi
    f2 = -1                         # No volume setting after the "vol"
    s1 = therest[0:sc]
    therest = therest[sc+1:]
    f1, type_error = is_float(s1, True)
    if type_error is not None or f1 is None:
        for j in vlprint:
            if s1 == vlprint[j]:
                f1 = j
                f2 = int(round(f1)) # flag same after setting it.
                type_error = None
                break
            # fi
        # rof
        if type_error is not None:
            for j in S_vlprint:
                if j == s1:
                    f1 = S_vlprint[j][0]
                    f2 = S_vlprint[j][1]
                    type_error = None
#--                    print_debug("type(f1)={} f1={}".format(type(f1),f1))
#--                    print_debug("type(f2)={} f2={}".format(type(f2),f2))
                    if f1 < 0 and not args.horizontal and not args.vertical:
                        f1 = determine_s_vol(f1, onvoice, line)
                    # fi
                    break
                # fi
            # rof
            if type_error is not None:
                print_error("m:{} v{} vol(xxx) did not get have a number or volume name.  {}".format(measure_on, onvoice, type_error), line)
                return '', None, None, None
            # fi
        # fi
    else:
        f2 = int(round(f1))         # flag same after setting it.
    # fi
    if f1 is None:
        print_error("m:{} v{} volume is not a number.".format(measure_on, onvoice), line)
        return '', None, None, None
    # fi
    if not args.horizontal and not args.vertical:
        f1 = int(round(f1))
        if f1 < 0  or f1 > 127:       # If out of range.
            print_error("m:{} v{} volume number must be between 0 and 127 inclusive. Not ({})".format(measure_on, onvoice, f1), line)
            return '', None, None, None
        # fi
    # fi
    return therest, f1, f2, s1
# End of get_vol_note

# ----------------------------------------------------------------------------
# therest,newvolume,newtime = get_cresc(temp1, line)
#       v22: cresc(ff,0.5)                          $$ Go from here to ff over 1/2 note time length.
#       v1: dimin(p,2.0) s3(1f,1f,1f)4, 1f4t, 1f1d  $$ Go to p over time of two whole notes.

def get_cresc(temp1, line):
    global measure_on

    while temp1[0] == ' ' or temp1[0] == "\t":
        temp1 = temp1[1:]
    # elihw
    therest = temp1[6:]
    sc = therest.find(',')
    if sc < 0 or sc == 0:
        print_error("m:{} A 'cresc(' needs a number followed by a ',' -- ',' or number is missing".format(measure_on), line)
        return '', None, None
    # fi
    s1 = therest[0:sc]
    s2 = therest[sc+1:]
    sc = s2.find(')')
    if sc < 0 or sc == 0:
        print_error("m:{} A 'cresc(' needs a number followed by a ',' and ')' -- ')' or time missing".format(measure_on), line)
        return '', None, None
    # fi
    therest = s2[sc+1:]
    s2 = s2[0:sc]
    # . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
    f1, type_error = is_float(s1, True)
    if type_error is not None:
        for j in vlprint:
            if s1 == vlprint[j]:
                f1 = j
                type_error = None
                break
            # fi
        # rof
        if type_error is not None:
            print_error("m:{} cresc(xxx,yyy) did not get have a number or volume name. {}".format(measure_on, type_error), line)
            return '', None, None
        # fi
    # fi
    if f1 is None:
        print_error("m:{} volume is not a number.".format(measure_on), line)
        return '', None, None
    # fi
    f1 = int(round(f1))
    if f1 < 0  or f1 > 127:       # If out of range.
        print_error("m:{} volume number must be between 0 and 127 inclusive. Not ({})".format(measure_on, f1), line)
        return '', None, None
    # fi
    if args.vertical or args.horizontal:
        f1 = s1
    # fi
    # . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
    f2, type_error = is_float(s2, True)
    if type_error is not None:
        print_error("m:{} cresc(xxx,yyy) did not get have a time value - {}".format(measure_on, type_error), line)
        return '', None, None
    # fi
    if f2 is None:
        print_error("m:{} time value is not a number.".format(measure_on), line)
        return '', None, None
    # fi
    if f2 <= 0:                     # If out of range.
        print_error("m:{} time value must be greater than 0. Not ({})".format(measure_on, f2), line)
        return '', None, None
    # fi
    # . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
    return therest, f1, f2
# End of get_cresc

# ----------------------------------------------------------------------------
# Returns:
#   prenote - things to put in front of a note.
#   postnote - things to put after the note
def do_vol_cresc(temp1, onvoice, line, prenote, postnote, onenotevolume):
    global running_vl
    global args
    global measure_on
    global vlprint

    while True:
        if re.match(r'^[ \t]*vol[(]', temp1):
            therest, onenotevolume, f2, s1 = get_vol_note(temp1, onvoice, line)
            # onenotevolume for midi1csv format.
            if onenotevolume is None:
                return temp1, None, prenote, postnote
            # fi
            if f2 != -1:
                running_vl[onvoice][measure_on] = f2
            # fi
            if args.vertical or args.horizontal or args.midi1csv or args.fluidsynth:
                prenote = prenote + 'vol(' + str(s1) + ') '
                # onenotevole already set for below.
            else:           # ABC
                # Cannot do sfp and such. Boo His.
                j = vol_to_vlprint_round(onenotevolume)
                prenote = prenote + DECORATIONS + vlprint[j] + DECORATIONS
                if f2 == -1:
                    j = vol_to_vlprint_round(running_vl[onvoice][measure_on])
                    postnote = postnote + DECORATIONS + vlprint[j] + DECORATIONS
                elif f2 != onenotevolume:
                    j = vol_to_vlprint_round(f2)
                    postnote = postnote + DECORATIONS + vlprint[j] + DECORATIONS
                # fi
            # fi
            temp1 = therest
            continue
        # fi
        if (re.match(r'^[ \t]*cres[(]', temp1) or re.match(r'^[ \t]*cre[(]', temp1) or
            re.match(r'^[ \t]*cr[(]', temp1) or
            re.match(r'^[ \t]*dimi[(]', temp1) or re.match(r'^[ \t]*dim[(]', temp1) or
            re.match(r'^[ \t]*di[(]', temp1)):
#--        if (temp1[0:5] == 'cres(' or temp1[0:4] == 'cre(' or temp1[0:3] == 'cr(' or
#--            temp1[0:6] == ' cres(' or temp1[0:5] == ' cre(' or temp1[0:4] == ' cr(' or
#--            temp1[0:5] == 'dimi(' or temp1[0:4] == 'dim(' or temp1[0:3] == 'di(' or
#--            temp1[0:6] == ' dimi(' or temp1[0:5] == ' dim(' or temp1[0:4] == ' di('):
            print_error("m:{} v{} cresc() and dimin() are incorrectly written.".format(measure_on, onvoice), line)
            return temp1, None, prenote, postnote
        # fi

        crd = None
        if re.match(r'^[ \t]*cresc[(]', temp1):
            crd = True
        elif re.match(r'^[ \t]*dimin[(]', temp1):
            crd = False
        # fi
        if crd is not None:
            # cresc(ff,5.25)    # volume to go to, 5.25 = time in floating.
            therest, newvolume, newtime = get_cresc(temp1, line)
            if newvolume is None:
                return temp1, None, prenote, postnote
            # fi
            if not (args.vertical or args.horizontal):
                if crd:
                    if newvolume <= running_vl[onvoice][measure_on]:
                        print_error("m:{} v{}: cresc({},{}) going down or already at {}".format(measure_on, onvoice, newvolume,newtime, running_vl[onvoice][measure_on]), line)
                    # fi
                else:
                    if newvolume >= running_vl[onvoice][measure_on]:
                        print_error("m:{} v{}: dimin({},{}) going up or already at {}".format(measure_on, onvoice, newvolume,newtime, running_vl[onvoice][measure_on]), line)
                    # fi
                # fi
            # fi
            cresc_volume[onvoice] = newvolume
            if args.vertical or args.horizontal:
                prenote = prenote + 'cresc(' + str(newvolume) + ',' + str(newtime) + ')'
                cresc_time[onvoice] = newtime + 0.0
            elif args.midi1csv or args.fluidsynth:
                cresc_time[onvoice] = int(round(newtime * MIDICLICKSPERQUARTER * 4))
            else:           # ABC
                if newvolume > running_vl[onvoice][measure_on]:
                    cresc_direction[onvoice] = True
                    prenote = prenote + DECORATIONS + 'crescendo(' + DECORATIONS
                else:
                    cresc_direction[onvoice] = False
                    prenote = prenote + DECORATIONS + 'diminuendo(' + DECORATIONS
                # fi
                cresc_time[onvoice] = newtime + 0.0
            # fi
            temp1 = therest
            continue
        # fi
        break
    # elihw
    return temp1, onenotevolume, prenote, postnote
#   End of do_vol_cresc

# ----------------------------------------------------------------------------
# Parse and process possible notes line.
# All have commas (',') as separators.
# old way is: voice1,voice2,voice3,voice4   -- 3c4, 3e4, 3g4, 4c4
# new way: v#:3c4,d,e,f,g,a,b,4c
# Both have measure terminate them.  NOTE: a second measure the same is allowed.
# --spaces means allow: " " between notes, instead of commas. No pre/post spacing.

def process_notes(line):
    global last_command
    global voices                       # number of voices
    global cis                          # if cis active, non-zero.
    global time                         # set default note length (time) dictionary
    global measure_on                   # The measure we are on.
    global legal_notes
    global mlth                         # measure length dictionary
    global args
    global bufs_suffixes
    global bufs_tie_next
    global bufs_legato_next
    global bufs
    global DECORATIONS
    global macro_buffer                 # Name of macro, array of lines for macro.
    global macro_internal               # Next internal macro.
    global cresc_direction
    global cresc_time
    global cresc_volume
    global macro_arguments              # Name of macro, array of arguments for macro.
    global macro_executing_args
    global macro_executing_depth
    global macro_line
    global meas
    global running_vl
    global vlprint

    if not measure_on or measure_on == '':  # no measure yet
        print_error("no measure processed yet - must have one before notes.", line)
        return
    # fi
    wline = re.sub(r'\s+', ' ', line)           # multiple spaces to single space, multiple times.
    if not args.spaces:
        wline = re.sub(r'([^,)]) ', r'\1', wline)    # ', ' left alone, elsewise strip spaces.
    # fi
    wline = re.sub(r'^  *v', 'v', wline)          # strip spaces before "v" (for voice number).
    wargs = arglist(wline, line, False)

# NOTDONEYET --spaces
#--    print("line='{}' wline='{}' wargs='{}'".format(line,wline,wargs),file=sys.stderr, flush=True)
#--    sys.exit(1)

    if not wargs or len(wargs) < 1:
        print_error("m:{} no arguments on note line".format(measure_on), line)
        return
    # fi
# ...........................................................................
    # Check if 'v#' or 'v(#)'
    vnumber = None
    if wargs[0]:
        if (wargs[0])[0] == 'v' and (wargs[0])[1] != 'o':
            s1 = (wargs[0])[1:]
            sc = s1.find(':')
            if sc < 0:
                print_error("m:{} A 'v' needs a number followed by a colon -- colon is missing".format(measure_on), line)
                return
            # fi
            if sc == 0:
                print_error("m:{} A 'v' needs a number followed by a colon -- number is missing".format(measure_on), line)
                return
            # fi
            s1 = s1[0:sc]

            f1, type_error = is_float(s1, True)
            if type_error is not None:
                print_error(type_error, line)
                return
            # fi
            if f1 is None:
                print_error("m:{} voice number is not a number.".format(measure_on), line)
                return
            # fi
            f1 = int(round(f1))
            if f1 < 1  or f1 > MAXVOICES:       # If out of range.
                print_error("m:{} voice number must be between 1 and {} inclusive. Not ({})".format(measure_on, MAXVOICES, f1), line)
                return
            # fi
            last_command = 'v' + str(f1) + ':'  # For continuation lines.
            do_set_voices(f1, line)
            cis = f1
            wargs[0] = (wargs[0])[sc+2:]
            if wargs[0] == '' and len(wargs) > 1:
                print_error("m:{} Cannot have a blank argument after v{}".format(measure_on, cis), line)
                return
            # fi
            vnumber = 0
        # fi
    # fi
# ...........................................................................
    if cis == 0:                        # if not doing only one voice continuously for a while...
        if len(wargs) > voices:
            print_error("m:{} too many arguments ({}), greater than voices (>{})".format(measure_on, len(wargs), voices), line)
            return
        # fi
        measlth = 0
        for i in range(0, len(wargs)):
            if not(wargs[i] == '' or wargs[i] == ' ' or wargs[i] == "\t"):
                measlth = max(measlth, mlth[i+1][measure_on])
            # fi
        # rof
        for i in range(0, len(wargs)):
            if not(wargs[i] == '' or wargs[i] == ' ' or wargs[i] == "\t"):
                l = measlth - mlth[i+1][measure_on]
                if l > 0:
                    nl = (MIDICLICKSPERQUARTER * 4) / l
                    print_warning("process_notes - missing rests l={} ({}) voice={} measure={}".format(l, nl, i+1, measure_on), line)
                    if args.horizontal or args.vertical:
                        instak(i+1, measure_on, '', 'r', l, '', line, None, '')
                    elif args.midi1csv or args.fluidsynth:
                        instak(i+1, measure_on, '', 0, l / (MIDICLICKSPERQUARTER * 4) , '', line, None, '')
                    else:           # ABC
                        instak(i+1, measure_on, '', 'z', l, '', line, None, '')
                    # fi
                # fi
            # fi
        # rof
    # fi
# ...........................................................................
    # Decode and stack the notes.
    loopstart = 1 if cis == 0 else cis
    for onvoice in range(loopstart, voices + 1):
        setvar('voice', onvoice, 0)
        while True:
            if cis == 0 and len(wargs) < onvoice:
                print_error("m:{} Not enough arguments on note line - want {}, have {}".format(measure_on, onvoice, wargs), line)
                return
            # fi
            if vnumber is None:
                temp1 = wargs[onvoice - loopstart]          # loopstart fixes "cis" being used.
                rest_wargs_on_line = wargs[onvoice - loopstart +1:]
            else:
                if vnumber >= len(wargs):
                    break
                # fi
                temp1 = wargs[vnumber]
                rest_wargs_on_line = wargs[vnumber +1:]
            # fi
            prenote = ''
            if temp1 and (temp1[0] == ' ' or temp1[0] == "\t"):
                prenote = ' '
                temp1 = temp1[1:]
            # fi
            postnote = ''
            onenotevolume = None
            while True:
                for c in macro_buffer:
                    t = temp1[0:len(c) + 1]
                    if c != '' and c + '(' == t:
                        therest = temp1[len(c)+1:]
                        f = therest.find(')')
                        if f < 0:
                            print_error("m:{} macro {} does not have a closing parenthesis".format(measure_on, c), line)
                            return
                        # fi
                        margs = [ therest[0:f] ]
                        temp1 = therest[f+1:]
                        # 1) Create and put in a temporary macro with no arguments for temp1
                        #    (rest of line), if anything in temp1 (not None, nor '').
                        # 2) Put in this macro with arguments.
                        if temp1 is not None and temp1 != '':
                            m_name = 'Internal_Macro_{}'.format(macro_internal)
                            if rest_wargs_on_line == []:
                                macro_buffer[m_name] = [ temp1 ]        # lines in bujffer.
                            else:
                                macro_buffer[m_name] = [ temp1 + "," + ",".join(rest_wargs_on_line) ]
                            # fi
                            # macro_defining = m_name               # No need, we did it.
                            macro_arguments[m_name] = []
                            macro_internal = macro_internal + 1     # Next internal macro.
                            macro_executing_depth.append(m_name)    # Add in the name.
                            macrodepth = len(macro_executing_depth) # one more to do.
                            macro_executing_args[macrodepth] = []   # No arguments
                            macro_line[macrodepth] = 0              # First line in buffer.
                        # fi
                        replace_macro(c, margs, line)
                        return                                      # Go out and read line for macro.
                    # fi
                # rof

                temp1, onenotevolume, prenote, postnote = do_vol_cresc(temp1, onvoice, line, prenote, postnote, onenotevolume)
                break
            # elihw
            therest, thenote, typenote = getnote(temp1, onvoice, line, True) # get next note

            if thenote is None:
                print_error("m:{} no note? therest='{}' thenote='{}' typenote='{}'".format(measure_on, therest, thenote, typenote), line)
                break
            # fi

            if type(thenote) == str and (thenote == '' or thenote == ' ' or thenote == "\t"):
                break
            # fi

#--             if typenote == gsw_operand:
#--                 print_error("m:{} NOTDONEYET - doing gsw_operand type of note".format(measure_on), line)
#--                 return
#--             # fi
#--             if typenote == freqency_note:
#--                 print_error("m:{} NOTDONEYET - doing freqency_note type of note".format(measure_on), line)
#--                 return
#--             # fi

            if type(thenote) is int and typenote != sequence_note:
                #-- if thenote == 0:                        # return nothing, ignore.
                #--     break
                #-- # fi
                if args.vertical or args.horizontal:
                    thenote = "({})".format(thenote)        # Put back as a number.
                elif args.midi1csv or args.fluidsynth:
                    if thenote <= 0:
                        thenote = 0
                    else:
                        if thenote >= 128:
                            thenote = 127
                        # fi
                    # fi
                else:           # ABC
                    thenote = to_abc_note(thenote)          # Convert number to abc text.
                # fi
            # fi
            if typenote == trill_note:
                therest, thenote, typenote = getnote(therest, onvoice, line, True)
                leading_space = False
                if thenote and type(thenote) is str and len(thenote) > 0 and (thenote[0] == ' ' or thenote == "\t"):
                    thenote = thenote[1:]
                    leading_space = True
                # fi
                if thenote is None or thenote == 0 or thenote == '':
                    print_error("m:{} trill is not legal, no first note".format(measure_on), line)
                    return
                # fi

                if typenote == gsw_operand:                                 # 2**16 gsw opnd
                    quotes = thenote - (1 << 16)
                else:
                    quotes = thenote
                # fi
                staccato = ''
                legato = ''
                if therest is not None and therest != '':   # Check for staccato/legato after note.
                    if therest[0] == 's':
                        staccato = 's'
                        therest = therest[1:]
                    # fi
                    if therest[0] in 'lz':
                        legato = 'l'
                        therest = therest[1:]
                    # fi
                # fi
                if therest is None or therest == '' or therest[0] != ',':
                    print_error("m:{} trill is not legal, no comma after first note".format(measure_on), line)
                    return
                # fi
                therest = therest[1:]                                       # comma removed
                therest, thenote, typenote = getnote(therest, onvoice, line, True) # get second note
                if thenote is None or thenote == 0 or thenote == '':
                    print_error("m:{} trill is not legal, second note missing".format(measure_on), line)
                    return
                # fi
                if typenote == gsw_operand:                                 # 2**16 gsw opnd
                    # quotes1 = thenote - (1 << 16)
                    print_error("m:{} trill is not legal, first note not correct".format(measure_on), line)
                    return
                elif typenote == freqency_note or typenote == trill_note or typenote == sequence_note:
                    print_error("m:{} trill is not legal, first note not correct".format(measure_on), line)
                    return
                # fi
                quotes1 = thenote
                if therest is None or therest == '':
                    print_error("m:{} trill is not legal, missing number of notes".format(measure_on), line)
                    return
                # fi
                staccato1 = ''
                legato1 = ''
                if therest is not None and therest != '':   # Check for staccato/legato after note.
                    if therest[0] == 's':
                        staccato1 = 's'
                        therest = therest[1:]
                    # fi
                    if therest[0] in 'lz':
                        legato1 = 'l'
                        therest = therest[1:]
                    # fi
                # fi
                if therest is None or therest == '' or therest[0] != ',':
                    print_error("m:{} trill is not legal, no comma after second note".format(measure_on), line)
                # fi
                therest = therest[1:]                                       # comma removed
                np = temp1 = 0
                f = therest.find(')')
                if f < 0:
                    print_error("m:{} trill is not legal, missing closing parenthesis".format(measure_on), line)
                    return
                # fi
                num = therest[0:f]
                if len(therest) <= f:
                    print_error("m:{} trill is not legal, missing length after parenthesis".format(measure_on), line)
                    return
                # fi
                therest = therest[f+1:]
                np, type_error = is_float(num, True)
                if np is None or np == 0 or type_error is not None:
                    print_error("m:{} trill is not legal, number of notes to play".format(measure_on), line)
                    return
                # fi
                timeofnote, r_suffixes, number_dots = get_time(therest, line)
                if r_suffixes is None or number_dots is None or (
                   r_suffixes != suffix_normal and r_suffixes != suffix_legato):
                    print_error("m:{} trill is not legal - r_suffixes={}".format(measure_on, r_suffixes), line)
                    return
                # fi
                if timeofnote == 0:
                    timeofnote = time[onvoice]
                # fi
                if number_dots != 0:
                    p = timeofnote / 2.0
                    for i in range(1, number_dots+1):
                        timeofnote = timeofnote + p
                        p = p / 2.0
                    # rof
                # fi
                time[onvoice] = timeofnote

    #   t(3a,3g,7)4 =>  '(7:4:2 3a3g'

                # vwork = float(timeofnote) / float(np)

                # t(quotes, quotes1, np)lengthl
                if args.horizontal or args.vertical or args.midi1csv or args.fluidsynth:
                    lengthf = [ timeofnote ]
                else:           # ABC
                    lengthl, lengthf, ifokay = get_time_stak(timeofnote, line, onvoice)
                    if ifokay != 0 or len(lengthl) != 1:         # if time is error
                        print_warning("m:{} trill time must be a printable note length, not '{}'".format(measure_on, lengthl), line)
                        t = 0
                        for l in range(0, len(lengthl)):
                            t = t + lengthf[l]
                        # fi
                        lengthf = [ t ]
                        print_warning("m:{} trill time remade '{}'".format(measure_on, lengthf), line)
                    # fi
                    l = str(Fraction(lengthf[0]).limit_denominator(256))
                    where = l.find('/')
                    lth = '1'
                    if where > 0:                               # / in fraction
                        numerator = l[0:where]
                        if numerator != '1':
                            lth = numerator
                            l = '1' + l[where:]
                        # fi
                    # fi
                    if l not in legal_notes:
                        print_warning("m:{} #2 Time fraction '{}' is not a printable note.  ({})".format(measure_on, lengthf[0], l), line)
                    # fi
                    if l == '1':
                        l = '1/1'
                    # fi
                # fi
# NOTDONEYET - check --vertical and not --wrongties. (But that is not the use for this argument.)
                append_tie = bufs_tie_next[onvoice]
                bufs_tie_next[onvoice] == ''
                if args.horizontal or args.vertical:
                    np = int(round(np))
                    abc_note = "t({}{}{},{}{}{},{})".format(quotes, staccato, legato, quotes1, staccato1, legato1, np)
                    if leading_space:
                        abc_note = ' ' + abc_note
                    # fi
                    if (r_suffixes & suffix_legato) != 0:
                        append_tie = append_tie + 'l'
                    # fi

                    put_on_bufs(onvoice, measure_on, prenote, abc_note, lengthf[0], append_tie, onenotevolume, '', line)
                    if vnumber is None:
                        break                                       # normal old way.
                    # fi
                    vnumber = vnumber + 1
                    continue
                elif args.midi1csv or args.fluidsynth:
                    # lthtrill = int(round((lengthf[0] / int(np)) * MIDICLICKSPERQUARTER * 4.0))
                    # Need to have left-over fractions work.
                    numerator = lengthf[0] * MIDICLICKSPERQUARTER * 4.0
                    lth_so_far = 0
                    np_to_do = int(np)
                    last_legato = False
                    if (r_suffixes & suffix_legato) != 0:
                        last_legato = True
                    # fi
                    for i in range(0, int(np)):
                        put_on_lth = int(round(numerator/np_to_do))
                        np_to_do = np_to_do - 1
                        numerator = numerator - put_on_lth
                        if (i % 2) == 0:
                            abc_note = quotes
                            if np_to_do != 0:
                                sn = append_tie + staccato + legato
                            elif last_legato:
                                sn = append_tie + staccato + 'l'
                            else:
                                sn = append_tie + staccato
                            # fi
                        else:
                            abc_note = quotes1
                            if np_to_do != 0:
                                sn = append_tie + staccato1 + legato1
                            elif last_legato:
                                sn = append_tie + staccato1 + 'l'
                            else:
                                sn = append_tie + staccato1
                            # fi
                        # fi

                        put_on_bufs(onvoice, measure_on, prenote, abc_note, put_on_lth, sn, onenotevolume, '', line)
                        append_tie = ''
                    # rof
                    if vnumber is None:
                        break                                       # normal old way.
                    # fi
                    vnumber = vnumber + 1
                    continue
                else:           # ABC
                    abc_note = "[L:{}]".format(l)
                    abc_note = abc_note + '(' + str(int(np)) + ':' + lth + ':' + str(int(np))
                    if leading_space:
                        abc_note = ' ' + abc_note
                    # fi
                    last_legato = False
                    if (r_suffixes & suffix_legato) != 0:
                        last_legato = True
                    # fi
                    for i in range(0, int(np)):
                        if (i % 2) == 0:
                            if i != (int(np) - 1):
                                leg = legato
                            elif last_legato:
                                leg = 'l'
                            else:
                                leg = ''
                            # fi
                            sta = staccato
                            quo = quotes
                        else:
                            if i != (int(np) - 1):
                                leg = legato1
                            elif last_legato:
                                leg = 'l'
                            else:
                                leg = ''
                            # fi
                            sta = staccato1
                            quo = quotes1
                        # fi

                        if leg != '':
                            if bufs_legato_next[onvoice] != 'l':
                                abc_note = abc_note + '('             # ( before the note for glide/legato
                            # fi
                            bufs_legato_next[onvoice] = 'l'
                        # fi
                        if sta == 's':
                            abc_note = abc_note + '.' + quo
                        else:
                            abc_note = abc_note + quo
                        # fi
                        if leg == '' and bufs_legato_next[onvoice] == 'l':
                            abc_note = abc_note + ')'
                            bufs_legato_next[onvoice] = ''
                        # fi
                    # rof
                    l_dl = default_note_text_fraction(measure_on)
                    if l_dl == '1':
                        l_dl = '1/1'
                    # fi
                    abc_note = abc_note + "[L:{}]".format(l_dl)

                    put_on_bufs(onvoice, measure_on, prenote, abc_note, lengthf[0], '', onenotevolume, postnote, line)
                    if vnumber is None:
                        break                                       # normal old way.
                    # fi
                    vnumber = vnumber + 1
                    continue
                # fi
            elif typenote == sequence_note:
                leading_space = False
                if therest and len(therest) > 0 and (therest[0] == ' ' or therest[0] == ' '):
                    therest = therest[1:]
                    leading_space = True
                # fi
                number_in_sequence = thenote
                if therest[0] != '(':
                    print_error("m:{} sequence is not legal, no parenthesis after number {}".format(measure_on, number_in_sequence), line)
                    return
                # fi
                therest = therest[1:]                                       # parenthesis removed
                notes = []
                vols_prenote = []               # for abc, vertical, horizontal.
                vols_postnote = []              # for abc.
                vols_onenote = []               # For midi1csv, volume for this note.
                stacs = []
                glides = []
                for sn in range(0, number_in_sequence):
                    s_postnote = ''
                    s_prenote = ''
                    if re.match(r'^[ \t]*vol[(]', temp1):
                        therest, onenotevolume, f2, s1 = get_vol_note(therest, onvoice, line)
                        # onenotevolume for midi1csv format.
                        if onenotevolume is None:
                            return
                        # fi
                        if f2 != -1:
                            running_vl[onvoice][measure_on] = f2
                        # fi
                        if args.vertical or args.horizontal or args.midi1csv or args.fluidsynth:
                            s_prenote = s_prenote + 'vol(' + str(s1) + ') '
                            # onenotevole already set for below.
                        else:           # ABC
                            # Cannot do sfp and such. Boo His.
                            j = vol_to_vlprint_round(onenotevolume)
                            s_prenote = s_prenote + DECORATIONS + vlprint[j] + DECORATIONS
                            if f2 == -1:
                                j = vol_to_vlprint_round(running_vl[onvoice][measure_on])
                                s_postnote = s_postnote + DECORATIONS + vlprint[j] + DECORATIONS
                            elif f2 != onenotevolume:
                                j = vol_to_vlprint_round(f2)
                                s_postnote = s_postnote + DECORATIONS + vlprint[j] + DECORATIONS
                            # fi
                        # fi
                    # fi

                    therest, thenote, typenote = getnote(therest, onvoice, line, True)
                    if thenote is None or thenote == '':
                        print_error("m:{} sequence is not legal, no note".format(measure_on), line)
                        return
                    # fi
                    if typenote == gsw_operand:                                 # 2**16 gsw opnd
                        quotes = thenote - (1 << 16)
                    else:
                        quotes = thenote
                    # fi
                    staccato = ''
                    legato = ''
                    if therest is not None and therest != '':   # Check for staccato after note.
                        if therest[0] == 's':
                            staccato = 's'
                            therest = therest[1:]
                        # fi
                        if therest[0] == 'l':
                            legato = 'l'
                            therest = therest[1:]
                        # fi
                    # fi
                    if sn != number_in_sequence - 1:
                        if therest is None or therest == '' or therest[0] != ',':
                            print_error("m:{} sequence is not legal, no comma after note".format(measure_on), line)
                            return
                        # fi
                    elif therest[0] != ')':
                        print_error("m:{} sequence is not legal, no right parenthesis after last note".format(measure_on), line)
                        return
                    # fi
                    therest = therest[1:]                                       # parenthesis removed
                    notes.append(quotes)
                    vols_prenote.append(s_prenote)
                    vols_postnote.append(s_postnote)
                    vols_onenote.append(onenotevolume)
                    onenotevolume = None                # We used the last one.
                    stacs.append(staccato)
                    glides.append(legato)
                # rof
                timeofnote, r_suffixes, number_dots = get_time(therest, line)
                if r_suffixes is None or r_suffixes != suffix_normal or number_dots is None:
                    print_error("m:{} sequence is not legal, r_suffixes={} number_dots={}".format(measure_on, r_suffixes, number_dots), line)
                    return
                # fi
                if timeofnote == 0:
                    timeofnote = time[onvoice]
                # fi
                if number_dots != 0:
                    p = timeofnote / 2.0
                    for i in range(1, number_dots+1):
                        timeofnote = timeofnote + p
                        p = p / 2.0
                    # rof
                # fi
                time[onvoice] = timeofnote

                if args.horizontal or args.vertical:
                    lengthf = [ timeofnote ]
                    n_s = ''
                    for i in range(0, len(notes)):
                        if i == 0:
                            n_s = vols_prenote[i] + notes[i] + stacs[i] + glides[i] + vols_postnote[i]
                        else:
                            n_s = n_s + ',' + vols_prenote[i] + notes[i] + stacs[i] + glides[i] + vols_postnote[i]
                        # fi
                    # rof
                    abc_note = "s{}({})".format(number_in_sequence, n_s)
                    if leading_space:
                        abc_note = ' ' + abc_note
                    # fi

                    put_on_bufs(onvoice, measure_on, prenote, abc_note, lengthf[0], '', onenotevolume, '', line)
                    if vnumber is None:
                        break                                       # normal old way.
                    # fi
                    vnumber = vnumber + 1
                elif args.midi1csv or args.fluidsynth:
                    lengthf = [ timeofnote ]
                    # lthseq = int(round((lengthf[0] / number_in_sequence) * MIDICLICKSPERQUARTER * 4.0))
                    numerator = lengthf[0] * MIDICLICKSPERQUARTER * 4.0
                    lth_so_far = 0
                    seq_num_so_far = number_in_sequence
                    for i in range(0, len(notes)):
                        if i == 0 and vols_prenote[i] == '':
                            prn = prenote
                        else:
                            prn = vols_prenote[i]
                        # fi
                        put_on_lth = int(round(numerator/seq_num_so_far))
                        seq_num_so_far = seq_num_so_far - 1
                        numerator = numerator - put_on_lth

# NOTDONEYET - check --vertical and not --wrongties. (But that is not the use of this argument.)
                        extra_t = 't' if bufs_tie_next[onvoice] == 't' else ''
                        bufs_tie_next[onvoice] = ''
                        # Tie from previous needs to go on first one, else blank it out.

                        put_on_bufs(onvoice, measure_on, prn, notes[i], put_on_lth, stacs[i] + glides[i] + extra_t, vols_onenote[i], '', line)
                    # rof
                    if vnumber is None:
                        break                                       # normal old way.
                    # fi
                    vnumber = vnumber + 1
                else:           # ABC
                    if number_in_sequence == 2 or number_in_sequence == 3:
                        dnl = timeofnote / 2
                        l_time = int(round(timeofnote / dnl - 0.5))
                    elif number_in_sequence == 4 or number_in_sequence == 6:
                        dnl = timeofnote / 4
                        l_time = int(round(timeofnote / dnl - 0.5))
                    elif number_in_sequence == 5:
                        dnl = timeofnote / 5
                        l_time = int(round(timeofnote / dnl - 0.5))
                    elif number_in_sequence == 7:
                        dnl = timeofnote / 7
                        l_time = int(round(timeofnote / dnl - 0.5))
                    elif number_in_sequence == 8:
                        dnl = timeofnote / 8
                        l_time = int(round(timeofnote / dnl - 0.5))
                    else:
                        print_error("m:{} number in sequence ({}) not 2,3,4,6,8.".format(measure_on, number_in_sequence), line)
                        return
                    # fi
                    dnl_str = str(Fraction(dnl).limit_denominator(256))

                    lengthl, lengthf, ifokay = get_time_stak(timeofnote, line, onvoice)
                    if ifokay != 0 or len(lengthl) != 1:         # if time is error
                        print_warning("m:{} sequence time must be a printable note length, not '{}'".format(measure_on, lengthl), line)
                        t = 0
                        for l in range(0, len(lengthl)):
                            t = t + lengthf[l]
                        # fi
                        lengthf = [ t ]
                        print_warning("m:{} sequence time remade '{}'".format(measure_on, lengthf), line)
                    # fi

                    if dnl_str == '1':
                        dnl_str = '1/1'
                    # fi
                    abc_note = ''
                    if leading_space:
                        abc_note = ' ' + abc_note
                    # fi
                    abc_note = abc_note + "[L:{}]".format(dnl_str)
                    abc_note = abc_note + '(' + str(number_in_sequence) + ':' + str(l_time) + ':' + str(number_in_sequence) + ' '
                    for l in range(0, len(notes)):
                        if l == 0 and vols_prenote[l] == '':
                            prn = prenote
                            psn = postnote
                        else:
                            prn = vols_prenote[l]
                            psn = vols_postnote[l]
                        # fi
                        abc_note = abc_note + prn
                        if glides[l] != '':
                            if bufs_legato_next[onvoice] != 'l':
                                abc_note = abc_note + '('             # ( before the note for glide/legato
                            # fi
                            bufs_legato_next[onvoice] = 'l'
                        # fi
                        if stacs[l] == 's':
                            abc_note = abc_note + '.'
                        # fi
                        abc_note = abc_note + notes[l] + psn
                        if glides[l] == '' and bufs_legato_next[onvoice] == 'l':
                            abc_note = abc_note + ')'
                            bufs_legato_next[onvoice] = ''
                        # fi
                    # rof
                    l_dl = default_note_text_fraction(measure_on)
                    if l_dl == '1':
                        l_dl = '1/1'
                    # fi
                    abc_note = abc_note + "[L:{}]".format(l_dl)

                    put_on_bufs(onvoice, measure_on, '', abc_note, lengthf[0], '', onenotevolume, '', line)
                    if vnumber is None:
                        break                                       # normal old way.
                    # fi
                    vnumber = vnumber + 1
                # fi
                continue
            # end of sequence processing above.

            timeofnote, r_suffixes, number_dots = get_time(therest, line)

            if r_suffixes is None or number_dots is None:
                print_error("m:{} Error getting time for note - ({} -> timeofnote={} r_suffixes={} number_dots={}".format(measure_on, therest,timeofnote,r_suffixes,number_dots), line)
                return
            # fi
            # suffix_legato = 16            -- glide to next note.
            # suffix_tied = 2               -- tied
            # suffix_staccato = 1           -- staccato
            # suffix_dotted = -1
            # suffix_normal = 0
            # bits are $union$'ed together for multiple modifiers.
            # number_dots are how many "d" (dotted) were found.
            if timeofnote is None or timeofnote == 0:
                if number_dots != 0:
                    print_error("m:{} cannot have dotted syntax on a default note length.".format(measure_on), line)
                    return
                # fi
                timeofnote = time[onvoice]
            # fi
            if number_dots != 0:
                p = timeofnote / 2.0
                for i in range(1, number_dots+1):
                    timeofnote = timeofnote + p
                    p = p / 2.0
                # rof
            # fi
            time[onvoice] = timeofnote

            append_tie = bufs_tie_next[onvoice]
            bufs_tie_next[onvoice] = ''
            # Tied note
            if (r_suffixes & suffix_tied) != 0:
                if vnumber is not None:         # vertical input format
                    if args.horizontal:                     # horizontal output
                        if not args.wrongties:
                            # put tie on following note.
                            bufs_tie_next[onvoice] = 't'
                        else:
                            append_tie = 't'
                        # fi
                    elif args.midi1csv or args.fluidsynth:                     # midi1csv output
                        if not args.wrongties:
                            bufs_tie_next[onvoice] = 't'
                        else:
                            append_tie = 't'
                        # fi
                    elif args.vertical:                     # vertical output
                        if not args.wrongties:
                            append_tie = 't'
                        else:
                            do_tie_on_previous_note(onvoice, line, 't')
                        # fi
                    else:           # ABC
                        if not args.wrongties:
                            append_tie = do_tie_abc(onvoice, vnumber, line)
                        else:
                            do_tie_on_previous_note(onvoice, line, '-')
                        # fi
                    # fi
                else:                           # horizontal input format
                    if args.vertical:                       # vertical output
                        # put tie on previous note.
                        if measure_on not in bufs[onvoice] or bufs[onvoice][measure_on] == '':
                            # Do measure before.
                            w = len(meas) - 1               # current measure number in array.
                            if w == 0:
                                print_error("m:{} no previous measure to tie note to.".format(measure_on), line)
                                return ''
                            else:
                                m = meas[w-1]
                            # fi
                        else:
                            m = measure_on
                        # fi
                        i = len(bufs_suffixes[onvoice][m]) - 1
                        bufs_suffixes[onvoice][m][i] = bufs_suffixes[onvoice][m][i] + 't'
                        append_tie = ''                     # Nothing on this note, on previous.
                    elif args.horizontal or args.midi1csv or args.fluidsynth:  # horizontal output
                        append_tie = 't'
                    else:           # ABC
                        append_tie = do_tie_abc(onvoice, vnumber, line)
                    # fi
                # fi
            # fi

            # Staccato
            if (r_suffixes & suffix_staccato) != 0:
                if args.horizontal or args.vertical or args.midi1csv or args.fluidsynth:
                    append_tie = append_tie + 's'
                else:           # ABC
                    # thenote = '.' + thenote                   # . before the note for staccato
                    if len(thenote) > 0 and (thenote[0] == ' ' or thenote[0] == "\t"):  # Special leading space!
                        thenote = ' .' + thenote[1:]            # . before the note for staccato
                    else:
                        thenote = '.' + thenote                 # . before the note for staccato
                # fi
            # fi

            # Legato
            if (r_suffixes & suffix_legato) != 0:
                if args.horizontal or args.vertical or args.midi1csv or args.fluidsynth:
                    append_tie = append_tie + 'l'
                else:           # ABC
                    if bufs_legato_next[onvoice] != 'l':
                        thenote = '(' + thenote             # ( before the note for glide/legato
                    # fi
                # fi
                bufs_legato_next[onvoice] = 'l'
            else:
                if bufs_legato_next[onvoice] == 'l':
                    if args.horizontal or args.vertical or args.midi1csv or args.fluidsynth:
                        pass
                    else:           # ABC
                        append_tie = ')' + append_tie
                    # fi
                # fi
                bufs_legato_next[onvoice] = ''
            # fi

            instak(onvoice, measure_on, prenote, thenote, timeofnote, append_tie, line, onenotevolume, postnote)

            if vnumber is None:
                break                                       # normal old way.
            else:
                vnumber = vnumber + 1
            # fi
        # elihw
    # rof
    return
# End of process_notes

# ============================================================================
def read_csv_file(l):
    global array_of_lines

    array_of_lines.append(l)
    return
# End of read_csv_file

# ============================================================================
# 1) For largest character name to smallest character name:
#   A) for all tokens /^[a-zA-Z][a-zA-Z0-9_]*/
#   B) for longest names, from the start first.
#      Then 1 less, from start, then from end (if matches /^[a-z]/).
#   C) go to above if not found until down to won't fit for #1.
# 2) Then one less, goto A) above.

# ============================================================================
#-- ntoken, aftertoken = replace_array_char(wary, thetoken, aftertoken, original_line)
# wary          is array entry ... 
# thetoken      is string where token name is.
# aftertoken    is the string after the token name, where dimensional value(s) are.
# original_line for error printing.

def replace_array_char(wary, thetoken, aftertoken, original_line):
    global measure_on

#--     print_debug("replace_array_char('{}','{}','{}',)".format(wary[numarry_name], thetoken, aftertoken))
    # Find end of array. Need add/match ()[]{}.
    w = 0
    while w < len(aftertoken) and aftertoken[w] in [ "\t", ' ' ]:
        w = w + 1
    # elihw
    if w >= len(aftertoken):
        print_warning("Found character variable {}, but no dimensions.".format(wary), original_line)
#--         print_debug("replace_array_char #1- thetoken={} aftertoken={}".format(thetoken, aftertoken))
#--         print_debug("replace_array_char #a- returning '{}'".format(thetoken + aftertoken))
        return thetoken, aftertoken
    # fi
    e = []
    c = aftertoken[w]
    if c == '(':
        enddelim = ')'
    elif c == '[':
        enddelim = ']'
    else:
        print_warning("Found character variable {}, but no parenthesis for dimension.".format(wary), original_line)
#--         print_debug("replace_array_char #2- thetoken={} aftertoken={}".format(thetoken, aftertoken))
#--         print_debug("replace_array_char #b- returning '{}'".format(thetoken + aftertoken))
        return thetoken, aftertoken
    # fi
    e.append(enddelim)
    w = w + 1
    if w >= len(aftertoken):
        print_warning("Found character variable {}, but no closing {}.".format(wary, enddelim), original_line)
#--         print_debug("replace_array_char #3- thetoken={} aftertoken={}".format(thetoken, aftertoken))
#--         print_debug("replace_array_char #c- returning '{}'".format(thetoken + aftertoken))
        return thetoken, aftertoken
    # fi
    while True:
        while w < len(aftertoken):
            c = aftertoken[w]
            w = w + 1
            if c == enddelim:
                break
            # fi
            if w >= len(aftertoken):
                print_warning("Found character variable {}, but not closing {}.".format(wary, enddelim), original_line)
#--                 print_debug("replace_array_char #4- thetoken={} aftertoken={}".format(thetoken, aftertoken))
#--                 print_debug("replace_array_char #d- returning '{}'".format(thetoken + aftertoken))
                return thetoken, aftertoken
            elif c == '(':
                enddelim = ')'
                e.append(enddelim)
            elif c == '[':
                enddelim = ']'
                e.append(enddelim)
            elif c == '{':
                enddelim = '}'
                e.append(enddelim)
            # fi
        # elihw
        enddelim = e.pop()
        if e == []:
            break
        # fi
    # elihw
    if w < len(aftertoken):
        s = aftertoken[w:]
    else:
        s = ''
    # fi
    # f will be the thing to pass to is_float. s = rest of string.
    f = thetoken + aftertoken[0:w]

    f1, type_error = is_float(f, False)     # Want a string.
    if type_error is not None or f1 is None:
        print_warning("m:{}".format(measure_on) + type_error, original_line)
#--         print_debug("replace_array_char #5- thetoken={} aftertoken={}".format(thetoken, aftertoken))
#--         print_debug("replace_array_char #e- returning '{}'".format(thetoken + aftertoken))
        return thetoken, aftertoken
    elif type(f1) is not str:
        f1 = str(f1)
    # fi
    # Need to retokenize.
#--     print_debug("replace_array_char #f- returning '{}'".format(f1 + s))
    return f1, s
# End of replace_array_char

# ============================================================================
#--     replacedline = replace_char_var(line, linestarts, lineends, original_line)
def replace_char_var(line, linestarts, lineends, original_line):
    global whichlocalchars

#--     print_debug("replace_char_var - Entering(, {}, {},)".format(linestarts,lineends))
    cnt = 0
    beforetokenline = line[0:linestarts]
    token = ntoken = line[linestarts:lineends]
    aftertokenline = line[lineends:]

    for w in whichlocalchars:
        if w not in ntoken:
            continue
        # fi
        a = ntoken.find(w)
        if a == -1:
            continue
        # fi
        lw = len(w)
        lt = len(ntoken)
        if lw + a != lt and len(whichlocalcharswary[w][numarry_indexes]) != 0:
            print_warning("Found character variable {}, but not at end of token, and it needs dimensions.".format(w), original_line)
            continue
        # fi
        if a > 0:
            beforetoken = ntoken[0:a]
        else:
            beforetoken = ''
        # fi
        if lw + a != lt:
            aftertoken = ntoken[a+lw:] + aftertokenline
        else:
            aftertoken = '' + aftertokenline
        # fi
        if len(whichlocalcharswary[w][numarry_indexes]) == 0:
            if whichlocalcharswary[w][numarry_value_type][0] == 0:
                b = str(whichlocalcharswary[w][numarry_values][0])
            else:
                b = whichlocalcharswary[w][numarry_values][0]
            # fi
            ntoken = beforetokenline + beforetoken + b + aftertoken
            return ntoken
        else:
            ntoken = ntoken[a:lt]
            ntoken, aftertoken = replace_array_char(whichlocalcharswary[w], ntoken, aftertoken, original_line)
            ntoken = beforetokenline + beforetoken + ntoken + aftertoken
#--             print_debug("replace_char_var - '{}' '{}' '{}'".format(beforetoken, ntoken, aftertoken))
            return ntoken
        # fi
    # rof

#--     print_debug("replace_char_var - returning '{}'".format(line))
    return line
# End of replace_char_var

# ============================================================================
# Go past all delimiters to an alpha for possible starting of character variable.
# Returns start of token, and start of delimiter or EOLN.

def next_token(startat, strg):
    while startat < len(strg) and not strg[startat].isalpha():
        startat = startat + 1
    # elihw
    if startat >= len(strg):
        return None, None
    # fi
    startoftoken = startat
    while startat < len(strg) and (strg[startat].isalnum() or strg[startat] == '_'):
        startat = startat + 1
    # elihw
    return startoftoken, startat
# End of next_token

# ============================================================================
# Returns start of first token (MUST BE zero), and start of delimiter.

def first_token(strg):
    # Token must start with alpha.
    if strg is None or strg == '' or not strg[0].isalpha():
        return None
    # fi
    looking = 0
    while looking < len(strg) and (strg[looking].isalnum() or strg[looking] == '_'):
        looking = looking + 1
    # elihw
    return looking
# End of first_token

# ============================================================================
def char_var_subst_whole_string(strg, line):
    if whichlocalchars == []:
        return strg
    # fi
#--     print_debug("char_var_subst_whole_string - Entering {}".format(strg))
    o_strg = strg
    w = 0
    while w < len(strg):
        linestarts,lineends = next_token(w, strg)
        if linestarts is None:
#--             print_debug("char_var_subst_whole_string - returning '{}'".format(strg))
            return strg
         # fi
#--         print_debug("char_var_subst_whole_string #a- '{}'".format(strg[linestarts:lineends]))
        strg = replace_char_var(strg, linestarts, lineends, line)
#--         print_debug("char_var_subst_whole_string #b- strg={}".format(strg))
        if strg != o_strg:
            o_strg = strg
            w = 0
            i_line.append('chrvs: ' + o_strg)             # Line as fixed or whatever.
        else:
            w = lineends
        # fi
    # elihw
#--     print_debug("char_var_subst_whole_string - returning '{}'".format(strg))
    return strg
# End of char_var_subst_whole_string

# ============================================================================
def char_var_subst_first_token(line):
    if whichlocalchars == []:
#--         print_debug("char_var_subst_first_token #a- returning '{}'".format(line))
        return line
    # fi
    repeat = True
    lineends = first_token(line)
    if lineends is None:
#--         print_debug("char_var_subst_first_token #b- returning '{}'".format(line))
        return line                             # Nothing to change.
    # fi
    replacedline = replace_char_var(line, 0, lineends, line)
#--     print_debug("char_var_subst_first_token #c- replacedline '{}'".format(replacedline))
    return replacedline
# End of char_var_subst_first_token

# ============================================================================
# process_line([t0, t1], line) => possible command, rest of line, with delimiter after possible command.
# Parse and process line.

def process_line(line):
    global last_command
    global iftest                       # check if after if or else.
    global ifdepth                      # level of if/else/endif
    global commands
    global cstop_processing
    global macro_defining               # If defining macro.
    global macro_buffer                 # Name of macro, array of lines for macro.
    global measure_on

    t0 = re.sub(r'^([a-zA-Z0-9%_]*).*$', r'\1', line, count=1)   # First token on line.
    t1 = re.sub(r'^[a-zA-Z0-9%_]*(.*)$', r'\1', line, count=1)   # Rest of line.

    command = t0.lstrip()
    if len(t1) > 0:
        delimiter = t1[0]
    else:
        delimiter = None
    # fi
    t_args = t1.strip()
    # Note: t0 + t1 = line. :) [Thus know how to do things in character variable substitution.]

    if cstop_processing:
        # Read until cstart found (or end of file)
        if command in commands and commands[command][1]:    # If flag to process while in cstop.
            last_command = command
            commands[command][0](t_args, line)              # Process some commands while cstop-ped.
        # fi
        return                          # Done with current cstop processing.
    # fi

    if macro_defining is not None:
        if command in commands and commands[command][0] in (do_endm, do_cstopnow):
            last_command = command
            commands[command][0](t_args, line)      # Process command endm or cstop*.
            return
        # fi
        macro_define(command, t_args, line)
        return
    # fi

    # Doing if section or else section.
    if iftest[ifdepth] == -1 or iftest[ifdepth] == 1:
        # Try to process command.
        if command is None:             # Ignore nothing given.
            return
        # fi
        if command in commands and commands[command][0] in (do_vars, do_encode, do_calc):
            # Do NOT substitute variables on these lines.
            last_command = command
            commands[command][0](t_args, line)      # Process command vars, encode, or calc.
            return
        # fi
        while True:
            nline = char_var_subst_whole_string(t_args, line).strip()
            if nline == t_args:
                break
            # fi
            numcharvar = numcharvar + 1
            if numcharvar > 25:
                print_error("Over 25 character variable substitutions done on arguments - loop?", line)
                break
            # fi
            t_args = nline
            i_line.append('chrvs: ' + command + ' ' + line)             # Line as fixed or whatever.
        # elihw
        if command in macro_buffer:
            last_command = command
            replace_macro(command, t_args, line)
            return                          # Henceforth get lines from macro_buffer.
        elif command[0] == '%':             # Change single percent to double percent signs.
            command = '%%'
            last_command = command
        # fi
        if command in commands:
            last_command = command
            try:
                r = commands[command][0]    # Had an error once ... thus try/expect.
            except:
                print_error("m:{} not found processing routine for command {}".format(measure_on), command)
                print("    ", sys.exc_info()[0], sys.exc_info, file=sys.stderr, flush=True)
            # fi
            r(t_args, line)
            return
        # fi
        if measure_on in goto_table:
            print_error("Notes after a goto are not allowed. measure='{}'".format(measure_on), line)
            return
        # fi

        process_notes(line)

        return
    # fi
    # Do not do macros in false part of if/elif/else section.
    if t[0] in commands:
        if commands[t[0]][0] in (do_cstopnow, do_if, do_else, do_endif):
            last_command = command
            commands[t[0]][0](t_args, line)
        # fi
    # fi
    return
# End of process_line

# ----------------------------------------------------------------------------
def dothefile():
    global last_command
    global commentonline
    global precomment
    global linecount
    global which_file_in

    precomment = ''
    while True:
        line, commentonline = read_next_line()
        line = line.rstrip()
        if not line:
            continue
        # fi
        num_putd = 0
        numcharvar = 0
        while True:
            if macro_defining is None:
                if line and line[0] == '=':
                    line = process_putd(line)
                    i_line.append('putd:  ' + line)             # Line as fixed or whatever.
                    if len(line) > 0 and line[0] == '=':
                        num_putd += 1
                        if num_putd > 25:
                            print_error("Over 25 putd's done on line", line)
                            break
                        # fi
                        continue
                    # fi
                elif line[0] == "\t" or re.match(r'^        ', line):
                    # This is a continuation line.
                    line = last_command + ' ' + line.strip()
                    break
                elif len(line) >= 1 and line[0] == '.' and (len(line) == 1 or (line[1] == "\t" or line[1] == ' ')):
                    line = line[1:].lstrip()
                    if len(line) == 0:
                        break
                    # fi
                    continue
                # fi
#--                     print_debug("dothefile - calling char_var_subst_first_token({})".format(line))
                nline = char_var_subst_first_token(line)
                if nline != line:
                    numcharvar = numcharvar + 1
                    if numcharvar > 25:
                        print_error("Over 25 character variable substitutions done on first token of line", line)
                        break
                    # fi
                    line = nline
                    i_line.append('charv: ' + line)             # Line as fixed or whatever.
                    continue        # might have putd's or continuation line.
                # fi
            else:
#--                     print_debug("dothefile - calling char_var_subst_whole_string({})".format(line))
                nline = char_var_subst_whole_string(line, line).rstrip()
                if nline != line:
                    numcharvar = numcharvar + 1
                    if numcharvar > 25:
                        print_error("Over 25 character variable substitutions done on line", line)
                        break
                    # fi
                    line = nline
                    i_line.append('chrvs: ' + line)             # Line as fixed or whatever.
                    continue        # might have putd's or continuation line.
                # fi
            # fi
            break
        # elihw
        if len(line) == 0:          # Ignore empty line.
            continue
        elif line[0] == "\t":
            line = (' ' * 8) + line[1:]
        # fi
        if line.startswith('^        '):
            print_error("continuation line -- NOTDONEYET!",line)
        else:
            line = line.strip()     # Strip leading and trailing spaces.
        # fi
        if len(line) == 0:          # Ignore empty line.
            continue
        # fi
        # If command == '*' ignore.
        if line[0] == '*':
            precomment = precomment + line + "\n"   # Comment line.
        elif line[0] == '#':        # C pre-processor line.
            # Parse # line to get line number and file.
            uxit = re.sub('^ *# ([0-9]+) "([^"]+)".*$', r"\1 \2", line)
            if uxit != line:               # If no 3rd argument (flags).
                wxit = re.split(r' ', uxit, maxsplit = 1)
                linecount = int(wxit[0]) - 1
                which_file_in = wxit[1]
            # fi
        else:                       # Note: empty blank line passed through.
            process_line(line)
            precomment = ''
        # fi
    # elihw
    return
# End of dothefile

# ----------------------------------------------------------------------------
def parse_args():
    global args
    global pages_to_do
    global measures_to_do
    global voices_to_do

#--    def offset_value(v):
#--        if len(v) > 0:
#--            if v[0] == '=':
#--                v = v[1:]
#--            # fi
#--        # fi
#--        return v
#--    # End of offset_value

#--    for indx in range(len(sys.argv) - 1):
#--        if '--offset' in sys.argv[indx]:
#--            sys.argv[indx + 1] = '={0}'.format(sys.argv[indx + 1])
#--        # fi
#--    # rof
    parser = argparse.ArgumentParser(
        description=__doc__,
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog='this is the epilog')
    parser.add_argument('--vertical', '--vertica', '--vertic', '--verti', '--vert',
                        '--ver', '--ve', '--v', '-v',
                        action='store_true',
                        help = 'Vertical musicomp format output.')
    parser.add_argument('--horizontal', '--horizonta', '--horizont', '--horizon',
                        '--horizo', '--horiz', '--hori', '--hor', '--ho', '--h',
                        action='store_true',
                        help = 'Horizontal musicomp format output.')
    parser.add_argument('--midi1csv', '--midi1cs', '--midi1c', '--midi1', '--midi',
                        '--mid', '--mi', '--m', '--csv', '--cs', '--c', '-c', '-m', '-1',
                        action='store_true',
                        help = 'Output MIDI 1.0 music format output.')
    parser.add_argument('--abc', '-abc',
                        action='store_const', const=1, default=0,
                        help = 'ABC music format output - default.')
    parser.add_argument('--fluidsynth', '--fluidsynt', '--fluidsyn', '--fluidsy', '--fluids',
                        '--fluid', '--flui', '--flu', '--fl', '--f', '--fs',
                        '-fluidsynth', '-fluidsynt', '-fluidsyn', '-fluidsy', '-fluids',
                        '-fluid', '-flui', '-flu', '-fl', '-f', '-fs',
                        action='store_true',
                        help = 'Output fluidsynth music format output.')
    parser.add_argument('--nogoto', '--nogot', '--nogo', '--nog',
                        '-nogoto', '-nogot', '-nogo', '-nog',
                        action='store_true',
                        help = 'Do not parse goto commands, ignore them.')
    parser.add_argument('--noxpose', '--noxpos', '--noxpo', '--noxp', '--nox',
                        '-noxpose', '-noxpos', '-noxpo', '-noxp', '-nox',
                        action='store_true',
                        help = 'Do not parse xpose commands, ignore them.')
#--    parser.add_argument('--offset', default=0, action = 'store', type=offset_value,
#--                        help = 'Offset for midi instruments +1, -1, -12 -- because they CAN differ for playing.')
    parser.add_argument('--shift', type=float, default=0.0,
                        help = 'Shift all measures before printing (0.5 = 1/2 note to left/earlier measure).')
    parser.add_argument('--pages', '--page', '-pages', '-page',
                        default='', action = 'store',
                        help = 'Only parse page(s) specified. "1,2,5" or "1,2,5-8,114". (via cstart/cstop)')
    parser.add_argument('--measures', '--measure', '--measur', '--measu', '--meas', '--mea', '--me',
                        '-measures', '-measure', '-measur', '-measu', '-meas', '-mea', '-me',
                        default='', action = 'store',
                        help = 'Only parse measure(s) specified. "1,2,5" or "1,2,5-8,114a,115". (via cstart/cstop)')
    parser.add_argument('--voices', '--voice', '--voic', '--voi', '--vo',
                        '-voices', '-voice', '-voic', '-voi', '-vo',
                        default='', action = 'store',
                        help = 'Only print voice(s) specified. (parsing done) "1,2,5" or "1,2,5-8,15". (when writing output)')
    parser.add_argument('--wrongties', '--wrongtie', '--wrongti', '--wrongt', '--wrong', '--wron', '--wro', '--wr',
                        '-wrongties', '-wrongtie', '-wrongti', '-wrongt', '-wrong', '-wron', '-wro', '-wr',
                        default='', action = 'store_true',
                        help = 'When reading, ties for --vertical are on the latter note, move to front.')
    parser.add_argument('--nolegato', '--no-legato', action='store_true',
                        help = 'Do not do legatos.')
    parser.add_argument('--multiplemeasures', action='store_true',
                        help = 'If measure appears multiple times, do not fill in voices with rests.')
    parser.add_argument('--D', '-D', action='append', type=str,
                        help = 'Example: "-D WHICH=5" Define variable in calculator. (e.g. "if WHICH==5")')
    parser.add_argument('--two', '-two', '--2', '-2', action='store_true',
                        help = 'Use soundfont number 2.')
    parser.add_argument('--warn_octave_accidental', '-warn_octave_accidental', action='store_true',
                        help = 'Warn if accidental in other octave set/used.')
    parser.add_argument('--spaces', '-spaces', action='store_true',
                        help = 'Use spaces as note separators in addition to commas (input only, not printing vertical/horizontal).')
    parser.add_argument('--xpose', '-xpose',
                        default='', action='store',
                        help = 'Arguments to process as an xpose command before procssing first measure.')
    parser.add_argument('rest', nargs='*',
                        help='Optional command to execute')
    args = parser.parse_args()

#--    if args.offset is not None:
#--        args.offset = int(args.offset)
#--    # fi

    if args.pages is not None and args.pages != '':
        # global pages_to_do
        n = re.sub(r'\s*,\s*', ',', args.pages)
        n = re.sub(r'\s*,\s*', ',', n)
        pages_to_do = arglist(n, 'parsing --pages', True)
    # fi

    if args.measures is not None and args.measures != '':
        n = re.sub(r'\s*,\s*', ',', args.measures)
        n = re.sub(r'\s*,\s*', ',', n)
        measures_to_do = arglist(n, 'parsing --measures', True)
    # fi

    if args.voices is not None and args.voices != '':
        n = re.sub(r'\s*,\s*', ',', args.voices)
        n = re.sub(r'\s*,\s*', ',', n)
        voices_to_do = arglist(n, 'parsing --voices', True)
    # fi

    if args.rest is not None:
        for indx in range(len(args.rest)):
            if args.rest[indx][0] == '=':
                nextargv = args.rest[indx]
                if len(nextargv) > 0:
                    nextargv = nextargv[1:]
                # fi
                args.rest[indx] = nextargv
            # fi
        # rof
    # fi
    if args.vertical:
        if args.horizontal or args.abc == 1 or args.midi1csv or args.fluidsynth:
            print_error_no_line("Only may have one of --vertical, --horizontal, --abc, --midi1" or --fluidsynth)
            sys.exit(1)
        # fi
    elif args.horizontal:
        if args.abc == 1 or args.midi1csv or args.fluidsynth:
            print_error_no_line("Only may have one of --vertical, --horizontal, --abc, --midi1 or --fluidsynth")
            sys.exit(1)
        # fi
    elif args.midi1csv:
        if args.abc == 1 or args.fluidsynth:
            print_error_no_line("Only may have one of --vertical, --horizontal, --abc, --midi1 or --fluidsynth")
            sys.exit(1)
        # fi
        setvar('play', -1, 0)    # compiling for playing
    elif args.fluidsynth:
        if args.abc == 1:
            print_error_no_line("Only may have one of --vertical, --horizontal, --abc, --midi1 or --fluidsynth")
            sys.exit(1)
        # fi
        setvar('play', -1, 0)    # compiling for playing
    else: # args.abc == 1
        setvar('print', -1, 0)   # compiling for printing
    # fi

    if args.D:
        for D in args.D:                    # If any defines, try to do them.
            sdefs = D.split('=')            # Quick check for assignment.
            if not sdefs or len(sdefs) < 2 or sdefs[0] == '' or sdefs[1] == '':
                print_error_no_line("Argument '-D {}' does not appear to be a variable assignment.".format(D))
                continue
            # fi
            sdef = sdefs[0].strip()
            typ = 0                         # Assume a numeric value (int or float).
            k = False
            for i in sdefs[1]:
                if i.isnumeric():
                    continue
                elif i == '.' and not k:
                    k = True
                    continue
                # fi
                typ = 1             # character string
                break
            # rof
            createlocalvar(sdef, sdefs[1], typ)   # pre-define
        # rof
    return
# End of parse_args

# ----------------------------------------------------------------------------
# Main program follows.
def main():
    global header
    global measure_meter
    global measure_meter_value
    global args
    global file_name
    global output_name
    global meter
    global voices
    global measure_on
    global key_default
    global key_voice
    global which_file_in

    parse_args()
    if args.vertical or args.horizontal:
        header = ( "meter   4/4\n" )
        key_default = "c"                   # Default to key of c.
                                            # At the end of header, print out the key - then follows notes.
        measure_meter = { '': '4/4'}        # Each measure change can have a different meter.
        measure_meter_value = 1             # Computed value for measure.
        meter = '4/4'
    elif args.midi1csv or args.fluidsynth:
        header = []
        key_default = 0                     # Default to key of C.
        measure_meter = { '': '4/4'}        # Each measure change can have a different meter.
        measure_meter_value = 1             # Computed value for measure.
        meter = '4/4'
    else:           # ABC
        header = (  "X:1\n" +               # Song number 1 in the output file.
                    "M:none\n" )            # No meter supposedly means don't check.
        key_default = "C"                   # Default to key of C.
                                            # At the end of header, print out the key - then follows notes.
        measure_meter = { '': 'none'}       # Each measure change can have a different meter.
        measure_meter_value = 1             # Computed value for measure.
        meter = 'none'
    # fi
    for v in range(1, MAXVOICES+1):
        key_voice[''][v] = key_default
    # rof

    new_voice_initialize(voices, measure_on)    # Set a bunch of things for voice=1 so acc_m, etc. are set.

    output_name = sys.stdout
    if args.rest:
        if len(args.rest) >= 1:             # Input.
            file_name = open(args.rest[0], 'r')
            which_file_in = args.rest[0]
        # fi
        if len(args.rest) >= 2:             # Output.
            output_name = open(args.rest[1], 'w')
        # fi
        if len(args.rest) > 2:              # Too many.
            print_error_no_line("Too many arguments, input, output only.  {}".format(args.rest))
            sys.exit(1)
        # fi
    # fi

    dothefile()
    return
# End of main

# ----------------------------------------------------------------------------
if __name__ == '__main__':
    main()
# fi
# ----------------------------------------------------------------------------
exit(errors_happened)
# ----------------------------------------------------------------------------
# End of file musicomp2abc
# ----------------------------------------------------------------------------

# Header:
# * X:          Reference number (think which track on CD, etc.).       First
# * T: Title of tune             (can have multiple)
#   C: Composer of song
#   M: meter    6/8              default common or "M: C"
#   L: 1/4                       length of default note (quarter)
#   K: key      C or D or ...                                           Last
#
#   Notes: follow Header
#       C, D, E, F, |G,A,B,C| D E F G|A B c d|e f g a|b c' d' e'|f' g' a' b'|]
#
#       ~A3 B3|gfe fdB|AFA B2c|dfe dcB|
#
#   Uppercase denote bottom octave (C = middle C on treble stave).
#   Comma after the letter means down an octave.
#   Apostrophe after the letter means up an octave. Multiple ' go up, as ,'s go down.
#   Lowercase letters are next octave above uppercase. four c's: "C, C c c' "
#   |  Vertical line means end of measure/bar -- || gives two lines.
#   ]  means thick bar.  [|  and |] thick/thin and thin/thick.
#   |: start of repeat. :| is end of repeat. Stop one and start another is :||: or "::".
#   Alternate repeats "[1", "[2". If by bar line, can omit the [. "|1" means "|[1". (no spaces)
#   To have notes with "beam"(lines together above/below) eliminate the "space".
#
#   Number after note changes duration. Number times default. B2=B twice as long therefore 1/4 because 1/2.
#   / means shorten, default is 2 or "/2".
#   > after a note, multiplying by 3/2 and removing from 2nd note. I.e. c8>c8 -> c8.c16 (dot means 1/16 extra)
#   < after a note, multiplying by 1/2 and adding rest on 2nd note. I.e. c8<c8 -> c16c8. means 1/16th extra
#
#   ~ is ornament -- roll or turn as in Irish music.
#   Default note lengths for common types of tunes: jig 1/8, reel 1/8, Schottische 1/8,
#       Waltz 1/4, Polka 1/8, Bourree 1/8
#   Time signagures typical: jig 6/8, reel 4/4, waltz 3/4.
#   L: can be used in the middle to change default note length.
#   Rests are lowercase z. Length follows.
#   ^C = C sharp. _B = B flat. ^^ = double sharp. The equals (=) naturalizes it.
#   G major scale: GABcde^fg            for K:C
#   G minor scale: GA_Bcd_efg           for K:C
#   K: automatically adds sharps or flats.      example K:G or K:Gmaj ... and K:Gm or K:Gmin
#   Also K:Bb and K:C#   (B flat and C sharp).
#   Other Modal keys exist: Lydian, Ionian, Mixolydian, Dorian, Aeolian, Phrygian, Locrian,
#       HP (bagpipe - no key signature), Hp (F#,C#,G natural) on printed.
#   K: can go in the middle of a song.   K:A =C -- A major, C natural -- F#,G#.
#   R: = rythm. ... R:reel, R:jig, R:schottische
#   Q: tempo    Example: Q: 120  # of default note length.  Q:1/8 = 120.
#   Can change in the middle of a line like (KRQ):
#       GABcdefg | [M:6/8 K:Gm] gfe dcB | AGB FED |
#   Optional:
#   C: composer
#   S: source of tune.
#   O: geographical origin
#   N: textual notes about the tune. (anything you want, multiple of them, etc.)
#   Z: identity of transcriber. # Z:Marshall Midden 2021-01-04
#   W: for song words           w:  also -- difficult syntax. :)
#   B: for book
#   A: geographical area
#   D: Discography -- D:New Victory Band, One More Dance And Then
#   F: File name (http://www.lesession.co.uk/woodenflute.abc)
#   G: Group -- used for indexing tunes in software.   G: Flute
#   H: history
#   I: Information -- used by some software packages.
#   P: Yuck.  Parts.
#
#   grace notes {GAGDG}G2 -- they can have no time values.
#   - minus sign between two notes of equal pitch "ties". () slurs or played legato.
#       |DEF-|FGA| and |DEF-FGA|
#       (DEF|GAB)
#   Triplets -- no spaces within:
#       Duplet:     (2GA                2 notes in the time of 3
#       Triplet:    (3GAB               3 notes in the time of 2
#       Quadruplet: (4GABA              4 notes in the time of 3
#       ...       : (5GABcd             5 notes in the time of n
#       ...       : (6GABcdc            6 notes in the time of 2
#       ...       : (7GABcdcB           7 notes in the time of n
#       ...       : (8GABcdcBA          8 notes in the time of 3
#       ...       : (9GABcdcBAG         9 notes in the time of n
#       n is 3 in compound time signatures (3/4, 3/8, 9/8 etc), and 2 in simple time signatures (C, 4/4, 2/4 etc.)
#       More complicated forms possible. (Yuck!)
#   [GB][Ac] [B2d2] | [Bd][Ac] [G2B2]   - multiple notes on a stem (chord/unisons)
#   Guitar chords:  "Dm7"               -- note accidental type/bass
#       note:       A to G
#       accidental: # or b
#       type:       m, min, maj, sus, dim, +, 7, 9, 11,#5, etc.
#       / bass:     Bass note
#   Fiddle bowing marks:  u=up-bow, v=down-bow.     v_Au=Bv^c   NOTE: flat A, natural B, sharp c.
#   Staccato, place dot before the note.            .G.A._B.c .d2.e.d.^c
#       H Fermata, L Accent, or emphasis, M Lower mordent (sometimes called mordent),
#       O Coda, P Upper mordent (sometimes called Pralltriller), S Segno, T Trill
#   or can enclose within exclamation marks (!):
#       !+!             Pizzicato for violins, rasp for brass
#       !0! to !5!      Fingerings
#       !D.C.!          Da capo
#       !D.S.!          Da segno
#       !accent!        Accent mark over the note
#       !breath!        Breath mark
#       !coda!          Coda mark
#       !crescendo(!    Start of a crescendo mark
#       !crescendo)!    End of a crescendo mark - this is placed AFTER the last note affected
#       !diminuendo(!   Start of a diminuendo mark
#       !diminuendo)!   End of a diminuendo mark - this is placed AFTER the last note affected
#       !downbow!       Down bow mark
#       !emphasis!      The same as !accent!
#       !fermata!       Fermata, or hold
#       !f!, !ff!, !fff! etc.   Dynamic markings - the more f -s, the louder
#       !fine!          Fine
#       !invertedfermata!   Inverted fermata / hold marking
#       !longphrase!    Vertical line on the upper part of the staff, extending 3/4 of the way down
#       !lowermordent!  Lower mordent, a.k.a. mordent
#       !mediumphrase!  Vertical line on the upper part of the staff, extending down to the centre line
#       !mf!            Dynamic marking for mezzoforte ('half-loud')
#       !mordent!       Lower mordent, a.k.a. mordent
#       !open!          Open string, or, harmonic
#       !p!, !pp!, !ppp!    Dynamic markings - the more p -s, the quieter
#       !pralltriller!  Upper mordent
#       !repeatbar!     Repeat whole of previous bar
#       !repeatbar2!    Repeat whole of previous two bars
#       !roll!          Roll mark
#       !segno!         Segno
#       !shortphrase!   Vertical line on the upper part of the staff
#       !snap!          Snap-pizzicato mark
#       !tenuto!        tenuto (hold note for full duration)
#       !thumb!         Cello thumb symbol
#       !trill!         Trill
#       !turn!          Turn
#       !upbow!         Up bow mark
#       !uppermordent!  Upper mordent, a.k.a. pralltriller
#       !wedge!         Wedge mark
#   As with the single letter symbols, the mark is placed before the note (or first note of a group) affected.
#       !trill!G4
#   V: voice number     V:1     V:20
#       M:6/8
#       L:1/8
#       K:G
#       V:1
#       B3 A3 | G6 | B3 A3 | G6 ||
#       V:2
#       BdB AcA | GAG D3 | BdB AcA | GAG D6 ||
#       V:3
#       D3 D3 | D6 | D3 D3 | D6 ||
#   or:
#       M:6/8
#       L:1/8
#       K:G
#       [V:1] B3 A3 | G6 | B3 A3 | G6 ||
#       [V:2] BdB AcA | GAG D3 | BdB AcA | GAG D3 ||
#       [V:3] D3 D3 | D6 | D3 D3 | D6 ||
#   Notes played at same time, but not a chord (two voices): AB BAG & D6 |
#       The & has the two same length.
#       x draws spaces (not rests).        GAB BAG & x3 G2x
#       Normally use [] for chords.
#   ==============================================================================
#   General MIDI 1
#        24 channels/voices     Alternatively 16 melodic and 8 percussive - respond to note velocity.
#       channel 10 is percussion.
#       multiple notes on each channel (polyphony)
#       128 instruments sounds or "program" number  - program change message.
#        47 percussion sounds
#       Channel messages/controller-number: 1,7,10,11,64,100,101,121,123
#   General MIDI 2
#        32 channels
#       2 percussion channels 10/11
#     16384 variation banks - each has 128 melodic sounds. Up to individual how to use.
#         9 Drum kits
#   ------------------------------------------------------------------------------
# select chan sfont bank prog
#   000-000 Stereo Grand
#   000-001 Bright Grand
#   000-002 Electric Grand
#   000-003 Honky-Tonk
#   000-004 Tine Electric Piano
#   000-005 FM Electric Piano
#   000-006 Harpsichord
#   000-007 Clavinet
#   000-008 Celeste
#   000-009 Glockenspiel
#   000-010 Music Box
#   000-011 Vibraphone
#   000-012 Marimba
#   000-013 Xylophone
#   000-014 Tubular Bells
#   000-015 Dulcimer
#   000-016 Tonewheel Organ
#   000-017 Percussive Organ
#   000-018 Rock Organ
#   000-019 Pipe Organ
#   000-020 Reed Organ
#   000-021 Accordian
#   000-022 Harmonica
#   000-023 Bandoneon
#   000-024 Nylon Guitar
#   000-025 Steel Guitar
#   000-026 Jazz Guitar
#   000-027 Clean Guitar
#   000-028 Muted Guitar
#   000-029 Overdrive Guitar
#   000-030 Distortion Guitar
#   000-031 Guitar Harmonics
#   000-032 Acoustic Bass
#   000-033 Finger Bass
#   000-034 Pick Bass
#   000-035 Fretless Bass
#   000-036 Slap Bass 1
#   000-037 Slap Bass 2
#   000-038 Synth Bass 1
#   000-039 Synth Bass 2
#   000-040 Violin
#   000-041 Viola
#   000-042 Cello
#   000-043 Double Bass
#   000-044 Stereo Strings Trem
#   000-045 Pizzicato Strings
#   000-046 Orchestral Harp
#   000-047 Timpani
#   000-048 Stereo Strings Fast
#   000-049 Stereo Strings Slow
#   000-050 Synth Strings 1
#   000-051 Synth Strings 2
#   000-052 Concert Choir
#   000-053 Voice Oohs
#   000-054 Synth Voice
#   000-055 Orchestra Hit
#   000-056 Trumpet
#   000-057 Trombone
#   000-058 Tuba
#   000-059 Muted Trumpet
#   000-060 French Horns
#   000-061 Brass Section
#   000-062 Synth Brass 1
#   000-063 Synth Brass 2
#   000-064 Soprano Sax
#   000-065 Alto Sax
#   000-066 Tenor Sax
#   000-067 Baritone Sax
#   000-068 Oboe
#   000-069 English Horn
#   000-070 Bassoon
#   000-071 Clarinet
#   000-072 Piccolo
#   000-073 Flute
#   000-074 Recorder
#   000-075 Pan Flute
#   000-076 Bottle Blow
#   000-077 Shakuhachi
#   000-078 Irish Tin Whistle
#   000-079 Ocarina
#   000-080 Square Lead
#   000-081 Saw Lead
#   000-082 Synth Calliope
#   000-083 Chiffer Lead
#   000-084 Charang
#   000-085 Solo Vox
#   000-086 5th Saw Wave
#   000-087 Bass & Lead
#   000-088 Fantasia
#   000-089 Warm Pad
#   000-090 Polysynth
#   000-091 Space Voice
#   000-092 Bowed Glass
#   000-093 Metal Pad
#   000-094 Halo Pad
#   000-095 Sweep Pad
#   000-096 Ice Rain
#   000-097 Soundtrack
#   000-098 Crystal
#   000-099 Atmosphere
#   000-100 Brightness
#   000-101 Goblin
#   000-102 Echo Drops
#   000-103 Star Theme
#   000-104 Sitar
#   000-105 Banjo
#   000-106 Shamisen
#   000-107 Koto
#   000-108 Kalimba
#   000-109 Bagpipes
#   000-110 Fiddle
#   000-111 Shenai
#   000-112 Tinker Bell
#   000-113 Agogo
#   000-114 Steel Drums
#   000-115 Wood Block
#   000-116 Taiko Drum
#   000-117 Melodic Tom
#   000-118 Synth Drum
#   000-119 Reverse Cymbal
#   000-120 Fret Noise
#   000-121 Breath Noise
#   000-122 Seashore
#   000-123 Birds
#   000-124 Telephone 1
#   000-125 Helicopter
#   000-126 Applause
#   000-127 Gun Shot
#   001-038 Synth Bass 101
#   001-044 Mono Strings Trem
#   001-048 Mono Strings Fast
#   001-049 Mono Strings Slow
#   001-052 Concert Choir Mono
#   001-056 Trumpet 2
#   001-057 Trombone 2
#   001-059 Muted Trumpet 2
#   001-060 Solo French Horn
#   001-061 Brass Section Mono
#   001-080 Square Wave
#   001-081 Saw Wave
#   001-098 Synth Mallet
#   001-120 Cut Noise
#   001-121 Fl. Key Click
#   001-122 Rain
#   001-123 Dog
#   001-124 Telephone 2
#   001-125 Car-Engine
#   001-126 Laughing
#   001-127 Machine Gun
#   002-102 Echo Pan
#   002-120 String Slap
#   002-122 Thunder
#   002-123 Horse Gallop
#   002-124 Door Creaking
#   002-125 Car-Stop
#   002-126 Scream
#   002-127 Lasergun
#   003-122 Howling Winds
#   003-123 Bird 2
#   003-124 Door
#   003-125 Car-Pass
#   003-126 Punch
#   003-127 Explosion
#   004-122 Stream
#   004-123 Scratch
#   004-125 Car-Crash
#   004-126 Heart Beat
#   005-122 Bubbles
#   005-124 Windchime
#   005-125 Siren
#   005-126 Footsteps
#   006-125 Train
#   007-125 Jet Plane
#   008-004 Chorused Tine EP
#   008-005 Chorused FM EP
#   008-006 Coupled Harpsichord
#   008-014 Church Bells
#   008-016 Detuned Tnwl. Organ
#   008-017 Detuned Perc. Organ
#   008-019 Pipe Organ 2
#   008-021 Italian Accordian
#   008-024 Ukulele
#   008-025 12-String Guitar
#   008-026 Hawaiian Guitar
#   008-027 Chorused Clean Gt.
#   008-028 Funk Guitar
#   008-030 Feedback Guitar
#   008-031 Guitar Feedback
#   008-038 Synth Bass 3
#   008-039 Synth Bass 4
#   008-048 Orchestra Pad
#   008-050 Synth Strings 3
#   008-061 Brass Section 2
#   008-062 Synth Brass 3
#   008-063 Synth Brass 4
#   008-080 Sine Wave
#   008-081 Doctor Solo
#   008-107 Taisho Koto
#   008-115 Castanets
#   008-116 Concert Bass Drum
#   008-117 Melodic Tom 2
#   008-118 808 Tom
#   008-125 Starship
#   009-014 Carillon
#   009-125 Burst Noise
#   011-000 Piano & Str.-Fade
#   011-001 Piano & Str.-Sus
#   011-004 Tine & FM EPs
#   011-005 Piano & FM EP
#   011-008 Tinkling Bells
#   011-014 Bell Tower
#   011-038 Techno Bass
#   011-039 Pulse Bass
#   011-049 Stereo Strings Velo
#   011-050 Synth Strings 4
#   011-051 Synth Strings 5
#   011-061 Brass Section 3
#   011-078 Whistlin'
#   011-081 Sawtooth Stab
#   011-087 Doctor's Solo
#   011-088 Harpsi Pad
#   011-089 Solar Wind
#   011-096 Mystery Pad
#   011-098 Synth Chime
#   011-100 Bright Saw Stack
#   011-119 Cymbal Crash
#   011-121 Filter Snap
#   011-127 Interference
#   012-000 Bell Piano
#   012-004 Bell Tine EP
#   012-010 Christmas Bells
#   012-027 Clean Guitar 2
#   012-038 Mean Saw Bass
#   012-048 Full Orchestra
#   012-049 Mono Strings Velo
#   012-080 Square Lead 2
#   012-081 Saw Lead 2
#   012-088 Fantasia 2
#   012-089 Solar Wind 2
#   012-119 Tambourine
#   012-122 White Noise Wave
#   012-127 Shooting Star
#   013-048 Woodwind Choir
#   013-080 Square Lead 3
#   013-081 Saw Lead 3
#   013-088 Night Vision
#   016-025 Mandolin
#   120-000 Standard Drums
#   120-001 Standard 2 Drums
#   120-008 Room Drums
#   120-016 Power Drums
#   120-024 Electronic Drums
#   120-025 808/909 Drums
#   120-026 Dance Drums
#   120-032 Jazz Drums
#   120-040 Brush Drums
#   120-048 Orchestral Perc.
#   120-056 SFX Kit
#   128-000 Standard
#   128-001 Standard 2
#   128-008 Room
#   128-016 Power
#   128-024 Electronic
#   128-025 808/909
#   128-026 Dance
#   128-032 Jazz
#   128-040 Brush
#   128-048 Orchestral
#   128-056 SFX
#   ------------------------------------------------------------------------------
#   Put in a V: section.
#   %%MIDI program 1 % Acoustic Grand Piano
#   Piano
#       0 Acoustic Grand Piano
#       1 Bright Acoustic Piano
#       2 Electric Grand Piano
#       3 Honky-tonk Piano
#       4 Electric Piano 1
#       5 Electric Piano 2
#       6 Harpsichord
#       7 Clavi
#   Chromatic Percussion
#       8 Celesta
#       9 Glockenspiel
#       10 Music Box
#       11 Vibraphone
#       12 Marimba
#       13 Xylophone
#       14 Tubular Bells
#       15 Dulcimer
#   Organ
#       16 Drawbar Organ
#       17 Percussive Organ
#       18 Rock Organ
#       19 Church Organ
#       20 Reed Organ
#       21 Accordion
#       22 Harmonica
#       23 Tango Accordion
#   Guitar
#       24 Acoustic Guitar (nylon)
#       25 Acoustic Guitar (steel)
#       26 Electric Guitar (jazz)
#       27 Electric Guitar (clean)
#       28 Electric Guitar (muted)
#       29 Overdriven Guitar
#       30 Distortion Guitar
#       31 Guitar Harmonics
#   Bass
#       32 Acoustic Bass
#       33 Electric Bass (finger)
#       34 Electric Bass (pick)
#       35 Fretless Bass
#       36 Slap Bass 1
#       37 Slap Bass 2
#       38 Synth Bass 1
#       39 Synth Bass 2
#   Strings
#       40 Violin
#       41 Viola
#       42 Cello
#       43 Contrabass
#       44 Tremolo Strings
#       45 Pizzicato Strings
#       46 Orchestral Harp
#       47 Timpani
#   Ensemble
#       48 String Ensemble 1
#       49 String Ensemble 2
#       50 Synth Strings 1
#       51 Synth Strings 2
#       52 Choir Aahs
#       53 Voice Oohs
#       54 Synth Voice
#       55 Orchestra Hit
#   Brass
#       56 Trumpet
#       57 Trombone
#       58 Tuba
#       59 Muted Trumpet
#       60 French Horn
#       61 Brass Section
#       62 Synth Brass 1
#       63 Synth Brass 2
#   Reed
#       64 Soprano Sax
#       65 Alto Sax
#       66 Tenor Sax
#       67 Baritone Sax
#       68 Oboe
#       69 English Horn
#       70 Bassoon
#       71 Clarinet
#   Pipe
#       72 Piccolo
#       73 Flute
#       74 Recorder
#       75 Pan Flute
#       76 Blown bottle
#       77 Shakuhachi
#       78 Whistle
#       79 Ocarina
#   Synth Lead
#       80 Lead 1 (square)
#       81 Lead 2 (sawtooth)
#       82 Lead 3 (calliope)
#       83 Lead 4 (chiff)
#       84 Lead 5 (charang)
#       85 Lead 6 (voice)
#       86 Lead 7 (fifths)
#       87 Lead 8 (bass + lead)
#   Synth Pad
#       88 Pad 1 (new age)
#       89 Pad 2 (warm)
#       90 Pad 3 (polysynth)
#       91 Pad 4 (choir)
#       92 Pad 5 (bowed)
#       93 Pad 6 (metallic)
#       94 Pad 7 (halo)
#       95 Pad 8 (sweep)
#   Synth Effects
#       96 FX 1 (rain)
#       97 FX 2 (soundtrack)
#       98 FX 3 (crystal)
#       99 FX 4 (atmosphere)
#       100 FX 5 (brightness)
#       101 FX 6 (goblins)
#       102 FX 7 (echoes)
#       103 FX 8 (sci-fi)
#   Ethnic
#       104 Sitar
#       105 Banjo
#       106 Shamisen
#       107 Koto
#       108 Kalimba
#       109 Bag pipe
#       110 Fiddle
#       111 Shanai
#   Percussive
#       112 Tinkle Bell
#       113 Agogo
#       114 Steel Drums
#       115 Woodblock
#       116 Taiko Drum
#       117 Melodic Tom
#       118 Synth Drum
#       119 Reverse Cymbal
#   Sound effects
#       120 Guitar Fret Noise
#       121 Breath Noise
#       122 Seashore
#       123 Bird Tweet
#       124 Telephone Ring
#       125 Helicopter
#       126 Applause
#       127 Gunshot
# ----------------------------------------------------------------------------
# timidity      000_Acoustic_Grand_Piano.pat
# timidity      001_Acoustic_Brite_Piano.pat
# timidity      002_Electric_Grand_Piano.pat
# timidity      004_Electric_Piano_1_Rhodes.pat
# timidity      005_Electric_Piano_2_Chorused_Yamaha_DX.pat
# timidity      006_Harpsichord.pat
# timidity      007_Clavinet.pat
# timidity      008_Celesta.pat
# timidity      009_Glockenspiel.pat
# timidity      013_Xylophone.pat
# timidity      014_Tubular_Bells.pat
# timidity      015_Dulcimer.pat
# timidity      016_Hammond_Organ.pat
# timidity      019_Church_Organ.pat
# timidity      021_Accordion.pat
# timidity      023_Tango_Accordion.pat
# timidity      024_Nylon_Guitar.pat
# timidity      025_Steel_Guitar.pat
# timidity      026_Jazz_Guitar.pat
# timidity      027_Clean_Electric_Guitar.pat
# timidity      028_Muted_Electric_Guitar.pat
# timidity      029_Overdriven_Guitar.pat
# timidity      030_Distortion_Guitar.pat
# timidity      032_Acoustic_Bass.pat
# timidity      033_Finger_Bass.pat
# timidity      034_Pick_Bass.pat
# timidity      035_Fretless_Bass.pat
# timidity      036_Slap_Bass_1.pat
# timidity      037_Slap_Bass_2.pat
# timidity      038_Synth_Bass_1.pat
# timidity      040_Violin.pat
# timidity      042_Cello.pat
# timidity      044_Tremolo_Strings.pat
# timidity      045_Pizzicato_Strings.pat
# timidity      046_Harp.pat
# timidity      047_Timpani.pat
# timidity      048_String_Ensemble_1_Marcato.pat
# timidity      053_Voice_Oohs.pat
# timidity      056_Trumpet.pat
# timidity      057_Trombone.pat
# timidity      058_Tuba.pat
# timidity      059_Muted_Trumpet.pat
# timidity      060_French_Horn.pat
# timidity      061_Brass_Section.pat
# timidity      064_Soprano_Sax.pat
# timidity      065_Alto_Sax.pat
# timidity      066_Tenor_Sax.pat
# timidity      067_Baritone_Sax.pat
# timidity      068_Oboe.pat
# timidity      069_English_Horn.pat
# timidity      070_Bassoon.pat
# timidity      071_Clarinet.pat
# timidity      072_Piccolo.pat
# timidity      073_Flute.pat
# timidity      074_Recorder.pat
# timidity      075_Pan_Flute.pat
# timidity      076_Bottle_Blow.pat
# timidity      079_Ocarina.pat
# timidity      080_Square_Wave.pat
# timidity      084_Charang.pat
# timidity      088_New_Age.pat
# timidity      094_Halo_Pad.pat
# timidity      095_Sweep_Pad.pat
# timidity      098_Crystal.pat
# timidity      101_Goblins--Unicorn.pat
# timidity      102_Echo_Voice.pat
# timidity      104_Sitar.pat
# timidity      114_Steel_Drums.pat
# timidity      115_Wood_Block.pat
# timidity      120_Guitar_Fret_Noise.pat
# timidity      122_Seashore.pat
# timidity      125_Helicopter.pat
# ----------------------------------------------------------------------------
# (Channel 10) MIDI Key Drum Sound
# 35 Acoustic Bass Drum
# 36 Bass Drum 1
# 37 Side Stick
# 38 Acoustic Snare
# 39 Hand Clap
# 40 Electric Snare
# 41 Low Floor Tom
# 42 Closed Hi Hat
# 43 High Floor Tom
# 44 Pedal Hi-Hat
# 45 Low Tom
# 46 Open Hi-Hat
# 47 Low-Mid Tom
# 48 Hi Mid Tom
# 49 Crash Cymbal 1
# 50 High Tom
# 51 Ride Cymbal 1
# 52 Chinese Cymbal
# 53 Ride Bell
# 54 Tambourine
# 55 Splash Cymbal
# 56 Cowbell
# 57 Crash Cymbal 2
# 58 Vibraslap
# 59 Ride Cymbal 2
# 60 Hi Bongo
# 61 Low Bongo
# 62 Mute Hi Conga
# 63 Open Hi Conga
# 64 Low Conga
# 65 High Timbale
# 66 Low Timbale
# 67 High Agogo
# 68 Low Agogo
# 69 Cabasa
# 70 Maracas
# 71 Short Whistle
# 72 Long Whistle
# 73 Short Guiro
# 74 Long Guiro
# 75 Claves
# 76 Hi Wood Block
# 77 Low Wood Block
# 78 Mute Cuica
# 79 Open Cuica
# 80 Mute Triangle
# 81 Open Triangle
# ----------------------------------------------------------------------------
# CC values have a range from 0-127, from minimum to maximum value. However, some parameters are (on/off), where 0 to 63 = Off, 64 to 127 = On.
# Most Common Parameters:
#     1 = Modulation wheel
#     2 = Breath Control
#     7 = Volume
#     10 = Pan
#     11 = Expression
#     64 = Sustain Pedal (on/off)
#     65 = Portamento (on/off)
#     71 = Resonance (filter)
#     74 = Frequency Cutoff (filter)
#
# NOTE: There is no standard CC value for Vibrato Amount or Vibrato Speed. Sometimes you can assign them (and other CC mappings) yourself in the software instrument you use.
# Complete List:
#     0 Bank Select (MSB)
#     1 Modulation Wheel
# x   2 Breath controller
# x   3 = Undefined
# x   4 Foot Pedal (MSB)
#     5 Portamento Time (MSB)
#     6 Data Entry (MSB)
#     7 Volume (MSB)
# x   8 Balance (MSB
#     9 = Undefined
#     10 Pan position (MSB)
#     11 Expression (MSB)
# x   12 Effect Control 1 (MSB)
# x   13 Effect Control 2 (MSB)
# x   14 = Undefined
# x   15 = Undefined
# x   16-19 = General Purpose
# x   20-31 = Undefined
# x   32-63 = Controller 0-31
#     64 Hold Pedal (on/off)
#     65 Portamento (on/off)
#     66 Sostenuto Pedal (on/off)
#     67 Soft Pedal (on/off)
#     68 Legato Pedal (on/off)
# x   69 Hold 2 Pedal (on/off)
# x   70 Sound Variation
# x   71 Resonance (Timbre)
# x   72 Sound Release Time
# x   73 Sound Attack Time
# x   74 Frequency Cutoff (Brightness)
# x   75 Sound Control 6
# x   76 Sound Control 7
# x   77 Sound Control 8
# x   78 Sound Control 9
# x   79 Sound Control 10
# x   80 Decay or General Purpose Button 1 (on/off) Roland Tone level 1
# x   81 Hi Pass Filter Frequency or General Purpose Button 2 (on/off) Roland Tone level 2
# x   82 General Purpose Button 3 (on/off) Roland Tone level 3
# x   83 General Purpose Button 4 (on/off) Roland Tone level 4
#     84 Portamento Amount
# x   85-90 = Undefined
#     91 Reverb Level
# x   92 Tremolo Level
#     93 Chorus Level
# x   94 Detune Level
# x   95 Phaser Level
# x   96 Data Button increment
# x   97 Data Button decrement
#     98 Non-registered Parameter (LSB)
#     99 Non-registered Parameter (MSB)
#     100 Registered Parameter (LSB)
#     101 Registered Parameter (MSB)
# x   102-119 = Undefined
#     120 All Sound Off
#     121 All Controllers Off
# x   122 Local Keyboard (on/off)
#     123 All Notes Off
#     124 Omni Mode Off
#     125 Omni Mode On
#     126 Mono Operation
#     127 Poly Mode
# ----------------------------------------------------------------------------
