#!/usr/bin/python3 -B
# ----------------------------------------------------------------------------
# vim: tabstop=8 expandtab shiftwidth=4 softtabstop=4
# ----------------------------------------------------------------------------
# These are interesting. If last_voice_staff being used with getting notes ... all oct/time set.
# When selecting them, what to do with ones that differ ... . Warn, and take first?
# * oct[voice]
# * time[voice]             -- chords? trill's, sequence.
#       decode's need changing for time[]
#
#   acc_m[voice]
#   acc_m_xpose[voice]
#   xpose_new_key[voice]
#   xpose[voice]
#
#   cresc_time[voice]
#   cresc_volume[voice]
#   cresc_direction[voice]
# ----------------------------------------------------------------------------
# This is for length of notes in voice after a measure. What to do for staves?
#   tlth = { voice : 0 }                    # 60ths of a second in a voice -- nothing in measure working on.
# ----------------------------------------------------------------------------
#   vl[voice][m]
#   running_vl[voice][m]
#   mlth[voice][m]
# ----------------------------------------------------------------------------
#   bufs[voice][m]
#   bufs_intensity[voice][m]
#   bufs_legato_next[voice][m]
#   bufs_length[voice][m]
#   bufs_suffixes[voice][m]
#   bufs_tie_next[voice][m]
#   bufs_velocity[voice][m]
#   bufs_vol[voice][m]
# ----------------------------------------------------------------------------
#   clef[voice][m]
#   vinstrument[voice][m]
#   reverb[voice][m]
#   pan[voice][m]
#   intensity[voice][m]
# ----------------------------------------------------------------------------
# midi only?
# ? inst[voice]
# ----------------------------------------------------------------------------
# Variables to do - NOTDONEYET:
#       accent, aaccent, arp, fermata, ferma, stac, marc
# ----------------------------------------------------------------------------
# TO DO:
# 1) vol(sf,0.25)    -- optional 2nd argument for length of sf.
#    vol(fp,0.25)    -- optional 2nd argument for length of "f" before returning to "p".
# 2) b-6 ... some 1/2 notes that are vol(sf) -- should they be shortened per above?
# 3) --fluidsynth input of a .csv file -- MIDI_port commands -- WTF?
# 4) vol(sfp) -- how long for s and then switching to p? Example tied whole note over 3 measures.
# 5) ppppp and fffff as lilypond.
# 6) lilypond output for printing.
# ----------------------------------------------------------------------------
# TO DO:
# 1) Select clef=treble or clef=bass by notes min and max notes on staff/staves.
#       # NOTDONEYET - add ' clef=bass'  (after the number)
#       # clef can occur each measure (abc, horizontal, vertical format).
# 2) --vertical and --horizontal: Can save comments on measures? Lines? Like before measures? * ------
# 3) -- accelerando/ritard -- basically tempo change over time.
#       My idea is to speed up over time -- perhaps by calculating it each time reference in --fs or --midi.
#       Specify it as 3rd argument to tempo -- as IMS does? (i.e. acc/rit)
# ----------------------------------------------------------------------------
# TO DO: Need to put out intensity values when they change. (Like cc 11 -> vol(xx).)
#   a) > Accent over a note.
#       ABC notation:   !>!                    accent (> mark)
#                       !accent!               same as !>!
#                       !emphasis!             same as !>!
#       L       accent or emphasis - shorthand for !>!
#   b) ^ Marcato over note.
#       ABC notation:   !^!                    marcato (inverted V)
#                       !marcato!              same as !^!
#   c) _ Tenuto over note.
#       !tenuto!        tenuto (hold note for full duration)
#   d) fermata over note.
#       ABC notation:   !fermata!               Fermata, or hold
#       H       fermata - shorthand for !fermata!
#
# Articulation marks.
#   Staccato    Period (.) over note.
# This indicates that the note should be played shorter than notated, usually half the value,
# leaving the rest of the metric value silent. Staccato marks may appear on notes of any value,
# shortening their performed duration without speeding up the music.
#
#  Filled in v over note -  Staccatissimo or Spiccato
# This indicates that the note should be played even shorter than staccato. It is usually
# applied to quarter notes or shorter notes. In the past this marking's meaning was more
# ambiguous it was sometimes used interchangeably with staccato and sometimes indicated
# an accent and not a shortened note. These usages are now almost defunct but still appear
# in some scores. For string instruments this indicates a bowing technique in which the
# bow bounces lightly upon the string.
#
#   Tenuto              - Line over note.
# This symbol indicates that the note should be played at its full value, or slightly
# longer. It can also indicate a degree of emphasis, especially when combined with dynamic
# markings to indicate a change in loudness, or combined with a staccato dot to indicate a
# slight detachment (portato or mezzo staccato). In percussion notation, this sign
# indicates a slight accent.
#
#   Fermata or Pause    - top 1/2 of circle over a period
# A fermata indicates that a note, chord, or rest is sustained longer than its written
# value. It will usually appear on all parts in an ensemble. The fermata is held for as
# long as the performer or conductor desires.
#
#   Accent              > over note.
# An accent indicates that a note should be played louder, or with a harder attack than
# surrounding unaccented notes. It may appear on notes of any duration.
#
#   Marcato             ^ over note.
# A marcato marking indicates that the note should be played louder or more forcefully than
# a note with a regular accent mark. In organ notation, this sign often does not indicate
# marcato when in the pedal staff otherwise it still does, but instead that a pedal note
# should be played with the toe. When printed above the note it indicates the right foot's
# toe, and below the note indicates the left foot's toe.
# ----------------------------------------------------------------------------
# Document: trills, legato on time means last note is legato.
# If no l on time, last note is unset if legato on note itself.
# i.e. t(3cl,3el,8)4   -> last 3e does not have legato set.
#      t(3cl,3el,8)4l  -> last 3e has legato set (which goes to next note).
# ----------------------------------------------------------------------------
# ./musicomp --midi1csv song.gcs song.csv   # Output midi1csv format.
# ./musicomp song.gcs song.abc              # Output ABC format.
# ./musicomp --vertical song.gcs song.v     # Either v or h (or mixed) input, vertical output.
# ./musicomp --horizontal song.gcs song.h   # Either v or h (or mixed) input, horizontal output.
# ./musicomp --fluidsynth song.gcs song.fs  # Input to fluidsynth.
# ./musicomp --fluidsynth song.csv song.fs  # Input can be CSV file, output can ONLY be fluidsynth.
# ----------------------------------------------------------------------------
# NOTDONEYET - Note processing:
#   print_error("NOTDONEYET - doing gsw_operand type of note", line)    - Not related to MIDI.
#   print_error("NOTDONEYET - do_temper", line)     -- no real need for this?
#   print_error("NOTDONEYET - do_sharp", line)      -- no real need for this?
#   print_error("NOTDONEYET - do_flat", line)       -- no real need for this?
#   print_error("NOTDONEYET - do_natural", line)    -- no real need for this?
# ----------------------------------------------------------------------------
# Note: Do not have blank lines in the file. Somehow python's readline() does
# not return them. Yeah, insanity.
# ----------------------------------------------------------------------------
# --fluidsynth.  2022-06-06
# MIDI channel is limited to 4 bits. 10 is reserved for drums.
# Thus, cannot have more than 0,1,2,3,4,5,6,7,8,9,11,12,13,14,15 (total 15).
# Cannot use the MIDI file format. MIDI 2.0 has no file format yet.
# ----------------------------------------------------------------------------
# A) To import an ABC into musescore, use the plugin "ABC Import".
#    Move "X:1" to the top of the file, before any other lines. The '%' confuses it.
# ----------------------------------------------------------------------------
# B) To export from musescore:
#     1) File->Export as MusicXML compressed (suffix .mxl).
#     2) Then use program 'xml2abc my.mxl > my.abc' to convert it to abc format.
# ----------------------------------------------------------------------------
# For youtube you need a video.
#       You need a .wav first.
#       You cannot get a .wav from fluidsynth input mode.
#       Thus capture audio via soundflower. OR blackhole.
# B) To grab from Blackhole. (Install it already. Reboot not needed.)
#     1) Open Preferences, then select Sound.
#     2) Select Output as BlackHole 2ch.
#     3) Recommend setting Sound Effects through External Headphones or Mac's default speakers.
#     4) Open audacity.
#        a) Audio Setup
#           A) Playback Device -> headphones or internal speakers.
#           B) Recording Device -> Blackhole 2ch.
#           C) Recording Channels -> 2 (Stereo) Recording Channels
#        b) Select Record to start.
#        c) Start fluidsynth playing.
#        d) When finished, press Record again to stop it.
#        e) Trim beginning and end of recording. (Command-X to cut ... if it works...)
#        f) Select everything, Command-A. Menu: Effect->Volume and Compression->Amplify
#           Amplification (dB): 7.042
#           Apply.
#        g) Save project (in case you need it again).
#        h) File -> Export -> Export as WAV.
#        i) Go to iMovie ("Convert .wav file to mp4) - below.
# C) To grab from soundflower:
#     1) Make sure it is downloaded.
#     2) In "sound preferences->Output", select "Soundflower (2ch)".
#        Undo by selecting Headphones or Internal Speakers, etc.
#     3) Capture output via: QuickTime Player (or garageband -- dunno about last :) ).
#     4) New->Audio Audio Recording
#     5) Red record button when ready to record.
#     6) sleep 5; fluidsynth ...
#        Or: Open music playing program, and ready to "Start".
#     7) Click to get into quicktime, then press record.
#     8) click back to window for playing, start it.
#     9) When finished, click on quicktime and press record button again to stop it.
#        The "<<  >  >>" for playing it opens up.
#     10) If you save it, it saves it as a .aifc file. If you "Export as audio" it, it is an .m4a type file.
# Convert to .wav file.
#     1) Start audacity. File->Open ... select file of type: (aifc,m4a,wav, ...).
#     2) Select blank starting to delete. Press sissors to cut away. Same with trailing/end of song.
#     3) Export as ... many types may be chosen.
# Convert .wav (etc.) file to mp4.
#     1) Open imovie. Should/might be on "My Media" (left column, top).
#     2) In lower left column (bottom, or iMovie Library), right click and select 'New Event'.
#     3) Enter name. Click on the name (if not already there).
#     4) Click on down arrow with label "Import Media". Opens new window to find/select media.
#     5) Find the audio to be used.
#     6) Drag and drop the picture to be used during play.
#     7) There will be two icons for audio and picture in the Media section.
#     8) Click on audio icon and drag it to the lower 1/2 of screen where it says to put them there. :)
#     9) Align the audio to the left.
#     10) Click on the picture icon and drag to lower, align to left.
#     11) A "drag bar" on right, drag it to end of audio. (So image displays for all of audio.)
#     12) In the upper right there is an arrow above/through a box -- meaning share if you hover over it.
#     13) Click and select "Export File". The Format should be "Video and Audio".
#     14) Probably reduce Resolution to 540, quality "Best (ProRes)", and Compress "Better Quality".
#     15) Click "Next..." at bottom right. Select name and where to store it. Do so.
#     16) There is a clock timer just to the left of the box with the uparrow. When it is filled in white... .
#     17) Done. Double click on file in Finder and QuickTime player will pop up to play it.
#     18) Can upload to youtube / facebook / dropbox now.
# ----------------------------------------------------------------------------
# measures and gotos may be calculations using "m1" type variables, but not
# any other alphanumeric characters.
# Character variables and ARGUMENTS to macros must be at start of token. May
# have characters after the variable ... like X:  Xa X16 X
# ----------------------------------------------------------------------------
# Accidentals - A tied note doesn't cause the accidental to be carried over so
# much as it indicates the duration of the note rather than the pitch. If a tied
# note is followed by another note on the same staff position the accidental
# will not carry into that note (a courtesy accidental would often be helpful).
#
# In most cases, a sharp raises the pitch of a note one semitone while a flat lowers
# it one semitone. A natural is used to cancel the effect of a flat or sharp. This
# system of accidentals operates in conjunction with the key signature, whose effect
# continues throughout an entire piece, unless canceled by another key signature.
# An accidental can also be used to cancel a previous accidental or reinstate the flats
# or sharps of the key signature.
#
# Accidentals apply to subsequent notes on the same staff position for the remainder
# of the measure where they occur, unless explicitly changed by another accidental.
# Once a barline is passed, the effect of the accidental ends, except when a note
# affected by an accidental is tied to the same note across a barline. Subsequent notes
# at the same staff position in the second or later bars are not affected by the
# accidental carried through with the tied note. NOTE: Octaves are independent.
# ............................................................................
# Courtesy accidentals - In modern scores, a barline cancels an accidental,
# with the exception of tied notes. Courtesy accidentals, also called cautionary
# accidentals or reminder accidentals are used to remind the musician of the
# correct pitch if the same note occurs in the following measure. The rules for
# applying courtesy accidentals (sometimes enclosed in parentheses) vary among
# publishers, though in a few situations they are customary:
#  - When the first note of a measure had an accidental in the previous measure.
#  - After a tie carries an accidental across a barline, and the same note
#    appears in the next measure.
#  - When a chord contains a diminished or augmented octave.
#  - When there is a cross relation with another part.
# ............................................................................
# While ties and phrasing slurs do look very similar, they are not the same thing at all.
# If the curved line is below the noteheads (written closest to the noteheads)
# and opposite the stems (if stems are ascending, the curved tie line is below;
# if stems are descending, the curved tie line is above).
#
# While the bar line cancels an accidental, the "Power of the Tie" is stronger.
#
#  - The composer would put a natural/flat/sharp on the second note of the tie.
#  - The composer would put the curved line above the stems, thus on OPPOSITE
#    side of the noteheads.
# (Remember - a curved line written closest to 2 noteheads in the same space or
# on the same line is a tie!)
# ----------------------------------------------------------------------------
# Additional note processing:
# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
# If the file format is in 'vertical' mode (i.e. 'v4: 3c8,3d8,3e8, 3f8,3g8'),
# Then for --abc format, the comma followed by a space means to separate the
# bars. (i.e. c,d,e have bar lines connected, and then there is a separation
# and lastly f and g have their bar lines connected.)
# This does not affect playing at all.
# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
# If a note's time (which may be optionally missing) is followed by a "l",
# then the note is legato (glided) to the next note. (i.e. there is no note
# attack section done when playing the note -- also considered slurred notes.)
# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
# vol(xxx) before a note sets volume for that note, and following notes ... .
# vol(sfp) before a note sets volume to f for that note only, and following p.
#   vol(p) 3c4, 3d4, vol(sfp) 3e4, 3f4, 3g4
#   (p,p,f,p,p)
# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
# cresc(xxx,yyy) xxx = ending volume. yyy = time (0.75 = three quarter notes).
# dimin(xxx,yyy) xxx = ending volume. yyy = time (0.75 = three quarter notes).
#   Like vol(), but does a volume change from present to xxx over time yyy.
# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
# Macro substitution is done for the first non-space item -- when looking for
# commands. Arguments to a command are NOT looked at for macros.
# Note lines have every argument looked at for possible macro processing.
# An argument of a command or macro are NOT looked at for macros.
# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
# Macro substitution during note processing.
# A line that looks like notes may use the macro whenever a complete note or
# vol(), cresc(),dimin() may appear. Example follows:
#   macro   abc,A,B,C
#      A4, B4
#      A8, C8
#   endm
#   measure 1
#   voice 2
#   0e4, 0g4
#   vol(ff) abc(1c,1e,1g) abc(2e,2c,2g) 3g4, vol(sf) 3a4
#
# The whole line is processed, left to right -- with the new lines from the
# macro inserted into place. NOTE: The "vol(ff)" refers to the next note in the
# line, but there is none, so it is tossed away. *NOTE*
#
# The first abc macro is done, then the second, then the two trailing notes.
# Correctly formatted line would have put the vol(ff) before the 3g4 (which
# would affect that note and subsequent for voice 1, but not the 2nd voice 3a4.
# vol(sf) affects the 3a4 and puts volume back to what it was before the "sf".
#
# This shows that no deliminators are used in substitution of arguments (all
# macros), and that intermixing of vertical 'v#:' format and horizontal format
# is allowed. Convert all to one type or the other via command line arguments:
# --horizontal or --vertical. (And it deletes macros too..., which may be useful
# when trying to figure out what a macro really did.)
#
#
# The above would then look like either:
#   measure 1
#   voice   2    0,0
#   v1: 0e4, 1c4, 1c8, 2e4, 2e8, 3g4
#   v2: 0g4, 1e4, 1g8, 2c4, 2g8, vol(sf) 3a4
# or:
#   voice   2    0,0
#      0e  4,  0g  4
#      1c  4,  1e  4
#      1c  8,  1g  8
#      2e  4,  2c  4
#      2e  8,  2g  8
#      3g  4,vol(sf) 3a  4
#
# If the second abc macro had been after 3g4, then there would be no second
# note for either 3g4 line (but comma would put in a r4 -- but the 3a4 would
# have been for voice 1 and without a second note for second voice, error!
#
#   vol(ff) abc(1c,1e,1g) 3g4, abc(2e,2c,2g) vol(sf) 3a4
#
# ./musicomp2abc --vert tv
#   ERROR - Not enough arguments on note line - want 2, have ['vol(sf)3a4']
#   Line 8 - vol(sf)3a4
#
# This shows that if not a command, spaces are eliminated for note processing.
# By the way, the arguments on the voice line for for instruments, 0=default.
# ----------------------------------------------------------------------------
# putd substitution lines are done in the order that they are defined. Once
# through the list, but only if '=' at start of line.
# ----------------------------------------------------------------------------
# xpose command is done for --vertical, --horizontal, and --midi1csv, but NOT abc format.
# ABC format thus will "print" right, but not "play" (abc2midi) right.
#       NOTDONEYET - so ABC format can print. NOTDONEYET - abc #
# ----------------------------------------------------------------------------
# instrument 1,2 flute            $$ voice, name or number.
#                                     v-- MIDI control number.
# intensity  1,2 84               $$  7 volume
# pan        1,2 8                $$ 10 pan
# reverb     1,2 52               $$ 91 Reverb level
# ----------------------------------------------------------------------------
#  10   Pan position   64 is center, 0 is hard left, and 127 is hard right.
#  Number: 10 (coarse) 42 (fine)
# Where within the stereo field the device's sound will be placed (assuming that it
# has stereo audio outputs). If a MultiTimbral device, then each Part usually has
# its own pan position. This is generally when Pan becomes useful, because then you
# can use Pan, Volume, and Balance controllers to internally mix all of the Parts to
# the device's stereo outputs. Pan should effect all notes on the channel, including
# notes that were triggered prior to pan message being received, and are still sustaining.
# 14-bit coarse/fine resolution. 16,384 possible positions, 0x0000 to 0x3FFF where 0x2000
# is center position, 0x0000 is hard left, and 0x3FFF is hard right. Some devices only
# respond to coarse adjust (128 positions) where 64 is center, 0 is hard left, and 127 is hard right.
# Note: Most all devices ignore the Fine adjust (#42) for Pan, and just implement Coarse
# adjust (#10) because 14-bit resolution isn't needed for this.
# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
# Expression, number 11 (course)
# Percentage of all playing instruments volume. 100% = all up.
# This is a percentage of Volume (ie, as set by Volume Controller). In other words,
# Expression divides the current volume into 16,384 steps (or 128 if 8-bit instead
# of 14-bit resolution is used). Volume Controller is used to set the overall volume
# of the entire musical part (on a given channel), whereas Expression is used for
# doing crescendos and decrescendos. By having both a master Volume and sub-Volume
# (ie, Expression), it makes possible to do crescendos and decrescendos without
# having to do algebraic calculations to maintain the relative balance between
# instruments. When Expression is at 100% (ie, the maximum of 0x3FFF), then the
# volume represents the true setting of Volume Controller. Lower values of
# Expression begin to subtract from the volume. When Expression is 0% (ie, 0x0000),
# then volume is off. When Expression is 50% (ie, 0x1FFF), then volume is cut in half.
#
# Here's how Expression is typically used. Let's assume only the coarse adjust is
# used (ie, #11) and therefore only 128 steps are possible. Set the Expression for
# every MIDI channel to one initial value, for example 100. This gives you some
# leeway to increase the expression percentage (ie, up to 127 which is 100%) or
# decrease it. Now, set the channel (ie, instrument) "mix" using Volume Controllers.
# Maybe you'll want the drums louder than the piano, so the former has a Volume
# Controller value of 110 whereas the latter has a value of 90, for example. Now if,
# at some point, you want to drop the volumes of both instruments to half of their
# current Main Volumes, then send Expression values of 64 (ie, 64 represents a 50%
# volume percentage since 64 is half of 128 steps). This would result in the drums
# now having an effective volume of 55 and piano having an effective volume of 45.
# If you wanted to drop the volumes to 25% of their current Main Volumes, then send
# Expression values of 32. This would result in the drums now having an effective
# volume of approximately 27 and piano having an effective volume of approximately
# 22. And yet, you haven't had to change their Volume settings, and therefore still
# maintain that relative mix between two instruments. So think of Volume Controllers
# as being the individual faders upon a mixing console. You set up the instrumental
# balance (ie, mix) using these values. Then you use Expression Controllers as
# "group faders", whereby you can increase or decrease the volumes of one or more
# tracks without upsetting the relative balance between them.
# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
# Can use legato for slur between notes -- i.e. no attack.
# Legato Pedal, Number: 68
# When on, this causes a legato effect between notes, which is usually achieved by
# skipping the attack portion of the VCA's envelope. Use of this controller allows
# a keyboard player to better simulate the phrasing of wind and brass players, who
# often play several notes with a single tonguing, or simulate guitar pull-offs and
# hammer-ons (ie, where secondary notes are not picked). If a MultiTimbral device,
# then each Part usually has its own Legato Pedal setting.
# Value Range: 0 (to 63) is off. 127 (to 64) is on.
# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
#  91   Reverb Level - Affects: this is usually the reverb or delay level.
#       If a MultiTimbral device, then each Part usually has its own effects level.
# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
# Tremulo Level, Number: 92
# The tremulo amount (ie, level) for the device. If a MultiTimbral device, then each
# part usually has its own tremulo level.
# Value Range: 0 to 127, with 0 being no tremulo applied at all.
# ----------------------------------------------------------------------------
# Note: New addition: second arguments on "voice" command is MIDI instruments.
# Suggest using instrument command instead.
#   %%MIDI program 6 % Harpsichord
#   %%MIDI program 57 % Trombone
#   %%MIDI program 56 % Trumpet
#   %%MIDI program 40 % Violin
#       voice   4       57,56,40,6
# ----------------------------------------------------------------------------
# clef  bass,treble,treble,treble
# clef  G clef = treble clef. 2nd line to the bottom is G pitch above middle C. 3C=1 line below printed.
# clef  C clef = Alto and Tenor clefs. The B points to the middle 3C line.  (viola)
# clef  F clef = Bass clef. The line between the two dots (?:) is F below middle 3C. 3c=1 line above printed.
# clef  Octave clef. Has a number under the G clef. 8=1 octave, 15=2 octaves higher.
# ----------------------------------------------------------------------------
# flats -> key:     B,E,A,D,G,C,F -- always this order. 2nd to last is Key-flat.
# sharps -> key:    F,C,G,D,A,E,B -- always this order. 2nd to last key Key-sharp.
#             vv - is key to use.
# 7 sharps is C# major or A# minor. f+,c+,g+,d+,a+,e+,b+
# 6 sharps is F# major or D# minor. f+,c+,g+,d+,a+,e+
# 5 sharps is B major or G# minor.  f+,c+,g+,d+,a+
# 4 sharps is E major or C# minor.  f+,c+,g+,d+
# 3 sharps is A major or F# minor.  f+,c+,g+
# 2 sharps is D major or B minor.   f+,c+
# 1 sharp  is G major or E minor.   f+
# None     is C major or A minor.
# 1 flat   is F major or D minor.   b-
# 2 flats  is B- major or G minor.  b-,e-
# 3 flats  is E- major or C minor.  b-,e-,a-
# 4 flats  is A- major or F minor.  b-,e-,a-,d-
# 5 flats  is D- major or B- minor. b-,e-,a-,d-,g-
# 6 flats  is G- major or E- minor. b-,e-,a-,d-,g-,c-
# 7 flats  is C- major or A- minor. b-,e-,a-,d-,g-,c-,f-
# ----------------------------------------------------------------------------
# For volume levels= { 0: 'ppp', 1: 'pp', 2: 'p', 3: 'mp', 4: 'mf', 5: 'f', 6: 'ff', 7: 'fff', 8: 'ffff' }
# can use the numbers or names as above. NOTE: lower than 4 is difficult to hear.
# ----------------------------------------------------------------------------
# ABC header:
#     X: 1
#     ...
#     T: title
#     ...
#     K: C
# Empty lines separate tunes, headers (X: ... K:), and free text
# Line-breaks (new-lines, line feeds, carriage returns, end-of-lines) aids readability and breaks long lines.
#   Music code: end of lines means end of typeset sheet music score (lines). Use backslash to for continuation.
#       It continues through information fields, comments, and stylesheet directives.
# Information fields continue with +: at start of next line.
# ..............................................................................
#         V:1
#         a b cd
#     is the same as:
#         [V:1] a b cd
#     Can use [M:9/8]
# K: Key                K:G, K:Dm, K:AMix
# L: Unit Note Length   L:1/4, L:1/8
# M: Meter              M:3/4, M:4/4        Note present means free - no checking.
# Q: Tempo              Q:1/4=120       Q:1/2 1/4=120 - means dotted half note. (GRUMBLE)
# T: Title              T:Name Of Song, whatever
# V: Voice              V:4 clef=bass               <----
# W: words              W: lyrics printed after the end of the tune
# w: words              w: lyrics printed aligned with the notes of tune
# ..............................................................................
# clef's can be on V: and K: lines
#       treble  Treble          <- normal treble clef.
#       bass    Bass            <- normal bass clef.
#       bass3   Baritone
#       tenor   Tenor           <- middle c on line above alto staff.
#       alto    Alto            <- middle c on middle staff line. (normal)
#       alto2   Mezzosoprano
#       alto1   Soprano
#       perc
#       none
# ----------------------------------------------------------------------------
# Pass 1
# Need the order of the measures.
# In a measure, want everything for that measure -- so that goto it works.
# Start with measure -1, and the default setup?
# Key, volume, note length, tempo
# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
#   Rests are lowercase z. Length follows.
#   Uppercase denote bottom octave (C = middle C on treble staff).
#   Comma after the letter means down an octave.
#   Apostrophe after the letter means up an octave. Multiple ' go up, as ,'s go down.
#   Lowercase letters are next octave above uppercase. four c's: "C, C c c' "
#   ^C = C sharp. _B = B flat. ^^ = double sharp. The equals (=) naturalizes it.
# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
#   Number after note changes duration. Number times default. B2=B twice as long therefore 1/4 because 1/2.
#   / means shorten, default is 2 or "/2".
#   > after a note, multiplying by 3/2 and removing from 2nd note. I.e. c8>c8 -> c8.c16 (dot means 1/16 extra)
#   < after a note, multiplying by 1/2 and adding rest on 2nd note. I.e. c8<c8 -> c16c8. means 1/16th extra
# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
#   print("   C,,     C,   c     c'   c''   z")
#             ++      +    -    --    n     r
#   print("   ^^C,,   ^C,  _c   __c'  =c''  z")
# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
# Have to think about the time ... if using simple ... then make "L: 1/64", and do multiples via:
#   2 = 32, 3 = 32d, 4 = 16, 6 = 16d, 8 = 8, 12 = 8d, 16 = 4, 24 = 4d, 32 = 2, 48 = 2d, 64 = 1, 96 = 1d, 128=2
# Trills, grace notes, staccato, and triplets, and ... *hmmm*
# staccato = .              (3.a.b.c = triplet staccato         (before note
# T = trill
# H = fermata
# . = staccato mark
# The order of abc constructs for a note is:
# <grace notes>, <chord symbols>, <annotations>/<decorations> (e.g. Irish roll, staccato marker or up/downbow),
#    ... <accidentals>, <note>, <octave>, <note length>, i.e. ~^c'3 or even "Gm7"v.=G,2.
#                                                           irish roll, c (down one, up one),
# syntax (p:q:r which means 'put p notes into the time of q for the next r notes'. If q is not given,
# it defaults as above. If r is not given, it defaults to p.
# For example, (3 is equivalent to (3:: or (3:2 , which in turn are equivalent to (3:2:3, whereas (3::2 is
# equivalent to (3:2:2.
# This can be useful to include notes of different lengths within a tuplet, for example (3:2:2 G4c2 or
# (3:2:4 G2A2Bc. It also describes more precisely how the simple syntax works in cases like (3 D2E2F2 or even
# (3 D3EF2. The number written over the tuplet is p.
# Spaces that appear between the tuplet specifier and the following notes are to be ignored.

# tie is minus (-) between two notes.   i.e. C-C3/2
# NOTE: 3 times normal note length divided by 2.  Or C-.C2
# Each tie symbol, -, should come immediately after a note group but may be followed by a space,
# i.e. =G,2- . Open and close chord delimiters, [ and ], should enclose entire note sequences (except for
# chord symbols), e.g.

# NOTE: spaces between notes means to not connect the notes when printed.
# ----------------------------------------------------------------------------
import argparse
import os
import re
import readline
import shlex
import sys
import random
import copy
#-- import pprint
#-- # Usage:   pprint.pprint(v_t_lines, width=110, sort_dicts=False)

from fractions import Fraction

# ----------------------------------------------------------------------------
import math
# Log base 2
def Log2(x):
    x = float(x)
    if x == 0:
        return 0
    # fi
    return (math.log10(x) / math.log10(2))
# End of Log2

# ----------------------------------------------------------------------------
def print_i_line(original_line):
    global i_line
    global lmp_executing_i_line
    global lmp_executing_number

    k = None
    if lmp_executing_number > 0:
        for i in lmp_executing_i_line[lmp_executing_number] + i_line:
            j = i.rstrip()              # In case there are new-lines, etc.
            if j != k:
                print("                  - '{}'".format(j), file=sys.stderr, flush=True)
            # fi
            k = j
        # rof
    else:
        for i in i_line:
            j = i.rstrip()
            if j != k:
                print("                  - '{}'".format(j), file=sys.stderr, flush=True)
            # fi
            k = j
        # rof
    # fi
    original_line = original_line.rstrip()
    if k is None or original_line != k:
        print("                  - 'line:  {}'".format(original_line), file=sys.stderr, flush=True)
    # fi
    return
# End of print_i_line

# ----------------------------------------------------------------------------
def print_error(strg, original_line):
    global linecount
    global which_file_in
    global errors_happened

    errors_happened = 1             # When exiting, do 1 instead of 0

    print("ERROR -", strg, file=sys.stderr, flush=True)
    print("  File {} Line {}".format(which_file_in, linecount, original_line), file=sys.stderr, flush=True)
    print_i_line(original_line)
    return
# End of print_error

# ----------------------------------------------------------------------------
def print_warning(strg, original_line):
    global linecount
    global which_file_in

    print("WARNING -", strg, file=sys.stderr, flush=True)
    print("  File {} Line {}".format(which_file_in, linecount, original_line), file=sys.stderr, flush=True)
    print_i_line(original_line)
    return
# End of print_warning

# ----------------------------------------------------------------------------
def print_error_no_line(strg):
    print("ERROR -", strg, file=sys.stderr, flush=True)
    return
# End of print_error_no_line

# ----------------------------------------------------------------------------
def print_warning_no_line(strg):
    print("WARNING -", strg, file=sys.stderr, flush=True)
    return
# End of print_warning_no_line

# ----------------------------------------------------------------------------
def really_print_output(strg):
    global output_name

    print(strg, file=output_name, flush=True)
    return
# End of really_print_output

# ----------------------------------------------------------------------------
def print_debug(strg):
    print("DEBUG -", strg, file=sys.stderr, flush=True)
    return
# End of erint_debug

# ----------------------------------------------------------------------------
def print_output(strg):
    global args
    global array_of_lines
    global fluidsynth_done

    if not args.fluidsynth and not fluidsynth_done:
        really_print_output(strg)
    else:
        if strg == "quit":
            fluidsynth_done = True
        else:
            array_of_lines.append(strg)
        # fi
    # fi
    return
# End of print_output

# ----------------------------------------------------------------------------
def print_output_no_eol(strg):
    global output_name

    print(strg, end='', file=output_name, flush=True)
    return
# End of print_output_no_eol

# ----------------------------------------------------------------------------
import calculate

calculate.cexp_parser()                         # initialize parser

numarry_name        = calculate.numarry_name        # The name of the variable.
numarry_maclevel    = calculate.numarry_maclevel    # The macro level was in effect when created.
numarry_indexes     = calculate.numarry_indexes     # The array indexes. []=value, [3]=1-dimen, [2,4]=2-dimen.
numarry_values      = calculate.numarry_values      # Array of values ([0] for not an array).
numarry_value_type  = calculate.numarry_value_type  # Array of types None=not-set, 0=int/float, 1= character string
numarry_macro_arg   = calculate.numarry_macro_arg   # True if a macro argument. False if normal variable.

# ----------------------------------------------------------------------------
global whichmacrochars                              # Unique Macro arguments         - 0
whichmacrochars = {}
global whichlocalchars                              # Unique local character strings - 1
whichlocalchars = {}
global whicharraychars                              # Unique local arrays w/ strings - 1    - special handling.
whicharraychars = {}
# ----------------------------------------------------------------------------
def recompute_whichchars():
    global whichmacrochars                          # Unique Macro arguments         - 1
    global whichlocalchars                          # Unique local character strings - 2
    global whicharraychars                          # Unique local arrays w/ strings - 2

    n_args = {}
    n_chars = {}
    n_arraychars = {}
    for wary in calculate.local_arrays:
        nam = wary[numarry_name]
        if wary[numarry_macro_arg]:                 # A macro argument
            if nam not in n_args:
                n_args[nam] = wary                  # New argument name.
            else:
#--                 print_debug("recompute_whichchars - n_args[nam][numarry_maclevel]={} wary[numarry_maclevel]={}".format(n_args[nam][numarry_maclevel], wary[numarry_maclevel]))
                if n_args[nam][numarry_maclevel] < wary[numarry_maclevel]:
                    n_args[nam] = wary              # Newer argument name.
                # fi
            # fi
        else:                                       # Try for character string without array.
            if len(wary[numarry_indexes]) == 0:     # No array.
                k = wary[numarry_value_type][0]
                # None means not set, so could be a character variable.
                if k is not None and k == 1:        # Is character variable
                    n_chars[nam] = wary
                # fi
            else:
                for v in wary[numarry_value_type]:
                    if v is None or v == 1:
                        n_arraychars[nam] = wary    # An array character variable.
                        break
                    # fi
                # rof
            # fi
        # fi
    # rof
    n = sorted(n_args, key=len)
    n.reverse()
    whichmacrochars = {}
    for w in n:
        whichmacrochars[w] = n_args[w]
    # rof
    n = sorted(n_chars, key=len)
    n.reverse()
    whichlocalchars = {}
    for w in n:
        whichlocalchars[w] = n_chars[w]
    # rof
    n = sorted(n_arraychars, key=len)
    n.reverse()
    whicharraychars = {}
    for w in n:
        whicharraychars[w] = n_arraychars[w]
    # rof
    return
# End of recompute_whichchars

# ----------------------------------------------------------------------------
def chkvarlevel(arg, maclev):
    for wary in calculate.arrays + calculate.local_arrays:
        if arg == wary[numarry_name]:
            if wary[numarry_maclevel] == maclev:
                return False                    # Already exists.
            # fi
        # fi
    # rof
    return True
# End of chkvarlevel

# ----------------------------------------------------------------------------
def print_some_variable_values(s, varnams):
#--    printed = []
    global whichmacrochars                          # Unique Macro arguments         - 1
    global whichlocalchars                          # Unique local character strings - 2
    global whicharraychars                          # Unique local arrays w/ strings - 2
    
#--     if whichmacrochars != {}:
#--         print_debug("{}: whichmacrochars={}".format(s, whichmacrochars))
#--     # fi
#--     if whichlocalchars != {}:
#--         print_debug("{}: whichlocalchars={}".format(s, whichlocalchars))
#--     # fi
#--     if whicharraychars != {}:
#--         print_debug("{}: whicharraychars={}".format(s, whicharraychars))
#--     # fi

    for wary in calculate.local_arrays:
        name = wary[numarry_name]
        if name in varnams:
            print_debug("{}: name={:8s} ML={:1d} MA={:5s} dim={} values={} types={}".format(s, name, wary[numarry_maclevel], str(wary[numarry_macro_arg]), wary[numarry_indexes], wary[numarry_values], wary[numarry_value_type]))
#--            printed.append(wary[numarry_name])
        # fi
    # rof
#++    for v in varnams:
#++        if v not in printed:
#++            print_debug("{}: NOT FOUND - {}".format(s, v))
#++        # fi
#++    # rof
# End of print_some_variable_values

# ----------------------------------------------------------------------------
def createglobalvar(arg, val, maclev, typ, macro_argument_tf):
    if not chkvarlevel(arg, maclev):
        return False
    # fi
    wary = [ arg, maclev, [ ], [ val ], [ typ ], macro_argument_tf ]
    calculate.arrays.append(wary)
    if typ == 1:
        recompute_whichchars()
    # fi
    return True
# End of createglobalvar

# ----------------------------------------------------------------------------
def createlocalvar(arg, val, maclev, typ, macro_argument_tf):
    if not chkvarlevel(arg, maclev):
        return False
    # fi
    wary = [ arg, maclev, [ ], [ val ], [ typ ], macro_argument_tf ]
    calculate.local_arrays.append(wary)
    if typ == 1:
        recompute_whichchars()
    # fi
    return True
# End of createlocalvar

# ----------------------------------------------------------------------------
def chkvar(arg):
    maxmaclev = -1
    maxwary = None
    for wary in calculate.arrays + calculate.local_arrays:
        if arg == wary[numarry_name]:
            if wary[numarry_maclevel] > maxmaclev:
                maxmaclev = wary[numarry_maclevel]
                maxwary = wary
            # fi
        # fi
    # rof
    return maxwary
# End of chkvar

# ----------------------------------------------------------------------------
def setvar(arg, val, typ):
#?    global commands
#?
#?    if arg in commands and typ != 0:
#?        return None                 # Must not set character variable to a command name.
#?    # fi
    wary = chkvar(arg)
#--     print_debug("setvar arg={} val={} typ={} wary={}".format(arg,val,typ,wary))
    if wary is None or (len(wary[numarry_indexes]) > 1 and wary[numarry_indexes][0] > 1):
        return None                 # Does not exist.
    # fi
    wary[numarry_values][0] = val
    wary[numarry_value_type][0] = typ
    if typ == 1:
        recompute_whichchars()
    # fi
    return wary                     # Index is 0 into pointer wary.
# End of setvar

# ----------------------------------------------------------------------------
def getvar(arg):
    wary = chkvar(arg)
    if wary is None or (len(wary[numarry_indexes]) > 1 and wary[numarry_indexes][0] > 1):
        print_error_no_line("getvar - multidimensional array {} ... without dimensions - wary={}".format(arg, wary))
        abc[1] = wary
        return None
    # fi
    return wary[numarry_values][0]
# End of getval

# ----------------------------------------------------------------------------
def getvar_checkokay(arg, original_line):
    wary = chkvar(arg)
    if wary is None or (len(wary[numarry_indexes]) > 1 and wary[numarry_indexes][0] > 1):
        print_error("getvar_checkokay - multidimensional array {} ... without dimensions - wary={}".format(arg, wary), original_line)
        return None
    # fi
    return wary[numarry_values][0]
# End of getvar

# ----------------------------------------------------------------------------
def getvarmaclevel(arg, maclev):
    for wary in calculate.arrays + calculate.local_arrays:
        if arg == wary[numarry_name] and maclev == wary[numarry_maclevel]:
            return wary[numarry_values][0]
        # fi
    # rof
    return None
# End of getvarmaclevel

# ----------------------------------------------------------------------------
# True if a macro argument, else false.

def chkargvar(arg):
    wary = chkvar(arg)
    if wary is None or (len(wary[numarry_indexes]) > 1 and wary[numarry_indexes][0] > 1):
        return False
    # fi
    return wary[numarry_macro_arg]
# End of chkargvar

# ----------------------------------------------------------------------------
 # Default ancient musicomp values -- not used within this script/program. (For input files.)
createglobalvar('pause', 4, 0, 0, True)
createglobalvar('grace', 4, 0, 0, True)
createglobalvar('voice', -1, 0, 0, True)        # no voices yet.

# IMS variables
# NOTDONEYET - accent
createglobalvar('accent', 10, 0, 0, True)       # light accent
# NOTDONEYET - aaccent
createglobalvar('aaccent', 20, 0, 0, True)      # heavy accent
# NOTDONEYET - arp
createglobalvar('arp', 1/32, 0, 0, True)        # Default arpeggiation length
# NOTDONEYET - fermata
createglobalvar('fermata', 1, 0, 0, True)       # fermata
# NOTDONEYET - ferma
createglobalvar('lferm', 1, 0, 0, True)         # No fermata yet.
# NOTDONEYET - stac
createglobalvar('stac', 0.25, 0, 0, True)       # Staccato length multiplier - used to be 4, but IMS is 1/4.
# NOTDONEYET - marc
createglobalvar('marc', 0.5, 0, 0, True)        # Marcato length multipliers.
createglobalvar('time', 0, 0, 0, True)          # The "time" in measure for current voice. (staff?)

# IMS "if" variables. -1 is true
createglobalvar('print', 0, 0, 0, True)         # if compiling for printing - args.abc is true
createglobalvar('play', 0, 0, 0, True)          # if compiling for playing - args.fluidsynth or args.midi1csv
# NOTDONEYET - lime
createglobalvar('lime', 0, 0, 0, True)          # if compiling for lime (does not apply)
# NOTDONEYET - include
createglobalvar('include', 0, 0, 0, True)       # if compiling an include file (does not apply)

# New default musicomp values for debugging, etc.
createglobalvar('page', -1, 0, 0, True)         # Page number from page command.
createglobalvar('measure', -1, 0, 0, True)      # measure number from last measure command.

# Default MIDI control values.
createglobalvar('default_reverb', 0, 0, 0, True)    # No reverb.
createglobalvar('default_pan', 64, 0, 0, True)  # Center of left<->right balance.
createglobalvar('default_intensity', 100, 0, 0, True)   # Volume = intensity% * velocity% * vol(ff)%.
createglobalvar('default_velocity', 120, 0, 0, True)    # Note attack (when played. (Leave 7) Appears to be volume.

# ----------------------------------------------------------------------------
#++ import inspect
#++ print(inspect.currentframe().f_code.co_name, '#0', file=sys.stderr, flush=True)
# ----------------------------------------------------------------------------
is_float_number = 0
is_float_string = 1
# ----------------------------------------------------------------------------
MAX_LOOP_VARIABLES = 10
#-- MAX_LOOP_VARIABLES = 25
#-- MAX_LOOP_VARIABLES = 50
#-- MAX_NESTING = 50                                # Maximum number of loops + macros + processes.
MAX_NESTING = 10                                # Maximum number of loops + macros + processes.
MAX_PUTDS = 25                                  # Maximum number of putd substitutions.
# ----------------------------------------------------------------------------
MAXMIDICHANNELS = 16
# MAXABCVOICES = 32
MAXABCVOICES = 256
MAXVOICES = 256
NUMBER_BARS_PER_STAFF = 4
# NUMBER_BARS_PER_STAFF = 1
MIDICLICKSPERQUARTER = 480.0

# Let the notes 'release' after piece finishes.
#?? clicks_at_end_of_piece = 2 * MIDICLICKSPERQUARTER   # Half note.
clicks_at_end_of_piece = MIDICLICKSPERQUARTER   # Quarter note.

# For setperm and randp commands.
global array_of_random_numbers
array_of_random_numbers = [ ]

# When getting note, various things found:
sequence_note = 2
trill_note = 1
normal_note = 0

# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
global allkeys
allkeys = [ 'c', 'd', 'e', 'f', 'g', 'a', 'b',
            'cn', 'dn', 'en', 'fn', 'gn', 'an', 'bn',
            'c-', 'd-', 'e-', 'f-', 'g-', 'a-', 'b-',
            'c--', 'd--', 'e--', 'f--', 'g--', 'a--', 'b--',
            'c+', 'd+', 'e+', 'f+', 'g+', 'a+', 'b+',
            'c++', 'd++', 'e++', 'f++', 'g++', 'a++', 'b++' ]
global accidentals
accidentals = { '':'', 'n':'=', '-':'_', '+':'^', '--':'__', '++':'^^' }

global legal_notes
legal_notes =   {
       '1/64': 0.015625,
      '3/128': 0.0234375,
       '1/32': 0.03125,
       '3/64': 0.046875,
      '7/128': 0.0546875,
       '1/16': 0.0625,
       '3/32': 0.09375,
       '7/64': 0.109375,
     '15/128': 0.1171875,
        '1/8': 0.125,
       '3/16': 0.1875,
       '7/32': 0.21875,
      '15/64': 0.234375,
     '31/128': 0.2421875,
        '1/4': 0.25,
        '3/8': 0.375,
       '7/16': 0.4375,
      '15/32': 0.46875,
      '31/64': 0.484375,
     '63/128': 0.4921875,
        '1/2': 0.5,
        '3/4': 0.75,
        '7/8': 0.875,
      '15/16': 0.9375,
      '31/32': 0.96875,
      '63/64': 0.984375,
    '127/128': 0.9921875,
          '1': 1.0,
        '3/2': 1.5,
        '7/4': 1.75,
       '15/8': 1.875,
      '31/16': 1.9375,
      '63/32': 1.96875,
     '127/64': 1.984375,
    '255/128': 1.9921875,
          '2': 2.0,
          '3': 3.0,
        '7/2': 3.5,
       '15/4': 3.75,
       '31/8': 3.875,
      '63/16': 3.9375,
     '127/32': 3.96875,
     '255/64': 3.984375,
    '511/128': 3.9921875,
       }

legal_mc_notes = {
        0.015625 : '64',
       0.0234375 : '64d',
         0.03125 : '32',
        0.046875 : '32d',
          0.0625 : '16',
         0.09375 : '16d',
           0.125 : '8',
          0.1875 : '8d',
            0.25 : '4',
           0.375 : '4d',
             0.5 : '2',
            0.75 : '2d',
             1.0 : '1',
             1.5 : '1d',
}

global legal_floating
legal_floating = dict((y, x) for x, y in legal_notes.items())
global legal_floating_times
legal_floating_times = sorted(legal_notes.values())

global DECORATIONS
DECORATIONS = '+'
# - DECORATIONS = '!'

global vlprint
# 2022-08-12_15-39-03 - allow more space at low range and upper range. (Gives intensity some space.)
vlprint = {  0: 'ppppp',        # Below anything to expect.
            20: 'pppp',
            30: 'ppp',
            40: 'pp',
            50: 'p',
            60: 'mp',
            70: 'mf',
            80: 'f',
            90: 'ff',
            100: 'fff',
            110: 'ffff',
            127: 'fffff',       # Above anything to expect.
          }
global volume_level
volume_level = { 'ppppp': 0,
                 'pppp': 0,
                 'ppp': 0,
                 'pp': 1,
                 'p': 2,
                 'mp': 3,
                 'mf': 4,
                 'f': 5,
                 'ff': 6,
                 'fff': 7,
                 'ffff': 7,
                 'fffff': 7 }
global v_name_print
v_name_print = {}
for i in vlprint:
    v_name_print[ vlprint[ i ] ] = i
# rof

vs = [ 'ppppp', 'pppp', 'ppp', 'pp', 'p', 'mp', 'mf', 'f', 'ff', 'fff', 'ffff', 'fffff' ]
for i in vs:
    createglobalvar('v' + i, v_name_print[ i ], 0, 0, False)
# rof

# Huge permutation dictionary.
global S_vlprint                        # First is this note volume, 2nd is following note volumes.
S_vlprint = { 'fz':[ -4, -1 ],          # getvar('vf'), then back to what it was (like sf, crazy).
              'sfz':[ -4, -1 ],         # like sf.
              'smfz':[ -5, -1 ],        # somewhat louder louder for one note, then back to where it was.
              'smpz':[ -6, -1 ],        # somewhat louder for one note, then back to where it was.
              'spz':[ -7, -1 ],         # p then back to what it was.
              'sppz':[ -8, -1 ],        # pp then back to what it was.
              'spppz':[ -9, -1 ],       # ppp then back to what it was.
              'sppppz':[ -10, -1 ],     # pppp then back to what it was.
            }
for i in [ 'ffff', 'fff', 'ff', 'f']:
    for j in [ 'pppp', 'ppp', 'pp', 'p']:
        S_vlprint[ i + j ] = [ getvar('v' + i), getvar('v' + j)]    # First one volume, then another.
    # rof
# rof
vss = { 'sfffff': -2, 'sffff': -2, 'sfff': -2, 'sff': -3, 'sf': -4, 'smf': -5,
        'smp': -6, 'sp': -7, 'spp': -8, 'sppp': -9, 'spppp': -10, 'sppppp': -10 }
for i in vss:
    if i not in S_vlprint:
        S_vlprint[ i ] = [ vss[i], -1 ]                     # much louder for this note, then return to where it was.
    # rof
    for j in vs:
        if i + j not in S_vlprint:
            S_vlprint[ i + j ] = [ vss[i], getvar('v' + j)] # much louder for this note, then return to ...
        # fi
    # rof
# rof

# ----------------------------------------------------------------------------
def vol_to_vlprint_round(j):
    global vlprint

    if type(j) is str:
        j = float(j)
        if j.is_integer():
            j = int(j)
        # fi
    # fi
#--     print_debug("vol_to_vlprint_round - type(j)={} j='{}' vlprint='{}'".format(type(j),j,vlprint))
    for i in vlprint:
#--         print_debug("vol_to_vlprint_round - type(i)={} i='{}' vlprint='{}'".format(type(i),i,vlprint))
        if i >= j:
            return i
            break
        # fi
    # rof
    return getvar('vfff')
# End of vol_to_vlprint_round

# ------------------------------------------------------------------------------
global instruments
# select chan sfont bank prog -      prog, bank.
instruments = {
    'Acoustic Grand Piano'.lower() : [0, 0],
    'Stereo Grand'.lower() : [0, 0],
    'Bright Acoustic Piano'.lower() : [1, 0],
    'Bright Grand'.lower() : [1, 0],
    'Electric Grand Piano'.lower() : [2, 0],
    'Electric Grand'.lower() : [2, 0],
    'Honky-tonk Piano'.lower() : [3, 0],
    'Honky-tonk'.lower() : [3, 0],
    'Electric Piano 1'.lower() : [4, 0],
    'Time Electric Piano 1'.lower() : [4, 0],
    'Electric Piano 2'.lower() : [5, 0],
    'FM Electric Piano'.lower() : [5, 0],
    'Harpsichord'.lower() : [6, 0],
    'Clavi'.lower() : [7, 0],
    'Clavinet'.lower() : [7, 0],
    'Celesta'.lower() : [8, 0],
    'Glockenspiel'.lower() : [9, 0],
    'Music Box'.lower() : [10, 0],
    'Vibraphone'.lower() : [11, 0],
    'Marimba'.lower() : [12, 0],
    'Xylophone'.lower() : [13, 0],
    'Tubular Bells'.lower() : [14, 0],
    'Dulcimer'.lower() : [15, 0],
    'Drawbar Organ'.lower() : [16, 0],
    'Tonewheel Organ'.lower() : [16, 0],
    'Percussive Organ'.lower() : [17, 0],
    'Rock Organ'.lower() : [18, 0],
    'Church Organ'.lower() : [19, 0],
    'Pipe Organ'.lower() : [19, 0],
    'Reed Organ'.lower() : [20, 0],
    'Accordion'.lower() : [21, 0],
    'Harmonica'.lower() : [22, 0],
    'Tango Accordion'.lower() : [23, 0],
    'Bandoneon'.lower() : [23, 0],
    'Acoustic Guitar (nylon)'.lower() : [24, 0],
    'Nylon Guitar'.lower() : [24, 0],
    'Acoustic Guitar (steel)'.lower() : [25, 0],
    'Steel Guitar'.lower() : [25, 0],
    'Electric Guitar (jazz)'.lower() : [26, 0],
    'Jazz Guitar'.lower() : [26, 0],
    'Electric Guitar (clean)'.lower() : [27, 0],
    'Clean Guitar'.lower() : [27, 0],
    'Electric Guitar (muted)'.lower() : [28, 0],
    'Muted Guitar'.lower() : [28, 0],
    'Overdriven Guitar'.lower() : [29, 0],
    'Overdrive Guitar'.lower() : [29, 0],
    'Distortion Guitar'.lower() : [30, 0],
    'Guitar Harmonics'.lower() : [31, 0],
    'Acoustic Bass'.lower() : [32, 0],
    'Electric Bass (finger)'.lower() : [33, 0],
    'Finger Bass'.lower() : [33, 0],
    'Electric Bass (pick)'.lower() : [34, 0],
    'Pick Bass'.lower() : [34, 0],
    'Fretless Bass'.lower() : [35, 0],
    'Slap Bass 1'.lower() : [36, 0],
    'Slap Bass 2'.lower() : [37, 0],
    'Synth Bass 1'.lower() : [38, 0],
    'Synth Bass 2'.lower() : [39, 0],
    'Violin'.lower() : [40, 0],
    'Viola'.lower() : [41, 0],
    'Cello'.lower() : [42, 0],
    'Contrabass'.lower() : [43, 0],
    'Double Bass'.lower() : [43, 0],
    'Tremolo Strings'.lower() : [44, 0],
    'Stero Strings Trem'.lower() : [44, 0],
    'Pizzicato Strings'.lower() : [45, 0],
    'Orchestral Harp'.lower() : [46, 0],
    'Timpani'.lower() : [47, 0],
    'String Ensemble 1'.lower() : [48, 0],
    'Stereo Strings Fast'.lower() : [48, 0],
    'String Ensemble 2'.lower() : [49, 0],
    'Stereo Strings Slow'.lower() : [49, 0],
    'Synth Strings 1'.lower() : [50, 0],
    'Synth Strings 2'.lower() : [51, 0],
    'Choir Aahs'.lower() : [52, 0],
    'Concert Choir'.lower() : [52, 0],
    'Voice Oohs'.lower() : [53, 0],              # NOT RIGHT!
    'Synth Voice'.lower() : [54, 0],             # NOT RIGHT!
    'Orchestra Hit'.lower() : [55, 0],           # ?? strange sound. ??
    'Trumpet'.lower() : [56, 0],
    'Trombone'.lower() : [57, 0],
    'Tuba'.lower() : [58, 0],
    'Muted Trumpet'.lower() : [59, 0],
    'French Horn'.lower() : [60, 0],
    'French Horns'.lower() : [60, 0],
    'Brass Section'.lower() : [61, 0],
    'Synth Brass 1'.lower() : [62, 0],
    'Synth Brass 2'.lower() : [63, 0],
    'Soprano Sax'.lower() : [64, 0],
    'Alto Sax'.lower() : [65, 0],
    'Tenor Sax'.lower() : [66, 0],
    'Baritone Sax'.lower() : [67, 0],
    'Oboe'.lower() : [68, 0],
    'English Horn'.lower() : [69, 0],
    'Bassoon'.lower() : [70, 0],
    'Clarinet'.lower() : [71, 0],
    'Piccolo'.lower() : [72, 0],
    'Flute'.lower() : [73, 0],
    'Recorder'.lower() : [74, 0],
    'Pan Flute'.lower() : [75, 0],
    'Blown bottle'.lower() : [76, 0],
    'Bottle Blow'.lower() : [76, 0],
    'Shakuhachi'.lower() : [77, 0],
    'Whistle'.lower() : [78, 0],
    'Irish Tin Whistle'.lower() : [78, 0],
    'Ocarina'.lower() : [79, 0],
    'Lead 1 (square)'.lower() : [80, 0],
    'Square Lead'.lower() : [80, 0],
    'Lead 2 (sawtooth)'.lower() : [81, 0],
    'Saw Lead'.lower() : [81, 0],
    'Lead 3 (calliope)'.lower() : [82, 0],
    'Synth Calliope'.lower() : [82, 0],
    'Lead 4 (chiff)'.lower() : [83, 0],
    'Chiffer Lead'.lower() : [83, 0],
    'Lead 5 (charang)'.lower() : [84, 0],
    'Charang'.lower() : [84, 0],
    'Lead 6 (voice)'.lower() : [85, 0],
    'Solo Vox'.lower() : [85, 0],
    'Lead 7 (fifths)'.lower() : [86, 0],
    '5th Saw Wave'.lower() : [86, 0],
    'Lead 8 (bass + lead)'.lower() : [87, 0],
    'Bass & lead'.lower() : [87, 0],
    'Pad 1 (new age)'.lower() : [88, 0],
    'Fantasia'.lower() : [88, 0],
    'Pad 2 (warm)'.lower() : [89, 0],
    'Warm Pad'.lower() : [89, 0],
    'Pad 3 (polysynth)'.lower() : [90, 0],
    'Polysynth'.lower() : [90, 0],
    'Pad 4 (choir)'.lower() : [91, 0],
    'Space Voice'.lower() : [91, 0],
    'Pad 5 (bowed)'.lower() : [92, 0],
    'Bowed Glass'.lower() : [92, 0],
    'Pad 6 (metallic)'.lower() : [93, 0],
    'Metal Pad'.lower() : [93, 0],
    'Pad 7 (halo)'.lower() : [94, 0],
    'Halo Pad'.lower() : [94, 0],
    'Pad 8 (sweep)'.lower() : [95, 0],
    'Sweep Pad'.lower() : [95, 0],
    'FX 1 (rain)'.lower() : [96, 0],
    'Ice Rain'.lower() : [96, 0],
    'FX 2 (soundtrack)'.lower() : [97, 0],
    'Soundtrack'.lower() : [97, 0],
    'FX 3 (crystal)'.lower() : [98, 0],
    'Crystal'.lower() : [98, 0],
    'FX 4 (atmosphere)'.lower() : [99, 0],
    'Atmosphere'.lower() : [99, 0],
    'FX 5 (brightness)'.lower() : [100, 0],
    'Brightness'.lower() : [100, 0],
    'FX 6 (goblins)'.lower() : [101, 0],
    'Goblins'.lower() : [101, 0],
    'FX 7 (echoes)'.lower() : [102, 0],
    'Echo Drops'.lower() : [102, 0],
    'FX 8 (sci-fi)'.lower() : [103, 0],
    'Star Theme'.lower() : [103, 0],
    'Sitar'.lower() : [104, 0],
    'Banjo'.lower() : [105, 0],
    'Shamisen'.lower() : [106, 0],
    'Koto'.lower() : [107, 0],
    'Kalimba'.lower() : [108, 0],
    'Bag pipe'.lower() : [109, 0],
    'Bagpipes'.lower() : [109, 0],
    'Fiddle'.lower() : [110, 0],
    'Shanai'.lower() : [111, 0],
    'Shenai'.lower() : [111, 0],
    'Tinkle Bell'.lower() : [112, 0],
    'Tinker Bell'.lower() : [112, 0],
    'Agogo'.lower() : [113, 0],
    'Steel Drums'.lower() : [114, 0],
    'Woodblock'.lower() : [115, 0],
    'Wood Block'.lower() : [115, 0],
    'Taiko Drum'.lower() : [116, 0],
    'Melodic Tom'.lower() : [117, 0],
    'Synth Drum'.lower() : [118, 0],
    'Reverse Cymbal'.lower() : [119, 0],
    'Guitar Fret Noise'.lower() : [120, 0],
    'Fret Noise'.lower() : [120, 0],
    'Breath Noise'.lower() : [121, 0],
    'Seashore'.lower() : [122, 0],
    'Bird Tweet'.lower() : [123, 0],
    'Birds'.lower() : [123, 0],
    'Telephone Ring'.lower() : [124, 0],
    'Telephone 1'.lower() : [124, 0],
    'Helicopter'.lower() : [125, 0],
    'Applause'.lower() : [126, 0],
    'Gunshot'.lower() : [127, 0],
    'Gun Shot'.lower() : [127, 0],
    'Synth Bass 101'.lower() : [38, 1],
    'Mono Strings Trem'.lower() : [44, 1],
    'Mono Strings Fast'.lower() : [48, 1],
    'Mono Strings Slow'.lower() : [49, 1],
    'Concert Choir Mono'.lower() : [52, 1],
    'Trumpet 2'.lower() : [56, 1],
    'Trombone 2'.lower() : [57, 1],
    'Muted Trumpet 2'.lower() : [59, 1],
    'Solo French Horn'.lower() : [60, 1],
    'Brass Section Mono'.lower() : [61, 1],
    'Square Wave'.lower() : [80, 1],
    'Saw Wave'.lower() : [81, 1],
    'Synth Mallet'.lower() : [98, 1],
    'Cut Noise'.lower() : [120, 1],
    'Fl. Key Click'.lower() : [121, 1],
    'Rain'.lower() : [122, 1],
    'Dog'.lower() : [123, 1],
    'Telephone 2'.lower() : [124, 1],
    'Car-Engine'.lower() : [125, 1],
    'Laughing'.lower() : [126, 1],
    'Machine Gun'.lower() : [127, 1],
    'Echo Pan'.lower() : [102, 2],
    'String Slap'.lower() : [120, 2],
    'Thunder'.lower() : [122, 2],
    'Horse Gallop'.lower() : [123, 2],
    'Door Creaking'.lower() : [124, 2],
    'Car-Stop'.lower() : [125, 2],
    'Scream'.lower() : [126, 2],
    'Lasergun'.lower() : [127, 2],
    'Howling Winds'.lower() : [122, 3],
    'Bird 2'.lower() : [123, 3],
    'Door'.lower() : [124, 3],
    'Car-Pass'.lower() : [125, 3],
    'Punch'.lower() : [126, 3],
    'Explosion'.lower() : [127, 3],
    'Stream'.lower() : [122, 4],
    'Scratch'.lower() : [123, 4],
    'Car-Crash'.lower() : [125, 4],
    'Heart Beat'.lower() : [126, 4],
    'Bubbles'.lower() : [122, 5],
    'Windchime'.lower() : [124, 5],
    'Siren'.lower() : [125, 5],
    'Footsteps'.lower() : [126, 5],
    'Train'.lower() : [125, 6],
    'Jet Plane'.lower() : [125, 7],
    'Chorused Tine EP'.lower() : [4, 8],
    'Chorused FM EP'.lower() : [5, 8],
    'Coupled Harpsichord'.lower() : [6, 8],
    'Church Bells'.lower() : [14, 8],
    'Detuned Tnwl. Organ'.lower() : [16, 8],
    'Detuned Perc. Organ'.lower() : [17, 8],
    'Pipe Organ 2'.lower() : [19, 8],
    'Italian Accordian'.lower() : [21, 8],
    'Ukulele'.lower() : [24, 8],
    '12-String Guitar'.lower() : [25, 8],
    'Hawaiian Guitar'.lower() : [26, 8],
    'Chorused Clean Gt.'.lower() : [27, 8],
    'Funk Guitar'.lower() : [28, 8],
    'Feedback Guitar'.lower() : [30, 8],
    'Guitar Feedback'.lower() : [31, 8],
    'Synth Bass 3'.lower() : [38, 8],
    'Synth Bass 4'.lower() : [39, 8],
    'Orchestra Pad'.lower() : [48, 8],
    'Synth Strings 3'.lower() : [50, 8],
    'Brass Section 2'.lower() : [61, 8],
    'Synth Brass 3'.lower() : [62, 8],
    'Synth Brass 4'.lower() : [63, 8],
    'Sine Wave'.lower() : [80, 8],
    'Doctor Solo'.lower() : [81, 8],
    'Taisho Koto'.lower() : [107, 8],
    'Castanets'.lower() : [115, 8],
    'Concert Bass Drum'.lower() : [116, 8],
    'Melodic Tom 2'.lower() : [117, 8],
    '808 Tom'.lower() : [118, 8],
    'Starship'.lower() : [125, 8],
    'Carillon'.lower() : [14, 9],
    'Burst Noise'.lower() : [125, 9],
    'Piano & Str.-Fade'.lower() : [0, 11],
    'Piano & Str.-Sus'.lower() : [1, 11],
    'Tine & FM EPs'.lower() : [4, 11],
    'Piano & FM EP'.lower() : [5, 11],
    'Tinkling Bells'.lower() : [8, 11],
    'Bell Tower'.lower() : [14, 11],
    'Techno Bass'.lower() : [38, 11],
    'Pulse Bass'.lower() : [39, 11],
    'Stereo Strings Velo'.lower() : [49, 11],
    'Synth Strings 4'.lower() : [50, 11],
    'Synth Strings 5'.lower() : [51, 11],
    'Brass Section 3'.lower() : [61, 11],
    'Whistlin'.lower() : [78, 11],
    'Sawtooth Stab'.lower() : [81, 11],
    "Doctor's Solo".lower() : [87, 11],
    'Harpsi Pad'.lower() : [88, 11],
    'Solar Wind'.lower() : [89, 11],
    'Mystery Pad'.lower() : [96, 11],
    'Synth Chime'.lower() : [98, 11],
    'Bright Saw Stack'.lower() : [100, 11],
    'Cymbal Crash'.lower() : [119, 11],
    'Filter Snap'.lower() : [121, 11],
    'Interference'.lower() : [127, 11],
    'Bell Piano'.lower() : [0, 12],
    'Bell Tine EP'.lower() : [4, 12],
    'Christmas Bells'.lower() : [10, 12],
    'Clean Guitar 2'.lower() : [27, 12],
    'Mean Saw Bass'.lower() : [38, 12],
    'Full Orchestra'.lower() : [48, 12],
    'Mono Strings Velo'.lower() : [49, 12],
    'Square Lead 2'.lower() : [80, 12],
    'Saw Lead 2'.lower() : [81, 12],
    'Fantasia 2'.lower() : [88, 12],
    'Solar Wind 2'.lower() : [89, 12],
    'White Noise Wave'.lower() : [122, 12],
    'Shooting Star'.lower() : [127, 12],
    'Woodwind Choir'.lower() : [48, 13],
    'Square Lead 3'.lower() : [80, 13],
    'Saw Lead 3'.lower() : [81, 13],
    'Night Vision'.lower() : [88, 13],
    'Mandolin'.lower() : [25, 16],
    'Standard Drums'.lower() : [0, 120],
    'Standard 2 Drums'.lower() : [1, 120],
    'Room Drums'.lower() : [8, 120],
    'Power Drums'.lower() : [16, 120],
    'Electronic Drums'.lower() : [24, 120],
    '808/909 Drums'.lower() : [25, 120],
    'Dance Drums'.lower() : [26, 120],
    'Jazz Drums'.lower() : [32, 120],
    'Brush Drums'.lower() : [40, 120],
    'Orchestral Perc.'.lower() : [48, 120],
    'SFX Kit'.lower() : [56, 120],
    'Standard'.lower() : [0, 128],
    'Standard 2'.lower() : [1, 128],
    'Room'.lower() : [8, 128],
    'Power'.lower() : [16, 128],
    'Electronic'.lower() : [24, 128],
    '808/909'.lower() : [25, 128],
    'Dance'.lower() : [26, 128],
    'Jazz'.lower() : [32, 128],
    'Brush'.lower() : [40, 128],
    'Orchestral'.lower() : [48, 128],
    'SFX'.lower() : [56, 128],
}

# ------------------------------------------------------------------------------
global drum_sounds
drum_sounds = {
    'Acoustic Bass Drum'.lower(): 35,
    'Bass Drum 1'.lower(): 36,
    'Side Stick'.lower(): 37,
    'Acoustic Snare'.lower(): 38,
    'Hand Clap'.lower(): 39,
    'Electric Snare'.lower(): 40,
    'Low Floor Tom'.lower(): 41,
    'Closed Hi Hat'.lower(): 42,
    'High Floor Tom'.lower(): 43,
    'Pedal Hi-Hat'.lower(): 44,
    'Low Tom'.lower(): 45,
    'Open Hi-Hat'.lower(): 46,
    'Low-Mid Tom'.lower(): 47,
    'Hi Mid Tom'.lower(): 48,
    'Crash Cymbal 1'.lower(): 49,
    'High Tom'.lower(): 50,
    'Ride Cymbal 1'.lower(): 51,
    'Chinese Cymbal'.lower(): 52,
    'Ride Bell'.lower(): 53,
    'Tambourine'.lower(): 54,
    'Splash Cymbal'.lower(): 55,
    'Cowbell'.lower(): 56,
    'Crash Cymbal 2'.lower(): 57,
    'Vibraslap'.lower(): 58,
    'Ride Cymbal 2'.lower(): 59,
    'Hi Bongo'.lower(): 60,
    'Low Bongo'.lower(): 61,
    'Mute Hi Conga'.lower(): 62,
    'Open Hi Conga'.lower(): 63,
    'Low Conga'.lower(): 64,
    'High Timbale'.lower(): 65,
    'Low Timbale'.lower(): 66,
    'High Agogo'.lower(): 67,
    'Low Agogo'.lower(): 68,
    'Cabasa'.lower(): 69,
    'Maracas'.lower(): 70,
    'Short Whistle'.lower(): 71,
    'Long Whistle'.lower(): 72,
    'Short Guiro'.lower(): 73,
    'Long Guiro'.lower(): 74,
    'Claves'.lower(): 75,
    'Hi Wood Block'.lower(): 76,
    'Low Wood Block'.lower(): 77,
    'Mute Cuica'.lower(): 78,
    'Open Cuica'.lower(): 79,
    'Mute Triangle'.lower(): 80,
    'Open Triangle'.lower(): 81,
}

# ----------------------------------------------------------------------------
global staff_name                   # Staff names, with key pair as array of voice numbers.
staff_name = {}
global last_voice_staff             # Staff/staves active. (array)
last_voice_staff = None             # For continuation lines.
global staff_chord                  # If in the middle of a chord for staff_name.
staff_chord = {}                    # Not collected any chords for any staff/staves yet.

global args
global errors_happened
errors_happened = 0                 # system exit, 0 = okay, 1 = errors happened

global which_file_in
which_file_in = 'stdin'
global linecount
linecount = 0
global i_line                       # Array of line as it is changed by macro arguments, putd, char vars, etc.
i_line = []

global putds                        # "micro" and it's replacement/substitution.
putds    = { }                      # dictionary of from:to

global goto_table                   # Goto is ONLY at end of measure. (Put in extra measures.)
global goto_variables               # When processing gotos for output, the count of times hit.
goto_table = { }                    # first index is measure number. Value is array of measures in goto.
goto_variables = { }                # first index is measure number. Value is number of times goto is hit.

global meas                         # measure names.
meas = []
global last_m                       # Previous measure.
last_m = ''                         # Default to none.
global measure_on                   # The measure/unit are we are working on.
measure_on = ''                     # Default to none. This means we are in the header section.
global premeasurecomment            # Collect comments before a new measure for before new measure.
premeasurecomment = {}
premeasurecomment[measure_on] = ''
global measurelinecomment
measurelinecomment = {}
measurelinecomment[measure_on] = ''
global bars                         # Number of bars per staff
bars = {}
bars[''] = NUMBER_BARS_PER_STAFF    # For abc notation, put new line in output, which ends staff.

global voices                       # Number of voices
voices = 1
global cis                          # If cis active, non-zero. (CIS measure one voice #XX only.)
cis = 0

global vl                           # volume levels
vl = { }                            # vl[voice][m] = volumelevel
vl[1] = { }                         # vl[voice][m] = volumelevel
vl[1][''] = getvar('vfff')          # vl[voice][m] = volumelevel
global running_vl                   # volume levels changing thru measures. (set vl to running_vl at measure.)
running_vl = { }                    # running_vl[voice][m] = volumelevel
running_vl[1] = { }                 # running_vl[voice][m] = volumelevel
running_vl[1][''] = getvar('vfff')  # running_vl[voice][m] = volumelevel

global xpose                        # The number of semitones to move up/down (positive=up), index by voice.
xpose = {}
global xpose_new_key                # Lowercase normal musicomp usage, index by voice.
xpose_new_key = {}

global MIDI_port                    # Which midi port to use for next channel.
MIDI_port = 0
global drums_MIDI_port              # For drums, which midi port to use for next usage.
drums_MIDI_port = 0

global percents
percents = { }                      # No %% passthru commands for start of [measure] (for abc).
percents[''] = []                   # Blank measure.

global staves                       # Array of array of voices on staff. [ [1,2] [5,6,7] [21] ]
staves = [ ]

global clef
clef = { }                          # No clef specified [voice][measure].
global vinstrument                  # vinstrument[3][1234] = 'Acoustic Grand Piano'
vinstrument = { }                   # No instruments specified [voice][measure].
global reverb
reverb = { }                        # Reverb value for voice, measure.
global pan
pan = { }                           # Pan (balance 0=left, 126=right, 64=center) for voice, measure
global intensity
intensity = { }                     # Instrument intensity (volume) for voice, measure..

global pitch                        # Pitch change up or down by semitones.
pitch = {}                          # Index by measure.
pitch[''] = 0                       # Before first measure is no pitch.

global cresc_volume
cresc_volume = [ ]
global cresc_time
cresc_time = []
global cresc_direction
cresc_direction = []

global voices_having_notes
voices_having_notes = {}

for i in range(1, MAXVOICES+1):     # This is used as [1] .. [MAXVOICES]
    vinstrument[i] = {}
    vinstrument[i][''] = 'Acoustic Grand Piano'.lower()
    reverb[i] = {}
    reverb[i][''] = getvar('default_reverb')
    pan[i] = {}
    pan[i][''] = getvar('default_pan')
    intensity[i] = {}
    intensity[i][''] = getvar('default_intensity')
    clef[i] = {}
    clef[i][''] = 'treble'          # No clef.       (voice, measure)
    xpose[i] = 0
    xpose_new_key[i] = ''           # No new key.   Text!  C for ABC, 0 for fluidsynth.
    cresc_volume.append(0)
    cresc_time.append(0)
    cresc_direction.append(True)
# rof

global inst
inst = { }                          # track using instrument by voice.

global oct                          # default octave
oct = { 1 : 0 }
global acc_v_init                   # Last accidental on a note in measure.
global acc_v_init_v_or_h            # Last accidental on a note in measure.
acc_v_init = { '0C':'', '0D':'', '0E':'', '0F':'', '0G':'', '0A':'', '0B':'',
               '1C':'', '1D':'', '1E':'', '1F':'', '1G':'', '1A':'', '1B':'',
               '2C':'', '2D':'', '2E':'', '2F':'', '2G':'', '2A':'', '2B':'',
               '3C':'', '3D':'', '3E':'', '3F':'', '3G':'', '3A':'', '3B':'',
               '4C':'', '4D':'', '4E':'', '4F':'', '4G':'', '4A':'', '4B':'',
               '5C':'', '5D':'', '5E':'', '5F':'', '5G':'', '5A':'', '5B':'',
               '6C':'', '6D':'', '6E':'', '6F':'', '6G':'', '6A':'', '6B':'',
               '7C':'', '7D':'', '7E':'', '7F':'', '7G':'', '7A':'', '7B':'',
               '8C':'', '8D':'', '8E':'', '8F':'', '8G':'', '8A':'', '8B':''}
acc_v_init_v_or_h = { '0c':'', '0d':'', '0e':'', '0f':'', '0g':'', '0a':'', '0b':'',
                      '1c':'', '1d':'', '1e':'', '1f':'', '1g':'', '1a':'', '1b':'',
                      '2c':'', '2d':'', '2e':'', '2f':'', '2g':'', '2a':'', '2b':'',
                      '3c':'', '3d':'', '3e':'', '3f':'', '3g':'', '3a':'', '3b':'',
                      '4c':'', '4d':'', '4e':'', '4f':'', '4g':'', '4a':'', '4b':'',
                      '5c':'', '5d':'', '5e':'', '5f':'', '5g':'', '5a':'', '5b':'',
                      '6c':'', '6d':'', '6e':'', '6f':'', '6g':'', '6a':'', '6b':'',
                      '7c':'', '7d':'', '7e':'', '7f':'', '7g':'', '7a':'', '7b':'',
                      '8c':'', '8d':'', '8e':'', '8f':'', '8g':'', '8a':'', '8b':''}
global acc_m
acc_m = { '': {''}}                 # voice: {notes:'+'/-/n}    For this measure, index is voice.
global acc_m_xpose
acc_m_xpose = { '': {''}}           # After xpose, the new key ... voice: {notes:'+'/-/n} previous accidental

global time                         # set default note length (time)
time = { 1 : 0 }
global mlth                         # measure length dictionary
mlth = { }
global tlth                         # #or 60ths/voice
tlth = { 1 : 0 }                    # 60ths of a second in a voice -- nothing in measure working on.

global bufs                         # bufs[voice][measure] = text line.
#                                   # ABC format, or musicomp format separated by commas.
bufs = { 1 : {} }

global bufs_length                  # bufs_length[voice][measure][#] ... number= 0..#commas-1 above.
bufs_length = { 1 : {} }

global bufs_velocity                # bufs_velocity[voice][measure][#] ... number= 0..#commas-1 above.
bufs_velocity = { 1 : {} }

# Notes with ties/staccato/legato/etc.
global bufs_suffixes                # bufs_suffixes[voice][measure][#] ... number= 0..#commas-1 above.
bufs_suffixes = { 1: {} }

global bufs_tie_next                # The --horizontal and --verticle have "t" (ties) swapped on where
bufs_tie_next = { 1: '' }           #    the "t" goes on which notes.

global bufs_legato_next
bufs_legato_next = { 1: '' }

global bufs_vol                     # vol(xx) for each note.
bufs_vol = { 1: {} }

global bufs_intensity               # intensity VOICE XXX for each note.
bufs_intensity = { 1: {} }

global pages_to_do
pages_to_do = []                    # argument line limiting which pages to do.
global measures_to_do
measures_to_do = []                 # argument line limiting which measures to do.
global voices_to_do
voices_to_do = []                   # argument line limiting which voices to do.

global iftest                       # check if after if or else.
iftest = { 0:-1 }                   # -1 = processing in if, 0 = skip till else,
#                                   # 1 processing in else, 2 = skip till endif,
#                                   # 3 = skip both if and else.
global ifdepth                      # level of if/else/endif
ifdepth = 0

global cstop_processing
cstop_processing = False            # True if after a cstop.

global macro_defining               # If currently defining a macro.
macro_defining = None
global macro_defining_count         # Nested macro defining count.
macro_defining_count = 0
# Processes execute on a staff line. (process_notes_oldway -- maybe rename/change/fix/modify to process_staves?)
global process_defining             # If currently defining a process.
process_defining = None
global process_defining_count       # Nested process defining count.
process_defining_count = 0
global in_process_already           # If not None, the process number run till quit or another begin or end of file.
in_process_already = False
global running_process_already      # If in a process -- so notes get processed as notes, not passed to process.
running_process_already = False
# loop -> endloop.  Count nested.
global loop_defining                # If currently defining a loop.
loop_defining = None
global loop_defining_count          # Nested loop defining count.
loop_defining_count = 0

# Macro definition, and for searching for matching, and arguments/terminators for executing.
global macro_number                 # Increment for each macro defined.
macro_number = 0                    # Matches len(following).
global macro_name                   # macro number: array of macro names (duplicates allowed)
macro_name = [ ]
global macro_name_terminator        # macro number: array of first terminator after name.
macro_name_terminator = [ ]
global macro_arguments              # macro number: array of argument names for macro.
macro_arguments = [ ]
global macro_arg_terminator         # macro number: array of terminators after macro arguments.
macro_arg_terminator = [ ]
global macro_buffer                 # macro number: array of lines for macro.
macro_buffer = [ ]

# Process definition.
global process_number               # Increment for each process defined.
process_number = 0                  # Matches len(following).
global process_name                 # process number: array of process names - No duplicates.
process_name = [ ]
global process_argument             # macro number: Single argument for process.
process_argument = [ ]
global process_buffer               # process number: array of lines for process.
process_buffer = [ ]

# Loop definition.
global loop_number                  # Increment for each nested loop.
loop_number = 0                     # Matches len(following).
global loop_location                # line where loop starts...
loop_location = [ ]
global loop_value_variable          # testing value if "loop a<b", else variable "loop m1=4,12,2"
loop_value_variable = [ ]
global loop_increment               # If None, then loop is "loop a<b" type. Else the increment.
loop_increment = [ ]
global loop_final_value             # If > or < when assigning/increment/decrement - depending on sign loop_increment.
loop_final_value = [ ]
global loop_endloop_exp             # If expression on endloop command.
loop_endloop_exp = [ ]
global loop_buffer                  # loop number: array of lines for nested loops.
loop_buffer = [ ]

global all_unique_macro_names       # Dictionary 'name': [ numbers ] -- From numbers, get terminators, etc.
all_unique_macro_names = { }

# Following are for executing macros.
global lmp_executing_number         # The depth (number) of executing macros/process/loop. (nested number)
lmp_executing_number = 0
global lmp_executing_which          # The {macro/process/loop}_number (above groups) we are executing.
lmp_executing_which = [ None ]
global lmp_executing_type           # "loop", "macro", "process" - type for "which", line, args, number... .
lmp_executing_type = [ None ]
global lmp_executing_args           # Array of argument(s) given to macro. (None for loop, one for process.)
lmp_executing_args = [ None ]
global lmp_executing_line           # Line number in macro/loop/process array currently processing.
lmp_executing_line = [ None ]
global lmp_executing_rest_of_line   # Rest of line - for in-line macro/process. Loop doesn't have this.
lmp_executing_rest_of_line = [ None ]
global lmp_executing_i_line         # Saved i_line in entered macro.
lmp_executing_i_line = [ None ]

global header                       # Header to print at top of file.

global meter
global measure_meter
global measure_meter_value          # Last computed value for above.

global key_default                  # First key applies globally, if not voice number arguments.
key_default = None
global key_voice                    # Running key by voice, then measure.
key_voice = {}

# This should really be 'where it occurs'.
global tempo_speed_default          # beats per minute
tempo_speed_default = 150.0
global default_note_length          # length of a beat (note)
default_note_length = { '': 1.0 / 4.0 } # before a measure.
global tempo_speed_now              # beats per minute for each measure.
tempo_speed_now = { '': tempo_speed_default }
global tempo_now_note_length        # length of a beat (note)
tempo_now_note_length = { '': 1.0 / 4.0 } # before a measure.

global file_name                    # None = use tty.
global output_name                  # File to print to (default is sys.stdout).

global array_of_lines               # For fluidsynth output, have an array of lines.
array_of_lines = []

global fluidsynth_done
fluidsynth_done = False             # Set True if done with midi1csv printing into array and 'quit'.

# ----------------------------------------------------------------------------
# Returns: lengthl : value given, like 4 for quarter note.
#          lengthf : value in floating, 0.25 for a quarter note.
#          ifokay  : 0 if everything is okay,
#                   -1 if unable to return number,
#                    1 if left-over value (tiny).
def get_time_stak(timeofnote, voiceon, original_line):
    global default_note_length          # length of a beat (note)
    global legal_floating_times
    global measure_on
    global args

    if type(voiceon) is not int:
        print_error("get_time_stak - voiceon type is not int ({})={}".format(type(voiceon),voiceon), original_line)
        print_die("voiceon must be a voice.")
    # fi
    if timeofnote <= 0.0:
        print_error("measure={} voiceon={} timeofnote '{}' negative or zero -- cannot play a note backwards.".format(measure_on, voiceon, timeofnote), original_line)
        return timeofnote, 0, -1    # False
    # fi
    lengthl = []
    lengthf = []
    t = timeofnote
    for i in reversed(range(len(legal_floating_times))):
        f = legal_floating_times[i]
        while True:
            if f > t:
                break
            # fi
            if args.horizontal or args.vertical:
                v = f
                v = 1.0 / v
                if f in legal_mc_notes:
                    vv = legal_mc_notes[f]
                else:
                    vv = str(Fraction(v).limit_denominator(256))
                    if '/' in vv or v > 1:
                        vv = '(' + str(f) + ')'
                    # fi
                # fi
                v = vv
            elif args.midi1csv or args.fluidsynth:
                v = round((f * 4.0) * MIDICLICKSPERQUARTER)
            else:       # ABC
                v = f / default_note_length[measure_on]
                v = str(Fraction(v).limit_denominator(256))
                if v[0:2] == '1/':
                    v = v[1:]
                # fi
            # fi
            lengthl.append(v)
            lengthf.append(f)
            t = t - f
            if t <= 0:                  # This isn't needed, but makes me more comfortable.
                break
            # fi
        # elihw
    # rof
    if t > 0:
        print_warning("measure={} voice={} timeofnote={} -> {} has left-over of t={}".format(measure_on, voiceon, timeofnote, lengthl, t), original_line)
        return lengthl, lengthf, 1      # Problems
    # fi
    if not lengthl or len(lengthl) == 0:
        print_error("measure={} voice={} timeofnote '{}' not able to return a usable fraction - min of 1/64".format(measure_on, on_voice, timeofnote), original_line)
        return timeofnote, 0, -1    # False
    # fi
    return lengthl, lengthf, 0      # True
# End of get_time_stak

# ----------------------------------------------------------------------------
def default_note_text_fraction(m):
    global default_note_length
    global legal_notes

    l = str(Fraction(default_note_length[m]).limit_denominator(256))
    if l not in legal_notes:
        print_warning("#1 Time fraction '{}' is not a printable note. ({})".format(default_note_length[m], l), m)
    # fi
    return(l)
# End of default_note_text_fraction

# ----------------------------------------------------------------------------
# Set all voices in all staves in voiceon array (or if int, only one voice).
def set_all_staff_arr(voiceon, value, arr, original_line):
    if type(voiceon) is int:
        arr[voiceon] = value
        return
    # fi
    if type(voiceon) is not list:
        print_error("set_all_staff_arr - voice is not an integer nor a list ({},{})".format(type(voiceon),voiceon), original_line)
        print_die(here)
    # fi
    # Go through all staves and set all voices for all to this octave.
    for s in voiceon:
        for v in staff_name[s]:
            arr[v] = value
        # rof
    # rof
    return
# End of set_all_staff_arr

# ----------------------------------------------------------------------------
# Get value from one of the voices (check all staves have the same).

def set_staff_arr_double(voiceon, value, m, arr, original_line):
    if type(voiceon) is int:
        arr[voiceon][m] = value
        return value
    # fi
    if type(voiceon) is not list:
        print_error("get_staff_arr - voice is not an integer nor a list ({}.{})".format(type(voiceon),voiceon), original_line)
        print_die(here)
    # fi
    # Go through all staves and set all voices for all to this octave.
    for s in voiceon:
        for v in staff_name[s]:
            arr[v][m] = value
        # rof
    # rof
    return value
# End of set_staff_arr_double

# ----------------------------------------------------------------------------
# Get value from one of the voices (check all staves have the same).

def get_staff_arr(voiceon, arr, original_line):
    if type(voiceon) is int:
        return arr[voiceon]
    # fi
    if voiceon is None or type(voiceon) is not list:
        print_error("get_staff_arr - voice is not an integer nor a list ({}.{})".format(type(voiceon),voiceon), original_line)
        print_die(here)
    # fi
    # Go through all staves and check if all voices are the same.
    value = None
    for s in voiceon:
#--        print_debug("get_staff_arr - s={}".format(s))
        for v in staff_name[s]:
            if value is not None:
                if value != arr[v]:
                    print_warning("get_staff_arr - staff {}, voice {} is not the same as previous {}.".format(s,v,value), original_line)
                # fi
            else:
                value = arr[v]
            # fi
        # rof
    # rof
    return value
# End of get_staff_arr

# ----------------------------------------------------------------------------
# Get value from one of the voices (check all staves have the same).

def get_staff_arr_double(voiceon, m, arr, original_line):
    if type(voiceon) is int:
        return arr[voiceon][m]
    # fi
    if type(voiceon) is not list:
        print_error("get_staff_arr - voice is not an integer nor a list ({}.{})".format(type(voiceon),voiceon), original_line)
        print_die(here)
    # fi
    # Go through all staves and check if all voices are the same.
    value = None
    for s in voiceon:
        if staff_name[s] is not None:
            for v in staff_name[s]:
                if value is not None:
                    if value != arr[v][m]:
                        print_error("get_staff_arr - staff={} voice={} m={} is not the same as previous {}.".format(s,v,m,value), original_line)
                    # fi
                else:
                    value = arr[v][m]
                # fi
            # rof
        # fi
    # rof
    return value
# End of get_staff_arr_double

# ----------------------------------------------------------------------------
# True or False check if all voiceon is in array.

def check_voice_staff_in(voiceon, arr):
    if type(voiceon) is int:
        return voiceon in arr
    # fi
    if type(voiceon) is not list:
        print_error("check_voice_staff_in - voice is not an integer nor a list ({}.{})".format(type(voiceon),voiceon), '')
        print_die(here)
    # fi
    # Go through all staves and check if all staffname's voices are in array.
    for s in voiceon:
        for v in staff_name[s]:
            if v not in arr:
                return False
            # fi
        # rof
    # rof
    return True
# End of check_voice_staff_in

# ----------------------------------------------------------------------------
def new_voice_initialize(voiceon, m):
    global vl                           # volume levels
    global vinstrument
    global reverb
    global pan
    global intensity
    global oct                          # default octave
    global time                         # set default note length (time)
    global mlth                         # measure length dictionary
    global tlth                         # #or 60ths/voice
    global bufs
    global bufs_length
    global bufs_velocity
    global bufs_suffixes
    global bufs_tie_next
    global bufs_legato_next
    global bufs_vol
    global bufs_intensity
    global acc_m
    global acc_m_xpose
    global acc_v_init                   # Last accidental on a note in measure.
    global acc_v_init_v_or_h            # Last accidental on a note in measure.
    global args
    global running_vl                   # volume levels changing thru measures.
    global key_default
    global key_voice
    global clef

    if type(voiceon) is not int:
        print_error("new_voice_initialize - voice type is not int ({})".format(type(voiceon), 'new_voice_initialize'))
        print_die("here")
    # fi
    if not check_voice_staff_in(voiceon, vl):
        vl[voiceon] = {}
        running_vl[voiceon] = {}
    # fi
    if not check_voice_staff_in(voiceon, oct):
        oct[voiceon] = 0
    # fi
    if not check_voice_staff_in(voiceon, time):
        time[voiceon] = 0
    # fi
    if not check_voice_staff_in(voiceon, mlth):
        mlth[voiceon] = {}
    # fi
    if not check_voice_staff_in(voiceon, tlth):
        tlth[voiceon] = 0
    # fi
    if not check_voice_staff_in(voiceon, bufs):
        set_all_staff_arr(voiceon, {}, bufs, 'new_voice_initialize')
        set_all_staff_arr(voiceon, {}, bufs_length, 'new_voice_initialize')
        set_all_staff_arr(voiceon, {}, bufs_velocity, 'new_voice_initialize')
        set_all_staff_arr(voiceon, {}, bufs_suffixes, 'new_voice_initialize')
        set_all_staff_arr(voiceon, '', bufs_tie_next, 'new_voice_initialize')
        set_all_staff_arr(voiceon, '', bufs_legato_next, 'new_voice_initialize')
        set_all_staff_arr(voiceon, {}, bufs_vol, 'new_voice_initialize')
        set_all_staff_arr(voiceon, {}, bufs_intensity, 'new_voice_initialize')
    # fi

    if m not in vl[voiceon]:
        vl[voiceon][m] = getvar('vfff')              # start volume out at maximum
        running_vl[voiceon][m] = getvar('vfff')
    # fi
    if not check_voice_staff_in(voiceon, vinstrument):
        set_all_staff_arr(voiceon, {}, vinstrument, 'new_voice_initialize')
        set_all_staff_arr(voiceon, {}, reverb, 'new_voice_initialize')
        set_all_staff_arr(voiceon, {}, pan, 'new_voice_initialize')
        set_all_staff_arr(voiceon, {}, intensity, 'new_voice_initialize')
    # fi
    if m not in vinstrument[voiceon]:
        vinstrument[voiceon][m] = 'Acoustic Grand Piano'.lower()
        reverb[voiceon][m] = getvar('default_reverb')
        pan[voiceon][m] = getvar('default_pan')
        intensity[voiceon][m] = getvar('default_intensity')
    # fi
    if not check_voice_staff_in(voiceon, key_voice):
        set_all_staff_arr(voiceon, {}, key_voice, 'new_voice_initialize')
#--        print_debug("new_voice_initialize {} nothing  key_voice")
    # fi
    if m not in key_voice[voiceon]:
        key_voice[voiceon][m] = key_default
#--        print_debug("new_voice_initialize key_default={} nothing  key_voice".format(key_default))
    # fi

    if m not in mlth[voiceon]:
        mlth[voiceon][m] = 0              # measure length dictionary
    # fi
    if not check_voice_staff_in(voiceon, acc_m):
# NOTDONEYET - set staff array acc_m, acc_m_xpose
        if args.horizontal or args.vertical:
            acc_m[voiceon] = {k: v for k, v in acc_v_init_v_or_h.items()}
            acc_m_xpose[voiceon] = {k: v for k, v in acc_v_init_v_or_h.items()}
        elif args.midi1csv or args.fluidsynth:
            acc_m[voiceon] = {k: v for k, v in acc_v_init_v_or_h.items()}
            acc_m_xpose[voiceon] = {k: v for k, v in acc_v_init_v_or_h.items()}
        else:           # ABC
            acc_m[voiceon] = {k: v for k, v in acc_v_init.items()}
            acc_m_xpose[voiceon] = {k: v for k, v in acc_v_init.items()}
        # fi
    # fi

    for j in vl:
        if j not in clef:
            clef[j] = {}
        # fi
        if m not in clef[j]:
            for k in reversed(range(0, len(meas)-1)):
                mmm = meas[k]
                if mmm in clef and j in clef[mmm]:
                    nc = clef[j][mmm]
                    break
                # fi
            # rof
        else:
            nc = clef[j][m]
        # fi
        clef[j][m] = nc
    # rof
    return
# End of new_voice_initialize

# ----------------------------------------------------------------------------
# Get volume levels at measures -- the volume(s) commands work at that point..
def get_volume_level(m, voiceon):
    global vl                           # volume levels
    global vlprint
    global args
    global DECORATIONS

    if type(voiceon) is not int:
        print_error("get_volume_level - voice type is not int ({})".format(type(voiceon), 'get_volume_level'))
        print_die("voiceon must be a voice.")
    # fi
    new_voice_initialize(voiceon, m)
    j = vl[voiceon][m]                    # volume level for this voice/measure
    if args.horizontal or args.vertical:
        return j
    # fi
    if args.midi1csv or args.fluidsynth:
        return j
    # fi
    j = vol_to_vlprint_round(j)
    p = vlprint[j]
    return (DECORATIONS + p + DECORATIONS)
# End of get_volume_level

# ----------------------------------------------------------------------------
def rests_in_empty_measure_voices(m, voiceon):
    global vl                               # volume levels
    global meas
    global mlth
    global bufs
    global bufs_length
    global bufs_velocity
    global bufs_suffixes
    global bufs_tie_next
    global bufs_legato_next
    global bufs_vol
    global bufs_intensity
    global args
    global running_vl

    if type(voiceon) is not int:
        print_error("rests_in_empty_measure_voices - voice type is not int ({})".format(type(voiceon), 'rests_in_empty_measure_voices'))
        print_die("voiceon must be a voice.")
    # fi
    if m in bufs[voiceon]:                    # Already present, then of right length.
        return
    # fi
    # No text for this voice, create rests to fill it out.
    l = 0
    for i in range(1, len(vl)+1):
        if m in mlth[i]:
            l = max(mlth[i][m], l)
        # fi
    # rof
    if m in mlth[voiceon]:
        l = l - mlth[voiceon][m]              # All measure lengths with voices are the same.
    # fi
    if m not in bufs[voiceon]:
        bufs_vol[voiceon][m] = []
        bufs_intensity[voiceon][m] = []
        if args.horizontal or args.vertical or args.midi1csv or args.fluidsynth:
            bufs[voiceon][m] = []
            bufs_length[voiceon][m] = []
            bufs_velocity[voiceon][m] = []
            bufs_suffixes[voiceon][m] = []
            set_all_staff_arr(voiceon, '', bufs_tie_next, 'rests_in_empty_measure_voices')
            set_all_staff_arr(voiceon, '', bufs_legato_next, 'rests_in_empty_measure_voices')
        else:       # ABC
            bufs[voiceon][m] = ''
        # fi
    # fi
    if voiceon in running_vl and m in running_vl[voiceon]:
        try:
            tt = running_vl[voiceon][m]
        except:
            print_debug("get_sequence_note - NOTDONEYET - voiceon not integer ({})".format(voiceon))
    else:
        tt = 127                            # Probably a rest, put as full volume.
    # fi
    bufs_vol[voiceon][m].append(tt)
# NOTDONEYET - set_all_staff_arr bufs_intensity
    if voiceon not in intensity or m not in intensity[voiceon]:
#--        print_debug("intensity='{}'".format(intensity))
        intensity[voiceon][m] = int(getvar_checkokay('default_intensity', 'rests_in_empty_measure_voices'))
    # fi
    if voiceon not in bufs_intensity or m not in bufs_intensity[voiceon]:
#--        print_debug("bufs_intensity='{}'".format(bufs_intensity))
        bufs_intensity[voiceon][m] = []
    # fi
# NOTDONEYET - set_all_staff_arr bufs_intensity
    bufs_intensity[voiceon][m].append(intensity[voiceon][m])
    # Put out rests.
    if l <= 0:                              # if nothing to do.
        return
    # fi
    txt = ''
    if args.horizontal or args.vertical or args.midi1csv or args.fluidsynth:
        pass
    else:       # ABC
        lengthl, lengthf, ifokay = get_time_stak(l, voiceon, 'pass2')
        for i in range(len(lengthl)):
            txt = txt + ' z' + lengthl[i]       # entry in array
        # rof
        if txt == '':
            print_error('no music for voiceon {} in measure {}'.format(voiceon, m), 'pass2')
            return
        # fi
    # fi

    set_all_staff_arr(voiceon, '', bufs_tie_next, 'rests_in_empty_measure_voices')
    set_all_staff_arr(voiceon, '', bufs_legato_next, 'rests_in_empty_measure_voices')
    if args.horizontal or args.vertical:
        bufs[voiceon][m].append('r')
        bufs_length[voiceon][m].append(l)
        bufs_velocity[voiceon][m].append(getvar('default_velocity'))
        bufs_suffixes[voiceon][m].append('')
    elif args.midi1csv or args.fluidsynth:
        bufs[voiceon][m].append(0)
        bufs_length[voiceon][m].append(l)
        bufs_velocity[voiceon][m].append(getvar('default_velocity'))
        bufs_suffixes[voiceon][m].append('')
    else:       # ABC
        bufs[voiceon][m] = bufs[voiceon][m] + txt   # Append the sleeps.
    # fi
    return
# End of rests_in_empty_measure_voices

# ----------------------------------------------------------------------------
def print_measure_abc(m, print_V, voiceon, l_meter, l_tempo, l_dl, l_clef, l_instrument, l_vl, l_txt, l_ky, l_pitch):
    global bufs
    global measure_meter
    global clef
    global meas
    global vinstrument
    global reverb
    global pan
    global intensity
    global key_voice                        # Running key by voice.
    global tempo_speed_now
    global pitch

    if type(voiceon) is not int:
        print_error("print_measure_abc - voice type is not int ({})".format(type(voiceon), 'print_measure_abc'))
        print_die("voiceon must be a voice.")
    # fi
    if not check_voice_staff_in(voiceon, bufs):
        return "ERROR - bufs voice dictionary is hosed.", '', '', '', '', '', '', '', ''
    # fi
    pr = l_txt

    # if first measure, and doing voice, output V:# line.
    if m == meas[0] or (voiceon in clef and m in clef [voiceon] and l_clef != clef[voiceon][m]):
        if pr != '' and pr[-1] != '\n':
            pr = pr + '\n'
        # fi
        pr = pr + "V:{}".format(print_V)
        if voiceon in clef and m in clef[voiceon]:
            if clef[voiceon][m] != l_clef:
                l_clef = clef[voiceon][m]
                pr = pr + ' clef={}'.format(l_clef)
            # fi
        # fi
        pr = pr + '\n'
    # fi

    if pitch[m] != l_pitch:
        if pr != '' and pr[-1] != '\n':
            pr = pr + '\n'
        # fi
        l_pitch = pitch[m]
        pr = pr + '%% pitch    {}'.format(l_pitch) + '\n'
    # fi

    if m not in vinstrument[voiceon]:
        vinstrument[voiceon][m] = 'Acoustic Grand Piano'.lower()
        reverb[voiceon][m] = getvar('default_reverb')
        pan[voiceon][m] = getvar('default_pan')
        intensity[voiceon][m] = getvar('default_intensity')
    # fi

    if l_instrument != vinstrument[voiceon][m]:
        l_instrument = vinstrument[voiceon][m]
        if pr != '' and pr[-1] != '\n':
            pr = pr + '\\\n'
        # fi
        if l_instrument in instruments:
            pr = pr + "%%MIDI program {}\n".format((instruments[l_instrument])[0])
        elif l_instrument in drum_sounds:
            pr = pr + "%%MIDI program {}\n".format((drum_sounds[l_instrument]))
        else:
            print_warning_no_line("print_measure_abc - voice#{} measure#{} instrument {} not acceptable!".format(voiceon, m, vinstrument[voiceon][m]))
        # fi
    # fi


    if m == meas[0]:
        flag = False
        for M in goto_table:
            for G in goto_table[M]:
                pr = pr + '|:'
                flag = True
                break
            # rof
            if flag:
                break
            # fi
        # rof
    # fi

    # if default note length != last one
    if l_dl != default_note_text_fraction(m):
        l_dl = default_note_text_fraction(m)
        if l_dl == '1':
            l_dl = '1/1'
        else:
            l_dl = l_dl
        # fi
        pr = pr + "[L:{}]".format(l_dl)
    # fi

    if l_tempo != tempo_speed_now[m]:
        l_tempo = tempo_speed_now[m]
        if type(l_tempo) is str:
            l_tempo = float(l_tempo)
        # fi
        if type(l_tempo) is float and l_tempo.is_integer():
            l_tempo = int(l_tempo)
        # fi
        pr = pr + "[Q:{}={}]".format(l_dl, l_tempo)
    # fi

    vvv = voiceon
    if m in key_voice[vvv]:
        if l_ky != key_voice[vvv][m]:
            ky = key_voice[vvv][m]
            if ky == 'atonal':
                ky = 'C'
            # fi
            pr = pr + "[K:{}]".format(ky)
            l_ky = ky
        # fi
    # fi
    # if meter != last one
    if l_meter != measure_meter[m]:
        l_meter = measure_meter[m]
        pr = pr + "[M:{}]".format(l_meter)
    # fi
    j = get_volume_level(m, voiceon)
    v_vl = j

    if v_vl != l_vl:
        pr = pr + v_vl
        l_vl = v_vl
    # fi
    pr = pr + bufs[voiceon][m] + ' |'
    return pr, l_meter, l_tempo, l_dl, l_clef, l_instrument, l_vl, l_ky, l_pitch
# End of print_measure_abc

# ----------------------------------------------------------------------------
def print_out_abc():
    global vl                               # volume levels
    global meas                             # measures
    global bars                             # number of bars per staff
    global key_default
    global voices_to_do
    global args

    printed_V = 0

    #-- for voice in reversed(range(1, len(vl)+1)):
    for voice in range(1, len(vl)+1):
        if args.voices and args.voices != '':
            if str(voice) not in voices_to_do:
                continue
            # fi
        # fi
        printed_V += 1
        if printed_V > MAXABCVOICES:
            print_error_no_line("voice ({}) - printed_V ({}) > {} abc voices".format(voice, printed_V, MAXABCVOICES))
        # fi
        print_output("% --- voice " + str(voice) + '  ---')
        l_meter = l_dl = l_clef = l_instrument = l_vl = ''
        l_ky = key_default
        l_tempo = ''
        l_pitch = ''
        print_line = ''

        bar = 0
        bar_print = 0
        last_bar = bars['']
        print_output(print_line + "%abc %%barsperstaff {}".format(last_bar))
        first_goto = True
        for i in range(0, len(meas)):
            bar = bar + 1
            m = meas[i]
            if (bar > int(last_bar) + bar_print):                # Zero-th one is ''.
                if print_line != '' and print_line[-1] != '\n':
                    print_line = print_line + '\n'
                # fi
                print_output(print_line + "% measure {}".format(m))
                print_line = ''
                bar_print = i
            # fi
            if last_bar != bars[m]:            # Zero-th one is ''.
                if print_line != '' and print_line[-1] != '\n':
                    print_line = print_line + '\n'
                # fi
                last_bar = bars[m]
                print_line = print_line + "%abc %%barsperstaff {}\n".format(last_bar)
            # fi

            if m in percents:
                if print_line != '' and print_line[-1] != '\n':
                    print_line = print_line + '\\n'
                # fi
                for p in percents[m]:
                    print_line = print_line + p + '\n'
                # rof
            # fi

            print_line, l_meter, l_tempo, l_dl, l_clef, l_instrument, l_vl, l_ky, l_pitch = print_measure_abc(m,
                        printed_V, voice, l_meter, l_tempo, l_dl, l_clef, l_instrument, l_vl, print_line, l_ky, l_pitch)

            if m in goto_table and goto_table[m] != '':
                print_warning_no_line("goto in measure {} not handled.".format(m))
                if print_line != '' and print_line[-1] != '\n' and print_line[-1] == '|' and first_goto:
                    print_line = print_line[:-1] + ':|'
                    first_goto = False
                # fi
            # fi

        # rof
        if print_line != '':
            print_line = print_line + ']'
            print_output(print_line)
        # fi
    # fi
    return
# End of print_out_abc

# ----------------------------------------------------------------------------
# input:
#   m               The measure.
#   l_meter         Last meter.
#   l_clef          Last clef for voices.
#   l_instrument    Last Instrument for voices.
#   l_vl            Last volume array for voices.
#   l_txt           (print_line entry)
#   l_ky            Last key for this voice.
#   l_tempo         Last tempo
#   l_t_n_l         Last tempo note length.
# returns:
#   print_line
#   l_meter
#   l_dl
#   l_clef
#   l_instrument
#   l_vl
#   l_ky
#   l_tempo
#   l_t_n_l

#   measure xyz
#   meter   x/y
#   clef    abc,def,ghi,jkl,mno,pqr
#   volume  4,5,6,7,6,5
#   tempo   100,4
#   voice   6   30,40,50,60,70,80           $$ needed if volume changes.
#   v1: 3c4, ...
#   vX: 3e4, ...
# NOTDONEYET - pan, intensity, reverb

def print_measure_vh_header(m, l_meter, l_clef, l_instrument, l_vl, l_txt, l_ky, l_tempo, l_t_n_l, l_pitch):
    global vl
    global measure_meter
    global clef
    global vinstrument
    global key_voice
    global tempo_speed_now
    global tempo_now_note_length
    global pitch
    global args
    global voices_to_do
    global vlprint

    pr = ''
    n_meter = ''
    n_clef = ''
    n_instrument = []
    n_vl = ''

    if premeasurecomment[m] != '':
        pr = pr + premeasurecomment[m]
    # fi
    pr = pr + "measure {}".format(m)
    if measurelinecomment[m] != '':
        pr = pr + '     ' + measurelinecomment[m]
    # fi
    pr = pr + "\n"

    n_meter = measure_meter[m]
    if l_meter != n_meter:
        pr = pr + 'meter   {}\n'.format(n_meter)
    # fi

    n_clef = ''
    for voice in range(1, len(vl)+1):
        if args.voices and args.voices != '':
            if str(voice) not in voices_to_do:
                continue
            # fi
        # fi
        if voice in clef and m in clef[voice]:
            t = str(clef[voice][m])
            if n_clef == '':
                n_clef = t
            else:
                n_clef = n_clef + ',' + t
            # fi
        # fi
    # rof
    if l_clef != n_clef:
        pr = pr + 'clef    {}\n'.format(n_clef)
    # fi

    pv = False

    for voice in range(1, len(vl)+1):
        if args.voices and args.voices != '':
            if str(voice) not in voices_to_do:
                continue
            # fi
        # fi
        new_voice_initialize(voice, m)
        t = str(get_volume_level(m, voice))
        for j in vlprint:
            if t == str(j):
                t = vlprint[j]
                break
            # fi
        # rof
        if n_vl == '':
            n_vl = t
        else:
            n_vl = n_vl + ',' + t
        # fi
    # rof
    if l_vl != n_vl:
        p_vl = n_vl
        for j in vlprint:
            if n_vl == j:
                p_vl = vlprint[j]
                break
            # fi
        # rof
        pr = pr + 'volumes {}\n'.format(p_vl)
        pv = True
    # fi

    for voice in range(1, len(vl)+1):
        if args.voices and args.voices != '':
            if str(voice) not in voices_to_do:
                continue
            # fi
        # fi
        if m in vinstrument[voice]:
            stri = ''
            if vinstrument[voice][m] in instruments.values():
                for x in instruments:
                    if vinstrument[voice][m] == instruments[x]:
                        stri = x
                        break
                    # fi
                # rof
            # fi
            if stri == '':
                for x in drum_sounds:
                    if vinstrument[voice][m] == x:
                        stri = x
                        break
                    # fi
                # rof
            # fi
            n_instrument.append('instrument {} {}'.format(voice, vinstrument[voice][m]))
        else:
            n_instrument.append('instrument {} Acoustic Grand Piano'.format(voice))
        # fi
    # rof

    if l_instrument != n_instrument or pv:
        if n_instrument != []:
            pr = pr + 'voice   {}\n'.format(len(vl))
            for x in range(0, len(vl)):
                if (x >= len(l_instrument) or l_instrument[x] != n_instrument[x]) and x < len(n_instrument):
                    pr = pr + '{}\n'.format(n_instrument[x])
                # fi
            # rof
        else:
            pr = pr + 'voice   {}\n'.format(len(vl))
        # fi
    # fi

    for voice in range(1, len(vl)+1):
        if args.voices and args.voices != '':
            if str(voice) not in voices_to_do:
                continue
            # fi
        # fi
        if m in key_voice[voice]:
            if l_ky[voice] != key_voice[voice][m]:
                l_ky[voice] = key_voice[voice][m]
                pr = pr + "key     {}  {}\n".format(voice, l_ky[voice])
                # NOTE: key printed out does not reflect new one of xpose. WARNING!
            # fi
        # fi
    # rof

    if l_pitch != pitch[m]:
        l_pitch = pitch[m]
        pr = pr + "pitch   {}\n".format(l_pitch)
    # fi

    if l_tempo != tempo_speed_now[m] or l_t_n_l != tempo_now_note_length[m]:
        l_tempo = tempo_speed_now[m]
        l_t_n_l = tempo_now_note_length[m]
        l = str(Fraction(1.0 / l_t_n_l).limit_denominator(256))
        j = l_tempo
        k = int(l_tempo)
        if (j - float(k)) * 1000 == 0:
            p = str(k)
        else:
            p = l_tempo
        # fi
        pr = pr + "tempo   {},{}\n".format(p, l)
    # fi

    pr = l_txt + pr
    return pr, n_meter, n_clef, n_instrument, n_vl, l_ky, l_tempo, l_t_n_l, l_pitch
# End of print_measure_vh_header

# ----------------------------------------------------------------------------
def print_out_notes_v_or_h(m, print_line):
    global args
    global vl
    global bufs
    global bufs_length
    global bufs_velocity
    global bufs_suffixes
    global args
    global voices_to_do

    if args.vertical:
        txt = ''
        for voice in range(1, len(vl)+1):
            if args.voices and args.voices != '':
                if str(voice) not in voices_to_do:
                    continue
                # fi
            # fi
            if len(bufs[voice][m]) == 0:
                continue
            # fi
            txt = txt + "v{}: ".format(voice)
            for i in range(0, len(bufs[voice][m])):
                if i != 0:
                    txt = txt + ','
                # fi
                l = bufs_length[voice][m][i]
                # NOTDONEYET - bufs_velocity[voice][m][i]
                if l in legal_mc_notes:
                    lth = legal_mc_notes[l]
                else:
                    lth = str(Fraction(l).limit_denominator(256))
                    if '/' in lth or l > 1:
                        lth = '(' + str(l) + ')'
                    # fi
                # fi
                txt = txt + bufs[voice][m][i] + lth + bufs_suffixes[voice][m][i].replace('c', '')
            # rof
            txt = txt + '\n'
        # rof
        print_line = print_line + txt
        return print_line
    # fi
    # else - horizontal

    ml = mlth[1][m]
    for i in range(1, len(vl)+1):
        if args.voices and args.voices != '':
            if str(i) not in voices_to_do:
                continue
            # fi
        # fi
        if m in mlth[i]:
            if mlth[i][m] != ml:
                print_error_no_line("voice#{} measure#{} not same length({}) as 1st({})".format(i, m, mlth[i][m], ml))
            # fi
            ml = max(mlth[i][m], ml)
        else:
            print_error_no_line("voice#{} not in measure#{}".format(i, m))
        # fi
    # rof
    workingtime = [ 0 ]                         # Zero is ignored.
    working= [ 0 ]
    for voice in range(1, len(vl)+1):
        working.append(0)
        workingtime.append(0)
    # rof

    now = 0
    txt = ''
    while now < ml:
        for voice in range(1, len(vl)+1):
            if args.voices and args.voices != '':
                if str(voice) not in voices_to_do:
                    continue
                # fi
            # fi
            if txt != '' or (args.horizontal and voice != 1):
                txt = txt + ','
            # fi
            i = workingtime[voice]
            if i <= now:
                j = working[voice]
                l = bufs_length[voice][m][j]
                # NOTDONEYET - bufs_velocity[voice][m][j]

                if l in legal_mc_notes:
                    lth = legal_mc_notes[l] + bufs_suffixes[voice][m][j].replace('c', '')
                else:
                    lth = str(Fraction(l).limit_denominator(256))
                    if '/' in lth or l > 1:
                        lth = '(' + str(l) + ')'
                    # fi
                    lth = lth + bufs_suffixes[voice][m][j].replace('c', '')
                # fi
                txt = txt + bufs[voice][m][j] + lth
                workingtime[voice] = workingtime[voice] + l
                working[voice] = working[voice] + 1
            # fi
        # rof
        print_line = print_line + txt + '\n'
        txt = ''
        nextmin = 999999
        for voice in range(1, len(vl)+1):
            if args.voices and args.voices != '':
                if str(voice) not in voices_to_do:
                    continue
                # fi
            # fi
            if workingtime[voice] < nextmin:
                nextmin = workingtime[voice]
            # fi
        # rof
        now = nextmin
    # elihw
    return print_line
# End of print_out_notes_v_or_h

# ----------------------------------------------------------------------------
# Vertical and horizontal have:
#   A header (meter, key, title, etc.)
#   voice   #
#   measure xyz
#   meter   x/y
#   clef    abc,def,ghi,jkl,mno,pqr
#   #-- volume  4,5,6,7,6,5
#   tempo   100,4
#   voice   6   30,40,50,60,70,80           $$ needed if volume changes.
#   v1: 3c4, ...
#   vX: ...
#
# NOTE: --voices does not affect this, otherwise it don't work.
def print_out_v_or_h():
    global vl                               # volume levels
    global meas                             # measures
    global args
    global key_default
    global tempo_speed_default
    global default_note_length
    global pitch

    print_output('voice   {}'.format(len(vl)))

    l_meter = ''
    l_clef = []
    l_vl = []
    l_instrument = []
    l_ky = [ '' ]
    for voice in range(1, len(vl)+1):
        l_ky.append(key_default)
    # fi
    l_tempo = tempo_speed_default
    l_t_n_l = default_note_length['']
    print_line = ''
    l_pitch = pitch['']

    bar_print = bars['']

    for i in range(0, len(meas)):
        m = meas[i]
        if args.horizontal and m == meas[0] and len(vl) > 1:
            print_line = print_line + "* 1"
            for j in range(2, len(vl)+1):
                print_line = print_line + ",{:>3s}".format(str(j))
            # rof
            print_line = print_line + '\n'
        # fi

        if m in percents:
            print_line = print_line + '\n'
            for p in percents[m]:
                print_line = print_line + p + '\n'
            # rof
        # fi

        print_line, l_meter, l_clef, l_instrument, l_vl, l_ky, l_tempo, l_t_n_l, l_pitch = print_measure_vh_header(m,
                    l_meter, l_clef, l_instrument, l_vl, print_line, l_ky, l_tempo, l_t_n_l, l_pitch)

        if bar_print != bars[m]:            # Zero-th one is ''.
            print_line = print_line + "bars    {}\n".format(bars[m])
            bar_print = bars[m]
        # fi

        # Print out notes for measure.
        print_line = print_out_notes_v_or_h(m, print_line)

        if m in goto_table and goto_table[m] != '':
            print_line = print_line + 'goto    ' + ','.join(goto_table[m]) + '\n'
        # fi
    # rof
    if print_line != '':
        print_output_no_eol(print_line)
    # fi
    return
# End of print_out_v_or_h

# ----------------------------------------------------------------------------
def print_out_midi1csv_start(voiceon):
    if type(voiceon) is not int:
        print_error("print_out_midi1csv_start - voiceon type is not int ({})".format(type(voiceon)), 'print_out_midi1csv_start')
        print_die("voiceon must be a voice.")
    # fi
    print_output('{}, 0, Start_track'.format(voiceon+1))
        # 121   Reset all Controllers.
    print_output('{}, 0, Control_c, 0, 121, 0'.format(voiceon+1))
    return
# End of print_out_midi1csv_start

# ----------------------------------------------------------------------------
def print_out_midi1csv_end(voiceon, lthworkingmeasures):
    if type(voiceon) is not int:
        print_error("print_out_midi1csv_end - voiceon type is not int ({})".format(type(voiceon)), 'print_out_midi1csv_end')
        print_die("voiceon must be a voice.")
    # fi
    print_output('{}, {}, End_track'.format(voiceon+1, lthworkingmeasures + int(clicks_at_end_of_piece)))
    return
# End of print_out_midi1csv_end

# ----------------------------------------------------------------------------
# Time Signature / meter.
# returns lastmeter printed (which this routine may update).
def print_out_midi1csv_ts(m, voiceon, lthworkingmeasure, last_bar_meter):
    global meas
    global measure_meter

    if last_bar_meter != measure_meter[m]:
        last_bar_meter = measure_meter[m]
        l = last_bar_meter.split('/', 1)
        numerator = l[0]
        denominator = Log2(l[1])
        if denominator.is_integer():
            denominator = int(denominator)
        else:
            denominator = l[1]
            print_error_no_line("meter denominator is not a power of two, leave as {}".format(denominator))
        # fi
        print_output("{}, {}, Time_signature, {}, {}, 48, 8".format(
                voiceon+1, int(round(lthworkingmeasure)), numerator, denominator))
    # fi
    return last_bar_meter
# End of print_out_midi1csv_ts

# ----------------------------------------------------------------------------
# input   m_number, voiceon, lthworkingmeasure, last_instrument, channel, chan
# returns last_instrument_on printed (which this routine may update).
#         channel (which may be updated).
#         chan (which may be updated).
def print_out_midi1csv_instrument(m, voiceon, lthworkingmeasure, last_instrument_on, channel, chan):
    global vinstrument
    global reverb
    global pan
    global intensity
    global meas
    global inst
    global mlth
    global args
    global MIDI_port
    global drums_MIDI_port
    global drum_sounds

    if voiceon not in vinstrument:
        vinstrument[voiceon] = {}
        reverb[voiceon] = {}
        pan[voiceon] = {}
        intensity[voiceon] = {}
    # fi
    if m not in vinstrument[voiceon]:
        vinstrument[voiceon][m] = 'Acoustic Grand Piano'.lower()
        reverb[voiceon][m] = getvar('default_reverb')
        pan[voiceon][m] = getvar('default_pan')
        intensity[voiceon][m] = getvar('default_intensity')
    # fi
    if last_instrument_on != vinstrument[voiceon][m]:
        last_instrument_on = vinstrument[voiceon][m]
        this_drum_on = False
        lit = None
        for q in instruments:
            if q == last_instrument_on:
                lit = instruments[last_instrument_on]
                break
            # fi
        # rof
        if lit is None:
            for q in drum_sounds:
                if q == last_instrument_on:
                    lit = drum_sounds[last_instrument_on]
                    this_drum_on = True
                    break
                # fi
        # rof
        if lit is None:
            print_error_no_line("Instrument {} not found.".format(last_instrument_on))
            return
        # fi
        if not check_voice_staff_in(voiceon, inst):
            set_all_staff_arr(voiceon, {}, inst, 'print_out_midi1csv_instrument')
        # fi
        if last_instrument_on not in inst[voiceon]:
            if this_drum_on:
                # MIDI_port -- channel = 9, get note to play from instruments[last_instrument_on].
                inst[voiceon][last_instrument_on] = [drums_MIDI_port, 9]
                drums_MIDI_port = drums_MIDI_port + 1
                chan = 9
            else:
                chan = channel
                # MIDI_port, channel to use for notes. (chan != 9 to play note as it is.)
                inst[voiceon][last_instrument_on] = [MIDI_port, chan]
                channel = channel + 1
                if channel == 9:
                    channel = 10
                elif channel >= MAXMIDICHANNELS and args.midi1csv:
                    print_error_no_line("Voice {} Instrument {} puts midi channels {} > {}.".format(voiceon, last_instrument_on, channel, MAXMIDICHANNELS))
# There are only 16 channels. No more can be fudged. You can have more instruments, but not channels.
                    MIDI_port = MIDI_port + 1
                # fi
            # fi
        # fi
        q = mlth[voiceon][m]
        [midiport, chan] = inst[voiceon][last_instrument_on]    # previously on this voice.
        if last_instrument_on in instruments:
            lit = instruments[last_instrument_on]
            print_output('{}, {}, Control_c, {}, 0, {}'.format(voiceon+1, lthworkingmeasure, chan, lit[1] >> 5))
            print_output('{}, {}, Control_c, {}, 32, {}'.format(voiceon+1, lthworkingmeasure, chan, lit[1] & 0x1f))
            if not args.fluidsynth:
                print_output('{}, {}, Title_t, "{}"'.format(voiceon+1, lthworkingmeasure, last_instrument_on))
                print_output('{}, {}, MIDI_port, {}'.format(voiceon+1, lthworkingmeasure, midiport))
                print_output('{}, {}, Program_c, {}, {}'.format(voiceon+1, lthworkingmeasure, chan, lit[0]))
            else:
                print_output('{}, {}, Program_c, {}, {}, {}'.format(voiceon+1, lthworkingmeasure, chan, lit[0], lit[1]))
            # fi
        elif last_instrument_on in drum_sounds:
            if not args.fluidsynth:
                print_output('{}, {}, MIDI_port, {}'.format(voiceon+1, lthworkingmeasure, midiport))
                print_output('{}, {}, Program_c, {}, {}'.format(voiceon+1, lthworkingmeasure, 9, 0))
            else:
                print_output('{}, {}, Program_c, {}, {}, {}'.format(voiceon+1, lthworkingmeasure, 9, 0, 0))
            # fi
        else:
            print_error_no_line("instrument not in instruments nor drum_sounds.")
        # fi
#????            # 125   Omni Mode On (and all notes off).
#????            print_output('{}, {}, Control_c, {}, 125, 0'.format(voiceon+1, lthworkingmeasure, chan))
#????            # 127   Set device mode to Polyphonic.
#????            print_output('{}, {}, Control_c, {}, 127, 0'.format(voiceon+1, lthworkingmeasure, chan))
        # 121   Reset all Controllers.
        # print_output('{}, {}, Control_c, {}, 121, 0'.format(voiceon+1, lthworkingmeasure, chan))
        #   7   Volume
        print_output('{}, {}, Control_c, {}, {}, {}'.format(voiceon+1, lthworkingmeasure, chan, 7,
                                                intensity[voiceon][m]))
        #   5   Portamento Time to 0. (No slide between two notes subsequently, without off between.)
        print_output('{}, {}, Control_c, {}, 5, 0'.format(voiceon+1, lthworkingmeasure, chan))
        #  65   Portamento Off. Note: can still portamento - stupid standard.
        print_output('{}, {}, Control_c, {}, 65, 0'.format(voiceon+1, lthworkingmeasure, chan))
        #  68   Legato Off.
        print_output('{}, {}, Control_c, {}, 68, 0'.format(voiceon+1, lthworkingmeasure, chan))
        #  64   Hold Pedal Off
        print_output('{}, {}, Control_c, {}, {}, {}'.format(voiceon+1, lthworkingmeasure, chan, 64, 0))
        #  10   Pan position   64 is center, 0 is hard left, and 127 is hard right.
        print_output('{}, {}, Control_c, {}, {}, {}'.format(voiceon+1, lthworkingmeasure, chan, 10,
                                                pan[voiceon][m]))
        #  91   Reverb Level
        print_output('{}, {}, Control_c, {}, {}, {}'.format(voiceon+1, lthworkingmeasure, chan, 91,
                                                reverb[voiceon][m]))
    # fi
    return last_instrument_on, channel, chan
# End of print_out_midi1csv_instrument

# ----------------------------------------------------------------------------
def print_out_midi1csv_tempo(m, voiceon, lthworkingmeasure, t, l):
    global tempo_speed_default
    global default_note_length
    global tempo_speed_now
    global tempo_now_note_length

    if (m in tempo_speed_now and t != tempo_speed_now[m]) or (m in tempo_now_note_length and l != tempo_now_note_length[m]):
        t = tempo_speed_now[m]
        l = tempo_now_note_length[m]
    else:
        return t, l
    # fi
    if args.fluidsynth:
        print_output("{}, {}, Tempo, {} {}".format(voiceon+1, lthworkingmeasure, t, l))
    else:
        X = int(round((60.0 * 1000000.0) / ((4.0 * l)) / t))
        print_output("{}, {}, Tempo, {}".format(voiceon+1, lthworkingmeasure, X))
    # fi
    return  t, l
# End of print_out_midi1csv_tempo

# ----------------------------------------------------------------------------
def print_out_midi1csv_keysignature(m, voiceon, lthworkingmeasure, last_keysig):
    global key_default
    global key_voice

    if lthworkingmeasure == 0 and m == '':
        if key_default is None or key_default == 'atonal':
            key_default = 0
        # fi
        last_keysig = key_default
        print_output('{}, {}, Key_signature, {}, "major"'.format(voiceon+1, lthworkingmeasure, last_keysig))
    else:
        if voiceon in key_voice and m in key_voice[voiceon] and last_keysig != key_voice[voiceon][m]:
            if key_voice[voiceon][m] is None or key_voice[voiceon][m] == 'atonal':
                key_voice[voiceon][m] = 0
            # fi
            last_keysig = key_voice[voiceon][m]
            print_output('{}, {}, Key_signature, {}, "major"'.format(voiceon+1, lthworkingmeasure, last_keysig))
        # fi
    # fi
    return  last_keysig
# End of print_out_midi1csv_keysignature

# ----------------------------------------------------------------------------
def print_header():
    global header
    global tempo_speed_default
    global default_note_length          # length of a beat (note)
    global args
    global vl
    global bars
    global key_voice
    global key_default
    global measure_meter
    global mlth

    if args.vertical or args.horizontal:
        l = str(Fraction(1.0 / default_note_length['']).limit_denominator(256))
        header = header + "bars    {}\n".format(bars[''])

        j = tempo_speed_default
        k = int(tempo_speed_default)
        if (j - float(k)) * 1000 == 0:
            p = str(k)
        else:
            p = tempo_speed_default
        # fi
        header = header + "tempo   {},{}\n".format(p, l)
        header = header + "key     {}".format(key_default)       # no \n, added when printed.
        for ve in range(1, len(vl) + 1):
            if ve in key_voice and key_voice[ve][''] != key_default:
                header = header + "\nkey     {}  {}".format(ve, key_voice[ve]['']) # No terminating \n.
            # fi
        # rof
    elif args.midi1csv:
    # 0, 0, Header, 1, 7, 480               # 480 = midi ticks per quarter note.
        print_output("0, 0, Header, 1, {}, {}".format(len(vl)+1, int(round(MIDICLICKSPERQUARTER))))
    # . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
    # First track does all tempo's, time and key signatures, and titles.
        print_out_midi1csv_start(0)
    # . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
    # 1, 0, Title_t, "promenade"
        for t in header:
            print_output('1, 0, Title_t, "{}"'.format(t))
        # rof
    # . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
    # 1, 0, Key_signature, -2, "major"
        last_keysig = print_out_midi1csv_keysignature('' , 0, 0, '')
    # . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
        # Get the voice with the most notes.
        # Does not do goto's, but that's okay enough -- all voices should be filled.
        maxtimelth = 0
        voice = 1
        for i in tlth:
            if maxtimelth < tlth[i]:
                maxtimelth = tlth[i]
                voice = i
            # fi
        # rof
    # . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
    # 1, 0, Time_signature, 4, 2, 48, 8
    # 2, 0, Time_signature, 5, 2, 30, 8
    # 2, 2400, Time_signature, 6, 2, 72, 8
    #           FF 58 04 nn dd cc bb Time Signature
    #       The time signature is expressed as four numbers. nn and dd represent the
    #       numerator and denominator of the time signature as it would be notated.
    #       The denominator is a negative power of two: 2 represents a quarter-note,
    #       3 represents an eighth-note, etc.
    #       The cc parameter expresses the number of MIDI clocks in a metronome click.
    #       The bb parameter expresses the number of notated 32nd-notes in what MIDI
    #       thinks of as a quarter-note (24 MIDI Clocks). This was added because there
    #       are already multiple programs which allow the user to specify that what
    #       MIDI thinks of as a quarter-note (24 clocks) is to be notated as, or
    #       related to in terms of, something else. Therefore, the complete event for
    #       6/8 time, where the metronome clicks every three eighth-notes, but there
    #       are 24 clocks per quarter-note, 72 to the bar, would be (in hex):
    #           FF 58 04 06 03 24 08
    #    4/(2^2)   72
    # . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
        # length of each measure. Index via [voice][measure].
        lthworkingmeasure = 0
        lastmeter = ''
        lasttempospeed = ''
        lasttempo_n_l = ''
        last_keysig = ''

        for v in goto_table:
            goto_variables[v] = 0           # This voice hasn't done any goto's yet.
        # rof

        m_number = 0
        while m_number < len(meas):
            m = meas[m_number]

            lastmeter = print_out_midi1csv_ts(m, 0, lthworkingmeasure, lastmeter)
            lasttempospeed, lasttempo_n_l = print_out_midi1csv_tempo(m , 0, lthworkingmeasure, lasttempospeed, lasttempo_n_l)
            # Do not do instruments here.
            lthworkingmeasure = lthworkingmeasure + mlth[voice][m]

            if m in goto_table:             # If goto exists, process it.
                f = goto_variables[m]
                g = goto_table[m][f]
#++                print_warning_no_line("goto at end measure='{}' value='{}' new_measure='{}'".format(m, f, g))
                if f+1 >= len(goto_table[m]): # If should start over.
                    f = 0
                else:
                    f = f + 1
                # fi
                goto_variables[m] = f
                if g == 'x':
                    m_number = m_number + 1
                else:
                    m_number = meas.index(g)
                # fi
            else:
                m_number = m_number + 1
            # fi
        # elihw
    # . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
        print_out_midi1csv_end(0, lthworkingmeasure)
        return
    elif args.fluidsynth:
        # set audio.coreaudio.device coreaudio
        print_output("0, 0, FS, set audio.driver coreaudio")
        print_output("0, 0, FS, set midi.driver coremidi")
        # set synth.chorus.active off
        # set synth.cpu-cores 2
        print_output("0, 0, FS, unload 1")
        print_output("0, 0, FS, unload 2")
        print_output("0, 0, FS, unload 3")
        print_output("0, 0, FS, unload 4")
        print_output("0, 0, FS, unload 5")
        if args.sf2 != '':
            print_output("0, 0, FS, set synth.default-soundfont \"{}\"".format(args.sf2))
        elif not args.two:
            print_output("0, 0, FS, set synth.default-soundfont /Users/m4/src/GeneralUser_GS/GeneralUser_GS.sf2")
        else:
            print_output("0, 0, FS, set synth.default-soundfont /Users/m4/src/GeneralUser/GeneralUser.sf2")
        # fi
        #-- print_output("0, 0, FS, set synth.gain 0.5")
        print_output("0, 0, FS, set synth.midi-channels 128")
        print_output("0, 0, FS, set synth.verbose 0")
        print_output("0, 0, FS, reset")
        if args.sf2 != '':
            print_output("0, 0, FS, load \"{}\"".format(args.sf2))
        elif not args.two:
            print_output("0, 0, FS, load /Users/m4/src/GeneralUser_GS/GeneralUser_GS.sf2")
        else:
            print_output("0, 0, FS, load /Users/m4/src/GeneralUser/GeneralUser.sf2")
        # fi
        print_output("0, 0, FS, prog 00 000")

        for t in header:
            print_output('0, 0, FS, echo {}'.format(t))
        # rof
        return
    # . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
    else:                                   # ABC format
        header = "%abc\n" + header

        header += "%abc2mtex: yes\n"

        if '' in percents:
            for p in percents['']:
                header = header + p + '\n'
            # rof
        else:
            # Default printing stuff.
            header += "%%pageheight 10.5in\n"
            header += "%%staffwidth 7.0in\n"
            # header += "%%stretchlast no\n"
            header += "%%leftmargin .25in\n"
            header += "%%rightmargin .25in\n"
            header += "%%scale 0.42\n"
            header += "%%vocalfont Times-BoldItalic 13.0\n"
            header += "%%combinevoices 1\n"
        # fi
        # Must be a fraction.
        fdnl = default_note_text_fraction('')
        if fdnl == '1':
            fdnl = '1/1'
        # fi
        header = header + "L:{}\n".format(fdnl)
        if type(tempo_speed_default) is str:
            tempo_speed_default = float(tempo_speed_default)
        # fi
        if type(tempo_speed_default) is float and tempo_speed_default.is_integer():
            tempo_speed_default = int(tempo_speed_default)
        # fi
        header = header + "Q:{}={}\n".format(fdnl, tempo_speed_default)
        if key_default is None or key_default == 'atonal':
            key_default = 'C'
        # fi
        header = header + "K:{}".format(key_default)       # no \n, added when printed.
    # fi
    print_output(header)
    return
# End of print_header

# ----------------------------------------------------------------------------
def print_out_midi1csv_notes():
    global vl                                   # volume levels
    global meas                                 # measures
    global inst
    global tempo_speed_default
    global default_note_length                  # Default note length.
    global tempo_speed_now                      # Beats per minute for each measure.
    global tempo_now_note_length                # Note length for a beat.

    global bufs                                 # Notes.
    global bufs_length                          # Lengths for notes.
    global bufs_suffixes                        # Ties/legato/etc. for notes.
    global bufs_vol                             # Volumes for notes.
    global bufs_intensity

    global goto_table
    global goto_variables

    global pitch                                # Offset note by this amount.

    global args
    global voices_to_do
    global voices_having_notes

    channel = 0                                 # Next midi instrument channel to use.
    chan = 0                                    # The midi channel using now (allows for repeated use).

    for voice in range(1, len(vl) + 1):
        if args.voices and args.voices != '':
            if str(voice) not in voices_to_do:
                continue
            # fi
        # fi
        if not check_voice_staff_in(voice, bufs):
            print_error_no_line("bufs voice dictionary is hosed (m='{}', voice='{}', lthworkingmeasures='{}')".format(m, voice, lthworkingmeasures))
            sys.exit(1)
        # fi

        # Nothing yet ...
        lastmeter = ''                          # Last meter put out.
        l_instrument = None                     # Last instrument for this voice.
        lt = ''                                 # Last tempo number of beats per minute.
        ll = ''                                 # Last tempo note type (whole,half,quarter,...).
        last_keysig = ''                        # Last key signature put out.

        print_out_midi1csv_start(voice)

        # A comment as to which musicomp voice being done.
        print_output('{}, 0, Text_t, "voice {}"'.format(voice+1, voice))

        m_number = 0                            # Start from absolute first (pre-first) measure.
        if m_number >= len(meas):
            print_error_no_line("No measures in song.")
            sys.exit(1)
        # fi
        lthworkingmeasures = 0                  # The time for event to occur.

        for v in goto_table:                    # All goto's in song.
            goto_variables[v] = 0               # This voice hasn't done any goto's yet.
        # rof

        legato_on = False                       # Legato is not on yet.
        last_note_on = ''                       # There is no note that is currently on.
        last_cc11 = 0                           # The last control 11 volume put out for voice.
        last_cc7 = 0                            # The last control 7 volume put out for "channel".
        note_playing = 0                        # There is no note length to '4c4s' rest (staccato/portamento).
        note_length = 0                         # The length of the last note (4c4).
        last_suffixes = ''                      # No ties/legaot/etc. to start with.

        l_instrument, channel, chan = print_out_midi1csv_instrument(meas[m_number], voice, lthworkingmeasures, l_instrument, channel, chan)
        lastmeter = print_out_midi1csv_ts(meas[m_number], voice, lthworkingmeasures, lastmeter)
        last_keysig = print_out_midi1csv_keysignature(meas[m_number], voice, lthworkingmeasures, last_keysig)
        lt, ll = print_out_midi1csv_tempo(meas[m_number], voice, lthworkingmeasures, lt, ll)

#       A comment as to which musicomp measure being done.
        print_output('{}, {}, Text_t, "measure {}"'.format(voice+1, lthworkingmeasures, meas[m_number]))
        while m_number < len(meas):             # While there are measures left to do.
            m = meas[m_number]

            if voice in vl and m in vl[voice]:
                v_vl = vl[voice][m]             # volume level for this voice/measure
            else:
                v_vl = 127                      # Probably a rest, put as full volume.
            # fi
            if voice in intensity and m in intensity[voice]:
                v_intens = intensity[voice][m]  # "channel" volume level for this voice/measure
            else:
                v_intens = [127]                # Probably a rest, put as full volume.
            # fi

            # Starting with first note in measure (i).
            i = 0
            while i < len(bufs[voice][m]):      # while there are notes in measure
                n = bufs[voice][m][i]           # note number
                v = bufs_vol[voice][m][i]       # volume for the next note.
# NOTDONEYET - set_all_staff_arr bufs_intensity
                v_intens = bufs_intensity[voice][m][i]       # "channel" volume for the next note.
                if note_length > 0:             # If there is a previous note to update length, or ...
                    # Crescendo needs current volume and next notes starting volume.
                    if 'c' in last_suffixes:
                        # Do crescendo between lthworkingmeasures and lthworkingmeasures+note_playing.
                        fvol = float(v_vl)      # Previous volume
                        dv = fvol - float(v)    # New volume
                        dinc = dv / float(note_length)
                        for T in range(lthworkingmeasures, lthworkingmeasures + note_playing):
                            # calculate crescendo number. If same as last, continue.
                            fvol = fvol - dinc
                            ivol = int(fvol)
                            if last_cc11 != ivol:
                                if last_note_on != '':
                                    print_output("{}, {}, Control_c, {}, 11, {}".format(voice+1, T, chan, ivol))
                                # fi
                                last_cc11 = ivol
                            # fi
                        # rof
                        if note_playing < note_length:
                            # Must turn off stacatto note before moving lthworkingmeasures.
                            if last_note_on != '':
                                print_output("{}, {}, Note_off_c, {}, {}, {}".format(voice+1, lthworkingmeasures + note_playing, chan, last_note_on, 0))
                            # fi
                            last_note_on = ''
                        # fi
                    # fi
                    lthworkingmeasures = lthworkingmeasures + note_length
                # fi

                if i == 0:
                    l_instrument, channel, chan = print_out_midi1csv_instrument(m, voice, lthworkingmeasures, l_instrument, channel, chan)
                    lastmeter = print_out_midi1csv_ts(m, voice, lthworkingmeasures, lastmeter)
                    last_keysig = print_out_midi1csv_keysignature(m, voice, lthworkingmeasures, last_keysig)
                    lt, ll = print_out_midi1csv_tempo(m, voice, lthworkingmeasures, lt, ll)
                # fi

                # If a rest - no suffixes/volumes/ can be on it.
                last_suffixes = bufs_suffixes[voice][m][i]    # ties/legato/etc. for the next note.
                note_length = bufs_length[voice][m][i]
                note_velocity = bufs_velocity[voice][m][i]

                if n == '0' or n == 0:
                    # If a note is turned on, turn it off.
                    if last_note_on != '':
                        print_output("{}, {}, Note_off_c, {}, {}, {}".format(voice+1, lthworkingmeasures, chan, last_note_on, 0))
                        last_note_on = ''
                    # fi
                    if legato_on:
                        print_output("{}, {}, Control_c, {}, 68, {}".format(voice+1, lthworkingmeasures, chan, 0))
                        legato_on = False
                    # fi
                    # To next note. While loop checks for end of measure.
                    v_vl = bufs_vol[voice][m][i]
# NOTDONEYET - set_all_staff_arr bufs_intensity
                    v_intens = bufs_intensity[voice][m][i]
                    i = i + 1
                    continue
                # fi

                # The note to be turned on then off later.
                try:
                    n = int(n) + pitch[m]
                except:
                    print_error_no_line("v:{} m:{} Not integer: n='{}' pitch='{}'".format(voice, m, n, pitch[m]))
                    break
                # yrt

                if 't' in last_suffixes:    # This note is tied to previous.
                    if legato_on:
                        print_error_no_line("voice {} measure {} - tied note #{} ({}, {}) coming from a legato playing note ({}, {}).".format(voice, m, i+1, n, midi_value_to_note_sharp[n], last_note_on, midi_value_to_note_sharp[last_note_on]))
                        print_output("{}, {}, Control_c, {}, 68, {}".format(voice+1, lthworkingmeasures, chan, 0))
                        legato_on = False
                    # fi
                    if n != last_note_on:
                        if last_note_on == '':
                            print_error_no_line("voice {} measure {} - tied note #{} ({}, {}) is not same as '' note?.".format(voice, m, i+1, n, midi_value_to_note_sharp[n]))
                        else:
                            print_error_no_line("voice {} measure {} - tied note #{} ({}, {}) is not same as previous playing note ({}, {}).".format(voice, m, i+1, n, midi_value_to_note_sharp[n], last_note_on, midi_value_to_note_sharp[last_note_on]))
                            print_output("{}, {}, Note_off_c, {}, {}, {}".format(voice+1, lthworkingmeasures, chan, last_note_on, 0))
                        # fi
                        voices_having_notes[voice] = True
                        if l_instrument in instruments:
                            last_note_on = n
                        else:
                            last_note_on = drum_sounds[l_instrument]
                        # fi
                        print_output("{}, {}, Note_on_c, {}, {}, {}".format(voice+1, lthworkingmeasures, chan, last_note_on, note_velocity))
                    # fi
                    # Already on, good.
                else:
                    # We want a note-on here.
                    if legato_on:
                        voices_having_notes[voice] = True
                        if l_instrument in instruments:
                            pass
                        else:
                            n = drum_sounds[l_instrument]
                        # fi
                        print_output("{}, {}, Note_on_c, {}, {}, {}".format(voice+1, lthworkingmeasures, chan, n, note_velocity))
                    # fi
                    if last_note_on != '':                  # If not a rest, or note off.
                        print_output("{}, {}, Note_off_c, {}, {}, {}".format(voice+1, lthworkingmeasures, chan, last_note_on, 0))
                    # fi
                    if not legato_on:
                        voices_having_notes[voice] = True
                        if l_instrument in instruments:
                            last_note_on = n
                        else:
                            last_note_on = drum_sounds[l_instrument]
                        # fi
                        print_output("{}, {}, Note_on_c, {}, {}, {}".format(voice+1, lthworkingmeasures, chan, last_note_on, note_velocity))
                    # fi
                    last_note_on = n
                    # fi
                # fi

                # If legato, turn it on, if not already on.
                if 'l' in last_suffixes:
                    if not legato_on:
                        print_output("{}, {}, Control_c, {}, 68, {}".format(voice+1, lthworkingmeasures, chan, 127))
                        legato_on = True
                    # fi
                else:
                    if legato_on:
                        print_output("{}, {}, Control_c, {}, 68, {}".format(voice+1, lthworkingmeasures, chan, 0))
                        legato_on = False
                    # fi
                # fi

                v_vl = bufs_vol[voice][m][i]
# NOTDONEYET - set_all_staff_arr bufs_intensity
                v_intens = bufs_intensity[voice][m][i]
                if last_cc11 !=  v_vl:
                    if last_note_on != '':
                        print_output("{}, {}, Control_c, {}, 11, {}".format(voice+1, lthworkingmeasures, chan, v_vl))
                    # fi
                    last_cc11 = v_vl
                # fi
                if last_cc7 !=  v_intens:
                    if last_note_on != '':
                        print_output("{}, {}, Control_c, {}, 7, {}".format(voice+1, lthworkingmeasures, chan, v_intens))
                    # fi
                    last_cc7 = v_intens
                # fi

                # note_playing will eventually be when to turn note off.
                note_playing = note_length
                if 's' in last_suffixes:
                    if 'l' in last_suffixes:
                        # Really should be a fixed length from end of note? Might just work without?
                        # note_playing = int(round(29.0 * (note_playing / 30.0)))
                        # note_playing = note_playing - 8
                        note_playing = note_playing - 4
                        legato_on = False
                    else:
                        note_playing = int(note_playing / 2.0)
                    # fi
                # fi

                i = i + 1
            # elihw

            # Go to next measure (or wherever a goto says, if it exists).
            if m in goto_table:
                f = goto_variables[m]
                g = goto_table[m][f]
                f = f + 1
                if f >= len(goto_table[m]):         # If should start over.
                    f = 0
                # fi
                goto_variables[m] = f
                if g == 'x':
                    m_number = m_number + 1
                else:
                    m_number = meas.index(g)
                # fi
            else:
                m_number = m_number + 1
            # fi
            if m_number < len(meas):
                m = meas[m_number]
            else:
                m = 'EOF'
            # fi
#           A comment as to which musicomp measure being done.
            print_output('{}, {}, Text_t, "measure {}"'.format(voice+1, lthworkingmeasures, m))
        # elihw

        # No more notes to turn on -- might be one already on.
        if note_length > 0:             # If there is a previous note to update length, or ...
            # Cannot crescendo to last note - don't have volume -- or do we?
            # Crescendo needs current volume and next notes starting volume.
            if 'c' in last_suffixes:
                # Do crescendo between lthworkingmeasures and lthworkingmeasures+note_playing.
                fvol = float(v_vl)      # Previous volume
                dv = fvol - float(v)    # New volume
                dinc = dv / float(note_length)
                # Use previous values for this one.
                for T in range(lthworkingmeasures, lthworkingmeasures + note_playing):
                    # calculate crescendo number. If same as last, continue.
                    fvol = fvol - dinc
                    if fvol < 1:
                        fvol = 0
                    elif fvol > 126.49:
                        fvol = 127
                    # fi
                    ivol = int(fvol)
                    if last_cc11 !=  ivol:
                        if last_note_on != '':
                            print_output("{}, {}, Control_c, {}, 11, {}".format(voice+1, T, chan, ivol))
                        # fi
                        last_cc11 = ivol
                    # fi
                # rof
                if note_playing < note_length:
                    # Must turn off stacatto note before moving lthworkingmeasures.
                    if last_note_on != '':
                        print_output("{}, {}, Note_off_c, {}, {}, {}".format(voice+1, lthworkingmeasures + note_playing, chan, last_note_on, 0))
                    # fi
                    last_note_on = ''
                # fi
            # fi
        # fi
        lthworkingmeasures = lthworkingmeasures + note_length

        if legato_on:
            legato_on = False
            print_output("{}, {}, Control_c, {}, 68, {}".format(voice+1, lthworkingmeasures, chan, 0))
        # fi
        if last_note_on != '':
            print_output("{}, {}, Note_off_c, {}, {}, {}".format(voice+1, lthworkingmeasures, chan, last_note_on, 0))
            last_note_on = ''
        # fi
        print_out_midi1csv_end(voice, lthworkingmeasures)
    # rof   voice in range
    return
# End of print_out_midi1csv_notes

# ----------------------------------------------------------------------------
global default_little_time
default_little_time = 0.1
global this_time
this_time = []
# ----------------------------------------------------------------------------
global measure_1st_only, fs_other_echo
measure_1st_only = []
fs_other_echo = ''
# ----------------------------------------------------------------------------
def process_fs_check(what, lth, min_next, vtlines, tempo_s, tempo_l):
    global this_time
    global measure_1st_only
    global fs_other_echo

    for voice, lines in vtlines.items():
        v = int(voice)
        if this_time[v] >= len(lines):
            continue
        # fi
        t = lines[this_time[v]].split(' ', 1) # 2 elements
        time = float(t[0])
        while time <= min_next:
            strg = t[1]
            if strg == 'End_track ':
                pass
            elif strg[0:lth] == what:
                really_print_output("{}".format(strg))
            elif strg[0:5] == 'echo ':           # echo "measure xxx"
                if strg[0:14] == 'echo "measure ':
                    if strg not in measure_1st_only:
                        really_print_output("{}".format(strg))
                        measure_1st_only.append(strg)
                    # fi
                elif strg != fs_other_echo:
                    really_print_output("{}".format(strg))
                    fs_other_echo = strg
                # fi
            elif strg[0:7] == 'select ':
                really_print_output("{}".format(strg))
            elif strg[0:4] == 'set ':
                really_print_output("{}".format(strg))
            elif strg[0:6] == 'reset ':
                really_print_output("{}".format(strg))
            elif strg[0:5] == 'load ':
                really_print_output("{}".format(strg))
            elif strg[0:7] == 'unload ':
                really_print_output("{}".format(strg))
            elif strg[0:5] == 'prog ':
                really_print_output("{}".format(strg))
            elif strg[0:6] == 'tempo ':
                x = strg[6:].split()
                if len(x) < 1 or len(x) > 2:
                    print_error_no_line("Tempo needs a speed - line='{}'".format(t))
                elif len(x) == 1:
                    #    1/(### / (60.0 * 1000000.0)) = 60.02400 = t              for l = 4 (quarter note).
                    tempo_s = int(1/(int(x[0]) / (60.0 * 1000000.0)))
                    tempo_l = 4
                else:
                    tempo_s, tempo_l = strg[6:].split()
                # fi
#--                really_print_output("echo tempo {} {}".format(tempo_s, tempo_l))
            elif strg[0:3] == 'cc ':
                break
            elif strg[0:8] == 'noteoff ':
                break
            elif strg[0:7] == 'noteon ':
                break
            else:
                print_error_no_line("Unrecognized - line='{}'".format(t))
                error_now = error_now + 1
                break
            # fi
            this_time[v] += 1
            if this_time[v] >= len(lines):
                break
            # fi
            t = lines[this_time[v]].split(' ', 1) # 2 elements
            time = float(t[0])
        # elihw
    # rof
    return tempo_s, tempo_l
# End of process_fs_check

# ----------------------------------------------------------------------------
# Thinking if we get each of the tracks in csvmidi format, in array, then go
# through them and order by:
    # track, time: In array order for each track.
    #       controls
    #       noteoff
    #       noteon
    # ... is that all that is needed? (And obvious format change.)

def print_out_fluidsynth():
    global array_of_lines
    global this_time
    global default_little_time

    change_name = {
        'Text_t': 'echo',
        'Note_on_c': 'noteon',
        'Note_off_c': 'noteoff',
        'Tempo': 'tempo',
        'Time_signature': 'echo meter',
        'Key_signature': 'echo key',
        'Control_c': 'cc',
        'End_of_file': 'echo End_of_file',
        'Title_t': 'echo Title_t',
        # Track, Time, MIDI_port, Number This meta-event specifies that subsequent events in
        # the Track should be sent to MIDI port (bus) Number, between 0 and 255. This meta-event
        # usually appears at the start of a track with Time zero, but may appear within a track
        # should the need arise to change the port while the track is being played.
#--        'MIDI_port': 'echo MIDI_port',
    }

    v_t_lines = { }
    tempo_s = 60
    tempo_l = 0.5

    max_midi_time = 0

    voices = 0
    for i in array_of_lines:
        # "2, 5280, Note_on_c, 0, 43, 127"
        t = i.split(', ', 3)        # 4 elements.
        t[0] = t[0].strip()
        if t[0] not in v_t_lines:
            v_t_lines[t[0]] = []
        # fi
        if 2 > len(t) or t[2] == "Start_track":
            continue
        # fi
        t[1] = t[1].strip()
        t[2] = t[2].strip()
        if t[2] in change_name:
            t[2] = change_name[t[2]]
#-            if t[2][0:4] == 'echo' or t[3][0:9] == '"measure ' or t[3][0:7] == '"voice ':
#-                continue
#-            # fi
            t[3] = t[3].strip()
        elif t[2] == 'FS':
            t[3] = t[3].strip()
            t[2] = t[3]
            t[3] = ''
        elif t[2] == 'Program_c':
# select chan sfont bank prog
            t[2] = 'select'
            t[3] = t[3].strip()
            s = t[3].split(", ", 2)     # 3 elements - channel, bank, program.
            if s[0] != '9':
                t[3] = '{} 1 {} {}'.format(s[0], s[2], s[1])
            else:
#               select 9 2 128 0  Combination of bank-select and program-change
                t[3] = '{} 1 128 0'.format(s[0])
            # fi
            t[2] = 'select'
        elif t[2] == 'End_track':
            if max_midi_time < float(t[1]):
                max_midi_time = float(t[1])
            # fi
            t.append('')
        else:
            print_error_no_line("Unexpected midi command - t='{}'".format(t))
        # fi
        if voices < int(t[0]):
            voices = int(t[0])
        # fi
        t[3] = t[3].replace(',', '').strip()
        v_t_lines[t[0]].append(t[1] + ' ' + t[2] + ' ' + t[3])
    # rof
    current_time = -1
    this_time = []
    for v in range(0, voices+1):
        this_time.append(0)
    # rof
    while current_time < max_midi_time:
        # Find smallest time difference.
        min_next = max_midi_time + 1
        for voice, lines in v_t_lines.items():
            v = int(voice)
            if this_time[v] >= len(lines):
                continue
            # fi
            t = lines[this_time[v]].split(' ', 1) # 2 elements
            time = float(t[0])
            if min_next > time:
                min_next = time
            # fi
        # rof
        if current_time >= 0 and (min_next - current_time) != 0:
            ms_1000 = float(min_next - current_time)
            if ms_1000 < default_little_time:
                ms_1000 = default_little_time
            else:
                # 480 => 250
                ms_1000 = ms_1000 * 1000.0
                ms_1000 = ms_1000 / ((float(tempo_s)/60.0) * (float(tempo_l) * 4.0))
                ms_1000 = int((ms_1000 / 480.0) * 1000)
                ms_1000 = float(ms_1000) / 1000.0
            # fi
            really_print_output("sleep {}".format(ms_1000))
        # fi
        current_time = min_next
        # Move all this_time voices forward past min_next.
    # . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
        tempo_s, tempo_l = process_fs_check('cc ', 3, min_next, v_t_lines, tempo_s, tempo_l)
        tempo_s, tempo_l = process_fs_check('noteoff ', 8, min_next, v_t_lines, tempo_s, tempo_l)
        tempo_s, tempo_l = process_fs_check('noteon ', 7, min_next, v_t_lines, tempo_s, tempo_l)
    # elihw

    really_print_output("quit")
    return
# End of print_out_fluidsynth

# ----------------------------------------------------------------------------
def pre_move_note_before(prev_m, m, voiceon, l, vel, intens, n, a, v):
    global bufs
    global bufs_length
    global bufs_velocity
    global bufs_vol
    global bufs_intensity
    global bufs_suffixes
    global mlth                         # measure length dictionary
    global tlth

    bufs[voiceon][prev_m].append(n)
    bufs_length[voiceon][prev_m].append(l)
    bufs_velocity[voiceon][prev_m].append(vel)
    bufs_suffixes[voiceon][prev_m].append(a)
    bufs_vol[voiceon][prev_m].append(v)
# NOTDONEYET - set_all_staff_arr bufs_intensity
    bufs_intensity[voiceon][m].append(intens)

    tlth[voiceon] = tlth[voiceon] + l
    if prev_m not in mlth[voiceon]:
        mlth[voiceon][prev_m] = 0
    # fi
    mlth[voiceon][prev_m] = mlth[voiceon][prev_m] + l
    if args.midi1csv or args.fluidsynth:
        setvar('time', mlth[voiceon][prev_m] / (MIDICLICKSPERQUARTER * 4), 0)
    else:
        setvar('time', mlth[voiceon][prev_m], 0)
    # fi
    return
# End of pre_move_note_before

# ----------------------------------------------------------------------------
def pre_shift_measure(prev_m, m):
    global args
    global vl
    global bufs
    global bufs_length
    global bufs_velocity
    global bufs_vol
    global bufs_intensity
    global bufs_suffixes
    global mlth                         # measure length dictionary
    global tlth

    for voice in range(1, len(vl)+1):
        s = args.shift
        if len(bufs[voice][m]) == 0:
            # If nothing in voice for this measure, go to next voice.
            continue
        # fi
        while s > 0:
            l = bufs_length[voice][m][0]       # Length of note.
            vel = bufs_velocity[voice][m][0]   # Velocity of note.
            n = bufs[voice][m][0]              # Note (plus pre and post?).
            a = bufs_suffixes[voice][m][0]      # Ties/legato/etc. -- oh my ...
            v = bufs_vol[voice][m][0]
# NOTDONEYET - set_all_staff_arr bufs_intensity
            intens = bufs_intensity[voice][m][0]
            if l <= s:
                if prev_m is not None:
                    # Move to previous measure.
                    pre_move_note_before(prev_m, m, voice, l, vel, intens, n, a, v)
                else:
                    print_warning("pre_shift_measure - tossing voice='{}' m='{}' n='{}' l='{}' a='{}' v='{}'".  format(voice, m, n, l, a, v), 'pass2')
                # fi
                # Remove from current measure.
                bufs[voice][m].pop(0)
                bufs_length[voice][m].pop(0)
                bufs_velocity[voice][m].pop(0)
                bufs_suffixes[voice][m].pop(0)
                bufs_vol[voice][m].pop(0)
# NOTDONEYET - set_all_staff_arr bufs_intensity
                bufs_intensity[voice][m].pop(0)
                tlth[voice] = tlth[voice] - l
                mlth[voice][m] = mlth[voice][m] - l
                if args.midi1csv or args.fluidsynth:
                    setvar('time', mlth[voice][m] / (MIDICLICKSPERQUARTER * 4), 0)
                else:
                    setvar('time', mlth[voice][m], 0)
                # fi
                s = s - l
                if s > 0:
                    continue
                # fi
                break
            # fi
            # l > s   : Need to break the note into two with a tie -- staccato? Trill? Sequence? *yuck*
            if 's' in a or 'b' in a:
                print_error("pre_shift_measure - cannot break up a staccato note: voice='{}' m='{}' n='{}' l='{}' a='{}' v='{}'".format(voice, m, n, l, a, v), 'pass2')
                return
            # fi
            if n[0] == 's' or n[0] == 't':
                print_error("pre_shift_measure - cannot break up a trill or sequence: voice='{}' m='{}' n='{}' l='{}' a='{}' v='{}'".format(voice, m, n, l, a, v), 'pass2')
                return
            # fi
            if n[0] == 'v' or n[0] == 'c' or n[0] == 'd':
                print_error("pre_shift_measure - cannot break up a vol(), cresc(), or dimin(): voice='{}' m='{}' n='{}' l='{}' a='{}' v='{}'".format(voice, m, n, l, a, v), 'pass2')
                return
            # fi
            if args.vertical:
                if 't' not in a:                    # if not tied, tie this one.
                    a = a + 't'
                # fi
            # fi
            pre_move_note_before(prev_m, m, voice, s, vel, n, a, v)
            # Reduce length in current measure.
            # bufs[voice][m][0]                     # note remains the same.
            bufs_length[voice][m][0] = l - s        # Reduce note length.
# NOTDONEYET - bufs_velocity -- think it is just duplicate... .
            bufs_velocity[voice][m][0] = vel        # velocity remains the same?
            if args.horizontal:
                if 't' not in a:                    # if not tied, tie this one.
                    bufs_suffixes[voice][m][0] = a + 't'
                # fi
            # fi
            # bufs_vol[voice][m][0]                 # volume remains the same.
# NOTDONEYET - bufs_intensity[voice][m][i]  # uh, confused.
            tlth[voice] = tlth[voice] - s           # Length reduced.
            mlth[voice][m] = mlth[voice][m] - s
            setvar('time', mlth[voice][m], 0)
            if args.midi1csv or args.fluidsynth:
                setvar('time', mlth[voice][m] / (MIDICLICKSPERQUARTER * 4), 0)
            else:
                setvar('time', mlth[voice][m], 0)
            # fi
            return
        # elihw
    # rof
    return
# End of pre_shift_measure

# ----------------------------------------------------------------------------
def pre_shift():
    '''
    This routine will shift measures forward (add rest at beginning of song),
    or remove notes/rests from beginning of song -- by args.shift value (float).
    '''
    global vl                               # volume levels
    global meas                             # measures
    global args
    global pitch

    if not args.vertical and not args.horizontal:
        return
    # fi
    if args.shift < 0:
        print_error('Shifting to left (upwards) not done yet -- args.shift={}'.format(args.shift), 'pass2')
    # fi
    # Only for outputting vertical and horizontal format.

    prev_m = None
    for i in range(0, len(meas)):
        m = meas[i]
        pre_shift_measure(prev_m, m)
        prev_m = m
    # rof
    return
# End of pre_shift

# ----------------------------------------------------------------------------
def check_staves_notes_order():
    global staves
    global meas
    global mlth
    global vl
    global bufs_length
    global bufs
    global bufs_suffixes
    global args

    # The idea is to go through the voices in array staves, checking that the
    # first listed one(s) are higher notes than the latter listed ones.
    # This needs to occur something like with the --horizontal option.
    # Perhaps the --midi can be done.
    # I don't know if the --abc can be done.

    for i in range(0, len(meas)):
        m = meas[i]
        ml = mlth[1][m]
        for voice in range(1, len(vl)+1):
            if m in mlth[voice]:
                if mlth[voice][m] != ml:
                    print_error_no_line("staves -- voice#{} measure#{} not same length({}) as 1st({})".format(voice, m, mlth[voice][m], ml))
                # fi
                ml = max(mlth[voice][m], ml)
            else:
                print_error_no_line("staves -- voice#{} not in measure#{}".format(voice, m))
            # fi
        # rof

        workingtime = [ 0 ]                         # Zero is ignored.
        working= [ 0 ]
        for voice in range(1, len(vl)+1):
            working.append(0)
            workingtime.append(0)
        # rof

        now = 0
        while now < ml:
            notes = [ ]
            for voice in range(1, len(vl)+1):
                i = workingtime[voice]
                m4_note = ''
                if i <= now:
                    j = working[voice]
                    l = bufs_length[voice][m][j]

                    if l in legal_mc_notes:
                        lth = legal_mc_notes[l] + bufs_suffixes[voice][m][j]
                    else:
                        lth = str(Fraction(l).limit_denominator(256))
                        if '/' in lth or l > 1:
                            lth = '(' + str(l) + ')'
                        # fi
                        lth = lth + bufs_suffixes[voice][m][j]
                    # fi

                    m4_note = bufs[voice][m][j].strip()
# NOTDONEYET - something does not change volumes ... or No idea what problem is.
                    workingtime[voice] = workingtime[voice] + l
                    working[voice] = working[voice] + 1
                # fi
                if m4_note == '0' or m4_note == 0:
                    m4_note = ''
                # fi
                notes.append(m4_note)
            # rof

            if not (args.vertical or args.horizontal):
                for l in range(0, len(staves)):
                    first = -1
                    for n in range(0, len(staves[l])):
                        try:
                            o = int(staves[l][n]) -1
                        except:
                            print_error_no_line("staves -- m:{} voice='{}' is not an integer.".format(m, staves[l][n]))
                            continue
                        # yrt
                        if o >= len(notes):
                            print_error_no_line("staves -- m:{} voice='{}' not in notes.".format(m, o+1))
                            continue
                        # fi
                        if notes[o] != '' and notes[o] != 0:
                            if first < 0:
                                try:
                                    first_note = int(notes[o]) - xpose[o+1]
                                except:
                                    print_error_no_line("staves -- m:{} Not midi note integer -- note='{}' xpose='{}' ".format(m, notes[o], xpose[o+1]))
                                    break
                                # yrt
                                if first_note not in midi_value_to_note_sharp:
                                    print_error_no_line("staves -- m:{} v{} {} not in midi_value_to_note_sharp".format(m, o+1, first_note))
                                    break
                                # fi
                                n1 = midi_value_to_note_sharp[first_note]
                                first = o
                                continue
                            # fi
                            tn = int(notes[o]) - xpose[o+1]
                            if tn > first_note:
                                n2 = midi_value_to_note_sharp[tn]
                                print_warning_no_line("staves -- m:{} v{} note {}({}) is greater than v{} note {}({})".format(m, o+1, tn, n2, first+1, first_note, n1))
                                break
                        # fi
                    # rof
                # rof
            # fi

            nextmin = 999999
            for voice in range(1, len(vl)+1):
                if workingtime[voice] < nextmin:
                    nextmin = workingtime[voice]
                # fi
            # rof
            now = nextmin
        # elihw
    # rof
    return
# End of check_staves_notes_order

# ----------------------------------------------------------------------------
def check_voices_without_notes():
    global vl
    global voices_having_notes

    for v in vl:
        if v not in voices_having_notes:
            print_warning_no_line("voice {} does not have any notes.".format(v))
        # fi
    # rof
    return
# End of check_voices_without_notes

# ----------------------------------------------------------------------------
def pass2():
    global meas                             # measures
    global args
    global bufs_tie_next
    global bufs_legato_next
    global vl
    global ifdepth
    global macro_defining
    global process_defining
    global loop_defining
    global lmp_executing_number
    global errors_happened
    global goto_table
    global staves
    global in_process_already

    if in_process_already:
        # Delete process from stack.
        set_process_quit()
    # fi
    # Check that song finishes 'reasonably'.
    if ifdepth > 0:
        print_warning_no_line("Inside an if block (depth='{}') when end of file or cstop* reached".format(ifdepth))
    # fi
    if macro_defining is not None:
        print_error_no_line("Inside defining macro {}, no endm reached.".format(macro_name[macro_defining]))
    # fi
    if process_defining is not None:
        print_error_no_line("Inside defining process {}, no endprocess reached.".format(process_name[process_defining]))
    # fi
    if loop_defining is not None:
        print_error_no_line("Inside defining loop {} at line number {}, no endloop reached.".format(loop_defining, loop_location[loop_defining]))
    # fi
    if lmp_executing_number > 0:
        print_error_no_line("Processing {} depth (nesting) is {}.".format(lmp_executing_type[lmp_executing_number], lmp_executing_number))
    # fi

    e = False
    for m in goto_table:                # The measures with a goto in it.
        for g in goto_table[m]:         # The goto measures as arguments.
            if g != 'x':                # "x" is okay, goto next measure.
                if g not in meas:       # unknown measure ...
                    print_error_no_line("Checking goto's values, '{}' not in measures.".format(g))
                    e = True            # Error occurred.
                    errors_happened = errors_happened + 1
                # fi
            # fi
        # rof
    # rof
    if e:
        sys.exit(errors_happened)
    # fi

    # Fix other voices before continuing to process.
    fill_voice_mlth(True, "pass2")             # Need to make measure for other voices up to here "mlth".

    # First get the empty measures to have rests of appropriate length.
    # All measures have all voices with same length -- even if some are rests.
    for i in range(0, len(meas)):
        m = meas[i]
        for voice in range(1, len(vl) +1):
#--            print_debug("m='{}' voice='{}'".format(m,voice))
            rests_in_empty_measure_voices(m, voice)
            if bufs_tie_next[voice] != '':
                print_error_no_line("voice {} ends with a tie".format(voice))
                set_all_staff_arr(voice, '', bufs_tie_next, 'pass2')
            # fi
            set_all_staff_arr(voice, '', bufs_legato_next, 'pass2')
        # rof
    # rof

    if len(staves) != 0:
        if args.vertical or args.horizontal:
            check_staves_notes_order()
        elif args.midi1csv or args.fluidsynth:
            check_staves_notes_order()
        else:       # ABC
            pass
        # fi
    # fi

    if args.shift and args.shift != 0:
        pre_shift()
    # fi

    # Now print out the file.
    print_header()

    if args.vertical or args.horizontal:
        print_out_v_or_h()
    elif args.midi1csv or args.fluidsynth:
        print_out_midi1csv_notes()
        check_voices_without_notes()
    else:       # ABC
        print_out_abc()
        print_output("")
    # fi

    # End of song processing.
    if args.vertical or args.horizontal:
        print_output("cstop*")
    elif args.midi1csv:
        print_output("0, 0, End_of_file")
    elif args.fluidsynth:
        print_output("quit")
        print_out_fluidsynth()
    # else:     # ABC
    # fi
    sys.exit(errors_happened)
# End of pass2

# ----------------------------------------------------------------------------
def delete_one_variable(name, l):
    c = []
    for w in range(0, len(calculate.arrays)):
        if calculate.arrays[w][numarry_name] == name and calculate.arrays[w][numarry_maclevel] == l:
            c.append(w)
        # fi
    # rof
    if c != []:
        c.reverse()
        for w in c:
            del calculate.arrays[w]
        # rof
    # fi
    c = []
    for w in range(0, len(calculate.local_arrays)):
        if calculate.local_arrays[w][numarry_name] == name and calculate.local_arrays[w][numarry_maclevel] == l:
            c.append(w)
        # fi
    # rof
    if c != []:
        c.reverse()
        for w in c:
            del calculate.local_arrays[w]
        # rof
    # fi
    recompute_whichchars()
# End of delete_one_variable

# ----------------------------------------------------------------------------
def delete_executing_variables(l):
    # No lines left, delete macro created variables.
    c = []
    for w in range(0, len(calculate.arrays)):
        if calculate.arrays[w][numarry_maclevel] == l:
            c.append(w)
        # fi
    # rof
    if c != []:
        c.reverse()
        for w in c:
            del calculate.arrays[w]
        # rof
    # fi
    c = []
    for w in range(0, len(calculate.local_arrays)):
        if calculate.local_arrays[w][numarry_maclevel] == l:
            c.append(w)
        # fi
    # rof
    if c != []:
        c.reverse()
        for w in c:
            del calculate.local_arrays[w]
        # rof
    # fi
    recompute_whichchars()
# End of delete_executing_variables

# ----------------------------------------------------------------------------
def get_next_process_line(l):
    global lmp_executing_number
    global lmp_executing_which
    global lmp_executing_type
    global lmp_executing_line
    global lmp_executing_i_line
    global lmp_executing_args
    global lmp_executing_rest_of_line
    global i_line
    global running_process_already
    global in_process_already

#--     print_debug("get_next_process_line - l='{}' lmp_executing_number='{}' lmp_executing_which='{}'".format(l,lmp_executing_number,lmp_executing_which[l]))
#--     print_debug("get_next_process_line - lmp_executing_type='{}' lmp_executing_line='{}'".format(lmp_executing_type[l],lmp_executing_line[l]))
#--     print_debug("get_next_process_line - lmp_executing_i_line='{}'".format(lmp_executing_i_line[l]))
#--     print_debug("get_next_process_line - lmp_executing_args='{}'".format(lmp_executing_args[l]))
#--     print_debug("get_next_process_line - lmp_executing_rest_of_line='{}'".format(lmp_executing_rest_of_line[l]))
#--     print_debug("get_next_process_line - in_process_already='{}' running_process_already='{}'".format(in_process_already,running_process_already))

    if lmp_executing_type[l] != 'process' or not running_process_already:
        print_error("get_next_process_line - lmp_executing_type[l]='{}' != 'process' or running_process_already='{}'".format(lmp_executing_type[l], running_process_already), 'in process')
        in_process_already = False
        running_process_already = False
        return ''
    # fi
    the_process = lmp_executing_which[l]
    linenumber = lmp_executing_line[l]
    lines = process_buffer[the_process]
    if linenumber >= len(lines):
        delete_executing_variables(l)
        retline = lmp_executing_rest_of_line[l]                   # Stuff after this process (if not EOLN)
        running_process_already = False
#--         print_debug("get_next_process_line - done retline='{}' in_process_already='{}' running_process_already='{}'".format(retline,in_process_already, running_process_already))
        return retline
    # fi
    line = lines[linenumber]
    i_line = [ 'process:      {:4d}:'.format(linenumber+1) + line ] # Line as given from process text buffer
    lmp_executing_line[l] = linenumber + 1
    return line
# End of get_next_process_line

# ----------------------------------------------------------------------------
def get_next_macro_line(l):
    global lmp_executing_number
    global lmp_executing_which
    global lmp_executing_type
    global lmp_executing_line
    global lmp_executing_i_line
    global lmp_executing_args
    global lmp_executing_rest_of_line
    global i_line

    the_macro = lmp_executing_which[l]
    linenumber = lmp_executing_line[l]
    lines = macro_buffer[the_macro]
    if linenumber >= len(lines):
        delete_executing_variables(l)
        # Delete rest of macro variables.
        del lmp_executing_which[l]
        del lmp_executing_type[l]
        del lmp_executing_args[l]
        del lmp_executing_line[l]
        del lmp_executing_i_line[l]
        retline = lmp_executing_rest_of_line[l]                   # Stuff after this macro (if not EOLN)
        del lmp_executing_rest_of_line[l]
        lmp_executing_number = lmp_executing_number - 1
        return retline
    # fi
    line = lines[linenumber]
    i_line = [ 'macro:        {:4d}:'.format(linenumber+1) + line ] # Line as given from macro text buffer
    lmp_executing_line[l] = linenumber + 1
    return line
# End of get_next_macro_line

# ----------------------------------------------------------------------------
# Types:
#   a) loop m1=1,10,1
#   b) loop m1=1,10
#   c) loop m1 == 0
#   d) loop                                                # outloop or endloop to get out.

def get_next_loop_line(l):
    global lmp_executing_number
    global lmp_executing_which
    global lmp_executing_type
    global lmp_executing_line
    global lmp_executing_i_line
    global lmp_executing_args
    global lmp_executing_rest_of_line
    global measure_on
    global i_line
    global loop_location
    global loop_increment
    global loop_value_variable
    global loop_final_value
    global loop_endloop_exp
    global loop_buffer
    global loop_number

    the_loop = lmp_executing_which[l]
    linenumber = lmp_executing_line[l]
    lines = loop_buffer[the_loop]
    flag = True                 # True = return line in loop_buffer.
                                # False = done with loop
    if linenumber == 0:
        i = loop_increment[the_loop]
        if i is None:                           # Type c or d.
            if loop_value_variable[the_loop] is not None:       # If not type d.
                # Compute end test.
                s2 = loop_value_variable[the_loop]
                f1, type_error = is_float(s2, is_float_number, False)
                if type_error is not None:
                    print_error(type_error, 'in loop')
                    return ''
                # fi
                if f1 is None:
                    print_error("m:{} loop expression error ('{}')".format(measure_on, s2), 'in loop')
                    return ''
                # fi
                if f1 < 0:                                      # True
                    flag = True
                else:
                    flag = False                                # End of loop!
                # fi
            # fi
        else:                                                   # Type a or b, test end condition.
            s2 = loop_value_variable[the_loop][:-1]             # Toss ending equal sign
            if i < 0:                           # if negative increment
                s2 = s2 + ' < ' + str(loop_final_value[the_loop])
            else:
                s2 = s2 + ' > ' + str(loop_final_value[the_loop])
            # fi
            f1, type_error = is_float(s2, is_float_number, False)
            if type_error is not None:
                print_error(type_error, 'in loop')
                return ''
            # fi
            if f1 is None:
                print_error("m:{} loop expression error ('{}')".format(measure_on, s2), 'in loop')
                return ''
            # fi
            if f1 < 0:                                      # True
                flag = False                                # We are at end of loop
            else:
                flag = True                                 # Not at and of loop, get next line!
            # fi
        # fi
    # fi
    if not flag or linenumber >= len(lines):
        # If end of loop expression, process it.
        if flag and loop_endloop_exp[the_loop] is not None:
            # Compute end test.
            s2 = loop_endloop_exp[the_loop]
            f1, type_error = is_float(s2, is_float_number, False)
            if type_error is not None:
                print_error(type_error, 'in loop')
                return ''
            # fi
            if f1 is None:
                print_error("m:{} endloop expression error ('{}')".format(measure_on, s2), 'endloop')
                return ''
            # fi
            if f1 < 0:                                      # True
                flag = True
            else:
                flag = False                                # End of loop!
            # fi
        # fi
        delete_executing_variables(l)
        if not flag:                                        # END OF LOOP
            # Delete rest of loop variables.
            del lmp_executing_which[l]
            del lmp_executing_type[l]
            del lmp_executing_args[l]
            del lmp_executing_line[l]
            del lmp_executing_i_line[l]
            del lmp_executing_rest_of_line[l]       # No stuff after loop. Ignore it.
            lmp_executing_number = lmp_executing_number - 1

            loop_location.pop()
            loop_increment.pop()
            loop_value_variable.pop()
            loop_final_value.pop()
            loop_endloop_exp.pop()
            loop_buffer.pop()
            loop_number = loop_number - 1
            return ''
        # fi
        i = loop_increment[the_loop]
        if i is not None:                                   # Type a or b.
            s2 = loop_value_variable[the_loop][:-1]             # Toss ending equal sign
            s2 = s2 + '= ' + s2 + ' + ' + str(loop_increment[the_loop])
            # Compute end test.
            f1, type_error = is_float(s2, is_float_number, False)
            if type_error is not None:
                print_error(type_error, 'in loop')
                return ''
            # fi
            if f1 is None:
                print_error("m:{} loop incrementing error ('{}')".format(measure_on, s2), 'in loop')
                return ''
            # fi
            if f1 < 0:                                      # True
                flag = True
            else:
                flag = False                                # End of loop!
            # fi
        # fi
        lmp_executing_line[l] = 0
        return ''
    # fi
    line = lines[linenumber]
    i_line = [ 'loop :        {:4d}:'.format(linenumber+1) + line ] # Line as given from loop text buffer
    lmp_executing_line[l] = linenumber + 1
    return line
# End of get_next_loop_line

# ----------------------------------------------------------------------------
# Get the next line, file, or macro.
# Return:
#   full_line           - the line without $$ comments.
#   commentdollardollar - The $$ comment, with the two dollar signs.

def read_next_line():
    global i_line
    global linecount
    global args
    global file_name
    global lmp_executing_number
    global lmp_executing_type
    global macro_buffer                 # Array of lines for macro.
    global errors_happened
    global running_process_already

#--     print_debug("read_next_line - lmp_executing_number='{}'".format(lmp_executing_number))
    if lmp_executing_number > 0:
        l = lmp_executing_number
        if lmp_executing_type[l] == 'macro':
            return get_next_macro_line(l), ''
        elif lmp_executing_type[l] == 'loop':
            return get_next_loop_line(l), ''
        elif lmp_executing_type[l] == 'process':
#--             print_debug("read_next_line - in_process_already='{}' running_process_already='{}'".format(in_process_already, running_process_already))
            if running_process_already:
                return get_next_process_line(l), ''
            # fi
        else:
#--             print_debug("read_next_line - lmp_executing_type[{}] ('{}') unknown - internal error".format(l, lmp_executing_type[l]))
            return '', ''
        # fi
    # fi

    full_line = ''
    i_line = []
    while True:
        try:
            if args.rest and len(args.rest) >= 1:
                line = file_name.readline()
            else:
                if sys.stdin.isatty():
                    if sys.platform == 'darwin':
                        input('input> ')
                        line = readline.get_line_buffer()
                    else:
                        line = input('input> ')
                    # fi
                else:
                    line = sys.stdin.readline()
                # fi
            # fi
            if line is None or line == '':
                sys.exit(errors_happened)
            # fi
            linecount = linecount + 1
            i_line.append('input: {:4d}:'.format(linecount) + line)         # Line as given from input file.
            if line:
                line = line.rstrip()                # trailing spaces gone.
                if line and line[-1] == '\\':       # if continued on next line
                    line = line[:-1]
                    line = line.rstrip()            # trailing spaces gone.
                    full_line += line
                    continue
                # fi
                full_line += line
                commentdollardollar = ''
                if '$$' in full_line:
                    # delete anything from $$ onwards.
                    commentdollardollar = re.sub(r'^.*[$][$]', '$$', full_line, count=1)
                    commentdollardollar = commentdollardollar.rstrip()  # trailing spaces gone
                    full_line = re.sub(r'[$][$].*$', '', full_line)
                # fi
#-- need to know continued line ... 8 spaces or start with a tab.
                i_line.append('input: {:4d}:'.format(linecount) + full_line)            # Line as fixed.
                return full_line, commentdollardollar
            # fi
        except EOFError:
            if full_line != '':
                i_line.append('input: {:4d}:'.format(linecount) + full_line)            # Line as fixed or whatever.
                return full_line, commentdollardollar
            # fi
            pass            # print("Read gave EOF", file=sys.stderr, flush=True)
        except SystemExit:
            if full_line != '':
                i_line.append('input: {:4d}:'.format(linecount) + full_line)            # Line as fixed or whatever.
                return full_line, commentdollardollar
            # fi
            pass            # print("Read gave system exit", file=sys.stderr, flush=True)
        except KeyboardInterrupt:
            print_error_no_line("Read got keyboard interrupt")
        except:
            if full_line != '':
                i_line.append('input: {:4d}:'.format(linecount) + full_line)            # Line as fixed or whatever.
                return full_line, commentdollardollar
            # fi
            print_error_no_line("Read got a processing error")
            print("    ", sys.exc_info()[0], sys.exc_info, file=sys.stderr, flush=True)
        # yrt
        break
    # elihw
    return None, None
# End of read_next_line

# ----------------------------------------------------------------------------
# Calculate values here.
# Input:
#   strg            - The string to compute.
#   type_float      - is_float_number if must be integer.
#                     is_float_string if can return a character var.
#   none_means_none = If true, return '' for None (or not set variable).
# Returns:
#   value      = So far computed value
#   type_error = type of error

def is_float(strg, type_float, none_means_none):
    tree = calculate.parse(strg)            # parse the string
    if tree is None or len(tree) != 2:
        return None, None
    elif tree[0] is None and tree[1] == 'error parsing':
        return strg, tree[1]
    elif tree[0] is not None and tree[0].startswith('ERROR'):
        return strg, tree[0]
#--    elif tree == ['CHAR',  None]:
#--        return '', None
    elif tree[1] is None:
        if none_means_none:
            return '', None
        # fi
        return strg, "is_float -- variable '{}' is not set".format(strg)
    # fi
    elif tree[1] == '.':
        return strg, "bad input to calculator#2"
    # fi
    if type_float == is_float_number:
        try:
            sexpr = float(tree[1])
            if sexpr.is_integer():
                sexpr = int(sexpr)
            # fi
            return sexpr, None
        except:
            return strg, "bad input to calculator#3"
        # yrt
    # fi
    recompute_whichchars()
    return tree[1], None
# End of is_float

# ----------------------------------------------------------------------------
# strg            = String to get value for.
# none_means_none = If true, return '' for None (or not set variable).

def is_anything(strg, none_means_none):
    tree = calculate.parse(strg)            # parse the string
    if tree is None or len(tree) != 2:
        return None, None
    elif tree[0] is None and tree[1] == 'error parsing':
        return strg, tree[1]
    elif tree[0] is not None and tree[0].startswith('ERROR'):
        return strg, tree[0]
    elif tree[0] == 'COMMA':
        return tree[0], tree[1]
    elif tree[1] is None:
        if none_means_none:
            return '', None
        # fi
        return strg, "is_anything -- variable '{}' is not set".format(strg)
    # fi
    elif tree[1] == '.':
        return strg, "bad input to calculator#2"
    # fi
    if type(tree[1]) is str:
        try:
            sexpr = float(tree[1])
            if sexpr.is_integer():
                sexpr = int(sexpr)
            # fi
            return sexpr, None
        except:
            pass
        # yrt
    # fi
    recompute_whichchars()
    sexpr = tree[1]
    if type(sexpr) is float and sexpr.is_integer():
        sexpr = int(sexpr)
    # fi
    return sexpr, None
# End of is_anything

# ----------------------------------------------------------------------------
def put_on_bufs(voiceon, p_meas, prenote, thenote, timeofnote, append_tie, onetimevolume, postnote, original_line):
    global tlth
    global mlth
    global bufs
    global bufs_length
    global bufs_velocity
    global bufs_suffixes
    global bufs_tie_next
    global bufs_legato_next
    global running_vl
    global DECORATIONS
    global args
    global bufs_vol
    global bufs_intensity
    global cresc_direction
    global cresc_time
    global cresc_volume
    global vlprint

    if type(voiceon) is not int:
        print_error("put_on_bufs - voiceon type is not int ({})".format(type(voiceon)), 'put_on_bufs')
        print_die("voiceon must be a voice.")
    # fi
#--     print_debug("put_on_bufs - v#{} m#{} prenote='{}' thenote='{}' timeofnote='{}' append_tie='{}' onetimevolume='{}' postnote='{}'".format(voiceon, p_meas, prenote, thenote, timeofnote, append_tie, onetimevolume, postnote, original_line))
#--     print_debug("#1 bufs='{}'".format(bufs))
#--     print_debug("#1 bufs_vol='{}'".format(bufs_vol))
#--     print_debug("#1 bufs_intensity='{}'".format(bufs_intensity))
#--     print_debug("#1 bufs_length='{}'".format(bufs_length))
#--     print_debug("#1 bufs_velocity='{}'".format(bufs_velocity))
#--     print_debug("#1 bufs_suffixes[{}]='{}'".format(voiceon, bufs_suffixes[voiceon]))
#--     print_debug("#1 bufs_tie_next='{}'".format(bufs_tie_next))
#--     print_debug("#1 bufs_legato_next='{}'".format(bufs_legato_next))
#--     print_debug("#1 cresc_time[voiceon]='{}'".format(cresc_time[voiceon]))

    if type(thenote) is int:
        thenote = str(thenote)
    # fi
    if thenote == 'r' and append_tie != '':
        print_warning("put_on_bufs - voice {} measure {} rest and suffixes='{}'".format(voiceon, p_meas, append_tie), original_line)
        append_tie = ''
    # fi
    tlth[voiceon] = tlth[voiceon] + timeofnote
    if p_meas not in mlth[voiceon]:
        mlth[voiceon][p_meas] = 0
    # fi
    mlth[voiceon][p_meas] = mlth[voiceon][p_meas] + timeofnote
    if args.midi1csv or args.fluidsynth:
        setvar('time', mlth[voiceon][p_meas] / (MIDICLICKSPERQUARTER * 4), 0)
    else:
        setvar('time', mlth[voiceon][p_meas], 0)
    # fi

    if not check_voice_staff_in(voiceon, bufs):
        set_all_staff_arr(voiceon, {}, bufs, original_line)
        set_all_staff_arr(voiceon, {}, bufs_length, original_line)
        set_all_staff_arr(voiceon, {}, bufs_velocity, original_line)
        set_all_staff_arr(voiceon, {}, bufs_suffixes, original_line)
        set_all_staff_arr(voiceon, '', bufs_tie_next, original_line)
        set_all_staff_arr(voiceon, '', bufs_legato_next, original_line)
        set_all_staff_arr(voiceon, {}, bufs_vol, original_line)
        set_all_staff_arr(voiceon, {}, bufs_intensity, original_line)
    # fi
    if onetimevolume is None:
        try:
            if voiceon in running_vl and p_meas in running_vl[voiceon]:
                onetimevolume = running_vl[voiceon][p_meas]
            else:
                onetimevolume = 127                 # Probably a rest, put as full volume.
            # fi
        except:
            print_debug("put_on_bufs - NOTDONEYET - voiceon not integer ({})".format(voiceon))
    # fi
    if p_meas not in bufs[voiceon]:
        bufs_vol[voiceon][p_meas] = [ onetimevolume ]
        if p_meas in intensity[voiceon]:
# NOTDONEYET - set_all_staff_arr bufs_intensity
            bufs_intensity[voiceon][p_meas] = [ intensity[voiceon][p_meas] ]
        else:
# NOTDONEYET - set_all_staff_arr bufs_intensity
            bufs_intensity[voiceon][p_meas] = [ getvar_checkokay('default_intensity', original_line)]
        # fi
        if args.horizontal or args.vertical:
            bufs[voiceon][p_meas] = [prenote + thenote]
            bufs_length[voiceon][p_meas] = [timeofnote]
            bufs_velocity[voiceon][p_meas] = [ getvar_checkokay('default_velocity', original_line) ]
            bufs_suffixes[voiceon][p_meas] = [append_tie]
        elif args.midi1csv or args.fluidsynth:
            bufs[voiceon][p_meas] = [thenote]
            bufs_length[voiceon][p_meas] = [timeofnote]
            bufs_velocity[voiceon][p_meas] = [ getvar_checkokay('default_velocity', original_line) ]
            if cresc_time[voiceon] != 0:
                append_tie = append_tie + 'c'
            # fi
            bufs_suffixes[voiceon][p_meas] = [append_tie]
        else:           # ABC
            bufs[voiceon][p_meas] = prenote + thenote + postnote
        # fi
    else:
        bufs_vol[voiceon][p_meas].append(onetimevolume)
# NOTDONEYET - set_all_staff_arr bufs_intensity
        bufs_intensity[voiceon][p_meas].append(intensity[voiceon][p_meas])
        if args.vertical or args.horizontal:
            bufs[voiceon][p_meas].append(prenote + thenote)
            bufs_length[voiceon][p_meas].append(timeofnote)
            bufs_velocity[voiceon][p_meas].append(getvar_checkokay('default_velocity', original_line))
            bufs_suffixes[voiceon][p_meas].append(append_tie)
        elif args.midi1csv or args.fluidsynth:
            bufs[voiceon][p_meas].append(thenote)
            bufs_length[voiceon][p_meas].append(timeofnote)
            bufs_velocity[voiceon][p_meas].append(getvar_checkokay('default_velocity', original_line))
            if cresc_time[voiceon] != 0:
                append_tie = append_tie + 'c'
            # fi
            bufs_suffixes[voiceon][p_meas].append(append_tie)
        else:           # ABC
            bufs[voiceon][p_meas] = bufs[voiceon][p_meas] + prenote + thenote + postnote
# NOTDONEYET - bufs_velocity
        # fi
    # fi

#--     print_debug("#2 bufs='{}'".format(bufs))
#--     print_debug("#2 bufs_vol='{}'".format(bufs_vol))
#--     print_debug("#2 bufs_intensity='{}'".format(bufs_intensity))
#--     print_debug("#2 bufs_length='{}'".format(bufs_length))
#--     print_debug("#2 bufs_velocity='{}'".format(bufs_velocity))
#--     print_debug("#2 bufs_suffixes[{}]='{}'".format(voiceon, bufs_suffixes[voiceon]))
#--     print_debug("#2 bufs_tie_next='{}'".format(bufs_tie_next))
#--     print_debug("#2 bufs_legato_next='{}'".format(bufs_legato_next))
#--     print_debug("#2 cresc_time[voiceon]='{}'".format(cresc_time[voiceon]))

    # If crescendo happening, do it.
    if cresc_time[voiceon] == 0:
        return
    # fi

    if cresc_time[voiceon] <= timeofnote:
        try:
            running_vl[voiceon][p_meas] = cresc_volume[voiceon]
        except:
            print_debug("put_on_bufs - NOTDONEYET - voiceon not integer ({})".format(voiceon))
        cresc_time[voiceon] = 0
        if args.vertical or args.horizontal or args.midi1csv or args.fluidsynth:
            pass
        else:
            j = vol_to_vlprint_round(cresc_volume[voiceon])
            if cresc_direction[voiceon]:
                k = 'crescendo)'
            else:
                k = 'diminuendo)'
            # fi
            bufs[voiceon][p_meas] = bufs[voiceon][p_meas] + \
                                    DECORATIONS + vlprint[j] + DECORATIONS + \
                                    DECORATIONS + k + DECORATIONS
        # fi
        return
    # fi

    dt = cresc_time[voiceon] + 0.0
    if not args.vertical and not args.horizontal:
        try:
            v = cresc_volume[voiceon] - running_vl[voiceon][p_meas] + 0.0
            x1 = v / dt                         # total  1920/48 = 4
            x2 = x1 * timeofnote                # x2 = x1 * timeofnote
            running_vl[voiceon][p_meas] = running_vl[voiceon][p_meas] + int(x2)
        except:
            print_debug("put_on_bufs - NOTDONEYET - voiceon not integer ({})".format(voiceon))
    # fi
    cresc_time[voiceon] = cresc_time[voiceon] - timeofnote

    return
# End of put_on_bufs

# ----------------------------------------------------------------------------
def instak(voiceon, p_meas, prenote, thenote, timeofnote, append_tie, onenotevolume, postnote, original_line):
    global args

#--     print_debug("instak - v#{} m#{} prenote='{}' thenote='{}' timeofnote='{}' append_tie='{}' onenotevolume='{}' postnote='{}'".format(voiceon, p_meas, prenote, thenote, timeofnote, append_tie, onenotevolume, postnote))

    if type(voiceon) is not int:
        print_error("instak - voiceon type is not int ({}) voiceon='{}'".format(type(voiceon),voiceon), 'instak')
        print_die("voiceon must be a voice.")
    # fi

    if args.midi1csv or args.fluidsynth:
        put_on_bufs(voiceon, p_meas, prenote, thenote,
                    int(round(timeofnote * MIDICLICKSPERQUARTER * 4)), append_tie, onenotevolume,
                    postnote, original_line)
        return
    # fi

    lengthl, lengthf, ifokay = get_time_stak(timeofnote, voiceon, original_line)
    if ifokay == -1:                    # if time is error
        return
    # fi

    j = 1
    q = 0
    if args.horizontal or args.vertical:
        if thenote == 'r':
            append_tie = ''
        # fi
        if ifokay == 1:                 # Did not fit properly.
            q = timeofnote
            put_on_bufs(voiceon, p_meas, prenote, thenote, q, append_tie, onenotevolume, postnote, original_line)
            return
        # fi
    # fi

    for l in lengthl:
        if args.horizontal:
            # Length done elsewise, and suffixes elsewise too.
            q = lengthf[j-1]
            if thenote == 'r':
                append_tie = ''
            # fi
            put_on_bufs(voiceon, p_meas, prenote, thenote, q, append_tie, onenotevolume, postnote, original_line)
            if thenote != 'r':
                append_tie = 't'
            # fi
            j = j + 1
        elif args.vertical:
            q = lengthf[j-1]
            # tie goes on one before
            if j == len(lengthl):           # last one gets passed in append_tie note.
                put_on_bufs(voiceon, p_meas, prenote, thenote, q, append_tie, onenotevolume, postnote, original_line)
            elif j < len(lengthl):
                if thenote == 'r':
                    append_tie = ''
                else:
                    append_tie = 't'
                # fi
                put_on_bufs(voiceon, p_meas, prenote, thenote, q, append_tie, onenotevolume, postnote, original_line)
            # fi
            if thenote == 'r':
                append_tie = ''
            else:
                append_tie = 't'
            # fi
            j = j + 1
        else:           # ABC
            if j != len(lengthl) and thenote != 'z':
                abc_note = thenote + l + '-'
            else:
                abc_note = thenote + l + append_tie
            # fi
            q = lengthf[j-1]
            put_on_bufs(voiceon, p_meas, prenote, abc_note, q, append_tie, onenotevolume, postnote, original_line)
            j = j + 1
        # fi
        prenote = ''
    # rof
    return
# End of instak

# ----------------------------------------------------------------------------
# Make all voices match with rests, etc. The ones we have are now to be processed.
# Need to make measure for all known voices up to here "mlth". (Add rests.)
def fill_voice_mlth(meter_check, original_line):
    global measure_meter_value
    global measure_on
    global vl
    global mlth
    global tlth
    global args
    global meas
    global cis

    maxvoice = len(vl) + 1
    for p_meas in meas:
        m = 0
        for i in range(1, maxvoice):
            if p_meas not in mlth[i]:
                mlth[i][p_meas] = 0
            # fi
            m = max(mlth[i][p_meas], m)
        # rof
        # Put out rests for smaller in measure.
        for i in range(1, maxvoice):
            x = mlth[i][p_meas]            # time short
            l = m - x                       # time short
            nl = x / (MIDICLICKSPERQUARTER * 4.0)
            if meter_check and measure_on == p_meas and measure_meter_value != nl and x != 0 and (args.midi1csv or args.fluidsynth):
                print_warning("fill_voice_mlth - measure='{}' voice='{}' measure_meter_value='{}' nl='{}' x='{}'".format(measure_on, i, measure_meter_value, nl, x), original_line)
            # fi
            if l > 0 :                      # if short, need a rest.
                if cis == 0 and (args.midi1csv or args.fluidsynth):
                    nl = (MIDICLICKSPERQUARTER * 4) / l
                    print_warning("fill_voice_mlth - l='{}' ({}) voice='{}' measure='{}' cis='{}'".format(l, nl, i, p_meas, cis), original_line)
                # fi
                if args.horizontal or args.vertical:
                    instak(i, p_meas, '', 'r', l, '', None, '', original_line)
                elif args.midi1csv or args.fluidsynth:
                    instak(i, p_meas, '', 0, l / (MIDICLICKSPERQUARTER * 4), '', None, '', original_line)
                else:           # ABC
                    instak(i, p_meas, '', 'z', l, '', None, '', original_line)
                # fi
            # fi
        # rof
    # rof
    # Set total for voice to max of all.
    t = 0
    for i in range(1, maxvoice):
        t = max(tlth[i], t)
    # rof
    for i in range(1, maxvoice):
        tlth[i] = t                     # Total for all voices is now max of all.
    # rof
    return
# End of fill_voice_mlth

# ----------------------------------------------------------------------------
# strng         is string where token name is.
# terminator    is the termination character looking for.
# doparens      True if should check parens match.
# original_line for error printing..
#
# Returns where in strng termination is. -1 if not found. 0=first character.

nest_terminator = { '(':')', '{':'}', "'":"'", '"':'"' }

def find_terminator_in_string(strng, terminators, doparens, original_line):
    global measure_on

#--     print_debug("find_terminator_in_string - strng='{}' terminators='{}' doparens='{}'".format(strng,terminators,doparens))
    w = 0
    e = []
    while w < len(strng):
        c = strng[w]
        if c in terminators:
            return w                                # Terminator immediately - blank argument.,
        # fi
        if c in nest_terminator and doparens:
            endterminator = nest_terminator[c]
        else:
            endterminator = None
        # fi
        e.append(endterminator)
        w = w + 1
        if w > len(strng):
            return -1
        # fi
        while endterminator is not None:
            while w < len(strng):
                c = strng[w]
                w = w + 1
                if c == endterminator:
                    break
                # fi
                if endterminator in ['"', "'"]:     # quotes nest nothing.
                    continue
                elif w >= len(strng):
                    if doparens:
                        print_error("nested parenthesis, did not find closing {}.".format(endterminator), original_line)
                        return -1
                    # fi
                    break
                elif c in nest_terminator:
                    endterminator = nest_terminator[c]
                    e.append(endterminator)
                # fi
            # elihw
            e.pop()
            if e != []:
                endterminator = e[-1]
            else:
                endterminator = None
                break
            # fi
        # elihw
    # elihw
    return -1
# End of find_terminator_in_string

# ----------------------------------------------------------------------------
# strng = int_range_to_array(strng, original_line)

def int_range_to_array(strng, original_line):
#--     print_debug("int_range_to_array - strng='{}'".format(strng))
    a = strng.find('..')
    if a == 0:
        print_error("Range does not start with number.", original_line)
        return [str(strng)]
    elif a < 0:                                 # Not a range
#-- NOTDONEYET # volume names as numbers here.
        strng, msg = is_float(strng, is_float_number, False)
        if msg is not None or strng is None:
#--             print_error("First number in range bad. {} '{}'".format(msg, strng), original_line)
            return [str(strng)]
        # fi
        if type(strng) is float and strng.is_integer():
            strng = int(strng)
        # fi
        return [str(strng)]
    # fi
#--    print_die("strng={}".format(strng))
    first = strng[0:a]
    second = strng[a+2:]
#--     print_debug("int_range_to_array - first='{}' second='{}'".format(first,second))
    if second is None or second == '':
        print_error("Second number in range bad.", original_line)
        return [str(strng)]
    # fi
    n, msg = is_float(first, is_float_number, False)
#--     print_debug("int_range_to_array - n='{}' msg='{}'".format(n,msg))
    if msg is not None or n is None or n == '':
        print_error("Range first number bad. {} '{}'".format(msg, first), original_line)
        return [str(strng)]
    # fi
    o, msg = is_float(second, is_float_number, False)
    if msg is not None or o is None or o == '':
        print_error("Range second number bad. {}".format(msg), original_line)
        return [str(strng)]
    # fi
    if type(n) is str:
        n = float(n)
    # fi
    if type(n) is float and n.is_integer():
        first = int(n)
    elif type(n) is not int:
        print_error("Range first number not an integer.", original_line)
        return [str(strng)]
    # fi
    if type(o) is str:
        o = float(o)
    # fi
    if type(o) is float and o.is_integer():
        second = int(o)
    elif type(o) is not int:
        print_error("Range second number not an integer.", original_line)
        return [str(strng)]
    # fi
    array_args = []
    while n < o + 1:
        array_args.append(str(n))
        n = n + 1
    # rof
    return array_args
# End of int_range_to_array

# ----------------------------------------------------------------------------
#   wline         - string to split
#   integers      - True if expect numbers as arguments.
#                 - False if alphanumberic.
#                 - None if voice numbers - staff_name -> voice numbers.
#                 - "volume" or "volumes" for 'f', etc.
#   nospaces      - True if do not split on spaces.
#   original_line - Line for error messages.

def separate_args(wline, integers, nospaces, original_line):
    def b4it(array_args, b4, integers, original_line):
#--         print_debug("b4it - #1 array_args='{}'".format(array_args))
        if b4 == '':
            array_args.append(b4)
#--             print_debug("b4it - #2 array_args='{}'".format(array_args))
        elif integers is None:
            if b4 in staff_name:
                for v in staff_name[b4]:
                    array_args.append(str(v))   # Do staff_name to voice numbers conversions.
#--                     print_debug("b4it - #3 array_args='{}'".format(array_args))
                # rof
            else:                               # maybe voice numbers. :)
                nums = int_range_to_array(b4, original_line)
                array_args = array_args + nums
#--                 print_debug("b4it - #4 array_args='{}'".format(array_args))
            # fi
        elif type(integers) is str:             # volume/volumes command.
            nums = int_range_to_array(b4, original_line)
#--             print_debug("b4it - type(nums)={} nums='{}'".format(type(nums),nums))
            new_nums = []
            for nm in nums:
                if type(nm) is not str:
                    nm = str(nm)
                # fi
                v = get_volume_number(nm, integers, original_line)
#--                 print_debug("b4it - type(v)={} v='{}' b4='{}' type(integers)={} integers='{}'".format(type(v),v,b4,type(integers),integers))
                new_nums.append(v)
            # fi
            array_args = array_args + new_nums
        elif integers:
            nums = int_range_to_array(b4, original_line)
            array_args = array_args + nums
#--             print_debug("b4it - #5 array_args='{}'".format(array_args))
        else:
            array_args.append(b4)
#--             print_debug("b4it - #6 array_args='{}'".format(array_args))
        # fi
#--         print_debug("b4it - #7 array_args='{}'".format(array_args))
        return array_args
    # End of b4it

    global args

#--     print_debug("separate_args - wline='{}' integers='{}' nospaces='{}'".format(wline,integers,nospaces))
    splitter = [ ',', ";" ]
    if args.spaces and not nospaces:
        splitter = splitter + [ ' ', "\t" ]
    # fi
    strng = wline.strip()
    if len(strng) == 0:
        return []
    # fi
    strng = re.sub(r'\s*]', r' ]', strng, count = 1)
    strng = re.sub(r'\s+', r' ', strng)
    strng = re.sub(r'\s*\[', r' [', strng, count = 1)
    strng = re.sub(r'\[\s*', r'[ ', strng, count = 1)
    strng = re.sub(r'\s+', r' ', strng)

    array_args = []
    w = 0
    b4 = ''
#--     print_debug("separate_args - #1 array_args='{}'".format(array_args))
    while w < len(strng):
        s = strng[w:]
        x = find_terminator_in_string(s, splitter, True, original_line)
        # x == -1   end of strng.
        if x < 0:                           # End of strng reached before splitter character found.
            b4 = s
            break
        # fi
        b4 = s[0:x]
        array_args = b4it(array_args, b4, integers, original_line)
#--         print_debug("separate_args - #2 array_args='{}'".format(array_args))
        b4 = ''
        w = w + x + 1
    # elihw

    array_args = b4it(array_args, b4, integers, original_line)
#--     print_debug("separate_args - #3 array_args='{}'".format(array_args))
    return array_args
# End of separate_args

# ----------------------------------------------------------------------------
# Input:
#   cnumber       - macro number (defined in order).
#   t_args        - The arguments (rest of line).
#   original_line - For error messages.

def replace_macro(cnumber, t_args, original_line):
    global macro_name_terminator
    global macro_arguments              # Array of arguments for macro.
    global macro_arg_terminator
    global lmp_executing_number         # If processing macro ... reading from macro buffer.
    global lmp_executing_which          # Which macro being executed. Means cannot reorder. *drats*
    global lmp_executing_args           # Array of arguments given to macro.
    global lmp_executing_line           # Line number in macro array.
    global lmp_executing_i_line
    global i_line

    command = macro_name[cnumber]
    if t_args is None or t_args == '':
        if macro_arguments[cnumber] != []:
            print_error("macro command {} does not have any arguments, but needs {}.".format(command, macro_arguments[cnumber]), original_line)
            return False
        # fi
        wargs = None
    else:
        # Get rid of multiple spaces/tabs.
        t_args = re.sub(r'\s+', r' ', t_args)
        # Get rid of spaces before/after commas/semicolons.
        t_args = re.sub(r'\s*([,;])\s*', r'\1', t_args)
        t_args = re.sub(r'\s*([()\[\]])\s*', r'\1', t_args)
        # Leading spaces before terminators are ignored here.
        while 1 < len(t_args):
            if t_args[0] != ' ' or re.match(r'\w', t_args[1]):
                break
            # fi
            t_args = t_args[1:]
        # elihw
        if t_args[0] != macro_name_terminator[cnumber]:
            if macro_name_terminator[cnumber] == ',' and t_args[0] in [' ', "\t"]:
                pass
            else:
#--                print_error("macro '{}' does not have right terminator ('{}') after name argument, but needs '{}'.".format(command, t_args[0], macro_name_terminator[cnumber]), original_line)
                return False
            # fi
        # fi
        t_args = t_args[1:]
        wargs = []
        n = 0
        # Any extra terminators that are NOT the same as the last (or following) ones may be okay. *UGH*
        err = False
        for a in macro_arguments[cnumber]:
            c = macro_arg_terminator[cnumber][n]
            # End of line terminator (it is known to be the last argument).
            if c is None and (n == len(macro_arg_terminator[cnumber]) - 1) and (t_args or t_args == ''):
                terminator_at = len(t_args)             # CANNOT CHECK, might want those terminators!
            elif c is None and wargs and wargs != '':
#--                print_warning("macro {} does not have right terminator after argument#{}, needs end-of-line".format(command, n+1), original_line)
                return False
            else:
                # Get to terminator here.        NOTDONEYET - the following needs to tokenize and find terminator.
                terminator_at = find_terminator_in_string(t_args, c, True, original_line)
                if terminator_at < 0:
#--                    print_warning("macro {} does not have right terminator after argument#{}, needs '{}'.".format(command, n+1, c), original_line)
                    return False
                # fi
            # fi
            x = t_args[0:terminator_at].strip()
            if a in x:
                print_error("macro '{}' argument '{}' would be recursive with '{}'.".format(command, a, x), original_line)
                err = True
            # fi
            wargs.append(x)
            t_args = t_args[terminator_at + 1:]
            n = n + 1
        # rof
        if err:
            return False
        # fi
    # fi
    if macro_arguments[cnumber] is None:
        l = 0
    else:
        l = len(macro_arguments[cnumber])
    # fi
    if wargs is None:
        w = 0
    else:
        w = len(wargs)
    # fi
    if w != l:
        print_error("macro {} does not have right number of arguments ({}), needs {}.".format(command, len(wargs), len(macro_arguments[cnumber])), original_line)
        return False
    # fi
    level = lmp_executing_number + 1                    # Create variables at next level.
    for a in macro_arguments[cnumber]:                  # Make sure the argument names do not currently exist.
        if not chkvarlevel(a, level):
            print_error("macro {} has variable {} already existing".format(command, a), original_line)
            return False
        # fi
    # fi
    for i in range(0, len(macro_arguments[cnumber])):    # Create them!
        if not createlocalvar(macro_arguments[cnumber][i], wargs[i], level, 1, True):
            print_error("macro {} unable to create variable {}".format(command, macro_arguments[cnumber][i]), original_line)
            return False
        # fi
    # fi
    lmp_executing_which.append(cnumber)
    lmp_executing_type.append('macro')                  # Going into a new macro.
    lmp_executing_args.append(wargs)                    # Save them, although no longer need them. :)
    lmp_executing_line.append(0)                        # First line in buffer.
    lmp_executing_rest_of_line.append(t_args)           # Rest of this line.

    t_line = i_line
    for i in range(0, len(t_line)):                      # Save current depth of line.
       t_line[i] = 'rmacr: ' + t_line[i]
    # rof
    lmp_executing_i_line.append(t_line)                 # Save current depth of line.
    lmp_executing_number = lmp_executing_number + 1
    return True
# End of replace_macro

# ----------------------------------------------------------------------------
def macro_define(command, t_args, original_line):
    global macro_defining               # If defining macro.
    global macro_defining_count
    global macro_buffer                 # Name of macro, array of lines for macro.

    if command in commands and commands[command][0] == do_macro:
        macro_defining_count = macro_defining_count + 1
    elif command in commands and commands[command][0] == do_endm:
        macro_defining_count = macro_defining_count - 1
        if macro_defining_count <= 0:
            commands[command][0](t_args, original_line)              # Process command endm.
            return
        # fi
    # fi
    if t_args and t_args != '':
        if t_args[0] not in [' ', "\t"] and not t_args[0].isalnum():
            macro_buffer[macro_defining].append(command + t_args)
        else:
            macro_buffer[macro_defining].append(command + ' ' + t_args)
        # fi
    else:
        macro_buffer[macro_defining].append(command)
    # fi
    return
# End of macro_define

# ----------------------------------------------------------------------------
def process_define(command, t_args, original_line):
    global process_defining               # If defining process.
    global process_defining_count         # If defining process.
    global process_buffer                 # Name of process, array of lines for process.

    if command in commands and commands[command][0] == do_process:
        process_defining_count = process_defining_count + 1
    elif command in commands and commands[command][0] == do_endprocess:
#--         print_debug("process_define - command='{}' t_args-'{}' do_endprocess".format(command, t_args))
        process_defining_count = process_defining_count - 1
        if process_defining_count <= 0:
            commands[command][0](t_args, original_line)              # Process command endprocess.
#--             print_debug("process_define - return after running command='{}'".format(command))
            return
        # fi
    # fi
    if t_args and t_args != '':
        if t_args[0] not in [' ', "\t"] and not t_args[0].isalnum():
            process_buffer[process_defining].append(command + t_args)
        else:
            process_buffer[process_defining].append(command + ' ' + t_args)
        # fi
    else:
        process_buffer[process_defining].append(command)
    # fi
    return
# End of process_define

# ----------------------------------------------------------------------------
def loop_define(command, t_args, original_line):
    global loop_defining               # If defining loop.
    global loop_defining_count         # If defining loop.
    global loop_buffer                 # Name of loop, array of lines for loop.

    if command in commands and commands[command][0] == do_loop:
        loop_defining_count = loop_defining_count + 1
    elif command in commands and commands[command][0] == do_endloop:
        loop_defining_count = loop_defining_count - 1
        if loop_defining_count <= 0:
            commands[command][0](t_args, original_line)              # Process command endloop.
            return
        # fi
    # fi
    if t_args and t_args != '':
        if t_args[0] not in [' ', "\t"] and not t_args[0].isalnum():
            loop_buffer[loop_defining].append(command + t_args)
        else:
            loop_buffer[loop_defining].append(command + ' ' + t_args)
        # fi
    else:
        loop_buffer[loop_defining].append(command)
    # fi
    return
# End of loop_define

# ----------------------------------------------------------------------------
def process_putd(line):
    global putds

    newline = line[1:]                  # Toss '=' (putd) character.
    for a in putds:
        newline = newline.replace(a, putds[a])
    # rof
    return newline
# End of process_putd

# ----------------------------------------------------------------------------
def to_abc_note(note_number):
    if note_number <= 0 or note_number == '0':
        return 'z'
    # fi
    o = int(note_number / 12)                           # get octave
    n = note_number - (o * 12)                          # note is remainder
    octaves = { 0:',,,', 1:',,', 2:',', 3:'', 4:'', 5:"'", 6:"''", 7:"'''", 8:"''''" }
    notes = { 0:'a', 1:'^a', 2:'b', 3:'c', 4:'^c', 5:'d', 6:'^d', 7:'e', 8:'f', 9:'^f', 10:'g', 11:'^g' }
    if o not in octaves:
        print_debug("to_abc_note({}) bad octave ({})".format(note_number, o))
        return 'z'
    # fi
    if n not in notes:
        print_debug("to_abc_note({}) bad note ({})".format(note_number, n))
        return 'z'
    # fi
    n = notes[n]
    if o <= 3:                                          # uppercase letter
        n = n.upper()
    else:                                               # lowercase letter
        n = n.lower()
    # fi
    o = octaves[o]
    thenote = n + o
    return thenote
# End of to_abc_note

# ----------------------------------------------------------------------------
#   decode  3c+             $$ One argument - sets defaults for voice/staff.
def set_default_ims(t_args, original_line):
    global args
    global measure_on
    global key_sig
    global time
    global key_voice

#--     print_debug("set_default_ims - Entering t_args='{}'".format(t_args))
    nline = replace_character_variables(t_args, original_line).strip()
#--     print_debug("set_default_ims - nline='{}'".format(nline))
    wargs = separate_args(nline, False, True, original_line)

    if not wargs or len(wargs) < 1:
        print_error("no decode arguments", original_line)
        return
    # fi
    if len(wargs) != 1:
        print_error("Not correct number of arguments for set_default_ims commmand", original_line)
        return
    # fi
    voice = getvar_checkokay('voice', original_line)     # Interesting - get last time used. :)
    if type(voice) is int and voice < 1:
        voice = 1
    elif type(voice) is str:
        voice = voice.split(',')
    # fi
    # Save what type of processing we are doing.
    save_current_type = [args.horizontal, args.vertical, args.midi1csv, args.fluidsynth, args.abc]
    savekeyvoice = get_staff_arr_double(voice, measure_on, key_voice, original_line)
    # ------------------------------------------------------------------------------
    if args.vertical or args.horizontal:
        k = key_sig[savekeyvoice]           # Convert to number.
    elif args.midi1csv or args.fluidsynth:
        k = savekeyvoice
    else:                                   # ABC
        # Convert to normal format.
        k = savekeyvoice.lower()
        k = re.sub(r'^([a-g])bb', r'\1--', k)
        k = re.sub(r'^([a-g])b', r'\1-', k)
        k = k.replace('#', '+')             # Does multiple sharps.
        k = k.replace('=', 'n')             # Does multiple naturals.
        k = key_sig[k]                      # Convert to number.
    # fi
    # ------------------------------------------------------------------------------
    # Set to midi format -- so we have a value.
    args.horizontal = False
    args.vertical = False
    args.midi1csv = True
    args.fluidsynth = False
    args.abc = False
    set_staff_arr_double(voice, k, measure_on, key_voice, original_line)

    wnote = wargs[0]
    therest, thenote, typenote = getnote(wnote, voice, True, True, original_line)  # Set defaults.

    # Restore type of processing we are doing.
    args.horizontal, args.vertical, args.midi1csv, args.fluidsynth, args.abc = save_current_type
    set_staff_arr_double(voice, savekeyvoice, measure_on, key_voice, original_line)

    if therest is None or thenote is None:
        print_error("decode note had error with note {}".format(wnote), original_line)
        return
    # fi
    if typenote != normal_note:
        print_error("decode note is not of type normal_note -- ({})".format(typenote), original_line)
        return
    # fi

    # Get the time value for the note.
    timeofnote, r_suffixes, number_dots = get_time(therest, original_line)

    if r_suffixes is None or number_dots is None:
        print_error("decode - Error getting time for note", original_line)
        return
    # fi
    # suffix_legato = 16            -- glide to next note.
    # suffix_tied = 2               -- tied
    # suffix_staccato = 1           -- staccato
    # suffix_dotted = -1
    # suffix_normal = 0
    # bits are $union$'ed together for multiple modifiers.
    # number_dots are how many "d" (dotted) were found.
    if timeofnote is None or timeofnote == 0:
        if number_dots != 0:
            print_error("cannot have dotted syntax on a default note length.", original_line)
            return
        # fi
        v = getvar_checkokay('voice', original_line)     # Interesting - get last time used. :)
        if type(v) is int and v < 1:
            v = 1
        elif type(v) is str:
            v = v.split(',')
        # fi
        timeofnote = get_staff_arr(v, time, 'set_default_ims ' + original_line)
    # fi
    if number_dots != 0:
        p = timeofnote / 2.0
        for i in range(1, number_dots+1):
            timeofnote = timeofnote + p
            p = p / 2.0
        # rof
    # fi
    set_all_staff_arr(voice, timeofnote, time, 'set_default_ims ' + original_line)
    return
# End of set_default_ims

# ----------------------------------------------------------------------------
# Original gsw type decode.
#   decode  m1,3c+          $$ note number for 3c+ into m1
#   decode  m1,m2,3c+4      $$ note number for 3c+ into m1, note length (4) in m2.
#   decode  m1,m2,m3,3c+4l  $$ note number for 3c+ into m1, note length (4) in m2, 16 into m3.

def decode_gsw(t_args, original_line):
    global args
    global measure_on
    global key_sig
    global key_voice

#--     print_debug("decode_gsw - Entering t_args='{}'".format(t_args))
    wargs = separate_args(t_args, False, True, original_line)
    if not wargs or len(wargs) < 1:
        print_error("no decode arguments", original_line)
        return
    # fi
    if len(wargs) > 4 or len(wargs) == 1:
        print_error("Not correct number of arguments for decode commmand", original_line)
        return
    # fi
    voice = getvar_checkokay('voice', original_line)     # Interesting - get last time used. :)
    if type(voice) is int and voice < 1:
        voice = 1
    elif type(voice) is str:
        voice = voice.split(',')
    # fi
    # Save what type of processing we are doing.
#--    print_debug("decode_ims #1 h='{}' v='{}' csv='{}' fs='{}'".format(args.horizontal,args.vertical,args.midi1csv,args.fluidsynth))
    save_current_type = [args.horizontal, args.vertical, args.midi1csv, args.fluidsynth, args.abc]
    savekeyvoice = get_staff_arr_double(voice, measure_on, key_voice, original_line)
    # ------------------------------------------------------------------------------
    if args.vertical or args.horizontal:
        k = key_sig[savekeyvoice]           # Convert to number.
    elif args.midi1csv or args.fluidsynth:
        k = savekeyvoice
    else:                                   # ABC
        # Convert to normal format.
        k = savekeyvoice.lower()
        k = re.sub(r'^([a-g])bb', r'\1--', k)
        k = re.sub(r'^([a-g])b', r'\1-', k)
        k = k.replace('#', '+')             # Does multiple sharps.
        k = k.replace('=', 'n')             # Does multiple naturals.
        k = key_sig[k]                      # Convert to number.
    # fi
    # ------------------------------------------------------------------------------
    # Set to midi format -- so we have a value.
    args.horizontal = False
    args.vertical = False
    args.midi1csv = True
    args.fluidsynth = False
    args.abc = False
    set_staff_arr_double(voice, k, measure_on, key_voice, original_line)

    if len(wargs) == 2:         # decode m1,3c4
        w_note = wargs[1]
    elif len(wargs) == 3:       # decode m1,m2,3c4
        w_note = wargs[2]
    else:                   # 4
        w_note = wargs[3]       # decode m1,m2,m3,3c4
    # fi
#--     print_debug("decode_gsw - calling replace_character_variables")
    nline = replace_character_variables(w_note, original_line).strip()
#--     print_debug("decode_gsw - after replace_character_variables")
    w_note = nline
    # Ignore leading space.
#--     print_debug("decode_gsw #1 h='{}' v='{}' csv='{}' fs='{}'".format(args.horizontal,args.vertical,args.midi1csv,args.fluidsynth))
    therest, thenote, typenote = getnote(w_note, voice, False, True, original_line)

    # Restore type of processing we are doing.
    args.horizontal, args.vertical, args.midi1csv, args.fluidsynth, args.abc = save_current_type
    set_staff_arr_double(voice, savekeyvoice, measure_on, key_voice, original_line)

    if therest is None or thenote is None:
        print_error("decode note had error with note {}".format(w_note), original_line)
        return
    # fi
    if therest and len(therest) > 0 and len(wargs) == 2:
        print_error("decode note has information ({}) after the note {}".format(therest, w_note), original_line)
    # fi
    if typenote != normal_note:
        print_error("decode note is not of type normal_note -- ({})".format(typenote), original_line)
        return
    # fi
    if thenote <= 12 + 12 - 3:
        computeit = wargs[0] + '=' + '0'                       # rest = 0
    else:
        computeit = wargs[0] + '=' + str(thenote) + '+3-12-12'  # Convert from midi note to musicomp value.
    # fi
    value, type_error = is_float(computeit, is_float_number, False)
    if type_error is not None or value is None:
        print_error("decode note unable to assign value({}) to first argument({}).".format(thenote, wargs[0]), original_line)
        return
    # fi
    if len(wargs) < 3:      # 3 or 4 arguments continue.
        return
    # fi

    # Get the time value for the note.
    timeofnote, r_suffixes, number_dots = get_time(therest, original_line)

    if r_suffixes is None or number_dots is None:
        print_error("decode - Error getting time for note", original_line)
        return
    # fi
    # suffix_legato = 16            -- glide to next note.
    # suffix_tied = 2               -- tied
    # suffix_staccato = 1           -- staccato
    # suffix_dotted = -1
    # suffix_normal = 0
    # bits are $union$'ed together for multiple modifiers.
    # number_dots are how many "d" (dotted) were found.
    if timeofnote is None or timeofnote == 0:
        if number_dots != 0:
            print_error("cannot have dotted syntax on a default note length.", original_line)
            return
        # fi
        v = getvar_checkokay('voice', original_line)     # Interesting - get last time used. :)
        if type(v) is int and v < 1:
            v = 1
        elif type(v) is str:
            v = v.split(',')
        # fi
        timeofnote = get_staff_arr(v, time, 'decode_gsw ' + original_line)
    # fi
    if number_dots != 0:
        p = timeofnote / 2.0
        for i in range(1, number_dots+1):
            timeofnote = timeofnote + p
            p = p / 2.0
        # rof
    # fi

    computeit = wargs[1] + '=' + str(timeofnote)    # Should be floating number.
    value, type_error = is_float(computeit, is_float_number, False)
    if type_error is not None or value is None:
        print_error("decode note unable to assign value({}) to second argument({}).".format(timeofnote, wargs[1]), original_line)
        return
    # fi

    if len(wargs) == 3:      # 4 arguments, get suffixes after the note.
        if r_suffixes != 0:
            print_error("decode note has information after the time, suffixes='{}'".format(r_suffixes), original_line)
        # fi
        return
    # fi

    computeit = wargs[2] + '=' + str(r_suffixes)
    value, type_error = is_float(computeit, is_float_number, False)
    if type_error is not None or value is None:
        print_error("decode note unable to assign value({}) to third argument({}).".format(r_suffixes, wargs[2]), original_line)
        return
    # fi
    return
# End of decode_gsw

# ----------------------------------------------------------------------------
# ? decode  note; {octave,notename,sharp,flat,natural,tuplet,notelength,dot},variable; [...]
# -1 if not standard note. Defaults normally apply.
#   l, s, m, t, z, a, aa, g, gg, @W, @X    1 if modifier present, 0 if not, or not a note.
# If staff-line word (which sets till changed):
#   [ ]                     : start/end of chord (1, 0 if not)
#   decode  note; {octave,notename,notenumber,sharp,flat,natural,tuplet,notelength,dot,duration},variable; [...]
# -1 if not standard note. Defaults normally apply.
#   l, s, m, t, z, a, aa, g,gg @W, @X    1 if modifier present, 0 if not, or not a note.
# If staff-line word (which sets till changed):
#   arp, fermata, legato, marcato, staccato, tie, slur, lh, rh
#   [ ]                     : start/end of chord (1, 0 if not)
#   glissando, volumenumber, volumename, crescendo, diminuendo, position, pan,
#   type, treble, bass, soprano, alto, tenor, normal, perc, nohead, oloz, floz,
#   oharm, fharm, trem0, trem1, trem2, trem3, stemsoff, stemson

def decode_ims(t_args, original_line):
    global args
    global measure_on
    global key_sig
    global key_voice

#--     print_debug("decode_ims - Entering t_args='{}'".format(t_args))
    if not t_args:
        print_error("no decode arguments", original_line)
        return
    # fi
    voice = getvar_checkokay('voice', original_line)     # Interesting - get last time used. :)
    if type(voice) is int and voice < 1:
        voice = 1
    elif type(voice) is str:
        voice = voice.split(',')
    # fi

    sg = t_args
    x = []                                                  # Argument list.
    t = []                                                  # Terminator after argument list.
    count = 0
    while len(sg) > 0:
        a = find_terminator_in_string(sg, [';', ','], True, original_line)
        if a < 0:
            break
        # fi
        if (count & 1) == 0:
            if sg[a] != ';':
                print_error("decode needs semi-colon every other argument", original_line)
                return
            # fi
        else:
            if sg[a] != ',':
                print_error("decode needs comma every other argument", original_line)
                return
            # fi
        # fi
        x.append(sg[:a].strip())                            # The argument.
        t.append(sg[a].strip())                             # The terminator.
        sg = sg[a+1:].strip()
        count = count + 1
    # elihw
    if len(sg) > 0:
        x.append(sg.strip())                                # The argument.
        t.append(None)                                      # The terminator.
    # fi

    # Save what type of processing we are doing.
    save_current_type = [args.horizontal, args.vertical, args.midi1csv, args.fluidsynth, args.abc]
# NOTDONEYET - voice is a staff name (or names).
    savekeyvoice = get_staff_arr_double(voice, measure_on, key_voice, original_line)
    # ------------------------------------------------------------------------------
    if args.vertical or args.horizontal:
        k = key_sig[savekeyvoice]           # Convert to number.
    elif args.midi1csv or args.fluidsynth:
        k = savekeyvoice
    else:                                   # ABC
        # Convert to normal format.
        k = savekeyvoice.lower()
        k = re.sub(r'^([a-g])bb', r'\1--', k)
        k = re.sub(r'^([a-g])b', r'\1-', k)
        k = k.replace('#', '+')             # Does multiple sharps.
        k = k.replace('=', 'n')             # Does multiple naturals.
        k = key_sig[k]                      # Convert to number.
    # fi
    # ------------------------------------------------------------------------------
    # Set to horizontal format -- so we have a text 3c+ from getnote.
    args.horizontal = False
    args.vertical = False
    args.midi1csv = True
    args.fluidsynth = False
    args.abc = False
    set_staff_arr_double(voice, k, measure_on, key_voice, original_line)

    w_note = x[0]
#--     print_debug("decode_ims - calling replace_character_variables")
    nline = replace_character_variables(w_note, original_line).strip()
#--     print_debug("decode_ims - after replace_character_variables")
    w_note = nline
#--    print_debug("decode_ims #1 h='{}' v='{}' csv='{}' fs='{}'".format(args.horizontal,args.vertical,args.midi1csv,args.fluidsynth))
#--     print_debug("w_note='{}'".format(w_note))
    therest, midinote, typenote = getnote(w_note, voice, False, True, original_line)
#--     print_debug("decode_ims therest='{}' midinote='{}' typenote='{}'".format(type(therest),type(midinote),type(typenote)))
#--     print_debug("decode_ims therest='{}' midinote='{}' typenote='{}'".format(therest,midinote,typenote))

    # What does key_voice have to me?
    args.horizontal = True
    args.midi1csv = False
    set_staff_arr_double(voice, key_sig_int[k], measure_on, key_voice, original_line)
    a, thenote, b = getnote(w_note, voice, False, True, original_line)

    # Restore type of processing we are doing.
    args.horizontal, args.vertical, args.midi1csv, args.fluidsynth, args.abc = save_current_type
    set_staff_arr_double(voice, savekeyvoice, measure_on, key_voice, original_line)

    if therest is None or thenote is None:
        print_error("decode note had error with note {}".format(w_note), original_line)
        return
    # fi

    # Get the time value for the note.
    timeofnote, r_suffixes, number_dots = get_time(therest, original_line)
    if r_suffixes is None or number_dots is None:
        print_error("decode - Error getting time for note", original_line)
        return
    # fi

    # Follows is not a standard note -- set values to -1.
    note_octave = -1
    note_notename = -1
    note_notenumber = -1                # Set far below.
    note_sharp = -1
    note_flat = -1
    note_natural = -1
    note_tuplet = -1                    # NOTDONEYET
    note_notelength = -1
    note_dot = number_dots
    note_duration = -1                  # Set far below.
#--     print_debug("decode_ims - type(thenote)='{}' thenote='{}'".format(type(thenote),thenote))
    if type(thenote) is str:
        if len(thenote) < 1:
            note_octave = 0
        else:
            note_octave = thenote[0]
            if len(thenote) < 2:
                note_notename = 0
            else:
                note_notename = thenote[1]
            # fi
        # fi
        if len(thenote) > 2:
            sfn = thenote[2:]
            if sfn == '+':
                note_sharp = 1
            elif sfn == '++':
                note_sharp = 2
            elif sfn == '-':
                note_flat = 1
            elif sfn == '--':
                note_flat = 2
            elif sfn == 'n':
                note_natural = 1
            else:
                print_error("decode - sharp/flat/natural unrecognized ('{}')".format(sfn), original_line)
            # fi
        # fi
    # fi
    # The suffixes (after time value).
    note_l = 0
    note_s = 0
    note_m = 0
    note_t = 0
    note_z = 0                              # Same as note_l here. May be NOTDONEYET.
    note_a = 0                              # NOTDONEYET
    note_aa = 0                             # NOTDONEYET
    note_g = 0                              # NOTDONEYET
    note_gg = 0                             # NOTDONEYET
    if (r_suffixes & suffix_legato) != 0:
        note_l = 1
        note_z = 1
    if (r_suffixes & suffix_staccato) != 0:
        note_s = 1
    if (r_suffixes & suffix_marcato) != 0:
        note_m = 1
    if (r_suffixes & suffix_tied) != 0:
        note_t = 1
    if (r_suffixes & suffix_emphasis) != 0:
        note_a = 1
    # fi

# If staff-line word (which sets till changed):
#   arp, fermata, legato, marcato, staccato, tie, slur, lh, rh
#   [ ]                     : start/end of chord (1, 0 if not)
#   type, treble, bass, soprano, alto, tenor, normal, perc, nohead, oloz, floz,
#   oharm, fharm, trem0, trem1, trem2, trem3, stemsoff, stemson
    note_arp = 0                    # NOTDONEYET
    note_fermata = 0                # NOTDONEYET
    note_legato = 0                 # NOTDONEYET
    note_marcato = 0                # NOTDONEYET
    note_staccato = 0               # NOTDONEYET
    note_tie = 0                    # NOTDONEYET
    note_slur = 0                   # NOTDONEYET
    note_lh = 0                     # NOTDONEYET
    note_rh = 0                     # NOTDONEYET
    note_chord_start = 0            # NOTDONEYET
    note_chord_end = 0              # NOTDONEYET [ ] : start/end of chord (1, 0 if not)
    note_glissando = 0              # NOTDONEYET    : Starting pitch of glissando = 1
    note_volumenumber = get_staff_arr_double(voice, measure_on, vl, original_line)
    note_volumename = -1            # Do not do this. : 1 = vfff, 2 = vff ... 8 = vppp. -1 not volume, 0 if numerical.
    note_crescendo = 0              # NOTDONEYET    : crescendo 1 = start of crescendo, 0 if not.
    note_diminuendo = 0             # NOTDONEYET    : 1 = start of diminuendo, 0 if not.
    note_position = 0               # NOTDONEYET    : 0 to 100% (probably 0 to 127) for numerical position (pan value).
    note_pan = get_staff_arr_double(voice, measure_on, pan, original_line)

    note_type = -1                  # Set this later.
    note_treble = 0                 # NOTDONEYET ??
    note_bass = 0                   # NOTDONEYET ??
    note_soprano = 0                # NOTDONEYET ??
    note_alto = 0                   # NOTDONEYET ??
    note_tenor = 0                  # NOTDONEYET ??
    note_normal = 0                 # NOTDONEYET ??
    note_perc = 0                   # NOTDONEYET ??
    note_nohead = 0                 # NOTDONEYET ??
    note_oloz = 0                   # NOTDONEYET ??
    note_floz = 0                   # NOTDONEYET ??
    note_oharm = 0                  # NOTDONEYET ??
    note_fharm = 0                  # NOTDONEYET ??
    note_trem0 = 0                  # NOTDONEYET ??
    note_trem1 = 0                  # NOTDONEYET ??
    note_trem2 = 0                  # NOTDONEYET ??
    note_trem3 = 0                  # NOTDONEYET ??
    note_stemsoff = 0               # NOTDONEYET ??
    note_stemson = 0                # NOTDONEYET ??

    if timeofnote is None or timeofnote == 0:
        timeofnote = get_staff_arr(voice, time, 'decode_ims ' + original_line)
    # fi
    if number_dots != 0:
        p = timeofnote / 2.0
        for i in range(1, number_dots+1):
            timeofnote = timeofnote + p
        p = p / 2.0
        # rof
    # fi
    note_duration = timeofnote      #               : 0.25 if 1/4 note. -1 if not a note.
    note_notenumber = midinote      #               : IMS 48 = 4c, etc. Default 3c=60, as per cyber1 (1978) musicomp.
    if timeofnote == 0:
        q = 0
    else:
        q = 1.0 / timeofnote
        if q.is_integer():
            q = int(q)
        # fi
    # fi
    note_notelength = str(q)
    if typenote != normal_note:
        note_type = -1              # Not a note.
    elif note_notename == 'r' or note_notename == 0 or note_notenumber == 0:
        note_type = 4               # Rest
    else:                           # NOTDONEYET - note_type == 1, for (48,0.25) format type.
        note_type = 0               # Presume 3c4 type of note.
    # fi

    convertit = {
        "octave": note_octave,
        "notename": note_notename,
        "notenumber": note_notenumber,
        "notelength": note_notelength,
        "duration": note_duration,
        "sharp": note_sharp,
        "flat": note_flat,
        "natural": note_natural,
        "tuplet": note_tuplet,
        "dot": note_dot,
        "octave": note_octave,
        "sharp": note_sharp,
        "flat": note_flat,
        "natural": note_natural,
        "l": note_l,
        "s": note_s,
        "m": note_m,
        "t": note_t,
        "z": note_z,
        "a": note_a,
        "aa": note_aa,
        "g": note_g,
        "gg": note_gg,
        "arp": note_arp,
        "fermata": note_fermata,
        "legato": note_legato,
        "marcato": note_marcato,
        "staccato": note_staccato,
        "tie": note_tie,
        "slur": note_slur,
        "lh": note_lh,
        "rh": note_rh,
        "chord_start": note_chord_start,
        "chord_end": note_chord_end,
        "glissando": note_glissando,
        "volumenumber": note_volumenumber,
        "volumename": note_volumename,
        "crescendo": note_crescendo,
        "diminuendo": note_diminuendo,
        "position": note_position,
        "pan": note_pan,
        "type": note_type,
        "treble": note_treble,
        "bass": note_bass,
        "soprano": note_soprano,
        "alto": note_alto,
        "tenor": note_tenor,
        "normal": note_normal,
        "perc": note_perc,
        "nohead": note_nohead,
        "oloz": note_oloz,
        "floz": note_floz,
        "oharm": note_oharm,
        "fharm": note_fharm,
        "trem0": note_trem0,
        "trem1": note_trem1,
        "trem2": note_trem2,
        "trem3": note_trem3,
        "stemsoff": note_stemsoff,
        "stemson": note_stemson,
    }
    for i in range(1, len(x), 2):
#--        orig_x = x[i]
#--        x[i] = replace_character_variables(x[i], original_line).strip()
        if x[i] not in convertit:
            print_error("decode - unknown name ({})".format(x[i]), original_line)
            return
        # fi
        if str(convertit[x[i]]) == '':
            computeit = x[i + 1] + '=' + '0'
        else:
            computeit = x[i + 1] + '=' + str(convertit[x[i]])
        # fi
#--         print_debug("type(computeit)='{}' computeit='{}'".format(type(computeit),computeit))
#--        print_debug("decode_ims - computeit='{}' x[i+1]='{}'".format(computeit,x[i+1]))
        value, type_error = is_float(computeit, is_float_number, False)
#--        print_debug("decode_ims - value='{}' type_error='{}'".format(value,type_error))
        if type_error is not None or value is None:
            print_error("decode note unable to assign value({}) to second argument({}).".format(convertit[x[i]], x[i+1]), original_line)
            return
        # fi
    # rof
    set_staff_arr_double(voice, note_volumenumber, measure_on, vl, original_line)
    set_staff_arr_double(voice, note_pan, measure_on, pan, original_line)
    return
# End of decode_ims

# ----------------------------------------------------------------------------
#       bars    7+1             $$ The first one must be one more than wanted -- due to "measure 0"
#                               $$ setting things line meter up. Dunno, it works.
#       bars    7               $$ Group the next 7 bars on one staff line -- .abc file.

def do_bars(t_args, original_line):
    global bars
    global measure_on
    global precomment

    precomment = precomment + original_line + "\n"   # Comment line.

    if t_args is None or t_args == '':
        print_error("bars does not have an expression to process", original_line)
        return
    # fi

    m = t_args

    f, type_error = is_float(m, is_float_number, False)
    if type_error is not None:
        print_error("bars error - {}".format(type_error), original_line)
        return
    # fi
    if f is None:
        print_error("bars argument as a calculation did not return a value", original_line)
        return
    # fi
    bars[measure_on] = int(round(f))
    # fi
    return
# End of do_bars

# ----------------------------------------------------------------------------
#   calc m1=10          $$ variables m1 to m50.  m(m2)=m9/5   # floating point.
#               Note: special variables stac, grace, frames, pause - don't really mean anything.
#   calc this=m1 * 5 + 6 ** 3 / 19      $$ Define variable "this", m1 is 10, so 266/9 gives 74.
# Note: m(10) is the same as m10.
# Functions:  freq(), neareast(), abs(), arctan(), cos(), exp(), frac(), int(),
#             log(), ln(), round(), sign(), sin(), sqrt(), not()
# Values:     pi, e, tau.
# Priority: =,                                      $$ Assignment.
#           $or$, $and$,                            $$ Logical or / and. (true/false $and$ true/false)
#           >,>=,<,<=,==,!=,                        $$ less than, equal, greater, etc.
#           $union$,$mask$,$diff$,$cls$,$ars$,      $$ bitwise operations.
#           +,-,                                    $$ addition/subtraction
#           /                                       $$ divide
#           *                                       $$ multiply
#           **                                      $$ exponent
#           +,-                                     $$ leading + or -
#           (,[,{, },],)                            $$ Parenthesis

def do_calc(t_args, original_line):
    global lmp_executing_number
    global lmp_executing_which
    global i_line

    if t_args is None or t_args == '':
        print_error("calc does not have an expression to process", original_line)
        return
    # fi

    # expand things after the assignment -- leaving variable before assignment alone - might be function argument name.
    assign = t_args.find('=')
    if assign <= 0:
        print_error("calc does not have a variable followed by an assignment character.", original_line)
        return
    # fi
    variable = t_args[0:assign].strip()         # Toss spaces before and after.    The Variable.
    nvariable = replace_macro_arguments(variable, original_line).strip()
    variable = nvariable
    strng = t_args[assign+1:].strip()           # Toss spaces before and after.    After Assignment.
    nstrng = replace_all_variables(strng, original_line).strip()
    strng = nstrng
    i_line.append('2calc: calc ' + variable + '=' + strng)    # Line as fixed or whatever.
#--    print_debug("do_calc - variable='{}' strng='{}'".format(variable,strng))
    t_args = variable + '=' + strng
#--    print_debug("do_calc - t_args='{}'".format(t_args))

    f, type_error = is_float(t_args, is_float_string, False)
    if type_error is not None:
        print_error("calc error - {}".format(type_error), original_line)
        return
    # fi
    if f is None:
        print_error("calculate did not return a value", original_line)
        return
    # fi
    return
# End of do_calc

# ----------------------------------------------------------------------------
# calcs   inaa,radio=1,6,25,8,react,isotp/8,,14
#                  neg 0 1  2   3        4  5 6

def do_calcs(t_args, original_line):
    if t_args is None or t_args == '':
        print_error("calc does not have an expression to process", original_line)
        return
    # fi
    x = [ ]
    sg = t_args
    termination = None
    while len(sg) > 0:
        a = find_terminator_in_string(sg, [';', ','], True, original_line)
        if a < 0:
            break
        # fi
        x.append(sg[:a])
        termination = sg[a]
        sg = sg[a+1:]
    # elihw
    if termination is not None:
        x.append(sg)
    # fi
    if len(x) < 3:
        print_error("calcs needs at least 3 arguments. x={}".format(x), original_line)
        return
    # fi
    f, type_error = is_float(x[0], is_float_number, False)  # first is expression to choose others.
    if type_error is not None:
        print_error("first expression needs to be an expression - {}".format(type_error), original_line)
        return
    # fi
    if f is None:
        print_error("calcs - calculate did not return a first expression value", original_line)
        return
    # fi
    f = int(round(f))
    if f < 0:
        y = 1                                       # If negative, then next calculation.
    elif f+2 >= len(x):
        y = len(x) - 1
    else:
        y = f + 2
    # fi
    if x[y] is not None and x[y] != '':
        xstore = re.sub(r'=.*', r'', x[1])
        x[1] = re.sub(r'^[^=]=', r'', x[1])

        compu = xstore + '=' + x[y]
        f1, type_error = is_float(compu, is_float_number, False)    # first is expression to choose others.
        if type_error is not None:
            print_error("calcs - position #{} needs to be an expression - {}".format(y, type_error), original_line)
            return
        # fi
        if f1 is None:
            print_error("calcs - calculate did not return expression #{} as a value".format(y), original_line)
            return
        # fi
    # fi
    return
# End of do_calcs

# ----------------------------------------------------------------------------
# calcc      part==3,val=10,val=4,val=6
#                       neg     0     1

def do_calcc(t_args, original_line):
    if t_args is None or t_args == '':
        print_error("calc does not have an expression to process", original_line)
        return
    # fi
    x = [ ]
    sg = t_args
    termination = None
    while len(sg) > 0:
        a = find_terminator_in_string(sg, [';', ','], True, original_line)
        if a < 0:
            break
        # fi
        x.append(sg[:a])
        termination = sg[a]
        sg = sg[a+1:]
    # elihw
    if termination is not None:
        x.append(sg)
    # fi
    if len(x) < 3:
        print_error("calcc needs at least 3 arguments.", original_line)
        return
    # fi
    f, type_error = is_float(x[0], is_float_number, False)  # first is expression to choose others.
    if type_error is not None:
        print_error("first expression needs to be an expression - {}".format(type_error), original_line)
        return
    # fi
    if f is None:
        print_error("calcc - calculate did not return a first expression value", original_line)
        return
    # fi
    # . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
    f = int(round(f))
    if f < 0:
        y = 1                                       # If negative, then next calculation.
    elif f+2 >= len(x):
        y = len(x) - 1
    else:
        y = f + 2
    # fi
    if x[y] is not None and x[y] != '':
        f1, type_error = is_float(x[y], is_float_number, False) # first is expression to choose others.
        if type_error is not None:
            print_error("calcc - position #{} needs to be an expression - {}".format(y, type_error), original_line)
            return
        # fi
        if f1 is None:
            print_error("calcc - calculate did not return expression #{} as a value".format(y), original_line)
            return
        # fi
    # fi
    return
# End of do_calcc

# ----------------------------------------------------------------------------
# change -- rename existing command or copy.
#         change  measure to unit   $$ or:
#         change  command measure to unit

def do_change(t_args, original_line):
    global all_unique_macro_names
    global commands
    global staff_keywords
    global staff_name

    if t_args is None or t_args == '':
        print_error("change does not have three or four arguments.", original_line)
        return
    # fi
    wargs = re.split(r'[ \t]', t_args)
    if wargs is None or len(wargs) < 3 or len(wargs) > 4:
        print_error("change -- there is not three or four arguments.", original_line)
        return
    # fi
    if len(wargs) == 4:
        if wargs[0] != 'command' or wargs[2] != 'to':
            print_error("change -- command is not first argument of four and to is not third.", original_line)
            return
        # fi
        wargs = wargs[1:]
    elif len(wargs) == 3:
        if wargs[1] != 'to':
            print_error("change -- to is not second argument.", original_line)
            return
        # fi
    # fi
    old = wargs[0]
    new = wargs[2]
    # make sure new name does not exist already. -- error
    if new in commands:
        if commands[new] == commands[old]:
            return
        # fi
        print_error("copy new name already exists as different command.", original_line)
    elif new in all_unique_macro_names:
        print_error("change new name already exists as macro.", original_line)
        return
    elif new in staff_keywords:
        print_error("change new name already exists as staff keyword.", original_line)
        return
    elif new in staff_name:
        print_error("change new name already exists as staff name.", original_line)
        return
    # fi
    if old not in commands:
        print_error("change old name does not exist.", original_line)
        return
    # fi
    commands[new] = commands[old]
    del commands[old]
    return
# End of do_change

# ----------------------------------------------------------------------------
#   cis   2             $$ only voice 2 follows. sets volume too.
# Probably do not want to use this.

def do_cis(t_args, original_line):
    global voices               # number of voices
    global cis                  # cis ...
    global vinstrument
    global reverb
    global pan
    global intensity
    global measure_on
    global instruments

    if t_args is None or t_args == '':
        print_error("cis does not have one or two arguments.", original_line)
        return
    # fi

    targs = re.sub(r'\s*,\s*', ',', t_args)

    vargs = targs.split()

    f1, type_error = is_float(vargs[0], is_float_number, False)
    if type_error is not None:
        print_error("cis error - {}".format(type_error), original_line)
        return
    # fi
    if f1 is None:
        print_error("cis does not have first argument as a number.", original_line)
        return
    # fi
    f1 = int(round(f1))
    if f1 < 1  or f1 > MAXVOICES:       # If out of range.
        print_error("number of cis must between 1 and {} inclusive. Not ({})".format(MAXVOICES, f1), original_line)
        return
    # fi

    voices = f1                         # Max voices.
    cis = f1                            # Doing just one voice from now on.

    for i in range(1, cis + 1):
        new_voice_initialize(i, measure_on)
    # rof

    # If there is a second argument, choose instrument for the voice.
    if len(vargs) > 1:
        i = str(vargs[1]).lower()
# NOTDONEYET - Not tested cis and instrument.
# NOTDONEYET - Do drum_sounds here.
# NOTDONEYET - Need to loop through instruments here, then drum_sounds.
        flg = False
        for q in instruments:
            if i == q:
                flg = True
                break
            # fi
        # rof
        if not flg:
            for q in drum_sounds:
                if i == q:
                    flg = True
                    break
                # fi
            # rof
        # fi
        if flg:
# NOTDONEYET - Not tested cis and instrument.
            vinstrument[cis][measure_on] = i
            reverb[cis][measure_on] = int(getvar_checkokay('default_reverb', original_line))
            pan[cis][measure_on] = int(getvar_checkokay('default_pan', original_line))
            intensity[cis][measure_on] = int(getvar_checkokay('default_intensity', original_line))
        else:
            f1, type_error = is_float(i, is_float_number, False)
            if type_error is not None:
                print_error("cis error - {}".format(type_error), original_line)
                return
            # fi
            if f1 is None:
                print_error("cis does not have instrument argument as a number.", original_line)
                return
            # fi
            f1 = int(round(f1))
# NOTDONEYET - Not tested cis and instrument.
# NOTDONEYET - Cannot do drum_sounds here.
            flg = False
            for q in instruments:
                if instruments[q] == [f1, 0]:
                    flg = True
                    break
                # fi
            # rof
            if not flg:
                print_error("instrument value {} not in instrument table.".format(f1), original_line)
                return
            # fi
            vinstrument[cis][measure_on] = q
            reverb[cis][measure_on] = int(getvar_checkokay('default_reverb', original_line))
            pan[cis][measure_on] = int(getvar_checkokay('default_pan', original_line))
            intensity[cis][measure_on] = int(getvar_checkokay('default_intensity', original_line))
        # fi
    # fi
    fill_voice_mlth(False, original_line)               # Need to make measure for all voices up to here "mlth".
    return
# End of do_cis

# ----------------------------------------------------------------------------
#       clef    1,2,3   treble          $$ Set voices 1,2,3 to treble.
#       clef    4       alto
#       clef    treble,bass,alto,tenor  $$ A different way to do it.
# NOTE: The argument is put into the .abc file, and NOT checked in any way.

def do_clef(t_args, original_line):
    global clef
    global measure_on

    if t_args is None or t_args == '':
        print_error("clef does not have arguments.", original_line)
        return
    # fi

    targs = re.sub(r'\s*,\s*', ',', t_args)

    vargs = targs.split()
    if len(vargs) <= 0 or len(vargs) > 2:
        print_error("clef does not have correct number of arguments.", original_line)
        return
    # fi
    if len(vargs) == 1:
        wargs = separate_args(targs, False, True, original_line)
        if not wargs or len(wargs) < 1:
            print_error("no clef selection arguments", original_line)
            return
        # fi
        for i in range(1, len(wargs)+1):
            clef[i][measure_on] = wargs[i-1].strip()   # No checking.
        # rof
        return
    # fi
    clf = vargs[1]

    jkl = "".join(vargs[0])
    wargs = separate_args(jkl, None, True, original_line)   # Allow staff_name and voice numbers.
    if not wargs or len(wargs) < 1:
        print_error("no voice arguments on clef line", original_line)
        return
    # fi
    for w in wargs:
        f1, type_error = is_float(w, is_float_number, False)
        if type_error is not None:
            print_error("clef error - {}".format(type_error), original_line)
            return
        # fi
        if f1 is None:
            print_error("voice {} is not a number.".format(w), original_line)
            return
        # fi
        f1 = int(round(f1))
        clef[f1][measure_on] = clf
    # rof
    return
# End of do_clef

# ----------------------------------------------------------------------------
# Do nothing for a comment.
#         comment Anything What-so-ever to ignore.
#         comment This is a comment $$ really!

def do_comment(t_args, original_line):
    global precomment

    precomment = precomment + original_line + "\n"   # Comment line.
    return
# End of do_comment

# ----------------------------------------------------------------------------
# copy -- make another name for existing name/copy, replace existing with warning.
#         copy    measure to unit   $$ or:
#         copy    command measure to unit

def do_copy(t_args, original_line):
    global all_unique_macro_names
    global commands
    global staff_keywords
    global staff_name

    if t_args is None or t_args == '':
        print_error("copy does not have three or four arguments.", original_line)
        return
    # fi
    wargs = re.split(r'[ \t]', t_args)
    if wargs is None or len(wargs) < 3 or len(wargs) > 4:
        print_error("copy - there is not three or four arguments.", original_line)
        return
    # fi
    if len(wargs) == 4:
        if wargs[0] != 'command' or wargs[2] != 'to':
            print_error("copy - command is not first argument of four and to is not third.", original_line)
            return
        # fi
        wargs = wargs[1:]
    elif len(wargs) == 3:
        if wargs[1] != 'to':
            print_error("copy - to is not second argument.", original_line)
            return
        # fi
    # fi
    old = wargs[0]
    new = wargs[2]
    # make sure new name does not exist already. -- error
    if new in commands and old in commands:
        if commands[new] == commands[old]:
            return
        # fi
        print_error("copy new name already exists as different command.", original_line)
    elif new in all_unique_macro_names:
        print_error("copy new name already exists as macro.", original_line)
        return
    elif new in staff_name:
        print_error("copy new name already exists as staff name.", original_line)
        return
    elif new in staff_keywords:
        print_error("copy new name already exists as staff keyword.", original_line)
        return
    # fi
    if old == '*' or old == '#':
        old = 'comment'
    # fi
    if old not in commands:
        print_error("copy old name does not exist.", original_line)
        return
    # fi
    commands[new] = commands[old]
    return
# End of do_copy

# ----------------------------------------------------------------------------
#       cstart              $$ restart compiling after cstop.
# In the C language, (like #if 0 ... #endif // 0)

def do_cstart(t_args, original_line):
    global cstop_processing

    if not cstop_processing:
        print_error("Not in cstop processing and got a cstart", original_line)
    # fi
    cstop_processing = False
    return
# End of do_cstart

# ----------------------------------------------------------------------------
#       cstop               $$ stop till cstart or cstop* found.
def do_cstop(t_args, original_line):
    global cstop_processing

    cstop_processing = True
    return
# End of do_cstop

# ----------------------------------------------------------------------------
#       cstop*      $$ Do not go beyond this line. Start second pass.

def do_cstopnow(t_args, original_line):
    global errors_happened

    print_error("cstop* processing should be done elsewhere?", original_line)
    pass2()
    sys.exit(errors_happened)
# End of do_cstopnow

# ----------------------------------------------------------------------------
#   decode  3c+             $$ IMS - One argument - sets defaults for voice/staff.
#   decode  m1,3c+          $$ GSW - note number for 3c+ into m1
#   decode  m1,m2,3c+4      $$ GSW - note number for 3c+ into m1, note length (4) in m2.
#   decode  m1,m2,m3,3c+4l  $$ GSW - note number for 3c+ into m1, note length (4) in m2, 16 into m3.
#
# ? decode  note; {octave,notename,sharp,flat,natural,tuplet,notelength,dot},variable; [...]
#
# -1 if not standard note. Defaults normally apply.
#   l, s, m, t, z, a, aa, @W, @X    1 if modifier present, 0 if not, or not a note.
# If staff-line word (which sets till changed):
#   arp, fermata, legato, marcato, staccato, tie, slur, lh, rh
#   [ ]                     : start/end of chord (1, 0 if not)
#   glissando               : Starting pitch of glissando = 1
#   volumenumber            : 0 to 100% (probably here do 0 to 127.
#   volumename              : 1 = vfff, 2 = vff ... 8 = vppp. -1 if not a volume, 0 if numerical.
#   crescendo               : 1 = start of crescendo, 0 if not.
#   diminuendo              : 1 = start of diminuendo, 0 if not.
#   position                : 0 to 100% (probably here do 0 to 127) for numerical position (pan value).
#   pan                     : 1 - start of pan, 0 if not. (Moving between two.) Like cresendo/glissando.
#   notenumber              : IMS 48 = 4c, etc. Default 3c=60, as per cyber1 (1978 era) musicomp.
#   duration                : 0.25 if 1/4 note. -1 if not a note.
# Special: explict (no variable paired with it). Only for encode.

# NOTE: "m3" values are as follows (for first 3 examples above):
#   suffix_emphasis = 32        # Emphasis
#   suffix_legato = 16          # glide to next note - no note attack on start of next note.
#   suffix_broken = 8           # broken - ignored - break between notes ... because gsw didn't have it.
#   suffix_marcato = 4          # ignored -- use vol(sf), etc.
#   suffix_tied = 2             # tied
#   suffix_staccato = 1         # staccato
#   suffix_normal = 0           # No suffix.

def do_decode(t_args, original_line):
    if t_args is None or t_args == '':
        print_error("decode command does not have any arguments.", original_line)
        return
    # fi
    if t_args.find(';') >= 0:            # if IMS format decode command (with pairs)
        decode_ims(t_args, original_line)
    elif t_args.find(',') < 0:          # No arguments - set default values for note
        set_default_ims(t_args, original_line)
    else:
        decode_gsw(t_args, original_line)
    # fi
    return
# End of do_decode

# ----------------------------------------------------------------------------
# Print out a line for debugging.
#   debug                               - Print out a count of debug commands..
#   debug   page                        - Current value of page variable.
#   debug   measure                     - Current value of measure variable.
#   debug   m1*2+7                      - A calculation.
#   debug   we are here                 - A message (not a calculation).

global debug_count
debug_count = 0

def do_debug(t_args, original_line):
    global args
    global debug_count
    global precomment

    precomment = precomment + original_line + "\n"   # Comment line.

    debug_count = debug_count + 1

    message = ''
    if t_args is None or t_args == '':
        message = 'count: ' + str(debug_count)
    else:
        wargs = separate_args(t_args, False, False, original_line)
        if not wargs or len(wargs) < 1:
            message = 'count: ' + str(debug_count)
        else:
            message = 'message: '
            for w in wargs:
                if w is None or w == '':
                    continue
                # fi
                value, type_error = is_float(w, is_float_string, False)
                if message != 'message: ':
                    message = message + ' '
                # fi
                if type_error is not None or value == 'error parsing':
                    if re.match(r'variable .* is not set', type_error):
                        print_warning("w='{}' has type_error='{}'".format(w, type_error), original_line)
                    # fi
                    message = message + str(w)
                elif value is None:
                    print_warning("w='{}' is not set".format(w), original_line)
                    message = message + str(w)
                else:
                    message = message + str(value)
                # fi
            # rof
        # fi
    # fi
    print('DEBUG ' + message, file=sys.stderr, flush=True)
    return
# End of do_debug

# ----------------------------------------------------------------------------
# Not likely to ever do. Would do it differently for MIDI.
#   delay 15            delay in 1/60ths of a second. Like a fermate.  15=1/4th of a second

def do_delay(t_args, original_line):
    global voices                       # number of voices
    global cis                          # if cis active, non-zero.
    global tempo_speed_default
    global default_note_length
    global measure_on
    global tempo_speed_now
    global tempo_now_note_length

    fill_voice_mlth(False, original_line)               # Need to make measure for other voices up to here "mlth".

    if t_args is None or t_args == '':
        print_error("delay command does not have any arguments.", original_line)
        return
    # fi
    wargs = separate_args(t_args, False, True, original_line)
    if not wargs or len(wargs) < 1:
        print_error("no delay arguments", original_line)
        return
    # fi
    value, type_error = is_float(wargs[0], is_float_number, False)
    if type_error is not None or value is None:
        print_error("delay unable to compute value({}).".format(wargs[0]), original_line)
        return
    # fi

    # Convert value/60.0 to note_beats/minute (tempo).
    # tempo_speed_default = 120.0                 # beats per minute.
    # default_note_length[measure_on]     # length of a beat (note)
    # (tempo beats/minute) * (1/60.0 minutes/sec)
    #  (tempo/60.0  beats/sec) * (1/default_note_length[measure_on] = ?_note/beats)
    #  (tempo/(60.0*default_note_length[measure_on]) ?_note/sec)  * seconds
    if measure_on == '':
        rvalue = value * tempo_speed_default / (60.0*default_note_length[measure_on])
    else:
        rvalue = value * tempo_speed_now[measure_on] / (60.0*tempo_now_note_length[measure_on])
    # fi

# NOTDONEYET - staff - this cannot work this way. [horizontal rest line]
# Perhaps, the fill_voice_mlth above, and a rest for last_voice_staff, then fill_voice_mlth again.
    loopstart = 1 if cis == 0 else cis
    r = 'r({}/60.0)'.format(rvalue)
    for onvoice in range(loopstart+1, voices + 1):
        r = r + ',r({}/60.0)'.format(rvalue)
    # rof
# NOTDONEYET - staff - process_staff_notes if last_voice_staff ... .
#--     print_debug("do_delay - calling process_notes_oldway({})".format(r))
    process_notes_oldway(r, original_line)
    return
# End of do_delay

# ----------------------------------------------------------------------------
# octave, note, notelength, midinote, duration, sharps, flats, natural = get_defaults_for_note(t_args, voiceon, original_line)

def get_defaults_for_note(t_args, voiceon, original_line):
    global args
    global measure_on
    global key_sig
    global key_voice

#--    print_debug("get_defaults_for_note #0 t_args='{}' h='{}' v='{}' csv='{}' fs='{}'".format(t_args,args.horizontal,args.vertical,args.midi1csv,args.fluidsynth))
#--    if type(voiceon) is not int:
#--        print_error("get_defaults_for_note - voiceon type is not int ({})".format(type(voiceon)), 'get_defaults_for_note')
#--        print_die("voiceon must be a voice.")
#--    # fi

    # Save what type of processing we are doing.
    save_current_type = [args.horizontal, args.vertical, args.midi1csv, args.fluidsynth, args.abc]
    savekeyvoice = get_staff_arr_double(voiceon, measure_on, key_voice, original_line)
    # ------------------------------------------------------------------------------
    if args.vertical or args.horizontal:
        k = key_sig[savekeyvoice]           # Convert to number.
    elif args.midi1csv or args.fluidsynth:
        k = savekeyvoice
    else:                                   # ABC
        # Convert to normal format.
        k = savekeyvoice.lower()
        k = re.sub(r'^([a-g])bb', r'\1--', k)
        k = re.sub(r'^([a-g])b', r'\1-', k)
        k = k.replace('#', '+')             # Does multiple sharps.
        k = k.replace('=', 'n')             # Does multiple naturals.
        k = key_sig[k]                      # Convert to number.
    # fi
    # ------------------------------------------------------------------------------
    # Set to midi format -- To get the midinote number.
    args.horizontal = False
    args.vertical = False
    args.midi1csv = True
    args.fluidsynth = False
    args.abc = False
    set_staff_arr_double(voiceon, k, measure_on, key_voice, original_line)

    w_note = t_args
#--     print_debug("get_defaults_for_note #1 h='{}' v='{}' csv='{}' fs='{}'".format(args.horizontal,args.vertical,args.midi1csv,args.fluidsynth))
    therest, midinote, typenote = getnote(w_note, voiceon, False, True, original_line)

    # Now do text form of note.
    args.horizontal = True
    args.midi1csv = False
    set_staff_arr_double(voiceon, key_sig_int[k], measure_on, key_voice, original_line)
    a, thenote, b = getnote(w_note, voiceon, False, True, original_line)

    # Restore type of processing we are doing.
    args.horizontal, args.vertical, args.midi1csv, args.fluidsynth, args.abc = save_current_type
    set_staff_arr_double(voiceon, savekeyvoice, measure_on, key_voice, original_line)
    if therest is None or thenote is None:
        print_error("note had error with note {}".format(w_note), original_line)
        return None, 0, 0, 0, 0, 0, 0, 0
    # fi
    if typenote != normal_note:
        print_error("note is not of type normal_note -- ({})".format(typenote), original_line)
        return None, 0, 0, 0, 0, 0, 0, 0
    # fi

    # Get the time value for the note.
    timeofnote, r_suffixes, number_dots = get_time(therest, original_line)
    if r_suffixes is None or number_dots is None:
        print_error("decode - Error getting time for note", original_line)
        return None, 0, 0, 0, 0, 0, 0, 0
    # fi

    note_sharp = note_flat = note_natural = note_octave = -1
    note_notename = ''
    if type(thenote) is str:
        note_octave = thenote[0]
        note_notename = thenote[1]
        if len(thenote) >= 2:
            sfn = thenote[2:]
            if sfn == '+':
                note_sharp = 1
            elif sfn == '++':
                note_sharp = 2
            elif sfn == '-':
                note_flat = 1
            elif sfn == '--':
                note_flat = 2
            elif sfn == 'n':
                note_natural = 1
            elif sfn != '':
                print_error("get_defaults_for_note - sharp/flat/natural unrecognized ('{}')".format(sfn), original_line)
            # fi
        # fi
    # fi
    if timeofnote is None or timeofnote == 0:
        v = getvar_checkokay('voice', original_line)     # Interesting - get last time used. :)
        if type(v) is int and v < 1:
            v = 1
        elif type(v) is str:
            v = v.split(',')
        # fi
        timeofnote = get_staff_arr(v, time, 'get_defaults_for_note ' + original_line)
    # fi
    note_duration = timeofnote      #               : 0.25 if 1/4 note. -1 if not a note.
    note_notenumber = midinote      #               : IMS 48 = 4c, etc. Default 3c=60, as per cyber1 (1978) musicomp.
    if timeofnote == 0:
        q = 0
    else:
        q = 1.0 / timeofnote
        if q.is_integer():
            q = int(q)
        # fi
    # fi
    note_notelength = q

    return note_octave, note_notename, note_notelength, midinote, note_duration, note_sharp, note_flat, note_natural
# End of get_defaults_for_note

# ----------------------------------------------------------------------------
def makeint(value, original_line):
    if type(value) is str:
        try:
            value = float(value)
        except:
            print_error("encode argument value '{}' must be integer".format(value), original_line)
            return None
        # yrt
    # fi
    return int(value)
# End of makeint

# ----------------------------------------------------------------------------
def set_var_string(variable, strng, original_line):
    t_args = variable + '="' + strng + '"'
    f, type_error = is_float(t_args, is_float_string, False)
    if type_error is not None:
        print_error("calc error - {}".format(type_error), original_line)
        return
    # fi
    if f is None:
        print_error("calculate did not return a value", original_line)
        return
    # fi
    return
# fi

# ----------------------------------------------------------------------------
#   encode  A=hi there; after,hi; upto,re
#   encode  A=4c4; octave,3; notelength,2
#
# encode has 5 extra pairs over decode - 'after','upto','explicit','number','staffname'
#
#   encode  note; {octave,notename,notenumber,sharp,flat,natural,tuplet,notelength,dot,duration},variable; [...]
# -1 if not standard note. Defaults normally apply.
#   l, s, m, t, z, a, aa, g,gg @W, @X    1 if modifier present, 0 if not, or not a note.
# If staff-line word (which sets till changed):
#   arp, fermata, legato, marcato, staccato, tie, slur, lh, rh
#   [ ]                     : start/end of chord (1, 0 if not)
#   glissando               : Starting pitch of glissando = 1
#   volumenumber            : 0 to 100% (probably here do 0 to 127.
#   volumename              : 1 = vfff, 2 = vff ... 8 = vppp. -1 if not a volume, 0 if numerical.
#   crescendo               : 1 = start of crescendo, 0 if not.
#   diminuendo              : 1 = start of diminuendo, 0 if not.
#   position                : 0 to 100% (probably here do 0 to 127) for numerical position (pan value).
#   pan                     : 1 - start of pan, 0 if not. (Moving between two.) Like cresendo/glissando.
#   type, treble, bass, soprano, alto, tenor, normal, perc, nohead, oloz, floz,
#   oharm, fharm, trem0, trem1, trem2, trem3, stemsoff, stemson
#
# Special: explict (no variable paired with it). Only for encode. Cause current
# defaults to be used for any note items missing.

def do_encode(t_args, original_line):
    global measure_on
    global last_voice_staff

#--    print_debug("do_encode - #1 t_args='{}'".format(t_args))
    if t_args is None or t_args == '':
        print_error("encode does not have a variable, nor string to assign to it.", original_line)
        return
    # fi
    t_args = t_args.strip()                     # Toss spaces before and after.
    if t_args is None or t_args == '':          # Check again. :)
        print_error("encode does not have a variable, nor string to assign to it.", original_line)
        return
    # fi
    assign = t_args.find('=')
    if assign <= 0:
        print_error("encode does not have a variable followed by an assignment character.", original_line)
        return
    # fi
    strng = t_args[assign+1:].strip()           # Toss spaces before and after.    After Assignment.
    variable = t_args[0:assign].strip()         # Toss spaces before and after.    The Variable.

    # At this point we have 'variable' with where to put the results of encode.
    # strng = everthing after the assignment character.

    a = strng.find(';')
    if a < 0:                                   # No Semi-colon's, just set string variable.
#--        print_debug("do_encode - #2c - strng='{}' variable='{}'".format(strng,variable))
        nstrng = replace_all_variables(strng, original_line)
        strng = nstrng.strip()
        i_line.append('2enco: encode ' + variable + '=' + strng)    # Line as fixed or whatever.
        set_var_string(variable, strng, original_line)
        return
    # fi

#--    print_debug("do_encode - #4b - strng='{}' variable='{}'".format(strng,variable))

    voiceon = getvar_checkokay('voice', original_line)     # Interesting - get last time used. :)
    if type(voiceon) is int and voiceon < 1:
        voiceon = 1
    elif type(voiceon) is str:
        voiceon = voiceon.split(',')
    # fi

    # semi-colons with comma pairs -- except for explict. ... pairs starts here.
    pairs = strng[a+1:].strip()                 # Toss semi-colon, now get paired arguments i.e. x,y;
    strng = strng[0:a].strip()                  # Set strng to string up to the semi-colon.
    cnt = 0
    while True:
        nstrng = replace_all_variables(strng, original_line)
#--        print_debug("do_encode - #4c1 strng='{}' nstrng='{}'".format(variable,strng,nstrng))
        if nstrng == strng:
            break
        # fi
        strng = nstrng.strip()
        cnt = cnt + 1
        if cnt > MAX_LOOP_VARIABLES:
            print_error("Over {} variable substitutions done on right argument - loop?".format(MAX_LOOP_VARIABLES), original_line)
            return
        # fi
        i_line.append('2enco: encode ' + variable + '=' + strng)    # Line as fixed or whatever.
    # elihw
    set_var_string(variable, strng, original_line)

#--    print_debug("do_encode - #5c - strng='{}' variable='{}'".format(strng,variable))

    need_to_decode = True
    tagtype = 0                                 # 0=none, 1=string, 2=note
    newstrng = ''                               # New string for string processing.
    newnumber = ''                              # Number(s) to append at end.
    restore_staff = ''                          # Insert staff name.
    suffix = ''
    prefix = ''

    # Initial in case we decode.
    octave = notename = notelength = notenumber = duration = -1
    sharp = flat = natural = dot = 0

#--    print_debug("do_encode - #6")
    while len(pairs) > 0:                       # Get first token.
#--         print_debug("do_encode - #7")
        a = find_terminator_in_string(pairs, [';', ','], True, original_line)
        # 'after', 'upto', 'explicit', 'number', 'staffname', 'string'
        if a < 0:
            token = pairs                       # Can only be explicit... .
            if token not in ['explicit', 'staffname']:
                print_error("encode has semicolon without a variable, that is not explicit/staffname.", original_line)
                return
            # fi
            pairs = ''
        elif a == 0:
            print_error("encode has semicolon at end of line, that is not allowed.", original_line)
            return
        elif pairs[a] == ';':                   # End of line (no more semicolons), or no comma.
            token = pairs[0:a].strip()
            pairs = pairs[a+1:].strip()
            if token not in ['explicit', 'staffname']:
                print_error("encode has semicolon without a variable, that is not explicit/staffname.", original_line)
                return
            # fi
        else:                                   # Comma separator.
            token = pairs[0:a].strip()
            pairs = pairs[a+1:].strip()
            # Still need to get argument for pair.
        # fi

#--         print_debug("token='{}' pairs='{}'".format(token, pairs))
        if token == 'explicit':
            if tagtype == 1:
                print_error("encode '{}' done 'after' or 'before'.".format(token), original_line)
            # fi
            tagtype = 2
            octave, notename, notelength, notenumber, duration, sharp, flat, natural = get_defaults_for_note(strng, voiceon, original_line)
#--             print_debug('do_encode explicit octave={} notename={} notelength={} notenumber={} duration={} sharp={} flat={} natural={}'.format(octave, notename, notelength, notenumber, duration, sharp, flat, natural))
            if octave is None:
                return                          # Error occurred.
            # fi
            if a < 0:
                pairs = ''
            else:
                pairs = pairs[a+1:]             # Toss semi-colon, now get any next arguments.
            # fi
            if notenumber == 0:
                note_type = 4                   # rest.
            else:
                note_type = 0                   # normal note.
            # fi
            continue
        elif token == 'staffname':
            if tagtype == 2:
                print_error("encode '{}' done after note processing".format(token), original_line)
                return
            # fi
            tagtype = 1
            if last_voice_staff is None:
                print_error("encode staffname with no staff or voice number specified yet.", original_line)
                return
            # fi
            if restore_staff != '':
                restore_staff = restore_staff + ' '
            # fi
            if type(last_voice_staff) is str:
                restore_staff = restore_staff + last_voice_staff
            elif type(last_voice_staff) is int or type(last_voice_staff) is float:
                restore_staff = restore_staff + 'v' + str(last_voice_staff)
            else:
                print_error("encode staffname with no staff or integer voice number ({}) specified yet.".format(last_voice_staff), original_line)
                return
            # fi
            continue
        # fi

        # Get paired item (usually variable?).
        if token in [ 'after', 'upto', 'number', 'before', 'string' ]:
            tf = False
        else:
            tf = True
        # fi
        a = find_terminator_in_string(pairs, [';'], tf, original_line)
#--         print_debug("a='{}'".format(a))
        if a < 0:
            secondary = pairs                       # Last item.
            pairs = ''
        elif a == 0:
            print_error("encode has null paired item, that is not allowed.", original_line)
            return
        else:
            secondary = pairs[0:a].strip()
            pairs = pairs[a+1:].strip()
        # fi
#--        print_debug("do_encode - #88a - token='{}' secondary='{}'".format(token,secondary))
        # 'after', 'upto', 'number'
        if token == 'after':
            if tagtype == 2:
                print_error("encode '{}' after note processing directives.".format(token), original_line)
            # fi
            tagtype = 1
            a = strng.find(secondary)
            if a >= 0:
                strng = strng[a + 1:]
            else:
                strng = ''
            # fi
            continue
        elif token in ['before', 'upto']:
            if tagtype == 2:
                print_error("encode '{}' after note processing directives.".format(token), original_line)
            # fi
            tagtype = 1
            a = strng.find(secondary)
            if a >= 0:
                strng = strng[0:a]
            else:
                strng = ''
            # fi
            continue
        elif token == 'number':
            if tagtype == 2:
                print_error("encode '{}' done after note processing".format(token), original_line)
            # fi
            tagtype = 1
            # Convert number to string and append to end of string.
            value, type_error = is_float(secondary, is_float_number, False)
            if type_error is not None or value is None:
                print_error("encode '{}' unable to determine number value from '{}'.".format(token, secondary), original_line)
                return
            # fi
#??            if newnumber != '':
#??                newnumber = newnumber + ' '
#??            # fi
            if type(value) is float and value.is_integer():
                newnumber = newnumber + str(int(value))
            else:
                newnumber = newnumber + str(value)
            # fi
            continue
        elif token == 'string':
            if tagtype == 2:
                print_error("encode '{}' done after note processing".format(token), original_line)
            # fi
            tagtype = 1
            if newnumber != '':
                newnumber = newnumber + ' '
            # fi
            if type(secondary) is str:
                newnumber = newnumber + secondary
            elif type(secondary) is float and secondary.is_integer():
                newnumber = newnumber + str(int(secondary))
            else:
                newnumber = newnumber + str(secondary)
            # fi
            continue
        # fi:

        if tagtype == 1:
            print_error("encode '{}' done after string processing".format(token), original_line)
        elif tagtype == 0:
            octave, notename, notelength, notenumber, duration, sharp, flat, natural = get_defaults_for_note(strng, voiceon, original_line)
        # fi
        tagtype = 2
# ----------------------------------------------------------------------------
        value, type_error = is_anything(secondary, False)
        if value is not None:
            if value == 'COMMA':
                value = ''
                for i in type_error:
                    if value != '':
                        value = value + ','
                    # fi
                    value = value + str(i)
                # rof
                type_error = None
            # fi
        # fi
# ----------------------------------------------------------------------------
        if type(value) is float and value.is_integer():
            value = int(value)
        # fi

        if token == 'octave':
            octave = makeint(value, original_line)
            if octave is None:
                return
            # fi
            notenumber = -1
        elif token == 'notename':
            notename = value
            notenumber = -1
        elif token == 'notenumber':
            notenumber = makeint(value, original_line)
            if notenumber is None:
                return
            # fi
            notename = -1
        elif token == 'notelength':
            notelength = makeint(value, original_line)
            if notelength is None:
                return
            # fi
            duration = -1
        elif token == 'duration':
            duration = value
            notelength = -1
        elif token == 'sharp':
            sharp = makeint(value, original_line)
            if sharp is None:
                return
            # fi
        elif token == 'flat':
            flat = makeint(value, original_line)
            if flat is None:
                return
            # fi
        elif token == 'natural':
            natural = makeint(value, original_line)
            if natural is None:
                return
            # fi
        elif token == 'dot':
            dot = makeint(value, original_line)
            if dot is None:
                return
            # fi
        elif token in [ 'l', 's', 'm', 't', 'z', 'a', 'g']:
            if type(value) is int and value > 0:
                suffix = suffix + token
            # fi
        elif token in [ 'arp', 'trem0', 'trem1', 'trem2', 'trem3', 'fermata',
                        'lh', 'rh', 'normal', 'perc', 'nohead', 'oloz', 'floz',
                        'oharm', 'fharm', 'legato', 'tie', 'staccato',
                        'marcato', 'slur',
    # . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
                        '[', ']',
                        'stemsoff', 'stemson', 'tuplet', 'aa', 'gg',
                        'glissando', 'crescendo', 'diminuendo',
                        'treble', 'bass', 'soprano', 'alto', 'tenor']:
            if type(value) is int and value > 0:
                if prefix != '':
                    prefix = prefix + ' '
                # fi
                prefix = prefix + token
            # fi
        elif token in [ 'volumenumber', 'volumename', 'position', 'pan']:
            if prefix != '':
                prefix = prefix + ' '
            # fi
            prefix = prefix + token + ' ' + str(value)
        elif token == 'type':
            note_type = value               # IGNORE THIS?? :)
            if note_type == 4:              # Rest
                notename = 'r'
                notenumber = 0
            # fi
        else:
            print_error("encode argument '{}' unrecognized, cannot assign '{}'.".format(token, value), original_line)
            return
        # fi
    # elihw
#--     print_debug("do_encode - #8")

    note = ''
    if tagtype == 2:
        if notenumber == -1:                    # Not given a midinote number.
            nn = -1
            if notename != -1:
                nametonum = { 'c':0, 'd':2, 'e':4, 'f':5, 'g':7, 'a':9, 'b':11}
                if notename in nametonum:
                    if octave != -1:
                        nn = 12 * octave + nametonum[notename] + 24
                        if notenumber != -1:
                            if notenumber != nn:
                                print_error("encode argument octave({}) notename({}) != notenumber({})".format(octave, notename, notenumber), original_line)
                                return
                            # fi
                        else:
                            notenumber = nn
                        # fi
                    else:
                        note = notename
                    # fi
                else:
                    if notename == 'r':
                        notenumber = 0
                    # fi
                # fi
            else:
                print_error("encode has no note name or number ...", original_line)
            # fi
        else:
            nn = notenumber
        # fi
        n = ''
        if nn != -1 and nn != 0:
            n = midi_value_to_note_flat[nn]
        else:
            if octave != -1:
                if notename != -1:
                    n = str(octave) + str(notename)
                else:
                    print_error("encode has no note name or number but octave ...", original_line)
                # fi
            elif notename != -1:
                n = str(notename)
            # fi
        # fi

        if len(n) <= 2:
            if sharp > 0:
                n = n + '+' * sharp
            # fi
            if flat > 0:
                n = n + '-' * flat
            # fi
            if natural > 0:
                n = n + 'n' * natural
            # fi
        # fi

        if notelength > 0:
            n = n + str(notelength)
            for d in range(0, dot):
                n = n + 'd'
            # rof
        else:
            if duration in legal_mc_notes:
                n = n + legal_mc_notes[duration]
            else:
                n = n + '(' + str(duration) + ')'
            # fi
        # fi
        newstrng = n
    else:                                   # tagtype = 1
        newstrng = strng
    # fi
    if prefix != '':
#--         print_debug("do_encode - #8a - prefix='{}' newstrng='{}'".format(prefix,newstrng))
        newstrng = prefix + ' ' + newstrng
    # fi
    if suffix != '':
#--         print_debug("do_encode - #8b - newstrng='{}' suffix='{}'".format(newstrng,suffix))
        newstrng = newstrng + suffix
    # fi
    if newnumber != '':
#--         print_debug("do_encode - #8c - newstrng='{}' newnumber='{}'".format(newstrng,newnumber))
        newstrng = newstrng + newnumber
    # fi
    if restore_staff != '':
#--        print_debug("do_encode - #8d - newstrng='{}' +' '+ restore_staff='{}'".format(newstrng,restore_staff))
        newstrng = newstrng + ' ' + restore_staff
    # fi
    set_var_string(variable, newstrng, original_line)
    recompute_whichchars()
    return
# End of do_encode

# ----------------------------------------------------------------------------
#       elseif          $$ elseif clause of an "if elseif else endif" sequence.

def do_else_if(t_args, original_line):
    global ifdepth
    global iftest

    if t_args is None or t_args == '':
        print_error("elseif command does not have exactly one argument.", original_line)
        return
    # fi
    if ifdepth == 0 or iftest[ifdepth] == 1 or iftest[ifdepth] == 2:
        print_error("elseif command while not in an if command", original_line)
        return
    # fi
    if iftest[ifdepth] == -1:           # already processing, handle as normal if.
        iftest[ifdepth] = 3             # Switch to skipping elseif and else.
        return
    # fi
    if iftest[ifdepth] != 0:            # skipping if, want to do else or elseif.
        # if iftest[ifdepth] == 3:            # skip both if and else, want endif
        # NOTE: do not test for if/else/endif ... second else.
        return;
    # fi
    wargs = separate_args(t_args, False, True, original_line)
    if not wargs or len(wargs) < 1:
        print_error("no elseif argument.", original_line)
        return
    # fi
    value, type_error = is_float(wargs[0], is_float_number, False)
    if type_error is not None or value is None:
        print_error("elseif unable to determine value ({}).".format(wargs[0]), original_line)
        return
    # fi
    value = -1 if value < 0 or value > 0 else 0   # 0 is false, otherwise everything is true.
    if value < 0:
        iftest[ifdepth] = -1            # Switch to as if processing.
    # fi
# End of do_else_if

# ----------------------------------------------------------------------------
#       else            $$ else clause of an "if else endif" sequence.

def do_else(t_args, original_line):
    global ifdepth
    global iftest

    if ifdepth == 0 or iftest[ifdepth] == 1 or iftest[ifdepth] == 2:
        print_error("else command while not in an if command", original_line)
        return
    # fi

    if iftest[ifdepth] == -1:           # already processing, handle as normal if.
        iftest[ifdepth] = 2             # Switch to skipping elseif and else.
        return
    # fi
    if iftest[ifdepth] == 0:            # skipping if, want to do else or elseif.
        iftest[ifdepth] = 1             # Switch to processing else.
        return
    # fi
    # if iftest[ifdepth] == 3:            # skip both if and else, want endif
    # NOTE: do not test for if/else/endif ... second else.
    return
# End of do_else

# ----------------------------------------------------------------------------
#       endif           $$ end of an "if else endif" sequence.

def do_endif(t_args, original_line):
    global ifdepth

    if ifdepth == 0:
        print_error("endif command while not in an if command", original_line)
        return
    # fi
    # if iftest[ifdepth] == -1:           # already processing, handle as normal if.
    # if iftest[ifdepth] == 0:            # skipping if, want to do else.
    # if iftest[ifdepth] == 1:            # processing in else, want to do as normal if.
    # if iftest[ifdepth] == 2:            # skipping in else, ignore if and else processing, want endif.
    # if iftest[ifdepth] == 3:            # skip both if and else, want endif
    ifdepth = ifdepth - 1
    return
# End of do_endif

# ----------------------------------------------------------------------------
#   endloop
#   endloop m1 == 0

def do_endloop(t_args, original_line):
    global loop_defining
    global loop_number
    global loop_location
    global i_line
    global lmp_executing_number
    global lmp_executing_which
    global lmp_executing_type
    global lmp_executing_args
    global lmp_executing_line
    global lmp_executing_rest_of_line
    global lmp_executing_i_line
    global loop_endloop_exp

    if loop_defining is None:
        print_error("endloop command while not defining a loop", original_line)
        return
    # fi
    loop_defining = None

    l = loop_number - 1
    if t_args is not None and t_args != '':
        loop_endloop_exp[l] = t_args                    # Possible termination expression.
    # fi

    if lmp_executing_number > MAX_NESTING:
        print_error("m:{} endloop->loop {} nesting to depth of more than {}".format(measure_on, command, MAX_NESTING), original_line)
        return                                      # Error ... ouch, many errors will follow. *sigh*
    # fi
    t_line = i_line
    for i in range(0, len(t_line)):                      # Save current depth of line.
       t_line[i] = 'loop : ' + t_line[i]
    # rof
    lmp_executing_which.append(loop_number - 1)
    lmp_executing_type.append('loop')                   # Going into a loop.
    lmp_executing_args.append(None)                     # Array of arguments - does not apply.
    lmp_executing_line.append(0)                        # First line in buffer.
    lmp_executing_rest_of_line.append(None)             # Rest of this line. Does not apply
    lmp_executing_i_line.append(t_line)                 # Save current depth of line.
    lmp_executing_number = lmp_executing_number + 1
    return
# End of do_endloop

# ----------------------------------------------------------------------------
#       macro   ABC,First,Second
#       v1: First
#       v2: Second
#       endm                $$ End of a macro definition.
# Usage: ABC    3c4,3e4
# Expands to:
#       v1: 3c4
#       v2: 3e4

def do_endm(t_args, original_line):
    global macro_defining

    if macro_defining is None:
        print_error("endm command while not defining a macro", original_line)
        return
    # fi
    macro_defining = None
    return
# End of do_endm

# ----------------------------------------------------------------------------
def do_endprocess(t_args, original_line):
    global process_defining

    if process_defining is None:
        print_error("endprocess command while not defining a process", original_line)
        return
    # fi
    process_defining = None
    return
# End of do_endprocess

# ----------------------------------------------------------------------------
def do_global(t_args, original_line):
    handle_vars_and_global(t_args, 0, original_line)     # Macro depth 0 is global variables.
    return
# End of global

# ----------------------------------------------------------------------------
#   goto    6.5,x,8,2,... $$ repeat and/or skip.  "x" = continue, forwards, backwards. No Max arguments?
#                       counter is number of times reached.
#   measure 78
#   goto    80
#   measure 79
#   goto    99
#   measure 80
#   goto    78,79
#   measure 99          $$ Executes: 78 -> 80 -> 78 -> 80 -> 79 -> 99
# Note: Wraps when counter reaches end of arguments.
# "goto 78,79" would repeat at 78, then 79 again, then 78 ...

def do_goto(t_args, original_line):
    global measure_on
    global goto_table
    global goto_variables

    if args.nogoto:
        print_warning("Ignoring goto parsing.", original_line)
        return
    # fi

    if measure_on in goto_table:
        print_error("Second goto in measure note allowed.", original_line)
        return
    # fi

    if t_args is None or t_args == '':
        print_error("goto needs at least one argument", original_line)
        return
    # fi
    wline = t_args
    # Get rid of all white spoce.
    wline = ''.join(wline.split())
    wargs = separate_args(wline, False, True, original_line)

    if len(wargs) == 0:
        print_error("goto needs at least one argument", original_line)
        return
    # fi

    g = []
    for i in range(1, len(wargs)+1):
        v = wargs[i - 1]

        if v is None:
            print_error("goto does not have argument as a measure.", original_line)
            return
        # fi

        f1 = None
        for a in v:
            if a in "abcdefghijklnopqrstuvwxyz_ABCDEFGHIJKLMNOPQRSTUVWXYZ":
                f1 = v
                break
            # fi
        # rof
        if f1 is None:
            f1, type_error = is_float(v, is_float_number, False)
            if type_error is not None or f1 is None:
                # Error, use it as string instead.
                f1 = str(v)
            else:
                tmp = int(round(f1))
                if (f1 - tmp) == 0:
                    f1 = tmp
                # fi
            # fi
        # fi
        v = str(f1)

        g.append(v)
    # rof
    fill_voice_mlth(True, original_line)               # Need to make measure for other voices up to here "mlth".
    goto_table[measure_on] = g
    return
# End of do_goto

# ----------------------------------------------------------------------------
#       key     a                   $$ key of a major for all voices. f+,c+,g+
#       =key    violaA..violaB g-   $$ viola - six flats
#       key     1,2 c major         $$ If "major" is present ...
#       key     1, 2  c minor       $$ b-,e-,a-  same as key e- or key e- major.
#       key     1, 2  atonal        $$ Each note is stand-alone.
#       key     atonal              $$ Each note is stand-alone.
# Changes at start of a measure.

def do_key(t_args, original_line):
    global args
    global measure_on
    global key_sig
    global key_default
    global key_voice
    global mlth
    global vl
    global minor_key_to_major

    if t_args is None or t_args == '':
        print_error("key command does not have arguments", original_line)
        return
    # fi

    targs = re.sub(r'\s*,\s*', ',', t_args)
    targs = re.sub(r'\s*\.\.\s*', '..', targs)
    # Voice numbers (optional), followed by key name, with major/minor (optional).
    vargs = targs.split()

    if len(vargs) <= 0 or len(vargs) > 3:
        print_error("key command does not have correct number of arguments", original_line)
        return
    # fi

    if len(vargs) == 3:                     # Handle major or minor.
        k = vargs[1].lower()
        mm = vargs[2].lower()
        vs = vargs[0]
        if mm == "minor":
            if k not in minor_key_to_major:
                print_error("key command does not recognize minor {}".format(k), original_line)
                return
            # fi
            k = minor_key_to_major[k]
        elif mm == "major":
            if k not in key_sig:
                print_error("key '{}' not recognized.".format(k), original_line)
                return
            # fi
        else:
            print_error("key command does not recognize {} as major or minor".format(vargs[2]), original_line)
            return
        # fi
    elif len(vargs) == 2:
        k = vargs[0].lower()
        mm = vargs[1].lower()
        vs = None
        if mm == "minor":
            if k not in minor_key_to_major:
                print_error("key command does not recognize minor {}".format(k), original_line)
                return
            # fi
            k = minor_key_to_major[k]
        elif mm == "major":
            if k not in key_sig:
                print_error("key '{}' not recognized.".format(k), original_line)
                return
            # fi
        else:                               # No major or minor, so "key 1,2 c-" format.
            vs = vargs[0]
            k = mm
            if k not in key_sig and k not in ['none', 'atonal']:
                print_error("key '{}' not recognized.".format(k), original_line)
                return
            # fi
        # fi
    else:
        vs = None
        k = vargs[0].lower()
        if k not in key_sig and k not in ['none', 'atonal']:
            print_error("key '{}' not recognized.".format(k), original_line)
            return
        # fi
    # fi

    if k in ('none', 'atonal'):
        k = 'atonal'
    elif args.vertical or args.horizontal:
        pass                                # printing and used are the same.
    elif args.midi1csv or args.fluidsynth:
        k = key_sig[k]                      # Key number extracted.
    else:                   # ABC
        k = k.upper()
        k = k.replace('-', 'b')             # Does multiple flats
        k = k.replace('+', '#')             # Does multiple sharps.
        k = k.replace('n', '=')             # Does multiple naturals.
    # fi
    # k = value to store in key_voice, key_default, etc. -- used for printing, etc.

    #-- fill_voice_mlth(original_line)                   # Need to make measure for other voices up to here "mlth".
    # By not doing this, we allow vertical format to specify keys for voices in the first measure (or any).

    if vs is None:                          # One argument, all voices change.
        for ve in range(1, len(vl)+1):
            if mlth[ve][measure_on] != 0:
                print_error("key with one argument not allowed in the middle of a measure", original_line)
                return
            # fi
        # rof
        if measure_on == '':
            key_default = k                 # Used in xpose, and when printing midicsv output.
        # fi
        for ve in range(1, MAXVOICES+1):
            set_staff_arr_double(ve, k, measure_on, key_voice, original_line)
        # rof
        return
    # fi                # multiple arguments, voices first.

    wargs = separate_args(vs, None, True, original_line)    # Allow staff_name and voice numbers.
    if not wargs or len(wargs) < 1:
        print_error("no voice arguments on key line", original_line)
        return
    # fi
    for w in wargs:
        f1, type_error = is_float(w, is_float_number, False)
        if type_error is not None:
            print_error("key error - {}".format(type_error), original_line)
            return
        # fi
        if f1 is None:
            print_error("voice {} is not a number.".format(w), original_line)
            return
        # fi
        f1 = int(round(f1))
        if f1 not in mlth:
            print_error("key with too many voices not allowed, voice {} is too many".format(f1), original_line)
            return
        # fi
        if mlth[f1][measure_on] != 0:
            for ve in range(1, len(vl)+1):
                print_error_no_line("mlth[{}][{}]='{}'".format(ve, measure_on, mlth[ve][measure_on]))
            # rof
            print_error("key with two arguments not allowed in the middle of a measure, voice {}".format(f1), original_line)
            return
        # fi
        set_staff_arr_double(f1, k, measure_on, key_voice, original_line)
    # rof
    return
# End of do_key

# ----------------------------------------------------------------------------
#       if      -1      $$ Start of an "if else endif" sequence.
#       if      0       $$ False
#       if      1       $$ Non-zero is true.
#       elseif          $$ if if was false, is this true? Else do the else clause. (optional)
#       else            $$ if if was false, do the else clause. (optional)
#       endif           $$ end of the if else.

def do_if(t_args, original_line):
    global iftest                       # check if after if or else.
    global ifdepth                      # level of if/else/endif

    if t_args is None or t_args == '':
        print_error("if command does not have exactly one argument.", original_line)
        return
    # fi
    # if iftest[ifdepth] == -1:           # already processing, handle as normal if.
    # if iftest[ifdepth] == 0:            # skipping if, want to do else.
    # if iftest[ifdepth] == 1:            # processing in else, want to do as normal if.
    # if iftest[ifdepth] == 2:            # skipping in else, ignore if and else processing, want endif.
    # if iftest[ifdepth] == 3:            # skip both if and else, want endif
    if iftest[ifdepth] == -1 or iftest[ifdepth] == 1:   # process this if normally.
        wargs = separate_args(t_args, False, True, original_line)
        if not wargs or len(wargs) < 1:
            print_error("no if argument.", original_line)
            return
        # fi
        value, type_error = is_float(wargs[0], is_float_number, False)
        if type_error is not None or value is None:
            print_error("if unable to determine if value ({}).".format(wargs[0]), original_line)
            return
        # fi
        value = -1 if value < 0 or value > 0 else 0   # 0 is false, otherwise everything is true.
#--         print_debug("do_if - t_args='{}' value='{}'".format(t_args,value))
    else:
        value = 3                           # Skip both if and else.
    # fi
    ifdepth = ifdepth + 1
    iftest[ifdepth] = value
    return
# End of do_if

# ----------------------------------------------------------------------------
#   instrument 1,2 flute                $$ voices for an instrument.
# See source for list of all instruments.

def do_instrument(t_args, original_line):
    global vinstrument
    global measure_on
    global instruments
    global drum_sound
    global mlth

    if t_args is None or t_args == '':
        print_error("instrument does not have arguments.", original_line)
        return
    # fi

    # Want a list of number separated by commas, followed by a space and an instrument name/number.
    targs = re.sub(r'\s*,\s*', ',', t_args)
    targs = re.sub(r'\s*\.\.\s*', '..', targs)
    # Voice numbers, followed by instrument name.
    vargs = targs.split()

    INST = " ".join(vargs[1:]).lower()
    foundinstrument = None
    for i in instruments:
        if i.lower() == INST:
            foundinstrument = i
            break
        # fi
    # rof
    if foundinstrument is None:
        for i in drum_sounds:
            if i.lower() == INST:
                foundinstrument = i
                break
            # fi
        # rof
    # fi
    if foundinstrument is None:
        print_error("do_instrument - instruments does not have INST='{}'".format(INST), original_line)
        f1, type_error = is_float(INST, is_float_number, False)
        if type_error is not None:
            print_error("instrument error - {}".format(type_error), original_line)
            return
        # fi
        if f1 is None:
            print_error("voice does not have instrument argument {} as a number.".format(INST), original_line)
            return
        # fi
        f1 = int(round(f1))
        for i in instruments:
            if instruments[i] == [f1, 0]:
                foundinstrument = i
                break
            # fi
        # rof
        if foundinstrument is None:
            print_error("instrument value {} not in instrument table.".format(f1), original_line)
            return
        # fi
        INST = foundinstrument
    # fi

    jkl = "".join(vargs[0])
    wargs = separate_args(jkl, None, True, original_line)   # Allow staff_name and voice numbers.
    if not wargs or len(wargs) < 1:
        print_error("no voice arguments on instrument line", original_line)
        return
    # fi
    for w in wargs:
        f1, type_error = is_float(w, is_float_number, False)
        if type_error is not None:
            print_error("instrument error - {}".format(type_error), original_line)
            return
        # fi
        if f1 is None:
            print_error("voice {} is not a number.".format(w), original_line)
            return
        # fi
        f1 = int(round(f1))
        if f1 not in mlth:
            print_error("instrument with too many voices not allowed, voice {} is too many".format(f1), original_line)
            return
        # fi
        if mlth[f1][measure_on] != 0:
            print_error("instrument in the middle of measure '{}' not allowed, voice '{}'".format(measure_on, f1), original_line)
            return
        # fi
        vinstrument[f1][measure_on] = foundinstrument
    # rof

    return
# End of do_instrument

# ----------------------------------------------------------------------------
#       intensity  1..4  90        $$ MIDI value 0 to 127.
# MIDI has 3 values that add together to create volume. "channel/note_on/intensity"
# *Blech*

def do_intensity(t_args, original_line):
    global intensity
    global measure_on

    if t_args is None or t_args == '':
        print_error("intensity does not have arguments.", original_line)
        return
    # fi

    targs = re.sub(r'\s*,\s*', ',', t_args)

    vargs = targs.split()
    if len(vargs) <= 0 or len(vargs) > 2:
        print_error("intensity does not have correct number of arguments.", original_line)
        return
    # fi
    if len(vargs) == 1:
        intens = 0
    else:
        intens = vargs[1]
        f1, type_error = is_float(intens, is_float_number, False)
        if type_error is not None:
            print_error("intensity error - {}".format(type_error), original_line)
            return
        # fi
        if f1 is None:
            print_error("voice does not have intensity argument {} as a number.".format(intens), original_line)
            return
        # fi
        intens = int(round(f1))
    # fi
    if intens < 0 or intens > 127:
        print_error("intensity value {} not in range 0 to 127".format(intens), original_line)
        return
    # fi

    jkl = "".join(vargs[0])
    wargs = separate_args(jkl, None, True, original_line)   # Allow staff_name and voice numbers.
    if not wargs or len(wargs) < 1:
        print_error("no voice arguments on intensity line", original_line)
        return
    # fi
    for w in wargs:
        f1, type_error = is_float(w, is_float_number, False)
        if type_error is not None:
            print_error("intensity error - {}".format(type_error), original_line)
            return
        # fi
        if f1 is None:
            print_error("voice {} is not a number.".format(w), original_line)
            return
        # fi
        f1 = int(round(f1))
        if f1 not in mlth:
            print_error("intensity with too many voices not allowed, voice {} is too many".format(f1), original_line)
            return
        # fi
        intensity[f1][measure_on] = intens
    # rof
    return
# End of do_intensity

# ----------------------------------------------------------------------------
#   do / loop
#   loop m1=1,10,1
#   loop m1=1,10
#   loop m1 == 0
#   loop                                                # outloop or endloop to get out.

def do_loop(t_args, original_line):
    global loop_defining
    global loop_defining_count
    global loop_number
    global loop_location
    global loop_value_variable
    global loop_increment
    global loop_final_value
    global loop_endloop_exp
    global loop_buffer
    global linecount

    lvv = None
    li = None
    lfv = None
    firstarg = None
    if t_args is None or t_args == '':
        pass
    else:
        x = [ ]
        sg = t_args
        while len(sg) > 0:
            a = find_terminator_in_string(sg, [';', ','], True, original_line)
            if a < 0:
                break
            # fi
            x.append(sg[:a])
            sg = sg[a+1:]
        # elihw
        x.append(sg)
        if len(x) > 3:
            print_error("loop with too many arguments ({})".format(len(x)), original_line)
            return
        elif len(x) <= 0:                               # No arguments, outloop/endloop to get out.
            pass
        elif len(x) == 1:
            lvv = x[0]
        elif len(x) == 2 or len(x) == 3:
            # Split on = (assignment).
            a = find_terminator_in_string(x[0], [ '=' ], True, original_line)
            if a < 0:
                print_error("loop with {} arguments needs first to be a variable to assign to".format(len(x)), original_line)
                return
            # fi
            lvv = x[0][0:a+1]                           # The assignment is present.
            if len(x) == 2:
                li = 1
            else:
                f, type_error = is_float(x[2], is_float_number, False)    # The increment.
                if type_error is not None:
                    print_error("loop - increment is not a value {}".format(type_error), original_line)
                    return
                # fi
                if f is None:
                    print_error("loop - increment did not return expression as a value", original_line)
                    return
                # fi
                li = f
            # fi
            f, type_error = is_float(x[1], is_float_number, False)        # The final value.
            if type_error is not None:
                print_error("loop - final value is not a value {}".format(type_error), original_line)
                return
            # fi
            if f is None:
                print_error("loop - final value did not return expression as a value", original_line)
                return
            # fi
            lfv = f
            f, type_error = is_float(x[0], is_float_number, False)        # The first value.
            if type_error is not None:
                print_error("loop - initial value () is not a value {}".format(x[0],type_error), original_line)
                return
            # fi
            if f is None:
                print_error("loop - initial value did not return expression as a value", original_line)
                return
            # fi
            # The initial value has been set.
        # fi
    # fi
    loop_location.append(linecount)
    loop_increment.append(li)
    loop_value_variable.append(lvv)
    loop_final_value.append(lfv)
    loop_endloop_exp.append(None)                   # No endloop expression (yet).
    loop_buffer.append([])
    loop_defining = loop_number
    loop_defining_count = loop_defining_count + 1
    loop_number = loop_number + 1
    return
# End of do_loop

# ----------------------------------------------------------------------------
def do_macro(t_args, original_line):
    global macro_number
    global macro_name
    global macro_name_terminator
    global macro_arguments
    global macro_arg_terminator
    global macro_buffer
    global macro_defining
    global macro_defining_count
    global all_unique_macro_names
    global staff_keywords
    global staff_name
    global commands

    if t_args is None or t_args == '':
        print_error("macro command does not have any arguments.", original_line)
        return ''
    # fi
    # Get rid of multiple spaces/tabs.
    t_args = re.sub(r'\s+', r' ', t_args)
    # Get rid of spaces before/after commas/semicolons.
    t_args = re.sub(r'\s*([,;])\s*', r'\1', t_args)
    # Split on [a-z0-9A-Z_] and not. (Identifier alphanumeric or underscore)
    wargs = [i for i in re.split(r'(\w+|\W+)', t_args) if i]
    if not wargs or len(wargs) < 1 or wargs == '':
        print_error("no macro name.", original_line)
        return
    # fi
    name = wargs[0]
    if name in commands:
        print_error("macro ({}) would replace existing command".format(name), original_line)
        return
    elif name in staff_name:
        print_error("macro ({}) would replace existing staff name".format(name), original_line)
        return
    elif name in staff_keywords:
        print_error("macro ({}) would replace existing staff keyword".format(name), original_line)
        return
    # fi
    wargs = wargs[1:]
    if len(wargs) == 0:                     # If no arguments for macro.
        firstterminator = None
    else:
        if len(wargs[0]) > 1:
            firstterminator = wargs[0].strip()   # Make sure no spaces with terminator.
        else:
            firstterminator = wargs[0]           # The macro ends with this terminator (could be space).
        # fi
        wargs = wargs[1:]                   # Remove first terminator from list of tokens.
    # fi
    n = 0
    argument_names = []
    argument_terminators = []
    while n < len(wargs):
        arg = wargs[n]
        if len(arg) > 1:
            arg = arg.strip()
        # fi
        n = n + 1
        if n < len(wargs):
            if len(wargs[n]) > 1:
                terminator = wargs[n].strip()
            else:
                terminator = wargs[n]
            # fi
            n = n + 1
        else:
            terminator = None
        # fi
        if arg in argument_names:
            print_error("macro {} duplicates argument named {}".format(name, arg), original_line)
            return
        # fi
        argument_names.append(arg)
        argument_terminators.append(terminator)
    # elihw
    # Check if name and terminators match previous macro - if so, warning and replace. (Delete old one.)
    macro_name.append(name)                             # Array of names, duplicates allowed.
    macro_name_terminator.append(firstterminator)       # Terminator after macro.
    macro_arguments.append(argument_names)              # Arguments.
    macro_arg_terminator.append(argument_terminators)   # Terminators after arguments.
    macro_buffer.append([])                             # No lines in buffer.
    macro_defining = macro_number
    macro_defining_count = macro_defining_count + 1
    if name not in all_unique_macro_names:
        all_unique_macro_names[name] = [ macro_number ]
    else:
        all_unique_macro_names[name].append(macro_number)
    # fi
    macro_number = macro_number + 1
    return
# End of do_macro

# ----------------------------------------------------------------------------
#  Halt input and requst user input.
#       marker  5                       $$ Printout "5" and prompt for input to continue.
# Allows output to be printed as compiling is occuring -- for debugging.
# Think "macros", "putd", or "calc".

def do_marker(t_args, original_line):
    global args
    global precomment

    precomment = precomment + original_line + "\n"   # Comment line.

    fill_voice_mlth(False, original_line)                   # Need to make measure for other voices up to here "mlth".

    if t_args is None or t_args == '':
        value = '0'
    else:
        value, type_error = is_float(t_args, is_float_string, False)
        if type_error is not None or value is None:
            print_warning("marker unable to compute value({}) - using text string.".format(t_args), original_line)
            value = str(t_args)
        else:
            if type(value) is float and value.is_integer():
                value = int(value)
            # fi
            value = str(value)                  # Stupid python language upgrade incompatibility.
        # fi
    # fi

    if args.rest and len(args.rest) >= 2:
        outf = sys.stdout
    else:
        outf = sys.stderr
    # fi
    if args.rest and len(args.rest) >= 1:
        # Can get input from terminal.
        if sys.stdin.isatty():
            if sys.platform == 'darwin':
                input('marker ' + str(value) + ' > ')
                line = readline.get_line_buffer()
            else:
                line = input('marker ' + str(value) + ' > ')
            # fi
        else:
            print('marker ' + str(value) + ' > ', file=outf, flush=True)
            line = sys.stdin.readline()
        # fi
    # fi
    return
# End of do_marker

# ----------------------------------------------------------------------------
#       measure 6.5             $$ need not be integers
#       measure 0               $$ usually first measure before any notes -- meter, etc.
#       measure 1               $$ put notes after this one.
#       calc    m10 = 2
#       measure m10 = m10 + 1   $$ can be calculated.
#       measure                 $$ auto-increment from last (if it was a number).

global measure_warn_once
measure_warn_once = True

def do_measure(t_args, original_line):
    global measure_on
    global last_m
    global meas
    global vl
    global running_vl
    global default_note_length
    global vinstrument
    global reverb
    global pan
    global intensity
    global acc_m                            # Last accidental on a note in measure.
    global acc_m_xpose
    global acc_v_init                       # Last accidental on a note in measure.
    global acc_v_init_v_or_h                # Last accidental on a note in measure.
    global meter
    global measure_meter
    global clef
    global bars
    global mlth                             # measure length dictionary
    global args
    global key_voice
    global tempo_now_note_length
    global tempo_speed_now
    global pitch
    global premeasurecomment                # Collected comments before a new measure for before new measure.
    global measurelinecomment               # Collected comments before a new measure for before new measure.
    global precomment
    global commentonline
    global measures_to_do
    global cstop_processing
    global measure_warn_once

#--    print_debug("do_measure - entering - t_args='{}'".format(t_args))
    # Process possible --xpose argument as xpose command before first measure.
    if args.xpose != '':
        do_xpose([args.xpose], "Argument --xpose present, processing:{}".format(args.xpose))
        args.xpose = ''
    # fi

    if t_args is None or t_args == '':  # Auto-incement from last measure if it was a number.
        if measure_on == '':
            print_error("Measure missing argument, auto-increment can only work after one is a number.", original_line)
            return
        # fi
        if not measure_on.isnumeric():
            print_error("Blank measure can only occur after measure is a number - was {}".format(measure_on), original_line)
            return
        # fi
        t_args = str(int(measure_on) + 1)
    # fi

    vargs = t_args
    # Starts with number and has letters in the middle.
    # NOTE: character variable in middle of string problem. But, want "12a" as string.  notes_array NOTDONEYET
    if vargs[0].isnumeric() and not vargs.isnumeric() and vargs.isalnum():
        if measure_warn_once:
            print_warning("ONCE#A: measure is a command, and cannot set character string variable to it.", original_line)
            measure_warn_once = False
        # fi
        setvar('measure', -1, 0)
        f1 = str(vargs)
    else:
        f1, type_error = is_float(vargs, is_float_string, False)
        if type_error is not None or f1 is None or 'a' in vargs:
            if measure_warn_once:
                print_warning("ONCE#B: measure is a command, and cannot set character string variable to it.", original_line)
                measure_warn_once = False
            # fi
            setvar('measure', -1, 0)
            f1 = str(vargs)
        elif type(f1) is float:
            if f1.is_integer():
                f1 = int(f1)
            # fi
            setvar('measure', f1, 0)
            f1 = str(f1)
        elif type(f1) is int:
            setvar('measure', f1, 0)
            f1 = str(f1)
        else:
            if measure_warn_once:
                print_warning("ONCE#C: measure is a command, and cannot set character string variable to it.", original_line)
                measure_warn_once = False
            # fi
            setvar('measure', -1, 0)
            f1 = str(vargs)
        # fi
    # fi

    # Check if in measures_to_do
    if args.measures and args.measures != '':
        if f1 not in measures_to_do:
            cstop_processing = True
        else:
            # Do cstart.
            cstop_processing = False
        # fi
    # fi


    # Last note length ... continue to this measure, until it changes.
    last_m = measure_on

    if not args.multiplemeasures:
        fill_voice_mlth(True, original_line)     # Rests needed to make measure for other voices up to here "mlth".
    # fi

    if f1 in meas:
        if not args.multiplemeasures:
            print_warning("Measure {} already exists. Want --multiplemeasures?".format(f1), original_line)
        # fi
        measure_on = str(f1)
        # Initialize the accidental for each note in measure.
        # NOTE: EVERYTHING ELSE SHOULD ALREADY BE INITIALIZED. "voice 25" at start of song.
        for i in range(1, len(vl)+1):
# NOTDONEYET - set staff array acc_m, acc_m_xpose
            if args.horizontal or args.vertical:
                acc_m[i] = {k: v for k, v in acc_v_init_v_or_h.items()}
                acc_m_xpose[i] = {k: v for k, v in acc_v_init_v_or_h.items()}
            elif args.midi1csv or args.fluidsynth:
                acc_m[i] = {k: v for k, v in acc_v_init_v_or_h.items()}
                acc_m_xpose[i] = {k: v for k, v in acc_v_init_v_or_h.items()}
            else:           # ABC
                acc_m[i] = {k: v for k, v in acc_v_init.items()}
                acc_m_xpose[i] = {k: v for k, v in acc_v_init.items()}
            # fi
        # rof
        return
    # fi

    measure_on = str(f1)
    meas.append(measure_on)
    for i in range(1, len(vl)+1):
        if not check_voice_staff_in(i, vinstrument):
            set_all_staff_arr(i, {}, vinstrument, original_line)
            set_all_staff_arr(i, {}, reverb, original_line)
            set_all_staff_arr(i, {}, pan, original_line)
            set_all_staff_arr(i, {}, intensity, original_line)
            set_all_staff_arr(i, {}, key_voice, original_line)
        # fi
        if not check_voice_staff_in(i, vl):
            set_all_staff_arr(i, {}, vl, original_line)
            set_all_staff_arr(i, {}, running_vl, original_line)
        # fi
        for j in vl:
            if j not in clef:
                clef[j] = {}
            # fi
            if measure_on not in clef[j]:
                clef[j][measure_on] = {}
            # fi
            if j not in clef or last_m not in clef[j]:
                for k in reversed(range(0, len(meas)-1)):
                    mmm = meas[k]
                    if j in clef and mmm in clef[j]:
                        nc = clef[j][mmm]
                        break
                    # fi
                # rof
            else:
                nc = clef[j][last_m]
            # fi
            clef[j][measure_on] = nc
        # rof
        new_voice_initialize(i, measure_on)
        mlth[i][measure_on] = 0
        # last instrument continues - might change shortly.
        vinstrument[i][measure_on] = vinstrument[i][last_m]
        pan[i][measure_on] = pan[i][last_m]
        reverb[i][measure_on] = reverb[i][last_m]
        intensity[i][measure_on] = intensity[i][last_m]
        key_voice[i][measure_on] = key_voice[i][last_m]

        # Carry forward.
        vl[i][measure_on] = vl[i][last_m]
        running_vl[i][measure_on] = running_vl[i][last_m]

        # Initialize the accidental for each note in measure.
# NOTDONEYET - set staff array acc_m, acc_m_xpose
        if args.horizontal or args.vertical:
            acc_m[i] = {k: v for k, v in acc_v_init_v_or_h.items()}
            acc_m_xpose[i] = {k: v for k, v in acc_v_init_v_or_h.items()}
        elif args.midi1csv or args.fluidsynth:
            acc_m[i] = {k: v for k, v in acc_v_init_v_or_h.items()}
            acc_m_xpose[i] = {k: v for k, v in acc_v_init_v_or_h.items()}
        else:           # ABC
            acc_m[i] = {k: v for k, v in acc_v_init.items()}
            acc_m_xpose[i] = {k: v for k, v in acc_v_init.items()}
        # fi
    # rof
    premeasurecomment[measure_on] = precomment
    measurelinecomment[measure_on] = commentonline
    # default note length continues with current - might change shortly.
    default_note_length[measure_on] = default_note_length[last_m]
    bars[measure_on] = bars[last_m]
    tempo_speed_now[measure_on] = tempo_speed_now[last_m]
    tempo_now_note_length[measure_on] = tempo_now_note_length[last_m]
    measure_meter[measure_on] = meter       # Each measure change can have a different meter.
    pitch[measure_on] = pitch[last_m]       # continue pitch from measure before.
    return
# End of do_measure

# ----------------------------------------------------------------------------
# The number of notes of second argument note length in a measure.
#       meter   1/4             $$ 1 quarter note per measure.
#       meter   12/8            $$ 12 eighth notes per measure.
#       meter   4,4             $$ 4 quarter notes per measure.
# Note: the comma allows for IMS format "time" command.

def do_meter(t_args, original_line):
    global meter
    global measure_meter
    global measure_meter_value
    global measure_on
    global args
    global mlth

    if t_args is None or t_args == '':
        print_error("meter does not have an expression to process", original_line)
        return
    # fi

    for ve in range(1, len(vl)+1):
        if mlth[ve][measure_on] != 0:
            print_error("meter in the middle of a measure not allowed", original_line)
            return
        # fi
    # rof

    m = t_args
    m = re.sub(r',', r'/', m)

    f, type_error = is_float(m, is_float_number, False)
    if type_error is not None:
        print_error("meter error - {}".format(type_error), original_line)
        return
    # fi
    if f is None:
        print_error("meter argument as a calculation did not return a value", original_line)
        return
    # fi
    meter = m
    measure_meter[measure_on] = m                       # Save text for meter.

    f, type_error = is_float(m, is_float_number, False)
    if type_error is not None:
        print_error("meter error - {}".format(type_error), original_line)
        return
    # fi
    if f is None:
        print_error("calculating meter did not return a value", original_line)
        return
    # fi
    measure_meter_value = f
    return
# End of do_meter

# ----------------------------------------------------------------------------
# The value for middle_c.
#       middlec 4c
#       middlec 3c
#       middlec 2b-

def do_middle_c(t_args, original_line):
    global middle_c
    global measure_on

    if t_args is None:
        print_error("middlec does not have a note to process", original_line)
        return
    # fi
    if t_args == '':
        compute_middle_c(39)
        return
    # fi
    note_to_decode = t_args
    temp3 = 0                                   # character pointer
    if note_to_decode[0] == '(':
        thenote, type_error = is_float(note_to_decode, is_float_number, False)
        if type_error is not None:
            print_error("middlec does not have a valid number in parenthesis", original_line)
            return
        # fi
        if thenote is None:
            print_error("middle_c - m:{} Note is not legal '{}', computation failed".format(measure_on, note_to_decode), original_line)
            return
        # fi
        note_to_decode = int(round(thenote))
        note_to_decode = note_to_decode + 12 + 12 - 3     # 3c -> 39 must be 60 for midi.
        if note_to_decode <= 0 or note_to_decode >= 127:
            print_error("middle_c - m:{} Note number '{}' not in range".format(measure_on, thenote), original_line)
            return
        # fi
        compute_middle_c(int(round(thenote)))
        return
     # fi

    if note_to_decode not in note_to_midi_value:
        print_error("middle_c - m:{} note_to_decode '{}' legal note".format(measure_on, note_to_decode), original_line)
        return
    # fi
    number = note_to_midi_value[note_to_decode] - (60 - middle_c)
    compute_middle_c(number)
    return
# End of do_middle_c

# ----------------------------------------------------------------------------
#   break
#   outloop
#   outloop abc == 4

def do_outloop(t_args, original_line):
    global measure_on
    global lmp_executing_which
    global lmp_executing_type
    global lmp_executing_args
    global lmp_executing_line
    global lmp_executing_i_line
    global lmp_executing_rest_of_line
    global lmp_executing_number
    global loop_location
    global loop_increment
    global loop_value_variable
    global loop_final_value
    global loop_endloop_exp
    global loop_buffer
    global loop_number

    l = lmp_executing_number
    if lmp_executing_type[l] != 'loop':
        print_error("outloop reached while not inside a loop", original_line)
        return
    # fi


    if t_args is None or len(t_args) == 0 or t_args == '':
        f1 = -1
    else:
        f1, type_error = is_float(t_args, is_float_number, False)
        if type_error is not None:
            print_error("m:{} outloop expression error - {}".format(measure_on, type_error), original_line)
            return
        # fi
        if f1 is None:
            print_error("m:{} outloop expression error - {}".format(measure_on, type_error), original_line)
            return
        # fi
    # fi

    if f1 < 0:
        delete_executing_variables(l)
        # Delete rest of loop variables.
        del lmp_executing_which[l]
        del lmp_executing_type[l]
        del lmp_executing_args[l]
        del lmp_executing_line[l]
        del lmp_executing_i_line[l]
        del lmp_executing_rest_of_line[l]       # No stuff after loop. Ignore it.
        lmp_executing_number = lmp_executing_number - 1

        loop_location.pop()
        loop_increment.pop()
        loop_value_variable.pop()
        loop_final_value.pop()
        loop_endloop_exp.pop()
        loop_buffer.pop()
        loop_number = loop_number - 1
    # fi
    return
# End of do_outloop

# ----------------------------------------------------------------------------
# Set page. This is only used for --pages argument to musicomp2abc command to
# limit which pages to do output for (.fs, .mid, .csv, .abc, .v, .h).

global page_warn_once
page_warn_once = True

def do_page(t_args, original_line):
    global cstop_processing
    global pages_to_do
    global args
    global page_warn_once
    global precomment

    precomment = precomment + original_line + "\n"   # Comment line.

    if t_args is None or t_args == '':
        print_error("Page missing argument.", original_line)
        return
    # fi

    vargs = t_args
    n, mesg = is_float(vargs, is_float_string, False)
    if mesg is not None or n is None:
        if page_warn_once:
            print_warning("ONCE#A: page is a command, and cannot set character string variable to it.", original_line)
            page_warn_once = False
        # fi
        setvar('page', -1, 0)           # integer/floating value
        n = vargs
    elif type(n) is float:
        if n.is_integer():
            n = int(n)
        # fi
        setvar('page', n, 0)            # integer/floating value
    elif type(n) is int:
        setvar('page', n, 0)            # integer/floating value
    else:
        if page_warn_once:
            print_warning("ONCE#B: page is a command, and cannot set character string variable to it.", original_line)
            page_warn_once = False
        # fi
        setvar('page', -1, 0)           # integer/floating value
        n = vargs
    # fi

    if args.pages == None or args.pages == '':
        return
    # fi
    if n not in pages_to_do:
        cstop_processing = True
        return
    # fi
    # Do cstart.
    cstop_processing = False
    return
# End of do_page

# ----------------------------------------------------------------------------
#       pan     1..4  90        $$ MIDI value 0 to 64 to 127.
# This is the left/right positioning of the audio sound. 64=straight ahead.

def do_pan(t_args, original_line):
    global pan
    global measure_on

    if t_args is None or t_args == '':
        print_error("pan does not have arguments.", original_line)
        return
    # fi

    targs = re.sub(r'\s*,\s*', ',', t_args)

    vargs = targs.split()
    if len(vargs) <= 0 or len(vargs) > 2:
        print_error("pan does not have correct number of arguments.", original_line)
        return
    # fi
    if len(vargs) == 1:
        p = 0
    else:
        p = vargs[1]
        f1, type_error = is_float(p, is_float_number, False)
        if type_error is not None:
            print_error("pan error - {}".format(type_error), original_line)
            return
        # fi
        if f1 is None:
            print_error("voice does not have pan argument {} as a number.".format(p), original_line)
            return
        # fi
        p = int(round(f1))
        if p < 0 or p > 127:
            print_error("pan value {} not in range 0 to 127.".format(p), original_line)
            return
        # fi
    # fi
    jkl = "".join(vargs[0])
    wargs = separate_args(jkl, None, True, original_line)   # Allow staff_name and voice numbers.
    if not wargs or len(wargs) < 1:
        print_error("no voice arguments on pan line", original_line)
        return
    # fi
    for w in wargs:
        f1, type_error = is_float(w, is_float_number, False)
        if type_error is not None:
            print_error("pan error - {}".format(type_error), original_line)
            return
        # fi
        if f1 is None:
            print_error("voice {} is not a number.".format(w), original_line)
            return
        # fi
        f1 = int(round(f1))

        pan[f1][measure_on] = p
    # rof
    return
# End of do_pan

# ----------------------------------------------------------------------------
# '%%'      : do_percents,
def do_percents(t_args, original_line):
    global measure_on
    global percents

    if original_line[0:9] == '%%staves ':
        do_staves(original_line[9:])
    # fi
    if measure_on not in percents:
        percents[measure_on] = []
    # fi
    percents[measure_on].append(original_line)
    return
# End of do_percents

# ----------------------------------------------------------------------------
# This command raises or lowers the note pitch by the specified number of
# semitones. A semitone is one of the 12 notes in a scale from
#       c,c+,d,d+,e,f,f+,g,g+,a,a+,b,b+ and back to c one octave higher.
#   pitch -2            $$ sets semitones lower

def do_pitch(t_args, original_line):
    global pitch
    global measure_on
    global mlth

    if t_args is None or t_args == '':
        print_error("pitch does not have an expression to process", original_line)
        return
    # fi

    for ve in range(1, len(vl)+1):
        if mlth[ve][measure_on] != 0:
            print_error("pitch in the middle of a measure not allowed", original_line)
            return
        # fi
    # rof

    m = t_args

    f, type_error = is_float(m, is_float_number, False)
    if type_error is not None:
        print_error("Tempo error - {}".format(type_error), original_line)
        return
    # fi
    if f is None:
        print_error("pitch argument as a calculation did not return a value", original_line)
        return
    # fi
    pitch[measure_on] = int(round(f))
    return
# End of do_pitch

# ----------------------------------------------------------------------------
def do_process(t_args, original_line):
    global process_defining
    global process_defining_count
    global process_number
    global process_name
    global process_argument
    global process_buffer
    global staff_keywords

    if t_args is None or t_args == '':
        print_error("process command does not have any arguments.", original_line)
        return ''
    # fi
    # Get rid of multiple spaces/tabs.
    t_args = re.sub(r'\s+', r' ', t_args)
    # Get rid of spaces before/after commas/semicolons.
    t_args = re.sub(r'\s*([,;])\s*', r'\1', t_args)
    # Split on [a-z0-9A-Z_] and not. (Identifier alphanumeric or underscore)
    wargs = [i for i in re.split(r'(\w+|\W+)', t_args) if i]
    if not wargs or len(wargs) < 3 or wargs == '':
        print_error("no process name.", original_line)
        return
    # fi
    name = wargs[0]
    if name in commands:
        print_error("process ({}) would replace existing command".format(name), original_line)
        return
    elif name in staff_keywords:
        print_error("process ({}) would replace existing staff keyword".format(name), original_line)
        return
    elif name in staff_name:
        print_error("process ({}) would replace existing staff name".format(name), original_line)
        return
    elif name in process_name:
        print_warning("process ({}) replaces existing process".format(name), original_line)
        x = process_name.index(name)
        process_name[x] = name                          # Array of names, duplicates NOT allowed.
        process_argument[x] = wargs[2]                  # Argument.
        process_buffer[x] = []                          # No lines in buffer.
        process_defining = x
        process_defining_count = process_defining_count + 1
        return
    elif wargs[1] != ',':
        print_error("process ({}) needs comma separator to named argument, not '{}'".format(name, wargs[1]), original_line)
        return
    elif not re.match(r'^\w+', wargs[2]):
        print_error("process ({}) needs named argument, not '{}'".format(name, wargs[2]), original_line)
        return
    # fi
    # Check if name and terminators match previous process.
    process_name.append(name)                           # Array of names, duplicates NOT allowed.
    process_argument.append(wargs[2])                   # Argument.
    process_buffer.append([])                           # No lines in buffer.
    process_defining = process_number
    process_number = process_number + 1
    process_defining_count = process_defining_count + 1
    return
# End of do_process

# ----------------------------------------------------------------------------
# putd ... if already existing, replace with warning.
#     putd   /cmajor/c,e,g/
#     =cmajor,b           # c,e,g,b       Note: do multiple putd's on this line.
# Stop when no change occurs, or 25 tries. (Catches A -> B -> A loops.)

def do_putd(t_args, original_line):
    if t_args is None or t_args == '':
        print_error("putd does not have an argument.", original_line)
        return
    # fi
    c = t_args[0]                    # The separation character.
    two = t_args.split(c)
    if len(two) != 4 or two[0] != '' or two[3] != '':
        print_error("putd should look like '/zzz/a,b,c/' - not right number of separators ({}).".format(c), original_line)
        return
    # fi
    putds[two[1]] = two[2]
    return
# End of do_putd

# ----------------------------------------------------------------------------
#   randp   m1          $$ Assigned unduplicated random numbers from last setperm.

def do_randp(t_args, original_line):
    global array_of_random_numbers

    if t_args is None or t_args == '':
        print_error("randp command does not have exactly one argument.", original_line)
        return
    # fi
    wargs = separate_args(t_args, False, True, original_line)
    if not wargs or len(wargs) < 1:
        print_error("no randp argument.", original_line)
        return
    # fi
    if len(array_of_random_numbers) <= 0:
        # print_error("randp needs a setperm before it runs.".format(wargs[0], value), original_line)
        ran = 0
    else:
        ran = array_of_random_numbers.pop()
    # fi
    computeit = wargs[0] + '=' + str(ran)       # Do the assignment.
    value, type_error = is_float(computeit, is_float_number, False)
    if type_error is not None or value is None:
        print_error("randp unable to assign value({}) to first argument({}).".format(wargs[0], value), original_line)
        return
    # fi
    return
# End of do_randp

# ----------------------------------------------------------------------------
#   randu   m1,10       $$ random number between 1 and 10 put into variable m1.

def do_randu(t_args, original_line):
    if t_args is None or t_args == '':
        print_error("randu command does not have any arguments.", original_line)
        return
    # fi
    wargs = separate_args(t_args, False, True, original_line)
    if not wargs or len(wargs) < 1:
        print_error("no randu arguments", original_line)
        return
    # fi

    value, type_error = is_float(wargs[1], is_float_number, False)     # From 1 to value.
    if type_error is not None or value is None or value < 1:
        print_error("randu unable to compute reasonable value({}) to store in ({}).".format(wargs[1], wargs[0]), original_line)
        return
    # fi
    ran = random.randint(1, int(round(value)))  # Random value.
    computeit = wargs[0] + '=' + str(ran)       # Do the assignment.
    value, type_error = is_float(computeit, is_float_number, False)
    if type_error is not None or value is None:
        print_error("randu unable to assign value({}) to first argument({}).".format(wargs[0], value), original_line)
        return
    # fi
    return
# End of do_randu

# ----------------------------------------------------------------------------
#   reloop                                      # Always reloop. (Go to endloop, then to top.)
#   reloop m1 == 0                              # Reloop if true. (Go to endloop, then to top.)

def do_reloop(t_args, original_line):
    global measure_on
    global lmp_executing_which
    global lmp_executing_type
    global lmp_executing_args
    global lmp_executing_line
    global lmp_executing_i_line
    global lmp_executing_rest_of_line
    global lmp_executing_number
    global loop_location
    global loop_increment
    global loop_value_variable
    global loop_final_value
    global loop_endloop_exp
    global loop_buffer
    global loop_number

    l = lmp_executing_number
    if lmp_executing_type[l] != 'loop':
        print_error("reloop reached while not inside a loop", original_line)
        return
    # fi

    if t_args is None or len(t_args) == 0 or t_args == '':
        f1 = -1
    else:
        f1, type_error = is_float(t_args, is_float_number, False)
        if type_error is not None:
            print_error("m:{} reloop expression error - {}".format(measure_on, type_error), original_line)
            return
        # fi
        if f1 is None:
            print_error("m:{} reloop expression error - {}".format(measure_on, type_error), original_line)
            return
        # fi
    # fi

    if f1 < 0:
        delete_executing_variables(l)
        the_loop = lmp_executing_which[l]
        lines = loop_buffer[the_loop]
        lmp_executing_line[l] = len(lines)
    # fi
    return
# End of do_reloop

# ----------------------------------------------------------------------------
# Set MIDI reverb value for voice.
#       reverb  1..4  90        $$ MIDI value 0 to 127.

def do_reverb(t_args, original_line):
    global reverb
    global measure_on

    if t_args is None or t_args == '':
        print_error("reverb does not have arguments.", original_line)
        return
    # fi

    targs = re.sub(r'\s*,\s*', ',', t_args)

    vargs = targs.split()
    if len(vargs) <= 0 or len(vargs) > 2:
        print_error("reverb does not have correct number of arguments.", original_line)
        return
    # fi
    if len(vargs) == 1:
        r = 0
    else:
        r = vargs[1]
        f1, type_error = is_float(r, is_float_number, False)
        if type_error is not None:
            print_error("reverb error - {}".format(type_error), original_line)
            return
        # fi
        if f1 is None:
            print_error("voice does not have reverb argument {} as a number.".format(r), original_line)
            return
        # fi
        r = int(round(f1))
    # fi
    if r < 0 or r > 127:
        print_error("reverb value {} not in range 0to 127.".format(r), original_line)
        return
    # fi

    jkl = "".join(vargs[0])
    wargs = separate_args(jkl, None, True, original_line)   # Allow staff_name and voice numbers.

    if not wargs or len(wargs) < 1:
        print_error("no voice arguments on reverb line", original_line)
        return
    # fi
    for w in wargs:
        f1, type_error = is_float(w, is_float_number, False)
        if type_error is not None:
            print_error("reverb error - {}".format(type_error), original_line)
            return
        # fi
        if f1 is None:
            print_error("voice {} is not a number.".format(w), original_line)
            return
        # fi
        f1 = int(round(f1))

        reverb[f1][measure_on] = r
    # rof
    return
# End of do_reverb

# ----------------------------------------------------------------------------
#   setperm 44          $$ Semi random numbers between 1 and 44, without duplication.

def do_setperm(t_args, original_line):
    global array_of_random_numbers

    if t_args is None or t_args == '':
        print_error("setperm command does not have any arguments.", original_line)
        return
    # fi
    wargs = separate_args(t_args, False, True, original_line)
    if not wargs or len(wargs) != 1:
        print_error("Need exactly one setperm argument", original_line)
        return
    # fi

    value, type_error = is_float(wargs[0], is_float_number, False)     # From 1 to value.
    if type_error is not None or value is None or value < 1:
        print_error("setperm unable to compute reasonable value({}) for number of unique random numbers.".format(wargs[0]), original_line)
        return
    # fi
    value = int(round(value))                   # So, python2 and python3 do round differently. *SCREAM*
    array_of_random_numbers = random.sample(range(1, value+1), value)
    return
# End of do_setperm

# ----------------------------------------------------------------------------
# For spaces command, set argument --spaces.
#       spaces
#   Use spaces instead of commas for note separators.
#       4c8 d e f g a b 5c
# Normal is: 4c8,d,e,f, g,a,b,c
# The "space" after a comma is used for printing to group first 4 eighth notes,
# and the second four 8th notes -- their heads.

def do_spaces(t_args, original_line):
    global args
    global precomment

    precomment = precomment + original_line + "\n"   # Comment line.
    if t_args and t_args in [ 'off', 'no', 'False', 'false', 'comma', 'none', 'not']:
        args.spaces = False
        return
    elif not t_args or t_args in [ 'on', 'yes', 'True', 'true']:
        args.spaces = True
        return
    else:
        print_error("spaces argument '{}' unrecognized, assuming 'on'".format(t_args), original_line)
        args.spaces = True
        return
    # fi
# End of do_spaces

# ----------------------------------------------------------------------------
#   staff -- complicated arguments, staff name, voices, etc.

def do_staff(t_args, original_line):
    global staff_name
    global last_voice_staff

#--     print_debug("do_staff - t_args='{}'".format(t_args))
    if t_args is None or t_args == '':
        print_error("staff does not have a name argument.", original_line)
        return
    # fi
    targs = re.sub(r'\s+', '', t_args)          # Toss spaces.
    if targs is None or targs == '':
        print_error("staff does not have a name argument.", original_line)
        return
    # fi
    # Returns where in strng termination is. -1 if not found. 0=first character.
    x = find_terminator_in_string(targs, [':'], True, original_line)
    if x < 0:
        sn = targs                              # Staff name.
        v = None                                # No voices.
    elif x == 0:
        print_error("staff does not have a name argument before the colon(:)", original_line)
        return
    else:
        sn = targs[0:x]
        if x+1 >= len(targs):
            v = None
        else:
            v = targs[x+1:]
        # fi
    # fi
    if v is not None:
        vs = separate_args(v, True, True, original_line)
#--         print_debug("do_staff - vs='{}'".format(vs))
        v = []
        for w in vs:
            f1, type_error = is_float(w, is_float_number, False)
            if type_error is not None:
                print_error("staff error - {}".format(type_error), original_line)
                return
            # fi
            if f1 is None:
                print_error("voice {} is not a number.".format(w), original_line)
                return
            # fi
            f1 = int(round(f1))
            if f1 < 1  or f1 > MAXVOICES:       # If out of range.
                print_error("number of voices must between 1 and {} inclusive. Not ({})".format(MAXVOICES, f1), original_line)
                return
            # fi
#--             print_debug("do_staff - f1='{}'".format(f1))
            # Check if voice already used in a stave.
            for a in staff_name:
                # Allow staff to be redefined. Can delete voices too.
                if f1 in staff_name[a] and a != sn:
                    print_warning("voice {} used in staff {} already".format(w, a), original_line)
                # fi
            # rof
            initialize_set_voices(f1, original_line)     # If voices not set up yet, set them up.
            fill_voice_mlth(False, original_line)        # Need to make measure for other voices up to here "mlth".
            v.append(f1)
        # fi
    # fi

    staff_name[sn] = v                          # Create or change it.
    staves.append(v)                            # For order checking for ABC printing -- indirectly.
    last_voice_staff = [sn]
    setvar('voice', ','.join(last_voice_staff), 1)  # Doesn't need join, but do it for consistency.
    cis = sn                                    # No longer doing just one voice.   NOTDONEYET - set voice to staff.
    do_spaces('on', original_line)              # Process spaces or commas -- no spaces in middle of notes.
    return
# End of do_staff

# ----------------------------------------------------------------------------
# See abc notation for format of %%staves command for printing.
#       %%staves [(1 2) 3 (4 5)]
#       =%%staves [(fluteA fluteB) (oboeA oboeB) (clarinetA clarinetB) \
#                  (bassoonA bassoonB) (french_hornA french_hornB)] \
#                 [(violin1A violin1B violin1C) (violin2A violin2B violin2C)] \
#                 [(violaA violaB violaC) celloA contrabassA]
# ( ) groups together on a staff.
# [...] puts all within "together" with bar on left.

def do_staves(original_line):
    global staves

    line = original_line.strip()
    line = ' '.join(line.split())
    line = line.replace('[', '')
    line = line.replace(']', '')
    line = line.replace(' )', ')')
    line = line.replace(' (', '(')
    line = line.replace(') ', ')')
    z = line.split(')')
    # Now, any array entry that starts with ( is a list of voices to order.
    #     Check for more than 1 number.
    # else ignore the numbers -- they are on separate staves.
    for x in z:
        if x == '' or x[0] != '(':
            continue
        # fi
        x = x[1:]
        y = x.split()
        if len(y) <= 1:
            continue
        # fi
        staves.append(y)
    # rof
    return
# End of do_staves

# ----------------------------------------------------------------------------
# Give a title to a printed or played song (abcm2ps, or .mid).
#       title   Inventio 15    by Bach
#       title   for plato by Marshall Midden

def do_title(t_args, original_line):
    global header
    global args

    if t_args is None or t_args == '':
        #-- print_warning("Title does not have any text.", original_line)
        if args.vertical or args.horizontal:
            header = header + "title   \n"
        elif args.midi1csv or args.fluidsynth:
            pass
        else:           # ABC
            header = header + "T:\n"
        # fi
        return
    # fi
    # T: Title of tune        (can have multiple)
    if args.vertical or args.horizontal:
        header = header + "title   {}\n".format(t_args)
    elif args.midi1csv or args.fluidsynth:
        header.append(t_args)
    else:           # ABC
        header = header + "T:{}\n".format(t_args)
    # fi
    return
# End of do_title

# ----------------------------------------------------------------------------
# tempo is measured according to beats per minute (bpm) and is divided into:
#       Grave ( <30 bpm)
#       largo (40-50 bpm)
#       larghetto (51-60 bpm)
#       adagio (61-76 bpm)
#       andantino (77-83 bpm)
#       andante (84-90 bpm)
#       andante moderato (90-100 bpm)
#       moderato (100-115 bpm)
#       allegretto (117-119 bpm)
#       allegro (120-160 bpm)
#       allegro con Brio (139 bpm)
#       molto allegro (140-160 bpm)
#       allegro vivace (161-170 bpm)
#       vivace (171-179 bpm)
#       presto (180-199 bpm)
#       prestissimo (>=200 bpm)
# Music types:
#       hip hop (80-115 bpm)
#       triphop (90-110 bpm)
#       concert marches (12- bpm)
#       house (118-135 bpm)
#           UK garage/2-step (130-135 bpm)
#           UK funky (130 bpm)
#       Techno (120-160 bpm)
#           Usually (120-135 bpm)
#           Acid Techno (135-150 bpm)
#           Schranz (150 bpm)
#       Dubstep (70-100 bpm)
#           *Dubstep (70-75 bpm) -- equivalent to 140-150 bpm (if you count on 2 and 4, or 3)
#       Screamers (130-150 bpm)
#       Hardstyle (150 bpm)
#       Juke/Footwork (160 bpm)
#       Drum and Bass (160-180 bpm)
#           Oldschool jungle 160-170 bpm)
#           Drum & Bass and Drumstep and Neurofunk (170-180 bpm)
#       Grime (140 bpm)
#
#   tempo  150,4        $$ Number of notes of given length in a minute.
#   tempo  30           $$ Number of frames (1/57.1429 seconds) per whole note.
#   tempo  200,8        $$ So fast you won't recognize individual notes (:-)>[=<
# NOTDONEYET (below) tempo - accel and rit.
#   tempo  accel        $$ accelerate from current tempo to next tempo command.             NOTDONEYET
#   tempo  120,4,accel  $$ Change to current tempo, and accelerate to next tempo command    NOTDONEYET
#   tempo  120,4,rit    $$ Change to current tempo, and decelerate to next tempo command.   NOTDONEYET

def do_tempo(t_args, original_line):
    global tempo_speed_default          # beats per minute
    global default_note_length          # length of a beat (note)
    global tempo_speed_now
    global tempo_now_note_length
    global measure_on
    global mlth
    global vl

    if t_args is None or t_args == '':
        print_error("tempo does not have one or two arguments.", original_line)
        return
    # fi
    wargs = t_args.split(',')
    if wargs is None or len(wargs) == 0 or len(wargs) > 2:
        if wargs[2] in ('accel','rit'):
            print_warning("NOTDONEYET - tempo '{}' NOTDONEYET.".format(wargs[2]), original_line)
        else:
            print_error("tempo - there is not one or two arguments.", original_line)
            return
        # fi
    # fi

    fill_voice_mlth(False, original_line)                   # Need to make measure for other voices up to here "mlth".

    for ve in range(1, len(vl)+1):
        if mlth[ve][measure_on] != 0:
            print_error("tempo in the middle of a measure not allowed mlth[{}][{}]='{}'".format(ve, measure_on, mlth[ve][measure_on]), original_line)
            return
        # fi
    # rof

    #   f1 is value -- So far computed value
    #   type_error -- type of error
    f1, type_error = is_float(wargs[0], is_float_number, False)
    if type_error is not None:
        print_error("tempo does not have first argument as a floating number. {}".format(type_error), original_line)
        return
    # fi
    if f1 is None:
        print_error("tempo does not have first argument as a floating number.", original_line)
        return
    # fi
    if len(wargs) == 1:
        x = f1 / 60.0
        if measure_on == '':
            tempo_speed_default = x
        # fi
        default_note_length[measure_on] = 1.0               # whole note
        tempo_speed_now[measure_on] = x
        tempo_now_note_length[measure_on] = 1.0
        return
    # fi
    xxx = wargs[1].replace('d', '*1.5')
    if xxx == 'w':
        xxx = '1'
    elif xxx == 'h':
        xxx = '2'
    elif xxx == 'q':
        xxx = '4'
    elif xxx == 'e':
        xxx = '8'
    # fi
    # f2, type_error = is_float(wargs[1], is_float_number, False)
    f2, type_error = is_float(xxx, is_float_number, False)
    if type_error is not None:
        print_error("Tempo error - {}".format(type_error), original_line)
        return
    # fi
    if f2 is None:
        print_error("tempo does not have second argument as a floating number.", original_line)
        return
    # fi
    if measure_on == '':
        tempo_speed_default = f1
    # fi
    default_note_length[measure_on] = (1.0 / f2)
    tempo_speed_now[measure_on] = f1
    tempo_now_note_length[measure_on] = (1.0 / f2)
    return
# End of do_tempo

# ----------------------------------------------------------------------------
# do_vars    cows, EAT, grass(2,10), TOO(2,2)
#
# Define numeric or character variables.
#
# Above, "cows" is a single numeric variable. "grass" is a 2 by 10 array of
# numeric variables. One and two dimensional arrays are allowed.
#
# "EAT" is a character variable. TOO is a two dimensional character variable.
#
# Variables defined within a macro are local to that macro and any macros it
# calls. Newly defined variables are initialized to zero.

def do_vars(t_args, original_line):
    global lmp_executing_number

    handle_vars_and_global(t_args, lmp_executing_number, original_line)
    return
# End of do_vars

# ----------------------------------------------------------------------------
#   voice 4                             $$ number of voices from now onwards.   sets volume too. Default 4?
#   voice 4   50,60,70,80               $$ Set the instruments %%MIDI program 50 ...
# NOTE: use "instrument" command instead. :)

def do_voice(t_args, original_line):
    global cis                          # non-zero if doing one voice only.
    global vinstrument
    global reverb
    global pan
    global intensity
    global measure_on
    global instruments
    global drum_sounds

    if t_args is None or t_args == '':
        print_error("voice does not have one argument.", original_line)
        return
    # fi

    for ve in range(1, len(vl)+1):
        if mlth[ve][measure_on] != 0:
            print_error("voice in the middle of a measure not allowed", original_line)
            return
        # fi
    # rof

    targs = re.sub(r'\s*,\s*', ',', t_args)

    vargs = targs.split()
    f1, type_error = is_float(vargs[0], is_float_number, False)
    if type_error is not None:
        print_error("voice error - {}".format(type_error), original_line)
        return
    # fi
    if f1 is None:
        print_error("voice does not have first argument as a number.", original_line)
        return
    # fi
    f1 = int(round(f1))
    if f1 < 1  or f1 > MAXVOICES:       # If out of range.
        print_error("number of voices must between 1 and {} inclusive. Not ({})".format(MAXVOICES, f1), original_line)
        return
    # fi

    initialize_set_voices(f1, original_line)

    fill_voice_mlth(False, original_line)               # Need to make measure for other voices up to here "mlth".

    # If there are more arguments, choose instruments for the voices.
    if len(vargs) > 1:
        jkl = "".join(vargs[1:])
        wargs = separate_args(jkl, False, True, original_line)
        if not wargs or len(wargs) < 1:
            print_error("no instrument selection arguments on voice line", original_line)
            return
        # fi
        if len(wargs) > f1:
            print_error("number instruments ({}) greater than voices ({})".format(len(wargs), f1), original_line)
        # fi
        for i in range(0, len(wargs)):
            j = str(wargs[i])    # No checking.
            j = str(j).lower()
            if j in instruments:
                vinstrument[i+1][measure_on] = j
                reverb[i+1][measure_on] = int(getvar_checkokay('default_reverb', original_line))
                pan[i+1][measure_on] = int(getvar_checkokay('default_pan', original_line))
                intensity[i+1][measure_on] = int(getvar_checkokay('default_intensity', original_line))
            elif j in drum_sounds:
                vinstrument[i+1][measure_on] = j
                reverb[i+1][measure_on] = int(getvar_checkokay('default_reverb', original_line))
                pan[i+1][measure_on] = int(getvar_checkokay('default_pan', original_line))
                intensity[i+1][measure_on] = int(getvar_checkokay('default_intensity', original_line))
            else:
                f1, type_error = is_float(j, is_float_number, False)
                if type_error is not None:
                    print_error("voice error - {}".format(type_error), original_line)
                    return
                # fi
                if f1 is None:
                    print_error("voice does not have instrument argument {} as a number.".format(j), original_line)
                    return
                # fi
                f1 = int(round(f1))
                flg = False
                for q in instruments:
                    if [f1, 0] == instruments[q]:
                        flg = True
                        break
                    # fi
                # rof

                if not flg:
                    print_error("instrument value {} not in instrument table.".format(f1), original_line)
                    return
                # fi
                vinstrument[i+1][measure_on] = q
                reverb[i+1][measure_on] = int(getvar_checkokay('default_reverb', original_line))
                pan[i+1][measure_on] = int(getvar_checkokay('default_pan', original_line))
                intensity[i+1][measure_on] = int(getvar_checkokay('default_intensity', original_line))
            # fi
        # rof
    # fi

    cis = 0                             # No longer doing just one voice.
    return
# End of do_voice

# ----------------------------------------------------------------------------
#       volume  3,6                         $$ Voice 1 volume at 3, 2 at 6 (out of 7).
#       volume  4,4,4,4                     $$ volume 4 on all four voices.

def do_volume(t_args, original_line):
    handle_volume_both(t_args, "volume", original_line)
    return
# End of do_volume

# ----------------------------------------------------------------------------
# This allows numbers 1 to 128.
#      =volumes fluteA..contrabassA f       $$ Set lots of voices to volume "f".
#       volumes mf, f, fff                  $$ Voice 1 at mf, 2 at f and 3 at fff.

def do_volumes(t_args, original_line):
    handle_volume_both(t_args, "volumes", original_line)
    return
# End of do_volumes

# ----------------------------------------------------------------------------
# NOTE/WARNING: if you have xpose without a key, it goes to key_default.
# This is UGLY.
#       =xpose  clarinetA..clarinetB -2     $$ clarinett in B ...  C, B-, B  ->  -2
#       xpose   c-                          $$ all voices, from current key to key c-.
#       xpose   1 c-                        $$ voice 1, from current key to key c-.
#       xpose   1 -1 c-                     $$ voice 1, down 1 semi-tone, then to key c-,
# and change to key c- if --vertical/--horizontal.
#       xpose   1 +12                       $$ 4c = 5c
#       xpose   1,2..5,7 +2                 $$ French Horn in D plays 2 semitones higher from what is written
#       xpose   1 -12                       $$ French Horn in C plays 12 semitones lower
#       xpose   1 -7                        $$ 4c = 3f
#       xpose   1 +2                        $$ Trombone in D plays 2 semitones higher from what is written
#       xpose   1 -3                        $$ Clarinet in A ... "C" plays "A" (i.e. C, B, B-, A = -3)
#       =xpose  bassdrumA  -13              $$ 2c (printed) -> 0bn (played)
#       =xpose  cymbalA  -1                 $$ 2e (printed) -> 2d- (played)
# NOTE: the --vertical and --horizontal and key changes ... *sigh* complicated.

def do_xpose(t_args, original_line):
    global xpose
    global xpose_new_key
    global measure_on
    global key_sig
    global key_sig_int
    global key_default
    global args
    global key_voice

    if args.noxpose:
        print_warning("Ignoring xpose parsing due to --noxpose argument.", original_line)
        return
    # fi
    if args.abc:
        print_warning("Ignoring xpose parsing for --abc output format. ", original_line)
        return
    # fi
    if t_args is None or t_args == '':
        print_error("xpose does not have arguments.", original_line)
        return
    # fi
    targs = re.sub(r'\s*,\s*', ',', t_args)
    vargs = targs.split()
    if len(vargs) <= 0 or len(vargs) > 4:
        print_error("xpose does not have correct number of arguments.", original_line)
        return
    # fi
    kl = None
    if len(vargs) > 1:
        mm = vargs[len(vargs) - 1].lower()      # Last argument
        kl = vargs[len(vargs) - 2].lower()      # Second to last argument
        if mm == 'minor':
            if kl not in minor_key_to_major:
                print_error("xpose command, key does not recognize minor {}".format(kl), original_line)
                return
            # fi
            kl = minor_key_to_major[kl].lower()
            vargs.pop()
        elif mm == 'major':
            if kl not in key_sig:
                print_error("xpose command, key '{}' not recognized.".format(kl), original_line)
                return
            # fi
            vargs.pop()
        else:
            kl = None
        # fi
    # fi
    if len(vargs) > 1:
        if len(vargs) == 4:
            print_error("xpose command only allows 3 arguments.".format(kl), original_line)
            return
        elif len(vargs) == 3:
            if kl is None:
                kl = vargs[2].lower()
            # fi
            x = vargs[1]                # shifting amount
            vs = vargs[0]               # voices to change
        elif len(vargs) == 2:
            vs = vargs[0]               # voices to change
            # Check if key, or a number.
            if kl is None:
                kl = vargs[1].lower()       # new key?
            # fi
            if kl in key_sig:
                x = '0'                 # shifting amount
            else:       # is a number?
                f1, type_error = is_float(kl, is_float_number, False)
                if type_error is not None:
                    print_error("xpose error#1 - {}".format(type_error), original_line)
                    return
                # fi
                if f1 is None:
                    print_error("voice does not have xpose argument {} as a number or key.".format(kl), original_line)
                    return
                # fi
                x = str(int(round(f1))) # Must be an integer as a string.
                kl = None
            # fi
        else:
            print_error("xpose has a problem.", original_line)
            return
        # fi
    else:   # Only one argument -- key or number?
        # Check if key, or a number.
        if kl is None:
            kl = vargs[0].lower()       # new key
        # fi
        if kl.lower() in key_sig:
            x = '0'                 # shifting amount
        else:       # is a number?
            x = kl
            kl = None
            f1, type_error = is_float(x, is_float_number, False)
            if type_error is not None:
                print_error("xpose error#2 - {}".format(type_error), original_line)
                return
            # fi
            if f1 is None:
                print_error("voice does not have xpose argument {} as a number or key.".format(kl), original_line)
                return
            # fi
            x = str(int(round(f1))) # Must be an integer as a string..
        # fi
        vs = '{}..{}'.format(1, len(vl))    # all voices
    # fi
    if type(kl) is str:
        if kl not in key_sig:
            print_error("no key '{}' in key_sig({})".format(kl, key_sig), original_line)
            return
        # fi
    # fi

    f1, type_error = is_float(x, is_float_number, False)
    if type_error is not None:
        print_error("xpose error#3 - {}".format(type_error), original_line)
        return
    # fi
    if f1 is None:
        print_error("voice does not have xpose argument {} as a number.".format(x), original_line)
        return
    # fi
    x = int(round(f1))              # Must be an integer.

    # kl is used in getnote via xpose_new_key (musicomp text)
    # kl is None means to use current key for voice.

    jkl = "".join(vs)
    wargs = separate_args(jkl, None, True, original_line)   # Allow staff_name and voice numbers.
    if not wargs or len(wargs) < 1:
        print_error("no voice arguments on xpose", original_line)
        return
    # fi
    # If kl is None, use key_default.
    if args.vertical or args.horizontal:
        kprint_lc = key_default                 # printing and used in xpose are the same.
    else:
        kprint_lc = key_sig_int[key_default]    # Key name extracted.
    # fi
    for w in wargs:
        f1, type_error = is_float(w, is_float_number, False)
        if type_error is not None:
            print_error("xpose error#4 - {}".format(type_error), original_line)
            return
        # fi
        if f1 is None:
            print_error("voice {} is not a number.".format(w), original_line)
            return
        # fi
        f1 = int(round(f1))
        if kl is None:
            if f1 in key_voice and measure_on in key_voice[f1]:
                xpose_new_key[f1] = key_voice[f1][measure_on]   # Use current key for voice
            else:
                xpose_new_key[f1] = kprint_lc
            # fi
        else:
            xpose_new_key[f1] = kl
        # fi
        xpose[f1] = x
    # rof
    return
# End of do_xpose

# ----------------------------------------------------------------------------
# ----------------------------------------------------------------------------
# Following does not do multiple sharps or flats, but that is crazy anyway. Neither naturals.
global key_sig
key_sig = { 'c+':7, 'f+':6, 'b':5, 'bn':5, 'e':4, 'en':4, 'a':3, 'an':3, 'd':2,
            'dn':2, 'g':1, 'gn':1, 'c':0, 'cn':0, 'f':-1, 'b-':-2, 'e-':-3,
            'a-':-4, 'd-':-5, 'g-':-6, 'c-':-7 }

global key_sig_int
key_sig_int = {}
for i in key_sig:
    if key_sig[i] not in key_sig_int:
        key_sig_int[key_sig[i]] = i
    # fi
# rof

global key_to_accidentals
key_to_accidentals = {
    'c':  ('c', 'd', 'e', 'f', 'g', 'a', 'b'),
    'cn':  ('c', 'd', 'e', 'f', 'g', 'a', 'b'),

    'f':  ('c', 'd', 'e', 'f', 'g', 'a', 'b-'),
    'b-': ('c', 'd', 'e-', 'f', 'g', 'a', 'b-'),
    'e-': ('c', 'd', 'e-', 'f', 'g', 'a-', 'b-'),
    'a-': ('c', 'd-', 'e-', 'f', 'g', 'a-', 'b-'),
    'd-': ('c', 'd-', 'e-', 'f', 'g-', 'a-', 'b-'),
    'g-': ('c-', 'd-', 'e-', 'f', 'g-', 'a-', 'b-'),
    'c-': ('c-', 'd-', 'e-', 'f-', 'g-', 'a-', 'b-'),

    'g':  ('c', 'd', 'e', 'f+', 'g', 'a', 'b'),
    'd':  ('c+', 'd', 'e', 'f+', 'g', 'a', 'b'),
    'a':  ('c+', 'd', 'e', 'f+', 'g+', 'a', 'b'),
    'e':  ('c+', 'd+', 'e', 'f+', 'g+', 'a', 'b'),
    'b':  ('c+', 'd+', 'e', 'f+', 'g+', 'a+', 'b'),
    'f+': ('c+', 'd+', 'e+', 'f+', 'g+', 'a+', 'b'),
    'c+': ('c+', 'd+', 'e+', 'f+', 'g+', 'a+', 'b+')
}

global key_convert
key_convert = { }
for i in key_to_accidentals:
    l = {}
    for o in range(0, 9) :
        m = 0
        for n in ('c', 'd', 'e', 'f', 'g', 'a', 'b'):
            l[str(o) + n + '--'] = str(o) + n + '--'
            l[str(o) + n + '-']  = str(o) + n + '-'
            l[str(o) + n]        = str(o) + key_to_accidentals[i][m]
            l[str(o) + n + 'n']  = str(o) + n + 'n'
            l[str(o) + n + '+']  = str(o) + n + '+'
            l[str(o) + n + '++'] = str(o) + n + '++'
            m = m + 1
        # rof
    # rof
    key_convert[i] = l
# rof

global minor_key_to_major
minor_key_to_major = {
    'a+': 'c+',
    'd+': 'f+',
    'g+': 'b',
    'c+': 'e',
    'f+': 'c+',
    'b':  'd',
    'e':  'g',

    'a':  'c',

    'd':  'f',
    'g':  'b-',
    'c':  'e-',
    'f':  'a-',
    'b-': 'd-',
    'e-': 'g-',
    'a-': 'c-'
}

# ----------------------------------------------------------------------------
def get_volume_number(name, command_name, original_line):
    global vlprint
    global volume_level

    v, type_error = is_float(name, is_float_number, False)
#--     print_debug("get_volume_number - name='{}' command_name='{}' v='{}' type_error='{}'".format(name,command_name,v,type_error))
    if type_error is not None:
        if command_name == 'volume':
            for j in volume_level:
                if name == j:
                    v = volume_level[j]
                    type_error = None
#--                     print_debug("get_volume_number - A - type(v)={} v={}".format(type(v),v))
                    break
                # fi
            # rof
        else:
            for j in vlprint:
                if name == vlprint[j]:
                    v = j
                    type_error = None
#--                     print_debug("get_volume_number - B - type(v)={} v={}".format(type(v),v))
                    break
                # fi
            # rof
        # fi
        if type_error is not None:
            print_error(command_name + " did not get have a number or volume name. {}".format(type_error), original_line)
            return None
        # fi
        # Fall through, because we found it via letters.
    # fi
#--     print_debug("get_volume_number - C - type(v)={} v={}".format(type(v),v))
    if v is None:
        print_error(command_name + " does not have argument as a number.", original_line)
        return None
    # fi
    v = int(round(v))
    if v < 0:                       # If error or bad value
        print_error(command_name + " for voice {} not good {}, making it zero.".format(i, v), original_line)
        v = 0
    # fi
#--     print_debug("get_volume_number - D - type(v)={} v={}".format(type(v),v))
    if command_name in ['volumes', 'keyword_volumename', 'keyword_volumenumber']:
        if v > 127:                 # If error or bad value
            print_error(command_name + " {} ({}) not good, making it 127.".format(name, v), original_line)
            v = 127
        # fi
    elif command_name == 'volume' and v > 7:    # If error or bad value
        print_error(command_name + " {} ({}) not good, making it 7 (127 for midi).".format(name, v), original_line)
        v = 127
    else:
#--         print_debug("get_volume_number - E - type(v)={} v={}".format(type(v),v))
        if v >= 7:
            v = getvar('vffff')               # 110: 'ffff',
        elif v ==6:
            v = getvar('vfff')                # 100: 'fff',
        elif v ==5:
            v = getvar('vff')                 # 90: 'ff',
        elif v ==4:
            v = getvar('vmf')                  # 70: 'mf',
        elif v ==3:
            v = getvar('vmp')                  # 60: 'mp',
        elif v ==2:
            v = getvar('vpp')                 # 40: 'pp',
        elif v ==1:
            v = getvar('vppp')                # 30: 'ppp',
        else:
            v = getvar('vpppp')
        # fi
    # fi
#--     print_debug("get_volume_number - F - type(v)={} v={}".format(type(v),v))
    return v
# End of get_volume_number

# ----------------------------------------------------------------------------
#   volume  4,7,5                       $$ for 3 voices; mf and fff, and a touch louder.
#       The volume is a number between 0 and 7, inclusive.
#       Caution: you should use only volumes 5 through 7
#   volumes mf,fff,f                    $$ for 3 voices; mf and fff, and a touch louder.
#       The volumes are a number between 0 and 127, inclusive.

def handle_volume_both(t_args, command_name, original_line):
    global vl                           # volume levels
    global measure_on
    global args
    global cresc_direction
    global cresc_time
    global cresc_volume
    global running_vl

#--     print_debug("handle_volume_both - t_args='{}' command_name='{}'".format(t_args, command_name))
    if t_args is None or len(t_args) == 0:
        print_error(command_name + " needs at least one argument", original_line)
        return
    # fi
    # All spaces before or after commas is gone.
    targs = re.sub(r'\s*,\s*', ',', t_args)
    vargs = targs.split()
    if len(vargs) <= 0 or len(vargs) > 2:
        print_error("{} does not have correct number of arguments.".format(command_name), original_line)
        return
    # fi
    # . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
    if len(vargs) == 1:
        # 1 or 1,2,3 ... .
#--         print_debug("handle_volume_both - #A")
        wargs = separate_args(vargs[0], command_name, True, original_line)
#--         print_debug("handle_volume_both #1 - wargs='{}'".format(wargs))
        if len(wargs) == 0 or len(wargs) > MAXVOICES:
            print_error(command_name + " needs from one to {} arguments".format(MAXVOICES), original_line)
            return
        # fi
#--         print_debug("handle_volume_both - wargs='{}'".format(wargs))
        for i in range(1, len(wargs)+1):
            v = str(wargs[i - 1])
#--             v = get_volume_number(nbr, command_name, original_line)
#--             print_debug("handle_volume_both #1 - i='{}' v={} nbr='{}'".format(i,v,nbr))
#--             if v is None:
#--                 return
#--             # fi
            if not i in vl:
                new_voice_initialize(i, measure_on)
            # fi
            vl[i][measure_on] = v           # Change volume for voice.
            running_vl[i][measure_on] = v   # Force running change - also stop crescendo.
            cresc_volume[i] = 0
            cresc_time[i] = 0
            cresc_direction[i] = True
        # rof
    else:
    # . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
#--         print_debug("handle_volume_both - #B")
        wargs = separate_args(vargs[0], command_name, True, original_line)
#--         print_debug("handle_volume_both #2 - vargs='{}' wargs='{}'".format(vargs,wargs))
        v = get_volume_number(vargs[1], command_name, original_line)
#--         print_debug("handle_volume_both #3 - v='{}' vargs[1]='{}'".format(v,vargs[1]))
        for i in range(1, len(wargs)+1):
            nbr = str(wargs[i - 1])
#--             print_debug("handle_volume_both #A - i={} nbr='{}' wargs[i-1]='{}'".format(i,nbr,wargs[i-1]))
            f1, type_error = is_float(nbr, is_float_number, False)
#--             print_debug("handle_volume_both #a - i='{}' v='{}' f1='{}' type_error='{}'".format(i,v,f1,type_error))
            if type_error is not None:
                print_error("volume error - {}".format(type_error), original_line)
                return
            # fi
            if f1 is None:
                print_error("voice {} is not a number.".format(nbr), original_line)
                return
            # fi
            f1 = int(round(f1))
#--             print_debug("handle_volume_both #b - i='{}' f1={} v={}".format(i,f1,v))

            vl[f1][measure_on] = v           # Change volume for voice.
            running_vl[f1][measure_on] = v   # Force running change - also stop crescendo.
            cresc_volume[f1] = 0
            cresc_time[f1] = 0
            cresc_direction[f1] = True
        # rof
    # fi

    fill_voice_mlth(False, original_line)               # Need to make measure for other voices up to here "mlth".
    return
# End of handle_volume_both

# ----------------------------------------------------------------------------
def initialize_set_voices(f1, original_line):
    global voices                       # number of voices
    global measure_on

    if type(f1) is int:
        for i in range(1, f1 + 1):
            new_voice_initialize(i, measure_on)
        # rof
        voices = f1
        return
    elif type(f1) is str:
        if f1 not in staff_name:
            print_error("initialize_set_voices string '{}' is not a staff_name".format(f1), original_line)
            return
        # fi
        num = 1
        for i in staff_name[f1]:
            num = max(num, i)
        # rof
    elif type(f1) is list:
        num = 1
        for s in f1:
            if s not in staff_name:
                print_error("initialize_set_voices string '{}' is not a staff_name".format(s), original_line)
                return
            # fi
            if staff_name[s] is not None:
                for i in staff_name[s]:
                    num = max(num, i)
                # rof
            # fi
        # rof
    else:
        print_error("initialize_set_voices type(f1)='{}'".format(f1), original_line)
        return
    # fi
    for i in range(1, num+1):
        new_voice_initialize(i, measure_on)
    # rof
    voices = max(voices, num)
    return
# End of initialize_set_voices

# ----------------------------------------------------------------------------
# arg           - string with variable name with parens in it.
# a             - where the first parenthesis is located.
# original_line - for error messages, original line.
# create_it     - True if should create variable. False means it must exist correctly.

def handle_vars_parens(arg, a, create_it, original_line):
    global lmp_executing_number

    if a == 0:
        print_error("variable definition {} does not have a name before parenthesis.".format(arg), original_line)
        return None, None
    # fi
    token = arg[0:a]
    if not token[0].isalnum():
        print_error("variable name {} does not start with a alphabetic character.".format(arg))
        return None, None
    # fi
    for t in token[1:]:
        if not t.isalnum() and t != '_':
            print_error("variable name {} does not have all alphanumeric characters or '_'.".format(arg))
            return None, None
        # fi
    # rof
    if create_it:                       # Creating, must not exist at this level.
        wary = getvarmaclevel(token, lmp_executing_number)
        if wary is not None:
            print_warning("#a variable name {} redefined at current macro depth level {}".format(token, lmp_executing_number), original_line)
            delete_one_variable(token, lmp_executing_number)
            wary = None
        # fi
    else:                               # Fetching variable, it must exist.
        wary = chkvar(token)
        if wary is None:
            print_error("variable name {} does not exist.".format(token), original_line)
            return None, None
        # fi
    # fi
    aftertoken = arg[a:]
    w = 0
    e = []
    c = aftertoken[w]
    if c == '(':
        enddelim = ')'
    elif c == '[':
        enddelim = ']'
    else:
        print_error("Internal problem? variable {}, but no parenthesis for dimension.".format(arg), original_line)
        return None, None
    # fi
    e.append(enddelim)
    w = w + 1
    if w >= len(aftertoken):
        print_error("Found character variable {}, but no closing {}.".format(wary, enddelim), original_line)
        return None, None
    # fi
    dimensions = []
    before_comma = 1
    while True:
        while w < len(aftertoken):
            c = aftertoken[w]
            w = w + 1
            if c == enddelim:
                break
            # fi
            if w >= len(aftertoken):
                print_error("variable {}, but no closing {} -- {}.".format(token, enddelim, arg), original_line)
                return None, None
            elif c == '(':
                enddelim = ')'
                e.append(enddelim)
            elif c == '[':
                enddelim = ']'
                e.append(enddelim)
            elif len(e) == 1 and c == ',':
                f1 = aftertoken[before_comma:w-1]
                f, type_error = is_float(f1, is_float_number, False)
                if type_error is not None:
                    print_error("dimension '{}' does not have argument as an integer. {}".format(f1, type_error), original_line)
                    return None, None
                # fi
                if f is None:
                    print_error("dimension does not have first argument as an integer.", original_line)
                    return None, None
                # fi
                if type(f) is float:
                    if f.is_integer():
                        f = int(f)
                    # fi
                # fi
                if type(f) is not int:
                    print_error("dimension '{}' is not an integer. {}".format(f1, type_error), original_line)
                    return None, None
                # fi
                dimensions.append(f)
                before_comma = w
            # fi
        # elihw
        enddelim = e.pop()
        if e == []:
            f1 = aftertoken[before_comma:w-1]
            f, type_error = is_float(f1, is_float_number, False)
            if type_error is not None:
                print_error("dimension '{}' does not have argument as an integer. {}".format(f1, type_error), original_line)
                return None, None
            # fi
            if type(f) is not float and type(f) is not int:
                print_error("dimension value '{}' is not an integer. {}".format(f1, type_error), original_line)
                return None, None
            # fi
            if type(f) is float and f.is_integer():
                f = int(f)
            # fi
            if f is None or type(f) is not int:
                print_error("dimension does not have {} argument as an integer.".format(len(dimensions)+1), original_line)
                return None, None
            # fi
            dimensions.append(f)
            break
        # fi
    # elihw
    if w < len(aftertoken):
        print_error("variable {}, characters after closing dimensional delimiter '{}' ? w='{}' aftertoken='{}' -- {}.".format(token, enddelim, w, aftertoken, arg), original_line)
        return None, None
    # fi
    if wary is not None:                                # It exists already. :)
        if len(wary[numarry_indexes]) != len(dimensions):
            print_error("variable {} with {} dimensions does not match dimensions {}.".format(token, len(wary[numarry_indexes]), len(dimensions)), original_line)
            return None, None
        # fi
        l = len(dimensions)
        x = mult = wary[numarry_indexes][0]             # Max dimension of first.
        h = dimensions[0] - 1                           # array index into numarry_values & numarry_value_type
        for a in range(1, l):
            d = dimensions[a]
            x = wary[numarry_indexes][a]
            if d < 1 or d > x:
                print_error("variable {} dimension#{} {} not in range 1 thru {}".format(token, a+1, d, x), original_line)
                return None, None
            # fi
            h = h + (d-1) * mult
            mult = mult * x
        # rof
        return wary, h                                  # variable array, and index into values.
    # fi
    num = 1
    for w in dimensions:
        num = num * w
    # rof
    values = []
    typevalues = []
    for i in range(0, num):
        values.append(None)
        typevalues.append(None)
    # rof
    wary = [ token, lmp_executing_number, dimensions, values, typevalues, False ]
    calculate.local_arrays.append(wary)
    return
# End of handle_vars_parens

# ----------------------------------------------------------------------------
def handle_vars_and_global(t_args, level, original_line):
    global lmp_executing_number

    if t_args is None or t_args == '':
        print_error("vars needs at least one argument", original_line)
        return
    # fi
    # Get rid of all white spoce.
    wline = ''.join(t_args.split())
    wargs = separate_args(wline, False, True, original_line)
    if len(wargs) == 0:
        print_error("var needs at least one argument", original_line)
        return
    # fi
    # Process each variable name.
    for token in wargs:
        if token is None or token == '':
            print_error("No variable name - token='{}'".format(token),original_line)
            return
        # fi
        # Are there any Parenthesis?
        a = token.find('(')
        if a >= 0:
            handle_vars_parens(token, a, True, original_line)
            continue
        # fi
        a = token.find('[')
        if a >= 0:
            handle_vars_parens(token, a, True, original_line)
            continue
        # fi
        if not token[0].isalnum():
            print_error("variable name {} does not start with a alphabetic character.".format(token),original_line)
            return
        # fi
        okay = True
        for t in token[1:]:
            if not t.isalnum() and t != '_':
                print_error("variable name {} does not start with a alphabetic character.".format(token),original_line)
                okay = False
                break
            # fi
        # rof
        if not okay:
            continue
        # fi
        # Normal variable name here.
        wary = getvarmaclevel(token, lmp_executing_number)
        if wary is not None:
            print_warning("#b variable name {} redefined at current macro depth level {}".format(token, lmp_executing_number), original_line)
            delete_one_variable(token, lmp_executing_number)
            wary = None
        # fi
        createlocalvar(token, None, lmp_executing_number, None, False)  # Not set, nor any type yet.
        wary = getvarmaclevel(token, lmp_executing_number)
    # elihw
    return
# End of handle_vars_and_global

# ----------------------------------------------------------------------------
# Not likely to ever do. Use key command.
#   flat    b,e         flat/sharp are cumulative -- double flats, etc.

def do_flat(t_args, original_line):                              # NOTDONEYET
    print_error("NOTDONEYET - do_flat", original_line)
    return
# End of do_flat

# ----------------------------------------------------------------------------
# Not likely to do. Doesn't make sense until other IMS processing is done.
#   pause, density, display, key, combine, lyrics, staff, systems, page

def do_format(t_args, original_line):                            # NOTDONEYET
    print_error("NOTDONEYET - do_format", original_line)
    return
# End of do_format

# ----------------------------------------------------------------------------
# Not likely to do. Use "cpp" or similar preprocessors instead.

def do_include(t_args, original_line):                           # NOTDONEYET
    print_error("NOTDONEYET - do_include", original_line)
    return
# End of do_include

# ----------------------------------------------------------------------------
# Not likely to do. No nameset processing ... use "instrument" instead.

def do_instr(t_args, original_line):                             # NOTDONEYET
    print_error("NOTDONEYET - do_instr", original_line)
    return
# End of do_instr

# ----------------------------------------------------------------------------
# Not likely to ever do.
#   midi(o300 + MIDCHN - 1, PATNUM)

def do_midi(t_args, original_line):                              # NOTDONEYET
    print_error("NOTDONEYET - do_midi", original_line)
    return
# End of do_midi

# ----------------------------------------------------------------------------
# Not likely to ever do. Use key command.
#   natural c           undo any flat/sharp.

def do_natural(t_args, original_line):                           # NOTDONEYET
    print_error("NOTDONEYET - do_natural", original_line)
    return
# End of do_natural

# ----------------------------------------------------------------------------
# Not likely to ever do.
#   percus              does things with slide projector.

def do_percus(t_args, original_line):                            # NOTDONEYET
    print_error("percus command makes no sense for python or MIDI.", original_line)
    return
# End of do_percus

# ----------------------------------------------------------------------------
# Not likely to do. Doesn't make sense until other IMS processing is done.

def do_print(t_args, original_line):                             # NOTDONEYET
    print_error("NOTDONEYET - do_print", original_line)
    return
# End of do_print

# ----------------------------------------------------------------------------
# ----------------------------------------------------------------------------
# Not likely to ever do. Use key command.
#   sharp   f

def do_sharp(t_args, original_line):                             # NOTDONEYET
    print_error("NOTDONEYET - do_sharp", original_line)
    return
# End of do_sharp

# ----------------------------------------------------------------------------
# Not likely to ever do.
#   slide  from,to,length     $$ Glissando - only can be used after voice 1 or cis n command.

def do_slide(t_args, original_line):                             # NOTDONEYET
    print_error("slide command makes no sense for python or MIDI.", original_line)
    return
# End of do_slide

# ----------------------------------------------------------------------------
# Not likely to do. No idea what this does.
#   temper a            $$ sets just intonation in the key.

def do_temper(t_args, original_line):                            # NOTDONEYET
    print_error("NOTDONEYET - do_temper", original_line)
    return
# End of do_temper

# ----------------------------------------------------------------------------
# Not likely to do.

def do_tuning(t_args, original_line):                            # NOTDONEYET
    print_error("NOTDONEYET - do_tuning", original_line)
    return
# End of do_tuning

# ----------------------------------------------------------------------------
# dictionary commandname : routine. execute via(?): globals()['do_cstopnow'](t_args, line)
global commands
commands = {
#            Command         Routine         Process-in-cstop
             'bars'       : (do_bars,        True),
             'break'      : (do_outloop,     False),         # break/outloop are the same thing
             'calc'       : (do_calc,        False),
             'calcc'      : (do_calcc,       False),
             'calcs'      : (do_calcs,       False),
             'change'     : (do_change,      False),
             'cis'        : (do_cis,         False),
             'clef'       : (do_clef,        True),
             'comment'    : (do_comment,     False),
             'continue'   : (do_reloop,      False),         # reloop/continue are the same thing
             'copy'       : (do_copy,        False),
             'cstart'     : (do_cstart,      True),
             'cstop'      : (do_cstop,       True),
             'cstop*'     : (do_cstopnow,    True),
             'debug'      : (do_debug,       False),
             'decode'     : (do_decode,      False),
             'delay'      : (do_delay,       False),
             'do'         : (do_loop,        False),
             'elif'       : (do_else_if,     False),
             'else'       : (do_else,        False),
             'elseif'     : (do_else_if,     False),
             'encode'     : (do_encode,      False),
             'end'        : (do_cstopnow,    True),          # cstop* alternative
             'endif'      : (do_endif,       False),
             'endloop'    : (do_endloop,     False),
             'endm'       : (do_endm,        False),
             'endmacro'   : (do_endm,        False),         # endm alternative
             'exit'       : (do_cstopnow,    True),          # cstop* alternative
             'for'        : (do_loop,        False),         # do/for/loop are the same thing.
             'global'     : (do_global,      False),         # global is like vars but level 0 variables.
             'globals'    : (do_global,      False),         # And should the s be there or not ... .
             'goto'       : (do_goto,        False),
             'if'         : (do_if,          False),
             'intensity'  : (do_intensity,   False),
             'instrument' : (do_instrument,  False),
             'key'        : (do_key,         False),
             'loop'       : (do_loop,        False),         # do/for/loop are the same thing
             'macro'      : (do_macro,       False),
             'marker'     : (do_marker,      False),
             'measure'    : (do_measure,     True),
             'meter'      : (do_meter,       True),
             'middlec'    : (do_middle_c,    True),
             'mytitle'    : (do_title,       False),         # title alternative
             'outloop'    : (do_outloop,     False),         # break/outloop are the same thing
             'page'       : (do_page,        True),
             'pan'        : (do_pan,         False),
             'percus'     : (do_percus,      False),
             'pitch'      : (do_pitch,       False),
             'putd'       : (do_putd,        False),
             'randu'      : (do_randu,       False),
             'randp'      : (do_randp,       False),
             'reloop'     : (do_reloop,      False),         # reloop/continue are the same thing
             'repeat'     : (do_goto,        False),         # goto alternative
             'reverb'     : (do_reverb,      False),
             'setperm'    : (do_setperm,     False),
             'spaces'     : (do_spaces,      False),
             'start'      : (do_cstart,      True),          # cstart alternative
             'stop'       : (do_cstop,       True),          # cstop alternative
             'stop*'      : (do_cstopnow,    True),          # cstop* alternative
             'tempo'      : (do_tempo,       True),
             'time'       : (do_meter,       True),          # meter alternative
             'title'      : (do_title,       False),
             'transpose'  : (do_xpose,       True),          # xpose alternative
             'unit'       : (do_measure,     True),          # measure alternative
             'var'        : (do_vars,        False),         # I make this mistake all the time.
             'vars'       : (do_vars,        False),
             'voice'      : (do_voice,       True),
             'volume'     : (do_volume,      True),
             'volumes'    : (do_volumes,     True),
             'xpose'      : (do_xpose,       True),
             '%%'         : (do_percents,    True),

             'endprocess':(do_endprocess,    False),
             'process'    : (do_process,     False),

             'staff'      : (do_staff,       False),

             'flat'       : (do_flat,        False),         # NOTDONEYET
             'format'     : (do_format,      False),         # IMS - will not do     NOTDONEYET
             'include'    : (do_include,     False),         # IMS - will not do     NOTDONEYET
             'instr'      : (do_instr,       False),         # IMS - will not do     NOTDONEYET
             'midi'       : (do_midi,        False),         # NOTDONEYET
             'natural'    : (do_natural,     False),         # NOTDONEYET
             'print'      : (do_print,       False),         # IMS - will not do     NOTDONEYET
             'sharp'      : (do_sharp,       False),         # NOTDONEYET
             'slide'      : (do_slide,       False),         # NOTDONEYET
             'temper'     : (do_temper,      False),         # NOTDONEYET
             'tuning'     : (do_tuning,      False),         # IMS - will not do     NOTDONEYET
             # '.' -- handled specially.
           }

# ----------------------------------------------------------------------------
# For plato calc command processing :)
# w=1,h=2,q=4,e=8,th=+0k        # for plato calc command
# s=(1),d=(1),b=(1),t=(1)       # for plato calc command
# m1, m2, m3, m4, m5, m6, m7, m8, m9
# freq(A) = 968000/A
# nearest(A)      = int(round(ln(A/27.5)*12/0.693147))
# framlth = 60*(20/21)          # frames per second
# tempo(a,b)      = 60*framlth*b*[1./a]
# min2(a,b)       = (a+b-abs(a-b))/2      $$ by Dan Sleator
# min4(l,a,b,d)   = min2(min2(l,a),min2(b,d))
# max2(a,b)       = (a+b+abs(a-b))/2      $$ note, no < or > ops
# max4(l,a,b,d)   = max2(max2(l,a),max2(b,d))
# ----------------------------------------------------------------------------
# Notes and comma for separating voices.
# Length of note in 1/60ths of a second.   r[1]    = 1/57.1429 frames per second
# Length of notes as floating number.      (0.25)  = 1/4 = quarter note.
# variable: pause = break between two identical notes, or "broken notes".
# Note: variables in () and [].
# ----------------------------------------------------------------------------
# rests
# Notes: 3c4,4c4,r2     $$ 3 voices, last is a rest.
#        3a8,,4c8       $$ voice 2 is still playing
# ONALM
# O = octave. default to most recently used for this voice. from 1 to 8.  Middle C = octave 3.
# N = note itself a through g. Probably allow upper or lower case. :) "r" = rest.
# A = Default to normal key value. accidental -> +, -, ++, --, n. Do not carry to next note. (n=natural)
# L = Default to most recently used for this voice. note length. Like 16 for sixteenth note. Can do 16th.
#       w, h, q -> whole, half, quarter.
#       3(4) -> 3 notes in the time of a quarter note. (triplets)
#       (.25) -> 1/4 note.
#       [12] -> number of output frames ... 1/57.1429 of a second.
#   Example:    4b-3(4)         $$ beginning of a triplet
# M = modifier. Normal note. Any combination: d = dotted, s=staccato, b = broken by pause from next, t = tie.
#   3a16t           $$ lengthens previous by 1/16th ... must be same note.

# Special note forms (replace O and N):  (13) - note number. [440] = frequency in Hz. {317} GSW - ignore.
#     t(3a,3g,7)4  = ON,ON,number,LM   - example, 7 notes, quarter note length.
#        NOTE: in 60ths of a second, be careful using it.
#     s4(4a,b,a,g) = sLM(ONA,ONA,...)  - play all notes as grace notes, length of staccato, LM=length
#               last note lasts until LM (quarter note in example) is reached.
# ----------------------------------------------------------------------------
#    octave  0      1      2      3      4       5       6       7       8
#  c/b+     24     36     48     60     72      84      96     108     120
#  c+/d-    25     37     49     61     73      85      97     109     121
#  d        26     38     50     62     74      86      98     110     122
#  d+/e-    27     39     51     63     75      87      99     111     123
#  e/f-     28     40     52     64     76      88     100     112     124
#  f/e+     29     41     53     65     77      89     101     113     125
#  f+/g-    30     42     54     66     78      90     102     114     126
#  g        31     43     55     67     79      91     103     115     127
#  g+/a-    32     44     56     68     80      92     104     116
#  a        33     45     57     69     81      93     105     117
#  a+/b-    34     46     58     70     82      94     106     118
#  b/c-     35     47     59     71     83      95     107     119

# For octave 3c = 60.
note_in_octave_value = {
   'c--':58, 'c-':59, 'c':60, 'cn':60, 'c+':61, 'c++':62,
   'd--':60, 'd-':61, 'd':62, 'dn':62, 'd+':63, 'd++':64,
   'e--':62, 'e-':63, 'e':64, 'en':64, 'e+':65, 'e++':66,
   'f--':63, 'f-':64, 'f':65, 'fn':65, 'f+':66, 'f++':67,
   'g--':65, 'g-':66, 'g':67, 'gn':67, 'g+':68, 'g++':69,
   'a--':67, 'a-':68, 'a':69, 'an':69, 'a+':70, 'a++':71,
   'b--':69, 'b-':70, 'b':71, 'bn':71, 'b+':72, 'b++':73
}

global note_to_midi_value
note_to_midi_value = { }
global midi_value_to_note_flat
midi_value_to_note_flat = { }
global midi_value_to_note_sharp
midi_value_to_note_sharp = { }

global middle_c
middle_c = 39                   # Default to 60, as per cyber1 (1978 era) musicomp.

def compute_middle_c(f):
    global note_in_octave_value
    global note_to_midi_value
    global midi_value_to_note_sharp
    global midi_value_to_note_flat
    global midi_value_to_note_flat
    global midi_value_to_note_sharp
    global midi_value_to_note_flat
    global middle_c

    middle_c = f
    f = f + 12 + 12 - 3         # 3c -> 39 must be 60 for midi.

    for o in range(0, 9):        # 0 thru 8
        for n in note_in_octave_value:
            x = str(o) + n
            v = (note_in_octave_value[n] - (f - 24)) + (12 * o)  # 60-36=24 = '0c'
            note_to_midi_value[x] = v
            if len(n) >= 3:     # ignore double flat and double sharp
                pass
            elif len(n) == 2:     # accidental
                if n[1] == '+':
                    if v not in midi_value_to_note_sharp:   # Prefer no sharp/flat.
                        midi_value_to_note_sharp[v] = x
                    # fi
                # fi
                if n[1] == '-':
                    if v not in midi_value_to_note_flat:    # Prefer no sharp/flat.
                        midi_value_to_note_flat[v] = x
                    # fi
                # Ignore 'n'.
                # fi
            else:
                midi_value_to_note_sharp[v] = x             # Prefer no sharp/flag.
                midi_value_to_note_flat[v] = x
            # fi
        # rof
    # rof
    return
# End of compute_middle_c

compute_middle_c(middle_c)                      # Default to 3c

# ----------------------------------------------------------------------------
# Input:
#       note_to_decode  - String of note to be decoded.
#       voiceon         - for defaults, voice for this note.
#       original_line   - semi-original line for error messages
#       update_defaults - decode gsw method does not change defaults. 1 Argument IMS does.
#       do_errors       - True if should do print_error().
# return:
#       therest (for time)
#       thenote         Convert to abc format for note, octave.
#       typenote:       -2 gsw oprnd, -1 freq, 0 note, 1 trill, 2 sequence

def getnote(note_to_decode, voiceon, update_defaults, do_errors, original_line):
    global oct                                  # default octave
    global accidentals
    global allkeys
    global acc_m                                # Last accidental on a note in measure.
    global measure_on
    global args
    global note_to_midi_value
    global midi_value_to_note_flat
    global midi_value_to_note_sharp
    global key_sig
    global key_sig_int
    global key_convert
    global key_voice
    global xpose
    global xpose_new_key
    global acc_m_xpose

#--     print_debug("getnote('{}', voiceon='{}', update_defaults='{}', do_errors='{}')".format(note_to_decode, voiceon, update_defaults, do_errors))
#--    print_debug("getnote #1 h='{}' v='{}' csv='{}' fs='{}'".format(args.horizontal,args.vertical,args.midi1csv,args.fluidsynth))

# NOTDONEYET-    if type(voiceon) is not int:
# NOTDONEYET-        print_error("getnote - voiceon type is not int ({})".format(type(voiceon)), 'getnote')
# NOTDONEYET-    # fi

    leading_space = False
    if note_to_decode and len(note_to_decode) > 0:
        while note_to_decode and len(note_to_decode) > 0 and (note_to_decode[0] == '\t' or note_to_decode[0] == ' '):
            note_to_decode = note_to_decode[1:]
            leading_space = True
        # fi
    # fi
    temp3 = 0                                   # character pointer
    if note_to_decode == '0':
        return '', 0, normal_note
    elif not note_to_decode or note_to_decode == '':
        return '', '', normal_note
    # fi
    elif note_to_decode[0] == '(':
        typenote = normal_note                  # return normal note
        work3 = 1
        #  must balance parens since note is followed by time
        for temp2 in range(temp3 + 1, len(note_to_decode)):
            work4 = note_to_decode[temp2]
            if work4 == '(':
                work3 = work3 + 1               # count ('s
            elif work4 == ')':
                work3 = work3 - 1               # subtract  )'s
                if work3 < 1:
                    temp3 = temp2 + 1           # temp2 has last matched )
                    therest = note_to_decode[temp3:]
                    note_to_decode = note_to_decode[0:temp3]
                    note_to_decode = re.sub(r'\s+', '', note_to_decode)     # Cheat?
                    r = re.sub(r'^(\w+).*', r'\1', note_to_decode[1:])
                    s = re.sub(r'^\w+(\W).*', r'\1', note_to_decode[1:])
                    t = re.sub(r'^\w+\W(.*)', r'\1', note_to_decode[1:])
                    flag = False
                    if s in [ ')' , ',']:       # Possible note in "r".
#--                         print_debug("getnote #2 h='{}' v='{}' csv='{}' fs='{}'".format(args.horizontal,args.vertical,args.midi1csv,args.fluidsynth))
                        tr1, thenote, te1 = getnote(r, voiceon, update_defaults, False, original_line)
#--                         print_debug("tr1='{}' thenote='{}' te1='{}'".format(tr1,thenote,te1))
                        if thenote is not None and thenote != '' and (tr1 is None or tr1 == '') and (te1 is None or te1 == normal_note):
                            if s == ',':
                                therest = '(' + t + therest
                            else:
                                therest = t + therest
                            # fi
                            type_error = None
                            flag = True
                        # fi
                    # fi
                    if not flag:
                        thenote, type_error = is_anything(note_to_decode, False)
                    # fi
                    if thenote is not None:
                        if thenote == 'COMMA':
                            if len(type_error) != 2:
                                return therest, note_to_decode, "bad input to is_float#2 - {}".format(type_error)
                            # fi
                            try:
                                thenote = float(type_error[0])
                                nl = float(type_error[1])
                            except:
                                return therest, note_to_decode, "bad input to is_float#3 - {}".format(type_error)
                            # yrt
                            type_error = None
                            therest = '(' + str(nl) + ')' + therest
                        # else:
                        #   pass    # Otherwise let fall below. :)
                        # fi
                    # fi
                    if type_error is not None:
                        return therest, thenote, type_error
                    # fi
                    if thenote is None:
                        if do_errors:
                            print_error("m:{} v{} Note is not legal '{}', computation failed".format(measure_on, voiceon, note_to_decode), original_line)
                        # fi
                        return therest, thenote, type_error
                    # fi
                    if type(thenote) is int or type(thenote) is float:
                        thenote = int(round(thenote))
                        if typenote == normal_note:
                            if thenote != 0 and (args.midi1csv or args.fluidsynth):
                                thenote = thenote + 12 + 12 - 3     # 3c -> 39 must be 60 for midi.
                            # fi
                            if thenote != 0:
                                thenote = thenote + get_staff_arr(voiceon, xpose, 'getnote1 ' + original_line)
                            # fi
                        # fi
                    # fi                                            # string is 'r'
                    # get ready for time computation
                    return therest, thenote, typenote
                # fi
            # fi
        # rof
        if do_errors:
            print_error("m:{} v{} Note is not legal '{}', unbalanced parenthesis".format(measure_on, voiceon, note_to_decode), original_line)
        # fi
        return '', None, normal_note
    elif note_to_decode[0] in [ '0', '1', '2', '3', '4', '5', '6', '7', '8' ]:    # check octave
        oct_voice = int(note_to_decode[0])
        if not update_defaults:
# NOTDONEYET - chords -- octave to which voice?
            set_all_staff_arr(voiceon, oct_voice, oct, 'getnote2 ' + original_line)     # save octave
        # fi
        temp3 = temp3 + 1
    else:
# NOTDONEYET - chords -- octave from which voice?
        oct_voice = get_staff_arr(voiceon, oct, 'getnote3 ' + original_line)
    # fi
# NOTDONEYET - chords -- octave to which voice?
    set_all_staff_arr(voiceon, oct_voice, oct, 'getnote4 ' + original_line)
    if len(note_to_decode) <= temp3 or note_to_decode[temp3] is None:
        if do_errors:
            print_error("m:{} v{} no note_to_decode '{}' temp3='{}' len(note_to_decode)='{}'".format(measure_on, voiceon, note_to_decode, temp3, len(note_to_decode)), original_line)
        # fi
        return '', None, normal_note
    # fi
    thenote = note_to_decode[temp3]
    if thenote not in [ 'a', 'b', 'c', 'd', 'e', 'f', 'g' ]:        # if not note -- reset, etc.
        if temp3 != 0:
            return '', None, "m:{} v{} Not a note (sequence/trill?) has an octave before it".format(measure_on, voiceon)
        # fi
        if note_to_decode[0] == 's':            # check for sequence
            if note_to_decode[1] == '(':        # if time given
                if do_errors:
                    print_error("m:{} v{} sequence does not have the number of notes before parenthesis".format(measure_on, voiceon), original_line)
                # fi
                return '', None, None           # ???
            # fi
            #       from, from_character, to, to_character, optionallength
            note_to_decode = note_to_decode[1:]
            sc = note_to_decode.find('(')
            if sc < 0:
                if do_errors:
                    print_error("m:{} v{} Sequence is not legal '{}' no parenthesis found.".format(measure_on, voiceon, note_to_decode), original_line)
                # fi
                return '', None, normal_note
            # fi
            number_in_sequence = note_to_decode[0:sc]
            number_in_sequence, type_error = is_float(number_in_sequence, is_float_number, False)
            if type_error is not None:
                if do_errors:
                    print_error(type_error, original_line)
                # fi
                return '', None, None           # ???
            # fi
            if number_in_sequence is None:
                if do_errors:
                    print_error("m:{} v{} sequence does not have a number of notes before parenthesis".format(measure_on, voiceon), original_line)
                # fi
                return '', None, None           # ???
            # fi
            number_in_sequence = int(round(number_in_sequence))
            therest = note_to_decode[sc:]
            if leading_space:
                therest = ' ' + therest         # Flag for later processing.
            # fi
            return therest, number_in_sequence, sequence_note
        elif note_to_decode[0] == 't':          # check for trill
            if len(note_to_decode) > 1:
                if note_to_decode[1] != '(':    # check for parenthesis
                    if do_errors:
                        print_error("m:{} v{} Note is not legal '{}', no parenthesis for trill.".format(measure_on, voiceon, note_to_decode), original_line)
                    # fi
                    return '', None, normal_note
                # fi
            else:
                if do_errors:
                    print_error("m:{} v{} Note is not legal '{}'".format(measure_on, voiceon, note_to_decode), original_line)
                # fi
                return '', None, normal_note
            # fi
            #-- if typenote == trill_note:
            #--     print_error("Note is not legal '{}' double trill".format(note_to_decode), original_line)
            #--     return '', None, normal_note
            #-- # fi
            therest = note_to_decode[2:]
            if leading_space:
                therest = ' ' + therest         # Flag for later processing.
            # fi
            return therest, 't(', trill_note
        elif note_to_decode[0] == 'r':          # check for rest
            # Rest follows.
            if args.horizontal or args.vertical:
                thenote = 'r'
            elif args.midi1csv or args.fluidsynth:
                thenote = 0
            else:       # ABC
                thenote = 'z'                   # Convert to abc format rest.
            # fi
            temp3 = temp3 + 1
            # get ready for time computation
            therest = note_to_decode[temp3:]
            if leading_space:
                therest = ' ' + therest         # Flag for later processing.
            # fi
            return therest, thenote, normal_note
        # fi
        if do_errors:
            print_error("m:{} v{} Note is not legal '{}' unknown".format(measure_on, voiceon, note_to_decode), original_line)
        # fi
        return '', None, normal_note
    # fi
    temp3 = temp3 + 1
    if len(note_to_decode) <= temp3:
        temp4 = ''
    else:
        temp4 = note_to_decode[temp3]
    # fi
    if temp4 == 'n':                            # natural special
        temp3 = temp3 + 1
        thenote = thenote + temp4               # construct  dn
        if thenote not in allkeys:
            if do_errors:
                print_error("m:{} v{} Note is not legal '{}' not good decode='{}'  n".format(measure_on, voiceon, note_to_decode, thenote), original_line)
            # fi
            return '', None, normal_note
        # fi
        therest = note_to_decode[temp3:]
    elif temp4 == '+' or temp4 == '-':          # check special note
        thenote = thenote + temp4               # construct  d+ or d-
        temp3 = temp3 + 1
        if len(note_to_decode) <= temp3:
            temp4 = ''
        else:
            temp4 = note_to_decode[temp3]
        # fi
        if temp4 == '+' or temp4 == '-':        # check special note
            thenote = thenote + temp4           # construct  d++ or d--
            temp3 = temp3 + 1
        # fi
        if thenote not in allkeys:
            if do_errors:
                print_error("m:{} v{} Note is not legal '{}' not good decode='{}' +/-".format(measure_on, voiceon, note_to_decode, thenote), original_line)
            # fi
            return '', None, normal_note
        # fi
    else:
        if thenote not in allkeys:
            if do_errors:
                print_error("m:{} v{} Note is not legal '{}' uh-ish {}".format(measure_on, voiceon, note_to_decode, thenote), original_line)
            # fi
            return '', None, normal_note
        # fi
    # fi

    #   thenote             Convert to abc format for note, octave.
    n = thenote[0].lower()
    if args.horizontal or args.vertical or args.midi1csv or args.fluidsynth:
        N = n.lower()
    else:                                       # ABC format
        N = n.upper()
    # fi
    if len(thenote) > 1:
        a = thenote[1:]
        if a not in accidentals:
            if do_errors:
                print_error("m:{} v{} sharp/flat/natural is not legal '{}'".format(measure_on, voiceon, a), original_line)
            # fi
            return '', None, normal_note
        # fi
        if args.horizontal or args.vertical:
            A = a
        elif args.midi1csv or args.fluidsynth:
            A = a
        else:                                   # ABC
            A = accidentals[a]
        # fi
    else:
        A = a = ''
    # fi
    #-- octaves = { 0:',,,', 1:',,', 2:',', 3:'', 4:'', 5:"'", 6:"''", 7:"'''", 8:"'''" }
    octaves = { 0:',,,', 1:',,', 2:',', 3:'', 4:'', 5:"'", 6:"''", 7:"'''" }
    o = oct_voice
    if o not in octaves:
        if do_errors:
            print_error("m:{} v{} Note is not legal '{}' oct strange {}".format(measure_on, voiceon, note_to_decode, o), original_line)
        # fi
        return '', None, normal_note
    # fi
    if a not in accidentals:
        if do_errors:
            print_error("m:{} v{} Note is not legal '{}' accidentals strange {}".format(measure_on, voiceon, note_to_decode, a), original_line)
        # fi
        return '', None, normal_note
    # fi

    ky = get_staff_arr_double(voiceon, measure_on, key_voice, 'getnote4 ' + original_line)
#--    print_debug("get_defaults_for_note ky='{}'   key_voice".format(ky))

    if update_defaults and ky != 'atonal':
# NOTDONEYET - set staff array acc_m, acc_m_xpose
        tN = str(o) + N
        if a == '':
            am = get_staff_arr_double(voiceon, tN, acc_m, original_line)
            if am != '':
                # Check if default from last potential problem.
                print_warning("previous note '{}' voiceon {} in measure {} was '{}' and this note is default - FIXING".format(n, voiceon, measure_on, am), original_line)
                if args.horizontal or args.vertical:
                    A = am
                elif args.midi1csv or args.fluidsynth:
                    A = am
                else:                               # ABC
                    A = accidentals[am]             # Convert to abc format.
                # fi
            # fi
        # fi
# NOTDONEYET - set staff array acc_m, acc_m_xpose
        if args.warn_octave_accidental and a != '':
            # Check if note in other octave was set.
            for O in octaves:
                if str(o) != str(O):
                    if acc_m[voiceon][str(O) + N] != '':
                        print_warning("m:{} v:{} octave/note {}{} accidental {} and this note {}{} is {}".format(measure_on, voiceon, O, N, acc_m[voiceon][str(O) + N], o, n, a), original_line)
                    # fi
                # fi
            # rof
        # fi
        set_staff_arr_double(voiceon, a, tN, acc_m, original_line)  # Save for next note for voiceon.
    # fi
    # Have o(ctave), a(ccidental), and n(ote).
    # Convert for key.
#--    print_debug("h='{}' v='{}' csv='{}' fs='{}'".format(args.horizontal,args.vertical,args.midi1csv,args.fluidsynth))
    if args.horizontal or args.vertical or args.midi1csv or args.fluidsynth:
        if args.horizontal or args.vertical:
            k_check = ky
#--            print_debug("#1 k_check='{}'".format(k_check))
            if k_check in ['none', 'atonal']:
                k_check = 'c'
#--                print_debug("#2 k_check='{}'".format(k_check))
            # fi
            if k_check not in key_sig:
                print_error("m:{} v{} key name='{}' not in key_sig.".format(measure_on, voiceon, ky), original_line)
                sys.exit(1)
            # fi
        else:
            k_check = ky
#--            print_debug("#3 k_check='{}'".format(k_check))
            if k_check in ['none', 'atonal']:
                k_check = 0
#--                print_debug("#4 k_check='{}'".format(k_check))
            # fi
            if k_check not in key_sig_int:
                print_error("m:{} v{} key number='{}' not in key_sig_int='{}'".format(measure_on, voiceon, ky, key_sig_int.keys()), original_line)
                sys.exit(1)
            else:
                k_check = key_sig_int[k_check]
#--                print_debug("#5 k_check='{}'".format(k_check))
            # fi
        # fi

        thenote = "{}".format(o) + n + a
        thenote = thenote.lower()
#--        print_debug("#6 k_check='{}'".format(k_check))
#--        print_debug("thenote='{}' k_check='{}'".format(thenote, k_check))
        if thenote not in key_convert[k_check]:
            print_error("m:{} v{} thenote='{}' not in key_convert[{}] - dictionary. ky='{}'".format(measure_on, voiceon, thenote, k_check, ky), original_line)
            sys.exit(1)
        # fi
        if key_convert[k_check][thenote] is None:
            if do_errors:
                print_error("m:{} v{} note {} is not legal for musicomp2abc".format(measure_on, voiceon, thenote), original_line)
            # fi
            return '', None, normal_note
        # fi
        xnk = get_staff_arr(voiceon, xpose_new_key, original_line)
        if (args.midi1csv or args.fluidsynth) or xnk != '':      # So can print transpose.
            thenote = key_convert[k_check][thenote]
        # fi
        o = thenote[0]
        n = thenote[1].lower()
        if len(thenote) > 2:
            A = a = thenote[2:]
        else:
            A = a = ''
        # fi
    else:           # ABC
        # ky = ky.lower()
        # ky = ky.replace('#', '+')           # Does multiple sharps.
        # ky = ky.replace('=', 'n')           # Does multiple naturals.
        # if ky not in key_sig:
        #     print_error("key name='{}' not in key_sig.".format(ky.lower()), original_line)
        #     sys.exit(1)
        # # fi
        # Do not convert it, already in ABC format.
        if ky == 'atonal':
            ky = 'C'
        # fi
        pass
    # fi
    # . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
    # Have translated key of o(ctave),a(ccidental),and n(ote). -- Original for ABC.
    # 1) xpose added to the note.
    # 2) xpose_new_key converted back to o/n/a

    xv = get_staff_arr(voiceon, xpose, original_line)
    xnk = get_staff_arr(voiceon, xpose_new_key, original_line)
    if (args.midi1csv or args.fluidsynth) and (xv != 0 or xnk != ''):       # So can print.
        jkl = str(o) + str(n) + a
        if jkl not in note_to_midi_value:
            if do_errors:
                print_error("m:{} v{} note {} for xpose is not in note_to_midi_value".format(measure_on, voiceon, jkl), original_line)
            # fi
            return '', None, normal_note
        # fi
        lkj = note_to_midi_value[jkl] + xv
        if lkj not in midi_value_to_note_flat or lkj not in midi_value_to_note_sharp:
            if do_errors:
                print_error("note jkl='{}' lkj='{}' for m:{} voiceon {} not in midi_value_to_note_flat array".format(jkl, lkj, measure_on, voiceon), original_line)
            # fi
            return '', None, normal_note
        # fi
        lkj = midi_value_to_note_flat[lkj]
        o = int(lkj[0])
        n = lkj[1].lower()
        if len(lkj) > 2:
            A = a = lkj[2:]
        else:
            A = a = ''
        # fi
    elif (args.horizontal or args.vertical) and (xv != 0 or xnk != ''):

        jkl = str(o) + str(n) + a
        if jkl not in note_to_midi_value:
            if do_errors:
                print_error("m:{} v{} note {} for xpose is not in note_to_midi_value".format(measure_on, voiceon, jkl), original_line)
            # fi
            return '', None, normal_note
        # fi
        lkj = note_to_midi_value[jkl] + xv
        if lkj not in midi_value_to_note_flat or lkj not in midi_value_to_note_sharp:
            if do_errors:
                print_error("note jkl='{}' lkj='{}' for m:{} voiceon {} not in midi_value_to_note_flat array".format(jkl, lkj, measure_on, voiceon), original_line)
            # fi
            return '', None, normal_note
        # fi
        ksxnk = xnk
        if ksxnk == '':
            ksxnk = ky                              # Convert back to key it was in.
        # fi
        if type(ksxnk) is str:
            nksxnk = key_sig[ksxnk]
        else:
            nksxnk = ksxnk
            ksxnk = key_sig_int[ksxnk]
        # fi
        # ksxnk is text for xpose new key.  nksxnk is numeric sharp/flat toggle (negative = flats).

        if xnk == 'cn':                             # Special case "cn" to mean use sharps. 'c' uses flats.
            lkj = midi_value_to_note_sharp[lkj]
        elif nksxnk <= 0:                            # If flat's on staff for key.
            lkj = midi_value_to_note_flat[lkj]
        else:                                       # If sharps's on staff for key.
            lkj = midi_value_to_note_sharp[lkj]
        # fi

        # Convert lkj to playing_o, playing_n, playing_a.
        playing_o = int(lkj[0])
        playing_n = lkj[1].lower()
        if len(lkj) > 2:
            playing_a = lkj[2:]
        else:
            playing_a = ''
        # fi

        # Here with playing:o/n/a set for note after midi up/down semi-tone change.
        playing_on = str(playing_o) + playing_n
        # See if this note in measure already has +/-/n.
        xposed_key_acc_note = get_staff_arr_double(voiceon, playing_on, acc_m_xpose, original_line)
        if xposed_key_acc_note != '':               # This note already has sharp/flat/nature
            if playing_a == '':                     # Set to n.
                xposed_key_acc_note = 'n'
            else:
                xposed_key_acc_note = playing_a
            # fi
        else:                                       # Default not set.
            # The default note played for a space/line on staff will be kc.
            kc = key_convert[ksxnk][playing_on]         # What does default note give for this new key?
            if kc == lkj:                               # The Default is this note.
                playing_a = ''
                # leave xposed_key_acc_note alone.
            else:
                if playing_a == '':                     # Set to n.
                    xposed_key_acc_note = 'n'
                else:
                    xposed_key_acc_note = playing_a
                # fi
            # fi
        # fi
        o = playing_o
        n = playing_n
        if update_defaults:
            set_staff_arr_double(voiceon, xposed_key_acc_note, playing_on, acc_m_xpose, original_line)
        # fi
        A = a = xposed_key_acc_note
    else:             # ABC format - do nothing.
        pass
    # fi
    # .............................................................................
    # Convert to right format.
    if args.horizontal or args.vertical:
        n = n.lower()
        thenote = "{}".format(o) + n + a
        if leading_space:
            thenote = ' ' + thenote
        # fi
    elif args.midi1csv or args.fluidsynth:
        n = n.lower()
        thenote = "{}".format(o) + n + a
        abc = note_to_midi_value[thenote]
        thenote = abc
    else:           # ABC
        # Do not convert it in ABC format.
        if o <= 3:                                      # uppercase letter
            n = n.upper()
        else:                                           # lowercase letter
            n = n.lower()
        # fi
        thenote = A + n + octaves[o]
        if leading_space:
            thenote = ' ' + thenote
        # fi
    # fi
    therest = note_to_decode[temp3:]
    return therest, thenote, normal_note
# End of getnote

# ----------------------------------------------------------------------------
# compute time
# Inputs:
#   String after note and accidental (or otherwise) to get time from.
#   Original line for error messages.
# Returns:
#   timeofnote      Computed length in 60ths.
#   suffixes        Union of bits for suffixes.
#   number_dots     Number of "dots".

global suffix_emphasis
global suffix_legato
global suffix_broken
global suffix_marcato
global suffix_tied
global suffix_staccato
global suffix_dotted        # NOTE: can others be set if this is?
global suffix_normal
suffix_emphasis = 32        # Emphasis
suffix_legato = 16          # glide to next note - no note attack on start of next note.
suffix_broken = 8           # broken - ignored - break between notes ... because gsw didn't have it.
suffix_marcato = 4          # ignored -- use vol(sf), etc.
suffix_tied = 2             # tied
suffix_staccato = 1         # staccato
suffix_dotted = 0           # dotted
suffix_normal = 0           # No suffix.

# Staccato, tied, break, dotted.
global bit_from_character
bit_from_character = {
   'a': suffix_emphasis,
   'z': suffix_legato,      # 'z' is also slur.
   'l': suffix_legato,      # 'l' is also slur.
   'b': suffix_broken,
   'm': suffix_marcato,
   't': suffix_tied,
   's': suffix_staccato,
   'd': suffix_dotted,      # Want the zero
   ' ': suffix_dotted,      # Want the zero
   "\t": suffix_dotted,     # Want the zero
   #-- hidden for crescendo ... 'c'.
}

def get_time(therest, original_line):
    suf_cnt_max = {
        'a': [ 0, 2],       # emphasis
        'b': [ 0, 1],       # broken
        'd': [ 0, 3],       # dotted
        'g': [ 0, 2],       # grace
        'l': [ 0, 1],       # legato
        'm': [ 0, 1],       # marcato
        's': [ 0, 1],       # staccato
        't': [ 0, 1],       # tied
        'z': [ 0, 1],       # legato by another name
        ' ': [ 0, 9999],    # ignore spaces
        "\t": [ 0, 9999],   # ignore tabs
    }
    whqe = { 'w':1, 'h':2, 'q':4, 'e':8 }
    global bit_from_character
    global measure_on

    vwork = 0
    work = 0
    # Delete leading spaces.
    while therest and len(therest) > 0 and therest[0] in [' ', "\t"]:
        therest = therest[1:]
    # elihw
    # Must exist. If not alphanumeric or if "whqe".
    if not therest or therest == '':
        pass
    elif therest[0].isnumeric() or therest[0] == '.' or therest[0] in [ '[', '(']:
        w = len(therest) - 1        # Work backwards till hitting a suffix.
        while w > 0:
            if therest[w] in bit_from_character:
                w = w - 1
                continue
            # fi
            break
        # elihw
        # 1 -> w=1
        # 2d -> w=2
        strng = therest[0:w+1]
        vwork, type_error = is_float(strng, is_float_number, False)
        # vwork = value calculated before error (even if not error).
        # type_error = message of error type.
        if type_error is not None:
            print_error(type_error, original_line)
            return 0, None, None                # ???
        # fi
        if vwork is None or vwork == 0:
            vwork = 0
            work = 0
        elif strng[0] != '(':
            work = 1.0 / vwork
        else:
            work = vwork
        # fi
        therest = therest[w+1:]
    elif therest[0] in whqe:            # convert whqe to 1,2,4,8.
        vwork = whqe[therest[0]]        # Integer value.
        work = 1.0 / vwork
        therest = therest[1:]
    # else: Not a time field. Returning 0 for time. Still check for suffixes.
    # fi
    #
    # Characters after length -- modifiers (suffixes).
    work4 = 0
    for i in therest:
        if i not in bit_from_character:
            print_error("m:{} suffix field has unrecognizable character ({})".format(measure_on, i), original_line)
            return 0, None, None                # ???
        # fi
        work4 = work4 | bit_from_character[i]
        suf_cnt_max[i][0] = suf_cnt_max[i][0] + 1
        if suf_cnt_max[i][0] > suf_cnt_max[i][1]:
            print_error("m:{} suffix field has too many '{}' characters, max='{}'".format(measure_on, i, suf_cnt_max[i][1]), original_line)
            return 0, None, None                # ???
        # fi
    # rof
    # l and z are the same thing.
    suf_cnt_max['l'][0] = suf_cnt_max['l'][0] + suf_cnt_max['z'][0]
    # Things not to be together.
    if suf_cnt_max['l'][0] != 0 and suf_cnt_max['t'][0] != 0:
        print_error("m:{} Multiple suffixes that cannot occur together, l and t".format(measure_on), original_line)
        return 0, None, None
    # fi
    if ((work4 & suffix_tied) != 0 and ( (work4 & suffix_staccato) != 0)):
        print_error("m:{} Multiple suffixes that cannot occur together, t and s".format(measure_on), original_line)
        return 0, None, None
    # fi
    number_dots = suf_cnt_max['d'][0]
    if work == 0 and number_dots != 0:
        print_error("cannot have dotted syntax on a default note length.", original_line)
        return 0, None, None
    # fi
    return work, work4, number_dots
# End of get_time

# ----------------------------------------------------------------------------
def set_tie_on_previous_note(voiceon, what, original_line):
    global measure_on                   # The measure we are on.
    global meas                         # volume levels
    global bufs
    global bufs_suffixes

    if what is None or what == '':
        return
    # fi

    if type(voiceon) is not int:
        print_error("set_tie_on_previous_note - voiceon type is not int ({})".format(type(voiceon)), 'set_tie_on_previous_note')
        print_die("voiceon must be a voice.")
    # fi

    m = measure_on
    if m not in bufs[voiceon] or bufs[voiceon][m] == '':
        # Do measure before.
        w = len(meas) - 1               # current measure number in array.
        if w == 0:
            print_error("m:{} v{} no previous measure to tie note to.".format(measure_on, voiceon), original_line)
            return ''
        else:
            m = meas[w-1]
        # fi
    # fi
    if args.horizontal or args.vertical:
#--        print_debug("set_tie_on_previous_note voiceon='{}' m='{}' bufs_suffixes='{}'".format(voiceon,m,bufs_suffixes))
        if m not in bufs_suffixes[voiceon] or len(bufs_suffixes[voiceon][m]) ==0:
            print_error("m:{} v{} no previous measure to tie note to.".format(measure_on, voiceon), original_line)
        else:
            bufs_suffixes[voiceon][m][-1] += what
        # fi
    elif args.midi1csv or args.fluidsynth:
        bufs_suffixes[voiceon][m].append(what)
    else:                   # abc format
        bufs[voiceon][m] = bufs[voiceon][m] + '-'
    # fi
    return
# End of set_tie_on_previous_note

# ----------------------------------------------------------------------------
def determine_s_vol(f1, voiceon, original_line):
    global running_vl
    global measure_on

    if type(voiceon) is not int:
        print_error("determine_s_vol - voiceon type is not int ({})".format(type(voiceon)), 'determine_s_vol')
        print_die("voiceon must be a voice.")
    # fi

    if f1 == -1:                        # -1 for getvar('vffff')
        return getvar('vffff')                    # Cannot get any louder.
    elif f1 == -2:                      # -2 for getvar('vff')
        if running_vl[voiceon][measure_on] >= getvar('vfff') :
            return getvar('vffff')
        # fi
        return getvar('vfff')
    elif f1 == -3:                      # -3 for getvar('vff')
        if running_vl[voiceon][measure_on] >= getvar('vff') :
            if running_vl[voiceon][measure_on] >= getvar('vfff') :
                return getvar('vffff')
            # fi
            return getvar('vfff')
        # fi
        return getvar('vff')
    elif f1 == -4:                      # -4 for getvar('vf')
        if running_vl[voiceon][measure_on] >= getvar('vf') :
            if running_vl[voiceon][measure_on] >= getvar('vff') :
                if running_vl[voiceon][measure_on] >= getvar('vfff') :
                    return getvar('vffff')
                # fi
                return getvar('vfff')
            # fi
            return getvar('vff')
        # fi
        return getvar('vf')
    elif f1 == -5:                      # -5 for mf
        if running_vl[voiceon][measure_on] >= getvar('vmf') :
            if running_vl[voiceon][measure_on] >= getvar('vf') :
                if running_vl[voiceon][measure_on] >= getvar('vff') :
                    if running_vl[voiceon][measure_on] >= getvar('vfff') :
                        return getvar('vffff')
                    # fi
                    return getvar('vfff')
                # fi
                return getvar('vff')
            # fi
            return getvar('vf')
        # fi
        return getvar('vmf')
    elif f1 == -6:                      # -6 for mp
        if running_vl[voiceon][measure_on] >= getvar('vmp') :
            if running_vl[voiceon][measure_on] >= getvar('vmf') :
                if running_vl[voiceon][measure_on] >= getvar('vf') :
                    if running_vl[voiceon][measure_on] >= getvar('vff') :
                        if running_vl[voiceon][measure_on] >= getvar('vfff') :
                            return getvar('vffff')
                        # fi
                        return getvar('vfff')
                    # fi
                    return getvar('vff')
                # fi
                return getvar('vf')
            # fi
            return getvar('vmf')
        # fi
        return getvar('vmp')
    elif f1 == -7:                      # -7 for getvar('vp')
        if running_vl[voiceon][measure_on] >= getvar('vp') :
            if running_vl[voiceon][measure_on] >= getvar('vmp') :
                if running_vl[voiceon][measure_on] >= getvar('vmf') :
                    if running_vl[voiceon][measure_on] >= getvar('vf') :
                        if running_vl[voiceon][measure_on] >= getvar('vff') :
                            if running_vl[voiceon][measure_on] >= getvar('vfff') :
                                return getvar('vffff')
                            # fi
                            return getvar('vfff')
                        # fi
                        return getvar('vff')
                    # fi
                    return getvar('vf')
                # fi
                return getvar('vmf')
            # fi
            return getvar('vmp')
        # fi
        return getvar('vp')
    elif f1 == -8:                      # -8 for getvar('vpp')
        return getvar('vpp')                       # Not really something you'll see.
    elif f1 == -9:                      # -9 for getvar('vppp')
        return getvar('vppp')                      # Cannot get much quieter.
    elif f1 == -10:                     # -10 for getvar('vpppp')
        return getvar('vpppp')                     # Cannot 'really' get any quieter.
    else:
        print_error("m:{} v{} determine_s_vol - volume with 's' out of range. ({})".format(measure_on, voiceon, f1), original_line)
        return getvar('vffff')
    # fi
# End of determine_s_vol

# ----------------------------------------------------------------------------
# therest,new_one_note_volume,newvolume,text_str = get_vol_note(temp1, original_line)
#       vol(f)
#       vol(sfp)
#       vol(sf)
# See volumes command for more volumes. And "s" for this note only,
# and like "sfp" after it to go to "f" for this note, and "p" for following notes.
#
# NOTDONEYET - The value should be allowed to have parenthesis.

def get_vol_note(temp1, voiceon, original_line):
    global S_vlprint
    global vlprint
    global measure_on

#--     print_debug("get_vol_note - #1 temp1='{}'".format(temp1))
    while temp1[0] == ' ' or temp1[0] == "\t":
        temp1 = temp1[1:]
    # elihw
#--     print_debug("get_vol_note - #2 temp1='{}'".format(temp1))
    therest = temp1[4:]         # get rid of vol()
    sc = therest.find(')')
#--     print_debug("get_vol_note - #2 therest='{}' sc='{}'".format(therest, sc))
    if sc < 0 or sc == 0:
        print_error("m:{} v{}: A 'vol(' needs a number followed by a ')' -- ')' or number is missing".format(measure_on, voiceon), original_line)
        return '', None, None, None
    # fi
    f2 = -1                         # No volume setting after the "vol"
    s1 = therest[0:sc]
    therest = therest[sc+1:]
    f1, type_error = is_float(s1, is_float_number, False)
    if type_error is not None or f1 is None:
        for j in vlprint:
            if s1 == vlprint[j]:
                f1 = j
                f2 = int(round(f1)) # flag same after setting it.
                type_error = None
                break
            # fi
        # rof
        if type_error is not None:
            for j in S_vlprint:
                if j == s1:
                    f1 = S_vlprint[j][0]
                    f2 = S_vlprint[j][1]
                    type_error = None
                    if f1 < 0 and not args.horizontal and not args.vertical:
                        f1 = determine_s_vol(f1, voiceon, original_line)
                    # fi
                    break
                # fi
            # rof
            if type_error is not None:
                print_error("m:{} v{} vol(xxx) did not get have a number or volume name.  {}".format(measure_on, voiceon, type_error), original_line)
                return '', None, None, None
            # fi
        # fi
    else:
        f2 = int(round(f1))         # flag same after setting it.
    # fi
    if f1 is None:
        print_error("m:{} v{} volume is not a number.".format(measure_on, voiceon), original_line)
        return '', None, None, None
    # fi
    if not args.horizontal and not args.vertical:
        f1 = int(round(f1))
        if f1 < 0  or f1 > 127:       # If out of range.
            print_error("m:{} v{} volume number must be between 0 and 127 inclusive. Not ({})".format(measure_on, voiceon, f1), original_line)
            return '', None, None, None
        # fi
    # fi
    return therest, f1, f2, s1
# End of get_vol_note

# ----------------------------------------------------------------------------
# therest,newvolume,newtime = get_cresc(temp1, original_line)
#       v22: cresc(ff,0.5)                          $$ Go from here to ff over 1/2 note time length.
#       v1: dimin(p,2.0) s3(1f,1f,1f)4, 1f4t, 1f1d  $$ Go to p over time of two whole notes.
#
# NOTDONEYET - The value should be allowed to have parenthesis.

def get_cresc(temp1, original_line):
    global measure_on
    global vlprint

    while temp1[0] == ' ' or temp1[0] == "\t":
        temp1 = temp1[1:]
    # elihw
    therest = temp1[6:]
    sc = therest.find(',')
    if sc < 0 or sc == 0:
        print_error("m:{} A 'cresc(' needs a number followed by a ',' -- ',' or number is missing".format(measure_on), original_line)
        return '', None, None
    # fi
    s1 = therest[0:sc]
    s2 = therest[sc+1:]
    sc = s2.find(')')
    if sc < 0 or sc == 0:
        print_error("m:{} A 'cresc(' needs a number followed by a ',' and ')' -- ')' or time missing".format(measure_on), original_line)
        return '', None, None
    # fi
    therest = s2[sc+1:]
    s2 = s2[0:sc]
    # . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
    f1, type_error = is_float(s1, is_float_number, False)
    if type_error is not None:
        for j in vlprint:
            if s1 == vlprint[j]:
                f1 = j
                type_error = None
                break
            # fi
        # rof
        if type_error is not None:
            print_error("m:{} cresc(xxx,yyy) did not get have a number or volume name. {}".format(measure_on, type_error), original_line)
            return '', None, None
        # fi
    # fi
    if f1 is None:
        print_error("m:{} volume is not a number.".format(measure_on), original_line)
        return '', None, None
    # fi
    f1 = int(round(f1))
    if f1 < 0  or f1 > 127:       # If out of range.
        print_error("m:{} volume number must be between 0 and 127 inclusive. Not ({})".format(measure_on, f1), original_line)
        return '', None, None
    # fi
    if args.vertical or args.horizontal:
        f1 = s1
    # fi
    # . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
    f2, type_error = is_float(s2, is_float_number, False)
    if type_error is not None:
        print_error("m:{} cresc(xxx,yyy) did not get have a time value - {}".format(measure_on, type_error), original_line)
        return '', None, None
    # fi
    if f2 is None:
        print_error("m:{} time value is not a number.".format(measure_on), original_line)
        return '', None, None
    # fi
    if f2 <= 0:                     # If out of range.
        print_error("m:{} time value must be greater than 0. Not ({})".format(measure_on, f2), original_line)
        return '', None, None
    # fi
    # . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
    return therest, f1, f2
# End of get_cresc

# ----------------------------------------------------------------------------
# Returns:
#   prenote - things to put in front of a note.
#   postnote - things to put after the note

def find_vol_cresc(temp1, voiceon, prenote, postnote, original_line):
    global running_vl
    global args
    global measure_on
    global vlprint
    global DECORATIONS
    global cresc_direction
    global cresc_time

# NOTDONEYET-    if type(voiceon) is not int:
# NOTDONEYET-        print_error("find_vol_cresc - voiceon type is not int ({})".format(type(voiceon)), 'find_vol_cresc')
# NOTDONEYET-    # fi
# NOTDONEYET - voiceon -- running_vl[voiceon][measure_on] = f2 -- Uh, does next voice. Cannot do previous ones.

    onenotevolume = None
#--    print_debug("find_vol_cresc - temp1={} voiceon={} prenote={} postnote={}".format(temp1,voiceon,prenote,postnote))
    while True:
        flag = False
        if re.match(r'^[ \t]*vol[(]', temp1) or re.match(r'^[ \t]*v[0-9]+', temp1):
#--            print_debug("find_vol_cresc - temp1={} voiceon={}".format(temp1,voiceon))
            temp1 = re.sub(r'^[ \t]*v([0-9]+)', r'vol(\1)', temp1)
#--            print_debug("find_vol_cresc - temp1={} voiceon={}".format(temp1,voiceon))
#--            print_debug("find_vol_cresc - calling get_vol_note - #1 temp1='{}'".format(temp1))
            therest, onenotevolume, f2, s1 = get_vol_note(temp1, voiceon, original_line)
#--            print_debug("find_vol_cresc - therest={} onenotevolume={} f2={} s1={}".format(therest,onenotevolume, f2, s1))
            # onenotevolume for midi1csv format.
            if onenotevolume is None:
                return temp1, None, prenote, postnote
            # fi
            if f2 != -1:
                try:
                    running_vl[voiceon][measure_on] = f2
                except:
                    print_debug("find_vol_cresc - NOTDONEYET - voiceon not integer ({})".format(voiceon))
            # fi
            if args.vertical or args.horizontal or args.midi1csv or args.fluidsynth:
                prenote = prenote + 'vol(' + str(s1) + ') '
                # onenotevole already set for below.
            else:           # ABC
                # Cannot do sfp and such. Boo His.
                j = vol_to_vlprint_round(onenotevolume)
                prenote = prenote + DECORATIONS + vlprint[j] + DECORATIONS
                if f2 == -1:
                    try:
                        j = vol_to_vlprint_round(running_vl[voiceon][measure_on])
                    except:
                        print_debug("find_vol_cresc - NOTDONEYET - voiceon not integer ({})".format(voiceon))
                    postnote = postnote + DECORATIONS + vlprint[j] + DECORATIONS
                elif f2 != onenotevolume:
                    j = vol_to_vlprint_round(f2)
                    postnote = postnote + DECORATIONS + vlprint[j] + DECORATIONS
                # fi
            # fi
            temp1 = therest
            continue
        # fi
        if (re.match(r'^[ \t]*cres[(]', temp1) or re.match(r'^[ \t]*cre[(]', temp1) or
            re.match(r'^[ \t]*cr[(]', temp1) or
            re.match(r'^[ \t]*dimi[(]', temp1) or re.match(r'^[ \t]*dim[(]', temp1) or
            re.match(r'^[ \t]*di[(]', temp1)):
            print_error("m:{} v{} cresc() and dimin() are incorrectly written.".format(measure_on, voiceon), original_line)
            return temp1, None, prenote, postnote
        # fi

        crd = None
        if re.match(r'^[ \t]*cresc[(]', temp1):
            crd = True
        elif re.match(r'^[ \t]*dimin[(]', temp1):
            crd = False
        # fi
        if crd is not None:
            # cresc(ff,5.25)    # volume to go to, 5.25 = time in floating.
            therest, newvolume, newtime = get_cresc(temp1, original_line)
            if newvolume is None:
                return temp1, None, prenote, postnote
            # fi
            if not (args.vertical or args.horizontal):
                if crd:
                    try:
                        if newvolume <= running_vl[voiceon][measure_on]:
                            print_error("m:{} v{}: cresc({},{}) going down or already at {}".format(measure_on, voiceon, newvolume, newtime, running_vl[voiceon][measure_on]), original_line)
                        # fi
                    except:
                        print_debug("find_vol_cresc - NOTDONEYET - voiceon not integer ({})".format(voiceon))
                else:
                    try:
                        if newvolume >= running_vl[voiceon][measure_on]:
                            print_error("m:{} v{}: dimin({},{}) going up or already at {}".format(measure_on, voiceon, newvolume, newtime, running_vl[voiceon][measure_on]), original_line)
                        # fi
                    except:
                        print_debug("find_vol_cresc - NOTDONEYET - voiceon not integer ({})".format(voiceon))
                # fi
            # fi
            cresc_volume[voiceon] = newvolume
            if args.vertical or args.horizontal:
                prenote = prenote + 'cresc(' + str(newvolume) + ',' + str(newtime) + ')'
                cresc_time[voiceon] = newtime + 0.0
            elif args.midi1csv or args.fluidsynth:
                cresc_time[voiceon] = int(round(newtime * MIDICLICKSPERQUARTER * 4))
            else:           # ABC
                try:
                    if newvolume > running_vl[voiceon][measure_on]:
                        cresc_direction[voiceon] = True
                        prenote = prenote + DECORATIONS + 'crescendo(' + DECORATIONS
                    else:
                        cresc_direction[voiceon] = False
                        prenote = prenote + DECORATIONS + 'diminuendo(' + DECORATIONS
                    # fi
                except:
                    print_debug("find_vol_cresc - NOTDONEYET - voiceon not integer ({})".format(voiceon))
                cresc_time[voiceon] = newtime + 0.0
            # fi
            temp1 = therest
            continue
        # fi
        break
    # elihw
    return temp1, onenotevolume, prenote, postnote
# End of find_vol_cresc

# ----------------------------------------------------------------------------
# Input: therest - string to decode note. (trill and sequence are considered a note).
# Input: voiceon - the voice the note goes with. (For error messages.)
# Input: prenote - spaces and stuff from before note(s) (volume for v/h).
# Input: postnote - spaces after note(s).
# Input: w - If line started with 'v#:' ... process all notes for voice.
# Input: tie_next -
# Input: legato_next -
# Input: original_line - for error messages (used with voiceon too).
#
# Return: False, [notes] = do a return - error occurred.
# Return: True, [notes]  = notes returned.
#   w - If all note gotten, and go to next one , if line started with 'v#:'.
#            0        1           2
#   notes: [pi, voiceon, measure_on,
#                    3-0      3-1         3-2       3-3
#              [ prenote, thenote, timeofnote, postnote ],
#                     4-0       4-1         4-2            4-3
#              [ prev_tie, tie_this, append_tie, append_legato ],
#                          5-0
#              [ onenotevolume ],
#                       6
#           original_line]
#   p_i = True for put_on_bufs(), False for instak()

def get_trill_note(therest, voiceon, prenote, onenotevolume, w, thenote, postnote, tie_next, legato_next, original_line):
    global args
    global measure_on
    global sequence_note
    global trill_note
    global suffix_legato
    global suffix_normal
    global time
    global legal_notes
    global MIDICLICKSPERQUARTER

    note_add = []
#--    print_debug("get_trill_note #1 h='{}' v='{}' csv='{}' fs='{}'".format(args.horizontal,args.vertical,args.midi1csv,args.fluidsynth))
    therest, thenote, typenote = getnote(therest, voiceon, True, True, original_line)
    leading_space = False
    if thenote and type(thenote) is str and len(thenote) > 0 and (thenote[0] == ' ' or thenote == "\t"):
        thenote = thenote[1:]
        leading_space = True
    # fi
    if thenote is None or thenote == 0 or thenote == '':
        print_error("m:{} trill is not legal, no first note".format(measure_on), original_line)
        return False, []                        # error occurred.
    # fi

    quotes = thenote
    staccato = ''
    legato = ''
    if therest is not None and therest != '':   # Check for staccato/legato after note.
        if therest[0] == 's':
            staccato = 's'
            therest = therest[1:]
        # fi
        if therest[0] in 'lz':
            legato = 'l'
            therest = therest[1:]
        # fi
    # fi
    if therest is None or therest == '' or therest[0] != ',':
        print_error("m:{} trill is not legal, no comma after first note".format(measure_on), original_line)
        return False, []                        # error occurred.
    # fi
    therest = therest[1:]                       # comma removed
#--     print_debug("get_trill_note #2 h='{}' v='{}' csv='{}' fs='{}'".format(args.horizontal,args.vertical,args.midi1csv,args.fluidsynth))
    therest, thenote, typenote = getnote(therest, voiceon, True, True, original_line) # get second note
    if thenote is None or thenote == 0 or thenote == '':
        print_error("m:{} trill is not legal, second note missing".format(measure_on), original_line)
        return False, []                        # error occurred.
    # fi
    if typenote == trill_note or typenote == sequence_note:
        print_error("m:{} trill is not legal, first note not correct".format(measure_on), original_line)
        return False, []                        # error occurred.
    # fi
    quotes1 = thenote
    if therest is None or therest == '':
        print_error("m:{} trill is not legal, missing number of notes".format(measure_on), original_line)
        return False, []                        # error occurred.
    # fi
    staccato1 = ''
    legato1 = ''
    if therest is not None and therest != '':   # Check for staccato/legato after note.
        if therest[0] == 's':
            staccato1 = 's'
            therest = therest[1:]
        # fi
        if therest[0] in 'lz':
            legato1 = 'l'
            therest = therest[1:]
        # fi
    # fi
    if therest is None or therest == '' or therest[0] != ',':
        print_error("m:{} trill is not legal, no comma after second note".format(measure_on), original_line)
    # fi
    therest = therest[1:]                       # comma removed
    np = temp1 = 0
    f = therest.find(')')
    if f < 0:
        print_error("m:{} trill is not legal, missing closing parenthesis".format(measure_on), original_line)
        return False, []                        # error occurred.
    # fi
    num = therest[0:f]
    if len(therest) <= f:
        print_error("m:{} trill is not legal, missing length after parenthesis".format(measure_on), original_line)
        return False, []                        # error occurred.
    # fi
    therest = therest[f+1:]
    np, type_error = is_float(num, is_float_number, False)
    if np is None or np == 0 or type_error is not None:
        print_error("m:{} trill is not legal, number of notes to play".format(measure_on), original_line)
        return False, []                        # error occurred.
    # fi
    timeofnote, r_suffixes, number_dots = get_time(therest, original_line)
    if r_suffixes is None or number_dots is None or (
       r_suffixes != suffix_normal and r_suffixes != suffix_legato):
        print_error("m:{} trill is not legal - r_suffixes='{}'".format(measure_on, r_suffixes), original_line)
        return False, []                        # error occurred.
    # fi
    if timeofnote == 0:
# NOTDONEYET - default time of this note(s).
        timeofnote = get_staff_arr(voiceon, time, 'get_trill_note ' + original_line)
    # fi
    if number_dots != 0:
        p = timeofnote / 2.0
        for i in range(1, number_dots+1):
            timeofnote = timeofnote + p
            p = p / 2.0
        # rof
    # fi
# NOTDONEYET - default time of next note(s).
    set_all_staff_arr(voiceon, timeofnote, time, 'get_trill_note ' + original_line)

#   t(3a,3g,7)4 =>  '(7:4:2 3a3g'
    # vwork = float(timeofnote) / float(np)

    # t(quotes, quotes1, np)lengthl
    if args.horizontal or args.vertical or args.midi1csv or args.fluidsynth:
        lengthf = [ timeofnote ]
    else:           # ABC
        lengthl, lengthf, ifokay = get_time_stak(timeofnote, voiceon, original_line)
        if ifokay != 0 or len(lengthl) != 1:    # if time is error
            print_warning("m:{} trill time must be a printable note length, not '{}'".format(measure_on, lengthl), original_line)
            t = 0
            for l in range(0, len(lengthl)):
                t = t + lengthf[l]
            # fi
            lengthf = [ t ]
            print_warning("m:{} trill time remade '{}'".format(measure_on, lengthf), original_line)
        # fi
        l = str(Fraction(lengthf[0]).limit_denominator(256))
        where = l.find('/')
        lth = '1'
        if where > 0:                           # / in fraction
            numerator = l[0:where]
            if numerator != '1':
                lth = numerator
                l = '1' + l[where:]
            # fi
        # fi
        if l not in legal_notes:
            print_warning("m:{} #2 Time fraction '{}' is not a printable note.  ({})".format(measure_on, lengthf[0], l), original_line)
        # fi
        if l == '1':
            l = '1/1'
        # fi
    # fi
# NOTDONEYET - check --vertical and not --wrongties. (But that is not the use for this argument.)
    append_tie = tie_next
    prev_tie = None
    tie_this = ''
    if args.horizontal or args.vertical:
        np = int(round(np))
        abc_note = "t({}{}{},{}{}{},{})".format(quotes, staccato, legato, quotes1, staccato1, legato1, np)
        if leading_space:
            abc_note = ' ' + abc_note
        # fi
        if (r_suffixes & suffix_legato) != 0:
            append_tie = append_tie + 'l'
        # fi

#            0        1           2
#   notes: [pi, voiceon, measure_on,
#                    3-0      3-1         3-2       3-3
#              [ prenote, thenote, timeofnote, postnote ],
#                     4-0       4-1         4-2            4-3
#              [ prev_tie, tie_this, append_tie, append_legato ],
#                          5-0
#              [ onenotevolume ],
#                       6
#           original_line]
#   p_i = True for put_on_bufs(), False for instak()
        notestuff = [ prenote, abc_note, lengthf[0], '' ]
        suffixstuff = [ None, tie_this, append_tie, '' ]
        cresvols = [onenotevolume]
        note_add.append([True, voiceon, measure_on, notestuff, suffixstuff, cresvols, original_line])
    elif args.midi1csv or args.fluidsynth:
        # lthtrill = int(round((lengthf[0] / int(np)) * MIDICLICKSPERQUARTER * 4.0))
        # Need to have left-over fractions work.
        numerator = lengthf[0] * MIDICLICKSPERQUARTER * 4.0
        lth_so_far = 0
        np_to_do = int(np)
        last_legato = False
        if (r_suffixes & suffix_legato) != 0:
            last_legato = True
        # fi
        for i in range(0, int(np)):
            put_on_lth = int(round(numerator/np_to_do))
            np_to_do = np_to_do - 1
            numerator = numerator - put_on_lth
            if (i % 2) == 0:
                abc_note = quotes
                if np_to_do != 0:
                    sn = append_tie + staccato + legato
                elif last_legato:
                    sn = append_tie + staccato + 'l'
                else:
                    sn = append_tie + staccato
                # fi
            else:
                abc_note = quotes1
                if np_to_do != 0:
                    sn = append_tie + staccato1 + legato1
                elif last_legato:
                    sn = append_tie + staccato1 + 'l'
                else:
                    sn = append_tie + staccato1
                # fi
            # fi

#            0        1           2
#   notes: [pi, voiceon, measure_on,
#                    3-0      3-1         3-2       3-3
#              [ prenote, thenote, timeofnote, postnote ],
#                     4-0       4-1         4-2            4-3
#              [ prev_tie, tie_this, append_tie, append_legato ],
#                          5-0
#              [ onenotevolume ],
#                       6
#           original_line]
#   p_i = True for put_on_bufs(), False for instak()
            notestuff = [ prenote, abc_note, put_on_lth, '' ]
            suffixstuff = [ None, tie_this, sn, '' ]
            cresvols = [onenotevolume]
            note_add.append([True, voiceon, measure_on, notestuff, suffixstuff, cresvols, original_line])
            append_tie = ''
        # rof
    else:           # ABC
        abc_note = "[L:{}]".format(l)
        abc_note = abc_note + '(' + str(int(np)) + ':' + lth + ':' + str(int(np))
        if leading_space:
            abc_note = ' ' + abc_note
        # fi
        last_legato = False
        if (r_suffixes & suffix_legato) != 0:
            last_legato = True
        # fi
        for i in range(0, int(np)):
            if (i % 2) == 0:
                if i != (int(np) - 1):
                    leg = legato
                elif last_legato:
                    leg = 'l'
                else:
                    leg = ''
                # fi
                sta = staccato
                quo = quotes
            else:
                if i != (int(np) - 1):
                    leg = legato1
                elif last_legato:
                    leg = 'l'
                else:
                    leg = ''
                # fi
                sta = staccato1
                quo = quotes1
            # fi

            if leg != '':
                if legato_next != 'l':
                    abc_note = abc_note + '('   # ( before the note for glide/legato
                # fi
                legato_next = 'l'
            # fi
            if sta == 's':
                abc_note = abc_note + '.' + quo
            else:
                abc_note = abc_note + quo
            # fi
            if leg == '' and legato_next == 'l':
                abc_note = abc_note + ')'
                legato_next = ''
            # fi
        # rof
        l_dl = default_note_text_fraction(measure_on)
        if l_dl == '1':
            l_dl = '1/1'
        # fi
        abc_note = abc_note + "[L:{}]".format(l_dl)

#            0        1           2
#   notes: [pi, voiceon, measure_on,
#                    3-0      3-1         3-2       3-3
#              [ prenote, thenote, timeofnote, postnote ],
#                     4-0       4-1         4-2            4-3
#              [ prev_tie, tie_this, append_tie, append_legato ],
#                          5-0
#              [ onenotevolume ],
#                       6
#           original_line]
#   p_i = True for put_on_bufs(), False for instak()
        notestuff = [ prenote, abc_note, lengthf[0], postnote ]
        suffixstuff = [ None, tie_this, append_tie, legato_next ]
        cresvols = [onenotevolume]
        note_add.append([True, voiceon, measure_on, notestuff, suffixstuff, cresvols, original_line])
    # fi
    # Use put_on_bufs() to process note.
    return True, note_add                   # Note(s) gotten, process them.
# End of get_trill_note

# ----------------------------------------------------------------------------
# Input: therest - string to decode note. (trill and sequence are considered a note).
# Input: voiceon - the voice the note goes with. (For error messages.)
# Input: prenote - spaces and stuff from before note(s) (volume for v/h).
# Input: postnote - spaces after note(s).
# Input: w - If line started with 'v#:' ... process all notes for voice.
# Input: tie_next -
# Input: legato_next -
# Input: original_line - for error messages (used with voiceon too).
#
# Return: False, [notes] = do a return - error occurred.
# Return: True, [notes]  = notes returned.
#   w - If all note gotten, and go to next one , if line started with 'v#:'.
#            0        1           2
#   notes: [pi, voiceon, measure_on,
#                    3-0      3-1         3-2       3-3
#              [ prenote, thenote, timeofnote, postnote ],
#                     4-0       4-1         4-2            4-3
#              [ prev_tie, tie_this, append_tie, append_legato ],
#                          5-0
#              [ onenotevolume ],
#                       6
#           original_line]
#   p_i = True for put_on_bufs(), False for instak()

def get_sequence_note(therest, voiceon, thenote, onenotevolume, prenote, w, postnote, tie_next, legato_next, original_line):
    global args
    global measure_on
    global suffix_normal
    global time
    global MIDICLICKSPERQUARTER
    global DECORATIONS
    global running_vl
    global vlprint

    leading_space = False
    note_add = []
    if therest and len(therest) > 0 and (therest[0] == ' ' or therest[0] == ' '):
        therest = therest[1:]
        leading_space = True
    # fi
    number_in_sequence = thenote
    if therest[0] != '(':
        print_error("m:{} sequence is not legal, no parenthesis after number {}".format(measure_on, number_in_sequence), original_line)
        return False, []                        # error occurred.
    # fi
    therest = therest[1:]                       # parenthesis removed
    notes = []
    vols_prenote = []                           # for abc, vertical, horizontal.
    vols_postnote = []                          # for abc.
    vols_onenote = []                           # For midi1csv, volume for this note.
    stacs = []
    glides = []
    for sn in range(0, number_in_sequence):
        s_postnote = ''
        s_prenote = ''
        if re.match(r'^[ \t]*vol[(]', therest) or re.match(r'^[ \t]*v[0-9]+', therest):
#--             print_debug("get_sequence_note - A - therest='{}'".format(therest))
            therest = re.sub(r'^[ \t]*v([0-9]+)', r'vol(\1)', therest)
#--             print_debug("get_sequence_note - B - therest='{}'".format(therest))
            therest, onenotevolume, f2, s1 = get_vol_note(therest, voiceon, original_line)
#--             print_debug("get_sequence_note - C - therest='{}'".format(therest))
            # onenotevolume for midi1csv format.
            if onenotevolume is None:
                return False, []                # error occurred.
            # fi
            if f2 != -1:
                try:
                    running_vl[voiceon][measure_on] = f2
                except:
                    print_debug("get_sequence_note - NOTDONEYET - voiceon not integer ({})".format(voiceon))
            # fi
            if args.vertical or args.horizontal or args.midi1csv or args.fluidsynth:
                s_prenote = s_prenote + 'vol(' + str(s1) + ') '
                # onenotevole already set for below.
            else:           # ABC
                # Cannot do sfp and such. Boo His.
                j = vol_to_vlprint_round(onenotevolume)
                s_prenote = s_prenote + DECORATIONS + vlprint[j] + DECORATIONS
                if f2 == -1:
                    try:
                        j = vol_to_vlprint_round(running_vl[voiceon][measure_on])
                        s_postnote = s_postnote + DECORATIONS + vlprint[j] + DECORATIONS
                    except:
                        print_debug("get_sequence_note - NOTDONEYET - voiceon not integer ({})".format(voiceon))
                elif f2 != onenotevolume:
                    j = vol_to_vlprint_round(f2)
                    s_postnote = s_postnote + DECORATIONS + vlprint[j] + DECORATIONS
                # fi
            # fi
        # fi

#--         print_debug("get_sequence_note #1 h='{}' v='{}' csv='{}' fs='{}'".format(args.horizontal,args.vertical,args.midi1csv,args.fluidsynth))
        therest, thenote, typenote = getnote(therest, voiceon, True, True, original_line)
        if thenote is None or thenote == '':
            print_error("m:{} sequence is not legal, no note".format(measure_on), original_line)
            return False, []                    # error occurred.
        # fi
        quotes = thenote
        staccato = ''
        legato = ''
        if therest is not None and therest != '':   # Check for staccato after note.
            if therest[0] == 's':
                staccato = 's'
                therest = therest[1:]
            # fi
            if therest[0] == 'l':
                legato = 'l'
                therest = therest[1:]
            # fi
        # fi
        if sn != number_in_sequence - 1:
            if therest is None or therest == '' or therest[0] != ',':
                print_error("m:{} sequence is not legal, no comma after note".format(measure_on), original_line)
                return False, []                # error occurred.
            # fi
        elif therest[0] != ')':
            print_error("m:{} sequence is not legal, no right parenthesis after last note".format(measure_on), original_line)
            return False, []                    # error occurred.
        # fi
        therest = therest[1:]                   # parenthesis removed
        notes.append(quotes)
        vols_prenote.append(s_prenote)
        vols_postnote.append(s_postnote)
        vols_onenote.append(onenotevolume)
        onenotevolume = None                    # We used the last one.
        stacs.append(staccato)
        glides.append(legato)
    # rof
    timeofnote, r_suffixes, number_dots = get_time(therest, original_line)
    if r_suffixes is None or r_suffixes != suffix_normal or number_dots is None:
        print_error("m:{} sequence is not legal, r_suffixes='{}' number_dots='{}'".format(measure_on, r_suffixes, number_dots), original_line)
        return False, []                        # error occurred.
    # fi
    if timeofnote == 0:
        timeofnote = get_staff_arr(voiceon, time, 'get_sequence_note ' + original_line)
    # fi
    if number_dots != 0:
        p = timeofnote / 2.0
        for i in range(1, number_dots+1):
            timeofnote = timeofnote + p
            p = p / 2.0
        # rof
    # fi
    set_all_staff_arr(voiceon, timeofnote, time, 'get_sequence_note ' + original_line)

    if args.horizontal or args.vertical:
        lengthf = [ timeofnote ]
        n_s = ''
        for i in range(0, len(notes)):
            if i == 0:
                n_s = vols_prenote[i] + notes[i] + stacs[i] + glides[i] + vols_postnote[i]
            else:
                n_s = n_s + ',' + vols_prenote[i] + notes[i] + stacs[i] + glides[i] + vols_postnote[i]
            # fi
        # rof
        abc_note = "s{}({})".format(number_in_sequence, n_s)
        if leading_space:
            abc_note = ' ' + abc_note
        # fi

#            0        1           2
#   notes: [pi, voiceon, measure_on,
#                    3-0      3-1         3-2       3-3
#              [ prenote, thenote, timeofnote, postnote ],
#                     4-0       4-1         4-2            4-3
#              [ prev_tie, tie_this, append_tie, append_legato ],
#                          5-0
#              [ onenotevolume ],
#                       6
#           original_line]
#   p_i = True for put_on_bufs(), False for instak()
        notestuff = [ prenote, abc_note, lengthf[0], '' ]
        suffixstuff = [ None, '', '', '' ]
        cresvols = [onenotevolume]
        note_add.append([True, voiceon, measure_on, notestuff, suffixstuff, cresvols, original_line])
    elif args.midi1csv or args.fluidsynth:
        lengthf = [ timeofnote ]
        # lthseq = int(round((lengthf[0] / number_in_sequence) * MIDICLICKSPERQUARTER * 4.0))
        numerator = lengthf[0] * MIDICLICKSPERQUARTER * 4.0
        lth_so_far = 0
        seq_num_so_far = number_in_sequence
        for i in range(0, len(notes)):
            if i == 0 and vols_prenote[i] == '':
                prn = prenote
            else:
                prn = vols_prenote[i]
            # fi
            put_on_lth = int(round(numerator/seq_num_so_far))
            seq_num_so_far = seq_num_so_far - 1
            numerator = numerator - put_on_lth

# NOTDONEYET - check --vertical and not --wrongties. (But that is not the use of this argument.)
            extra_t = 't' if tie_next == 't' else ''
            tie_next = ''
            # Tie from previous needs to go on first one, else blank it out.
#            0        1           2
#   notes: [pi, voiceon, measure_on,
#                    3-0      3-1         3-2       3-3
#              [ prenote, thenote, timeofnote, postnote ],
#                     4-0       4-1         4-2            4-3
#              [ prev_tie, tie_this, append_tie, append_legato ],
#                          5-0
#              [ onenotevolume ],
#                       6
#           original_line]
#   p_i = True for put_on_bufs(), False for instak()
            notestuff = [ prn, notes[i], put_on_lth, '' ]
            suffixstuff = [ None, '', stacs[i] + glides[i] + extra_t, '' ]
            cresvols = [vols_onenote[i]]
            note_add.append([True, voiceon, measure_on, notestuff, suffixstuff, cresvols, original_line])
        # rof
    else:           # ABC
        if number_in_sequence == 2 or number_in_sequence == 3:
            dnl = timeofnote / 2
            l_time = int(round(timeofnote / dnl - 0.5))
        elif number_in_sequence == 4 or number_in_sequence == 6:
            dnl = timeofnote / 4
            l_time = int(round(timeofnote / dnl - 0.5))
        elif number_in_sequence == 5:
            dnl = timeofnote / 5
            l_time = int(round(timeofnote / dnl - 0.5))
        elif number_in_sequence == 7:
            dnl = timeofnote / 7
            l_time = int(round(timeofnote / dnl - 0.5))
        elif number_in_sequence == 8:
            dnl = timeofnote / 8
            l_time = int(round(timeofnote / dnl - 0.5))
        else:
            print_error("m:{} number in sequence ({}) not 2,3,4,6,8.".format(measure_on, number_in_sequence), original_line)
            return False, []                    # error occurred.
        # fi
        dnl_str = str(Fraction(dnl).limit_denominator(256))

        lengthl, lengthf, ifokay = get_time_stak(timeofnote, voiceon, original_line)
        if ifokay != 0 or len(lengthl) != 1:    # if time is error
            print_warning("m:{} sequence time must be a printable note length, not '{}'".format(measure_on, lengthl), original_line)
            t = 0
            for l in range(0, len(lengthl)):
                t = t + lengthf[l]
            # fi
            lengthf = [ t ]
            print_warning("m:{} sequence time remade '{}'".format(measure_on, lengthf), original_line)
        # fi

        if dnl_str == '1':
            dnl_str = '1/1'
        # fi
        abc_note = ''
        if leading_space:
            abc_note = ' ' + abc_note
        # fi
        abc_note = abc_note + "[L:{}]".format(dnl_str)
        abc_note = abc_note + '(' + str(number_in_sequence) + ':' + str(l_time) + ':' + str(number_in_sequence) + ' '
        for l in range(0, len(notes)):
            if l == 0 and vols_prenote[l] == '':
                prn = prenote
                psn = postnote
            else:
                prn = vols_prenote[l]
                psn = vols_postnote[l]
            # fi
            abc_note = abc_note + prn
            if glides[l] != '':
                if legato_next != 'l':
                    abc_note = abc_note + '('   # ( before the note for glide/legato
                # fi
                legato_next = 'l'
            # fi
            if stacs[l] == 's':
                abc_note = abc_note + '.'
            # fi
            abc_note = abc_note + notes[l] + psn
            if glides[l] == '' and legato_next == 'l':
                abc_note = abc_note + ')'
                legato_next = ''
            # fi
        # rof
        l_dl = default_note_text_fraction(measure_on)
        if l_dl == '1':
            l_dl = '1/1'
        # fi
        abc_note = abc_note + "[L:{}]".format(l_dl)

            # Tie from previous needs to go on first one, else blank it out.
#            0        1           2
#   notes: [pi, voiceon, measure_on,
#                    3-0      3-1         3-2       3-3
#              [ prenote, thenote, timeofnote, postnote ],
#                     4-0       4-1         4-2            4-3
#              [ prev_tie, tie_this, append_tie, append_legato ],
#                          5-0
#              [ onenotevolume ],
#                       6
#           original_line]
#   p_i = True for put_on_bufs(), False for instak()
        notestuff = [ '', abc_note, lengthf[0], '' ]
        suffixstuff = [ None, tie_next, '', legato_next ]
        cresvols = [onenotevolume]
        note_add.append([True, voiceon, measure_on, notestuff, suffixstuff, cresvols, original_line])
    # fi
    # Use put_on_bufs() to process note.
    return True, note_add                       # Note(s) exist, process them.
# End of get_sequence_note

# ----------------------------------------------------------------------------
# Input: temp1 - string to decode note. (trill and sequence are considered a note).
# Input: voiceon - the voice the note goes with. (For error messages.)
# Input: prenote - spaces and stuff from before note(s) (volume for v/h).
# Input: postnote - spaces after note(s).
# Input: w - If line started with 'v#:' ... process all notes for voice.
# Input: tie_next -
# Input: legato_next -
# Input: original_line - for error messages (used with voiceon too).
#
# Return: False, [notes] = do a return - error occurred.
# Return: True, [notes]  = notes returned.
#   w - If all note gotten, and go to next one , if line started with 'v#:'.
#            0        1           2
#   notes: [pi, voiceon, measure_on,
#                    3-0      3-1         3-2       3-3
#              [ prenote, thenote, timeofnote, postnote ],
#                     4-0       4-1         4-2            4-3
#              [ prev_tie, tie_this, append_tie, append_legato ],
#                          5-0
#              [ onenotevolume ],
#                       6
#           original_line]
#   p_i = True for put_on_bufs(), False for instak()

def do_a_note(temp1, voiceon, prenote, postnote, w, tie_next, legato_next, original_line):
    global args
    global measure_on
    global sequence_note
    global trill_note
    global suffix_legato
    global suffix_staccato
    global suffix_tied
    global time
#--    global bufs_suffixes

#--     print_debug("do_a_note - temp1='{}' voiceon='{}' prenote='{}' postnote='{}' w='{}' tie_next='{}' legato_next='{}'".format(temp1, voiceon, prenote, postnote, w, tie_next,legato_next))

# NOTDONEYET-    if type(voiceon) is not int:
# NOTDONEYET-        print_error("do_a_note - voiceon type is not int ({})".format(type(voiceon)), 'do_a_note')
# NOTDONEYET-    # fi

    temp1, onenotevolume, prenote, postnote = find_vol_cresc(temp1, voiceon, prenote, postnote, original_line)
    #.............................................................................
#--     print_debug("do_a_note h='{}' v='{}' csv='{}' fs='{}'".format(args.horizontal,args.vertical,args.midi1csv,args.fluidsynth))
    therest, thenote, typenote = getnote(temp1, voiceon, True, True, original_line) # get next note
#--     print_debug("do_a_note #a therest='{}' thenote='{}' typenote='{}'".format(therest,thenote,typenote))
    if thenote is None:
        print_error("m:{} no note? therest='{}' thenote='{}' typenote='{}'".format(measure_on, therest, thenote, typenote), original_line)
        return True, []                             # get next note for this voice (old way)
    # fi
    if type(thenote) == str and (thenote == '' or thenote == ' ' or thenote == "\t"):
        return True, []                             # get next note for this voice (old way)
    # fi
    # . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
    if type(thenote) is int and typenote != sequence_note:
        if args.vertical or args.horizontal:
            thenote = "({})".format(thenote)        # Put back as a number.
        elif args.midi1csv or args.fluidsynth:
            if thenote <= 0:
                thenote = 0
            else:
                if thenote >= 128:
                    thenote = 127
                # fi
            # fi
        else:           # ABC
            thenote = to_abc_note(thenote)          # Convert number to abc text.
        # fi
    # fi
    # . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
    notdone = False
    # . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
    if typenote in (trill_note, sequence_note):
        if typenote == trill_note:
            do_break, note_add = get_trill_note(therest, voiceon, prenote, onenotevolume, w, thenote, postnote, tie_next, legato_next, original_line)
        else:
            do_break, note_add = get_sequence_note(therest, voiceon, thenote, onenotevolume, prenote, w, postnote, tie_next, legato_next, original_line)
        # fi
        return do_break, note_add                   # get next note for this voice (old way) (put_on_bufs)
    # fi
    # Normal note processing follows.
    #.............................................................................
    timeofnote, r_suffixes, number_dots = get_time(therest, original_line)
    #.............................................................................
    if r_suffixes is None or number_dots is None:
        print_error("m:{} Error getting time for note ('{}') - ('{}') -> timeofnote='{}' r_suffixes='{}' number_dots='{}' therest='{}'".format(measure_on, thenote, therest, timeofnote, r_suffixes, number_dots, therest), original_line)
        return False, []                            # error occurred.
    # fi
    # suffix_legato = 16            -- glide to next note.
    # suffix_tied = 2               -- tied
    # suffix_staccato = 1           -- staccato
    # suffix_dotted = 0
    # suffix_normal = 0
    # bits are $union$'ed together for multiple modifiers.
    # number_dots are how many "d" (dotted) were found.
    if timeofnote is None or timeofnote == 0:
        if number_dots != 0:
            print_error("m:{} cannot have dotted syntax on a default note length.".format(measure_on), original_line)
            return False, []                        # error occurred.
        # fi
        timeofnote = get_staff_arr(voiceon, time, 'do_a_note1 ' + original_line)
    # fi
    if number_dots != 0:
        p = timeofnote / 2.0
        for i in range(1, number_dots+1):
            timeofnote = timeofnote + p
            p = p / 2.0
        # rof
    # fi
    set_all_staff_arr(voiceon, timeofnote, time, 'do_a_note2 ' + original_line)

    append_tie = tie_next                           # In case it's already set.
    tie_this = ''
    prev_tie = None
    # Tied note
    if (r_suffixes & suffix_tied) != 0:
        if w is not None:                           # vertical input format
            if args.horizontal:                     # horizontal output
                if not args.wrongties:
                    # put tie on following note.
                    tie_this = 't'
                else:
                    append_tie = 't'
                # fi
            elif args.midi1csv or args.fluidsynth:  # midi1csv output
                if not args.wrongties:
                    tie_this = 't'
                else:
                    append_tie = 't'
                # fi
            elif args.vertical:                     # vertical output
                if not args.wrongties:
                    append_tie = 't'
                else:
                    prev_tie = 't'
                # fi
            else:           # ABC
                if not args.wrongties:
                    if w is not None:               # If vertical input format.
                        append_tie = '-'
                    else:
                        prev_tie = '-'
                        append_tie = ''
                    # fi
                else:
                    prev_tie = '-'
                # fi
            # fi
        else:                                       # horizontal input format
            if args.vertical:                       # vertical output
                # put tie on previous note.
#--                i = len(bufs_suffixes[voiceon][m]) - 1
#--                bufs_suffixes[voiceon][m][i] = bufs_suffixes[voiceon][m][i] + 't'
#--                print_debug("do_a_note - # i bufs_suffixes NOTDONEYET")
                prev_tie = 't'
                append_tie = ''                     # Nothing on this note, on previous.
            elif args.horizontal or args.midi1csv or args.fluidsynth:  # horizontal output
                append_tie = 't'
            else:           # ABC
                if w is not None:                   # If vertical input format.
                    append_tie = '-'
                else:
                    prev_tie = '-'
                    append_tie = ''
                # fi
            # fi
        # fi
    # fi
    # . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
    # Staccato
    if (r_suffixes & suffix_staccato) != 0:
        if args.horizontal or args.vertical or args.midi1csv or args.fluidsynth:
            append_tie = append_tie + 's'
        else:           # ABC
            # thenote = '.' + thenote               # . before the note for staccato
            if len(thenote) > 0 and (thenote[0] == ' ' or thenote[0] == "\t"):  # Special leading space!
                thenote = ' .' + thenote[1:]        # . before the note for staccato
            else:
                thenote = '.' + thenote             # . before the note for staccato
        # fi
    # fi
    # . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
    # Legato
    if (r_suffixes & suffix_legato) != 0:
        if args.horizontal or args.vertical or args.midi1csv or args.fluidsynth:
            append_tie = append_tie + 'l'
        else:           # ABC
            if legato_next != 'l':
                thenote = '(' + thenote             # ( before the note for glide/legato
            # fi
        # fi
        legato_next = 'l'
    else:
        if legato_next == 'l':
            if args.horizontal or args.vertical or args.midi1csv or args.fluidsynth:
                pass
            else:           # ABC
                append_tie = ')' + append_tie
            # fi
        # fi
        legato_next = ''
    # fi
    # . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
    note_add = []
    # Use instak() to process note.
#            0        1           2
#   notes: [pi, voiceon, measure_on,
#                    3-0      3-1         3-2       3-3
#              [ prenote, thenote, timeofnote, postnote ],
#                     4-0       4-1         4-2            4-3
#              [ prev_tie, tie_this, append_tie, append_legato ],
#                          5-0
#              [ onenotevolume ],
#                       6
#           original_line]
#   p_i = True for put_on_bufs(), False for instak()
    notestuff = [ prenote, thenote, timeofnote, postnote ]
    suffixstuff = [ prev_tie, tie_this, append_tie, legato_next ]
    cresvols = [onenotevolume]
    note_add.append([False, voiceon, measure_on, notestuff, suffixstuff, cresvols, original_line])
    return True, note_add                           # Normal note found. (instak)
# End of do_a_note

# ----------------------------------------------------------------------------
# Input: #        note_add - array of notes.
#            0        1           2
#   notes: [pi, voiceon, measure_on,
#                    3-0      3-1         3-2       3-3
#              [ prenote, thenote, timeofnote, postnote ],
#                     4-0       4-1         4-2            4-3
#              [ prev_tie, tie_this, append_tie, append_legato ],
#                          5-0
#              [ onenotevolume ],
#                       6
#           original_line]
#   p_i = True for put_on_bufs(), False for instak()

def handle_note(note_add, original_line):
    for n in note_add:
        if len(n) != 7:
            print_error("handle_note - input note[] is not 7 long. n='{}'".format(n), original_line)
            return
        # fi
        p_i = n[0]
        voiceon = n[1]
        m = n[2]
        notestuff = n[3]
        if len(notestuff) != 4:
            print_error("handle_note - notestuff[] is not 4 long. notestuff='{}'".format(notestuff), original_line)
            return
        # fi
        prenote = notestuff[0]
        thenote = notestuff[1]
        timeofnote = notestuff[2]
        postnote = notestuff[3]
        suffixstuff = n[4]
        if len(suffixstuff) != 4:
            print_error("handle_note - suffixstuff[] is not 4 long. suffixstuff='{}'".format(suffixstuff), original_line)
            return
        # fi
        prev_tie = suffixstuff[0]
        tie_this = suffixstuff[1]
        append_tie = suffixstuff[2]
        append_legato = suffixstuff[3]
        cresvols = n[5]
        if len(cresvols) != 1:
            print_error("handle_note - cresvols[] is not 1 long. suffixstuff='{}'".format(suffixstuff), original_line)
            return
        # fi
        onenotevolume = cresvols[0]
        original_line = n[6]

        if prev_tie is not None:
            set_tie_on_previous_note(voiceon, prev_tie, original_line)
        # fi
        bufs_tie_next[voiceon] = tie_this
        bufs_legato_next[voiceon] = append_legato
#--        print_debug("handle_note - calling put_on_bufs or instak p_i='{}'".format(p_i))
        if p_i:
            put_on_bufs(voiceon, m, prenote, thenote, timeofnote, append_tie, onenotevolume, postnote, original_line)
        else:
            instak(voiceon, m, prenote, thenote, timeofnote, append_tie, onenotevolume, postnote, original_line)
        # fi
    # rof
# End of handle_note

# ----------------------------------------------------------------------------
# Parse and process possible notes line.
# All have commas (',') as separators.
# old way is: voice1,voice2,voice3,voice4   -- 3c4, 3e4, 3g4, 4c4
# new way: v#:3c4,d,e,f,g,a,b,4c
# Both have measure terminate them.  NOTE: a second measure the same is allowed.
# --spaces means allow: " " between notes, instead of commas. No pre/post spacing.

def process_notes_oldway(line, original_line):
    global last_voice_staff
    global voices                       # number of voices
    global cis                          # if cis active, non-zero.
    global time                         # set default note length (time) dictionary
    global measure_on                   # The measure we are on.
    global mlth                         # measure length dictionary
    global args
    global bufs
    global macro_name                   # Possible unique macro names -- they may be duplicated.
    global macro_name_terminator        # Terminator after macro name.
    global macro_arguments              # Array of arguments for macro.
    global macro_arg_terminator         # Terminators after arguments.
    global macro_buffer                 # Array of lines for macro.
    global meas
    global bufs_legato_next
    global bufs_tie_next

#DEBUG    print_debug("process_notes_oldway - Entering - line='{}'".format(line))
    if not measure_on or measure_on == '':  # no measure yet
        print_error("no measure processed yet - must have one before notes.", original_line)
        return
    # fi
    wline = re.sub(r'\s+', ' ', line)           # multiple spaces to single space, multiple times.
    if not args.spaces:
        wline = re.sub(r'([^,)]) ', r'\1', wline)    # ', ' left alone, elsewise strip spaces.
    # fi
    wargs = separate_args(wline, False, False, line)

    if not wargs or len(wargs) < 1:
        print_error("m:{} no arguments on note line".format(measure_on), original_line)
        return
    # fi
    # ...........................................................................
    # Check if 'v#' or 'v(#)'
    w = None
    if wargs[0] and len(wargs[0]) > 0 and wargs[0][0] == 'v':
        w = 0
        c = 1
        if 1 == len(wargs[0]):
            w = 1
            if w >= len(wargs):
                print_error("m:{} 'v' with nothing after it.".format(measure_on), original_line)
                return
            # fi
            c = 0
        # fi
        if wargs[w][c] != 'o':
            s1 = wargs[w][c:]
            sc = s1.find(':')
            if sc < 0:
                if w+1 < len(wargs):
                    if wargs[w+1][0] == ':':
                        w = w + 1
                        s1 = s1 + wargs[w]
                    # fi
                # fi
                sc = s1.find(':')
            # fi
            if sc < 0:
                print_error("m:{} A 'v' needs a number followed by a colon -- colon is missing".format(measure_on), original_line)
                return
            # fi
            if sc == 0:
                print_error("m:{} A 'v' needs a number followed by a colon -- number is missing".format(measure_on), original_line)
                return
            # fi
            s2 = s1[0:sc]

            f1, type_error = is_float(s2, is_float_number, False)
            if type_error is not None:
                print_error(type_error, original_line)
                return
            # fi
            if f1 is None:
                print_error("m:{} voice number is not a number.".format(measure_on), original_line)
                return
            # fi
            f1 = int(round(f1))
            if f1 < 1  or f1 > MAXVOICES:       # If out of range.
                print_error("m:{} voice number must be between 1 and {} inclusive. Not ({})".format(measure_on, MAXVOICES, f1), original_line)
                return
            # fi
            last_voice_staff = f1               # For continuation lines and lines without v#:.
            initialize_set_voices(f1, line)
            cis = f1
            wargs[w] = s1[sc+1:]
            if wargs[w] == '' and w + 1 > len(wargs):
                print_error("m:{} Cannot have a blank argument after v{}".format(measure_on, cis), original_line)
                return
            # fi
            if len(wargs[w]) == 0:
                w = w + 1
            # fi
        # fi
    elif last_voice_staff != None:
        initialize_set_voices(last_voice_staff, line)
# NOTDONEYET - last_voice_staff can be a list -- when it is a staff_name entry.
        cis = last_voice_staff
        w = 0
    # fi
    # ...........................................................................
    if cis == 0:                        # if not doing only one voice continuously for a while...
        last_voice_staff = None
        if len(wargs) > voices:
            print_error("m:{} too many arguments ({}), greater than voices (>{})".format(measure_on, len(wargs), voices), original_line)
            return
        # fi
        measlth = 0
        for i in range(0, len(wargs)):
            if not(wargs[i] == '' or wargs[i] == ' ' or wargs[i] == "\t"):
                measlth = max(measlth, mlth[i+1][measure_on])
            # fi
        # rof
        for i in range(0, len(wargs)):
            if not(wargs[i] == '' or wargs[i] == ' ' or wargs[i] == "\t"):
                l = measlth - mlth[i+1][measure_on]
                if l > 0:
                    nl = (MIDICLICKSPERQUARTER * 4) / l
                    print_warning("process_notes - missing rests l='{}' ({}) voice='{}' measure='{}'".format(l, nl, i+1, measure_on), original_line)
                    if args.horizontal or args.vertical:
                        instak(i+1, measure_on, '', 'r', l, '', None, '', original_line)
                    elif args.midi1csv or args.fluidsynth:
                        instak(i+1, measure_on, '', 0, l / (MIDICLICKSPERQUARTER * 4), '', None, '', original_line)
                    else:           # ABC
                        instak(i+1, measure_on, '', 'z', l, '', None, '', original_line)
                    # fi
                # fi
            # fi
        # rof
    # fi
    # ...........................................................................
    # Decode and stack the notes.
    loopstart = 1 if cis == 0 else cis
    for voiceon in range(loopstart, voices + 1):
        setvar('voice', voiceon, 0)
        while True:
            if cis == 0 and len(wargs) < voiceon:
                print_error("m:{} Not enough arguments on note line - want {}, have {}".format(measure_on, voiceon, wargs), original_line)
                return
            # fi
            if w is None:
                temp1 = wargs[voiceon - loopstart]          # loopstart fixes "cis" being used.
                rest_wargs_on_line = wargs[voiceon - loopstart:]
            else:
                # Does not work if tokenizing.
                if w >= len(wargs):
                    break
                # fi
                temp1 = wargs[w]
                rest_wargs_on_line = wargs[w + 1:]
            # fi
            prenote = ''
            while temp1 and (temp1[0] == ' ' or temp1[0] == "\t"):
                prenote = ' '
                temp1 = temp1[1:]
            # elihw
            if not temp1 or not re.match(r'\w', temp1[0]):
                temp1 = prenote + temp1
            # fi
            temp2 = temp1
            for a in rest_wargs_on_line:
                if len(a) > 0 and re.match(r'\w', a[0]):
                    temp1 = temp1 + ' ' + a
                else:
                    temp1 = temp1 + a
                # fi
            # rof
            postnote = ''
# NOTDONEYET - MACRO with right terminators -- order of match - longest argument list first. process_notes_oldway()
            for c in range(0, macro_number):
                if len(macro_name[c]) > len(temp1):
                    continue
                # fi
                if temp1[0:len(macro_name[c])] != macro_name[c]:
                    continue
                # fi
                if macro_name_terminator[c] is None:
                    if temp1 != macro_name[c]:
                        continue
                    # fi
                    md = ''
                else:
                    if temp1[0:len(macro_name[c])] != macro_name[c]:
                        continue
                    # fi
                    t = temp1[len(macro_name[c]):]
                    md = macro_name_terminator[c]
                    if md != t[0]:
                        continue
                    # fi
                # fi
                therest = temp1[len(macro_name[c])+1:]
                if len(therest) > 0 and w and w+1 < len(wargs):
                    if re.match(r'\w', therest[-1]):          # last character in therest is NOT terminator.
                        if len(wargs[w+1]) > 0 and re.match(r'\w', wargs[w+1][0]):
                            therest = therest + ' '
                        # fi
                    # fi
                    therest = therest + ' '.join(wargs[w+1:])
                # fi
                # Need to match argument terminators ... end of line == None.
                q = len(macro_arg_terminator[c])
                if macro_arg_terminator[c][q-1] is None:
                    f = len(therest)
                else:
                    f = therest.find(macro_arg_terminator[c][q-1])
                    if f < 0:
                        print_warning("m:{} macro {} does not have a closing delimiter '{}'".format(measure_on, c, macro_arg_terminator[c][q-1]), original_line)
                        continue        # Try another macro
                    # fi
                    f = f + 1
                # fi
                if replace_macro(c, md + therest, line):
                    return                                  # Go out and read line for macro.
                # fi
                # NOT THE RIGHT MACRO IF HERE.
            # rof
            temp1 = temp2
            #.............................................................................
            next_tie = get_staff_arr(voiceon, bufs_tie_next, 'process_notes_oldway ' + original_line)
            next_legato = get_staff_arr(voiceon, bufs_legato_next, 'process_notes_oldway ' + original_line)
#--             print_debug("process_notes_oldway - calling do_a_note({})".format(temp1))
            do_break, note_add = do_a_note(temp1, voiceon, prenote, postnote, w, next_tie, next_legato, original_line)
            if not do_break:                                # Error occurred.
                return
            # fi
            handle_note(note_add, original_line)
            if w is None:
                break
            # fi
            w = w + 1
        # elihw
    # rof
    return
# End of process_notes_oldway

# ----------------------------------------------------------------------------
#  w = parens_match(enddelim, aftertoken, w, original_line)
# Input:
#   enddelim    - delimiter to end with.
#   aftertoken  - string after token (with the enddelim) that is matching parens/braces.
#   w           - pointer in aftertoken for where the enddelim is located.
# return: w --
#   None    - if no token replaced and message put out already.
#   one past character where enddelim was found in aftertoken.

def parens_match(enddelim, aftertoken, w, original_line):
#--     print_debug("parens_match - enddelim='{}' aftertoken='{}' w={}".format(enddelim, aftertoken, w))
    e = []
    e.append(enddelim)
    w = w + 1
    if w >= len(aftertoken):
        print_error("Found character variable, but no closing '{}'.".format(enddelim), original_line)
        return None
    # fi
    while True:
        while w < len(aftertoken):
            c = aftertoken[w]
#--             print_debug("parens_match - c='{}' w={} enddelim='{}' e={}".format(c,w,enddelim,e))
            w = w + 1
            if c == enddelim:
                break
            # fi
            if w >= len(aftertoken):
                print_error("Found character variable, but not closing '{}'.".format(enddelim), original_line)
                return None
            elif c == '(':
                enddelim = ')'
                e.append(enddelim)
            elif c == '[':
                enddelim = ']'
                e.append(enddelim)
            elif c == '{':
                enddelim = '}'
                e.append(enddelim)
            # fi
#--             print_debug("parens_match - end of while c='{}' w={} enddelim='{}' e={}".format(c,w,enddelim,e))
        # elihw
        e.pop()
        if e == []:
            break
        # fi
        enddelim = e[-1]
#--         print_debug("parens_match - after while enddelim='{}' e={}".format(enddelim,e))
    # elihw
    # w = the character after the ending delimiter.
    return w
# End of parens_match

# ----------------------------------------------------------------------------
# Input:
#   token      - The string returned from the character string lookup.
#   dimensions - The possible dimensions after the string token.
#   aftertoken - The rest of the line, after the original token name (dimensions).
#   original_line - for error messages.
# Returns:
#   strng      - The limited string, or the string associated with token.
#   aftertoken - The rest of the line, after the {...} is processed.

def fix_limiting_char_variables(wary, aftertoken, original_line):
#--     print_debug("fix_limiting_char_variables #1 - wary[numarry_name]={} aftertoken={}".format(wary[numarry_name],aftertoken))
    prew = 0
    name = wary[numarry_name]
    w = 0
    while w < len(aftertoken) and aftertoken[w] in [ ' ', "\t"]:
        w = w + 1
    # elihw
    if w + 2 >= len(aftertoken):
        return name + aftertoken
    # fi
    # ............................................................................
    if len(wary[numarry_values]) > 1:                  # array token ...
        if aftertoken[w] != '(':                        # Must have parens.
#--             print_debug("fix_limiting_char_variables #a - '{}'".format(name + aftertoken))
            return name + aftertoken
        # fi
        prew = parens_match(')', aftertoken, w, original_line)
#--         print_debug("fix_limiting_char_variables #b - w={} prew={}".format(w,prew))
        if prew is None or prew-w <= 2:                 # No array or part of a character string.
            return name + aftertoken
        # fi
        if prew+2 <= len(aftertoken):
#--             print_debug("fix_limiting_char_variables #c")
            if aftertoken[prew] == '{':                 # partial token selection ...
                prex = parens_match('}', aftertoken, prew, original_line)
#--                 print_debug("fix_limiting_char_variables #d - prex={}".format(prex))
                if prex is None or prex - prew <= 2:    # Cannot have {}
                    f = name + aftertoken[w:prew]
                else:
                    f = name + aftertoken[w:prex]       # Yes, {}
                    prew = prex
                # fi
            else:
#--                 print_debug("fix_limiting_char_variables #e")
                f = name + aftertoken[w:prew]
            # fi
        else:
#--             print_debug("fix_limiting_char_variables #f")
            f = name + aftertoken[w:prew]
        # fi
    else:
#--         print_debug("fix_limiting_char_variables #g")
        if aftertoken[w] != '{':                        # partial token selection ...
#--             print_debug("fix_limiting_char_variables #h")
            return name + aftertoken
        # fi
#--         print_debug("fix_limiting_char_variables #i")
        prew = parens_match('}', aftertoken, w, original_line)
#--         print_debug("fix_limiting_char_variables #j - prew={}".format(prew))
        if prew is None or prew-w <= 2:                 # No array or part of a character string.
#--             print_debug("fix_limiting_char_variables #k - name={} aftertoken={}".format(name,aftertoken))
            return name + aftertoken
        # fi
#--         print_debug("fix_limiting_char_variables #l")
        # f will be the thing to pass to is_float. s = rest of string.
        f = name + aftertoken[w:prew]
    # fi
    # ............................................................................
#--     print_debug("fix_limiting_char_variables #m - f='{}' name='{}' aftertoken[{}:{}]='{}'".format(f,name,w,prew,aftertoken[w:prew]))

    f1, type_error = is_float(f, is_float_string, True)       # Want a string.
#NOTANYTHING!    f1, type_error = is_anything(f, True)               # Want a string.
#--     print_debug("fix_limiting_char_variables #n - type(f1)={} f1='{}' type_error='{}' f='{}'".format(type(f1),f1,type_error,f))
    if type_error is not None or f1 is None:
#--         print_debug("fix_limiting_char_variables #o - aftertoken={}".format(aftertoken))
        return name + aftertoken
    elif type(f1) is str:                               # Must have a string.
        aftertoken = aftertoken[prew:]
#--         print_debug("fix_limiting_char_variables #p")
        return f1 + aftertoken
    elif type(f1) is int or type(f1) is float:          # Must have a string.
        aftertoken = aftertoken[prew:]
#--         print_debug("fix_limiting_char_variables #q")
        return str(f1) + aftertoken
    else:                                               # Must have a string.
        print_error("m:{} variable '{}' ".format(measure_on, f) + "return is not a string", original_line)
        return name + aftertoken
    # fi
# End of fix_limiting_char_variables

# ----------------------------------------------------------------------------
def replace_char_var_type(strng, linestarts, lineends, wary, original_line):
    def w0(wary):
        if wary[numarry_values][0] is None:
            return ''
        else:
            return str(wary[numarry_values][0])
        # fi
    # End of w0

#--     print_debug("replace_char_var_type - strng='{}', linestarts={} lineends={} wary={}".format(strng, linestarts, lineends, wary))
    beforetokenline = strng[0:linestarts]
    token = wary[numarry_name]
    w = len(token)
    token_ends = linestarts + w
    aftertokenline = strng[token_ends:]

    # NOTDONEYET = {} for partial token grabbing.
    if len(aftertokenline) > 2:    # Possible {} for limiting character variables.
        fixed_after = fix_limiting_char_variables(wary, aftertokenline, original_line)
        nline = beforetokenline + fixed_after
        if nline == strng and len(wary[numarry_values]) == 1:
#--             print_debug("replace_char_var_type Q - wary={}, wary[numarry_values]={} wary[numarry_values][0]='{}'".format(wary, wary[numarry_values], wary[numarry_values][0]))
#--             print_debug("replace_char_var_type Q - beforetokenline={}, token={} aftertokenline='{}'".format(beforetokenline, token, aftertokenline))
            nline = beforetokenline + w0(wary) + aftertokenline
        # fi
    else:
        if len(wary[numarry_values]) == 1:
#--         print_debug("replace_char_var_type R - wary={}, wary[numarry_values]={} wary[numarry_values][0]='{}'".format(wary, wary[numarry_values], wary[numarry_values][0]))
            nline = beforetokenline + w0(wary) + aftertokenline
        else:
            nline = strng
        # fi
    # fi
#--     print_debug("replace_char_var_type - beforetokenline='{}', token='{}' aftertokenline='{}' nline='{}'".format(beforetokenline, token, aftertokenline, nline))
    return nline
# End of replace_char_var_type

# ----------------------------------------------------------------------------
# Go past all delimiters to an alpha for possible starting of character variable.
# Returns start of token, and start of delimiter or EOLN.

def alpha_token(startat, strg, original_line):
    looking = startat
    nstrg = strg[looking:]
    # Token must start with alpha.
    if nstrg is None or nstrg == '':
#--         print_debug("alpha_token - #A looking='{}' nstrg='{}'".format(looking,nstrg))
        return looking, len(strg)
    # fi
#--     print_debug("alpha_token - strg='{}' startat='{}' c='{}' checking='{}'".format(strg,startat,strg[startat],strg[startat:]))
    while True:
        # NOTE: skip all non-alphanumeric at start of string.
#--         print_debug("alpha_token - looking='{}' strg='{}' len(strg)={}".format(looking,strg,len(strg)))
        while looking < len(strg) and not strg[looking].isalpha():
            looking = looking + 1
        # elihw
#--        while looking < len(strg) and not strg[looking].isalnum():
#--            looking = looking + 1
#--        # elihw
#--         print_debug("alpha_token - #B looking='{}'".format(looking))
        if looking >= len(strg):
            return looking, len(strg)
        # fi
#--         print_debug("alpha_token - #C looking='{}'".format(looking))
        p_s_t = looking

        # Find the ending of alphanum token.
        while looking < len(strg) and (strg[looking].isalnum() or strg[looking] in ('_', '{', '(')):
            if strg[looking] == '{':
                looking = parens_match('}', strg, looking, original_line )
                break
            elif strg[looking] == '(':
                looking = parens_match(')', strg, looking, original_line )
                break
            else:
                looking = looking + 1
            # fi
        # elihw
        # Token must start with alpha.
#--         print_debug("alpha_token - startat={} p_s_t={} looking={}".format(startat,p_s_t,looking))
        if not strg[p_s_t].isalpha():
#--             print_debug("alpha_token - #G p_s_t={} looking='{}'".format(p_s_t,looking))
            continue
        # fi
        break
    # elihw
#--     print_debug("alpha_token - p_s_t={} looking={}".format(p_s_t,looking))
    return p_s_t, looking
# End of alpha_token

# ----------------------------------------------------------------------------
def replace_macro_arguments(line, original_line):
    if whichmacrochars == {}:
        return line
    # fi
#--     print_debug("replace_macro_arguments - line='{}' whichmacrochars={}".format(line,whichmacrochars))
    w = 0
    cnt = 0
    while w < len(line) and cnt < 35:
        linestarts, lineends = alpha_token(w, line, original_line)
        if linestarts is None:
            return line
        # fi
        ntoken = line[linestarts:lineends]
        flag = False
        if ntoken is None or ntoken == '':
            break
        # fi
#--         print_debug("replace_macro_arguments - macrochars - linestarts={} lineends={} ntoken={}".format(linestarts,lineends,ntoken))
        # ----------------------------------------------------------------------------
        for wh in whichmacrochars:
            a = ntoken.find(wh)
#--             print_debug("OOO - ntoken='{}' a={} wh='{}'".format(ntoken,a,wh))
            if a == -1 or a > 0:                            # Token must start at beginning of token.
                continue
            # fi
            lw = len(wh)
            lt = len(ntoken)
#--             print_debug("OOO - lw={} lt={}".format(lw,lt))
            aftertoken = ''
            if lw != lt:
                if ntoken[lw] in ( '{', '(' ):
                    lw = lt
                else:
                    aftertoken = ntoken[lw:]
                # fi
            # fi
#--             print_debug("OOO - aftertoken={} st={} end={}".format(aftertoken,linestarts,linestarts + lw))
            nline = replace_char_var_type(line, linestarts, linestarts + lw, whichmacrochars[wh], original_line)
            if line != nline:
                line = nline
                i_line.append('1mros: ' + line)             # Line as fixed or whatever.
                cnt = cnt + 1
                flag = True
                break
            # fi
        # rof
        w = linestarts
#--         print_debug("OOO - line={} w={}".format(line,w))
        if flag:
            continue
        # fi
        # ----------------------------------------------------------------------------
        if w < len(line):
            if line[w].isalpha():
                w = w + 1
#--                 while w < len(line) and line[w].isalnum():
#--                     w = w + 1
#--                 # elihw
            else:
                w = w + 1
                while w < len(line) and not line[w].isalpha():
                    w = w + 1
                # elihw
        # elihw
#--         print_debug("OOO - line={} w={}".format(line,w))
    # elihw
    return line
# End of replace_macro_arguments

# ----------------------------------------------------------------------------
def replace_character_variables(line, original_line):
    line = replace_macro_arguments(line, original_line)
    if whichlocalchars == {} and whicharraychars == {}:
        return line
    # fi
#--     print_debug("replace_character_variables - line='{}'".format(line))
    w = 0
    cnt = 0
    while w < len(line) and cnt < 35:
#--         print_debug("replace_character_variables - calling alpha_token({},'{}')".format(w,line))
        linestarts, lineends = alpha_token(w, line, original_line)
#--         print_debug("replace_character_variables - linestarts={} lineends={} checking='{}'".format(linestarts,lineends,line[linestarts:lineends]))
        if linestarts is None:
            return line
        # fi
        ntoken = line[linestarts:lineends]
#--         print_debug("replace_character_variables - ntoken='{}'".format(ntoken))
        # ----------------------------------------------------------------------------
        flag = False
        for wh in whichlocalchars:
            a = ntoken.find(wh)
#--             print_debug("MMM - ntoken='{}' a={} wh='{}'".format(ntoken,a,wh))
            if a == -1 or a > 0:                            # Token must start at beginning of token.
                continue
            # fi
            lw = len(wh)
            lt = len(ntoken)
#--             print_debug("MMM - lw={} lt={}".format(lw,lt))
            aftertoken = ''
            if lw != lt:
                if ntoken[lw] in ( '{', '(' ):
                    lw = lt
                else:
                    aftertoken = ntoken[lw:]
                # fi
            # fi
#--             print_debug("MMM - aftertoken={} st={} end={}".format(aftertoken,linestarts,linestarts + lw))
            nline = replace_char_var_type(line, linestarts, linestarts + lw, whichlocalchars[wh], original_line)
#--             print_debug("MMM - nline='{}'".format(nline))
            if line != nline:
                line = nline
                i_line.append('1chvs: ' + line)             # Line as fixed or whatever.
                cnt = cnt + 1
                flag = True
                break
            # fi
        # rof
        if flag:
            continue
        # fi
        # ----------------------------------------------------------------------------
        for wh in whicharraychars:
            a = ntoken.find(wh)
#--             print_debug("NNN - ntoken='{}' a={} wh='{}'".format(ntoken,a,wh))
            if a == -1 or a > 0:
                continue
            # fi
            lw = len(wh)
            lt = len(ntoken)
#--             print_debug("NNN - lw={} lt={}".format(lw,lt))
            aftertoken = ''
            if lw != lt:
                if ntoken[lw] in ( '{', '(' ):
                    lw = lt
                else:
                    aftertoken = ntoken[lw:]
                # fi
            # fi
#--             print_debug("NNN - aftertoken={} st={} end={}".format(aftertoken,linestarts,linestarts + lw))
            nline = replace_char_var_type(line, linestarts, linestarts + lw, whicharraychars[wh], original_line)
#--             print_debug("NNN - nline='{}'".format(nline))
            if line != nline:
                line = nline
                i_line.append('1arvs: ' + line)             # Line as fixed or whatever.
                cnt = cnt + 1
                flag = True
                break
            # fi
        # rof
        if flag:
            continue
        # fi
        # ----------------------------------------------------------------------------
        # Need to move forward either past current by only those limited characters... .
        w = linestarts
#--         print_debug("PPP - w={} line={}".format(w,line))
        if w < len(line):
            if line[w].isalpha():
                w = w + 1
#--                 while w < len(line) and line[w].isalnum():
#--                     w = w + 1
#--                 # elihw
            else:
                w = w + 1
                while w < len(line) and not line[w].isalpha():
                    w = w + 1
                # elihw
        # elihw
#--         print_debug("PPP - line={} w={}".format(line,w))
    # elihw
    return line
# End of replace_character_variables

# ----------------------------------------------------------------------------
def replace_all_variables(line, original_line):
#--     print_debug("replace_all_variables - line='{}'".format(line))
    cnt = 0
    while True:
        nline = replace_macro_arguments(line, original_line).rstrip()
        if nline == line:
#--             print_debug("char_var_subst_first_token #1Ba - calling replace_character_variables, line={}".format(line))
            nline = replace_character_variables(line, original_line).rstrip()
#--             print_debug("char_var_subst_first_token #1Ba - after replace_character_variables, nline={}".format(nline))
            if nline == line:
                break
            # fi
        # fi
        line = nline
        cnt = cnt + 1
#--         print_debug("replace_all_variables - cnt={} nline={}".format(cnt,nline))
        if cnt > MAX_LOOP_VARIABLES:
            print_error("Over {} variable substitutions done - loop?".format(MAX_LOOP_VARIABLES), line)
            return line
        # fi
    # elihw
    return line
# End of replace_all_variables

# ----------------------------------------------------------------------------
# Returns start of first token (MUST BE zero), and start of delimiter.

def first_token(strg, original_line):
    # Token must start with alpha.
    if strg is None or strg == '' or not strg[0].isalpha():
        return None
    # fi
    looking = 1
    while looking < len(strg) and (strg[looking].isalnum() or strg[looking] in ['_', '{', '(']):
        if strg[looking] in [ '{', '(' ]:
            looking = parens_match('}', strg, looking, original_line )
        else:
            looking = looking + 1
        # fi
    # elihw
    return looking
# End of first_token

# ----------------------------------------------------------------------------
def char_var_subst_first_token(original_line):
#--     print_debug("char_var_subst_first_token - original_line={}".format(original_line))
    if whichmacrochars == {} and whichlocalchars == {}:
        return original_line
    # fi
    line = original_line
    cnt = 0
    while True:
        tokenends = first_token(line, original_line)
#--        print_debug("char_var_subst_first_token - after tokenends='{}' = first_token(line='{}')".format(tokenends,line))
        if tokenends is None:
            return line                                      # Nothing to change.
        # fi
        start = line[0:tokenends]
        rest = line[tokenends:]
#--        print_debug("char_var_subst_first_token b - start='{}' rest='{}'".format(start,rest))
        if whichmacrochars != {}:
            ntoken = replace_macro_arguments(start, original_line).rstrip()
#--            print_debug("char_var_subst_first_token A- ntoken='{}' replace_macro_arguments(start='{}')".format(ntoken,start))
        else:
            ntoken = start
        # fi
        if ntoken == start:
            if whichlocalchars != {}:
#--                 print_debug("char_var_subst_first_token #1Ba - calling replace_character_variables")
                ntoken = replace_character_variables(start, original_line).rstrip()
#--                 print_debug("char_var_subst_first_token B- ntoken='{}' replace_macro_arguments(start='{}')".format(ntoken,start))
            # fi
            if ntoken == start:
                break
            # fi
        # fi
        line = ntoken + rest
        cnt = cnt + 1
        if cnt > MAX_NESTING:
            print_error("Over {} variable substitutions done on first token - loop?".format(MAX_NESTING), original_line)
            break
        # fi
    # elihw
    if cnt > 0:
        i_line.append('first: ' + line)             # Line as fixed or whatever.
    # fi
    return line
# End of char_var_subst_first_token

# ----------------------------------------------------------------------------
def compute_command_args(expand_line):
    if not expand_line:
        return '', '', ''
    # fi
    t0 = re.sub(r'^([a-zA-Z0-9%_*]*).*$', r'\1', expand_line, count=1)   # First token on line.
    t1 = re.sub(r'^[a-zA-Z0-9%_*]*(.*)$', r'\1', expand_line, count=1)   # Rest of line.

    command = t0.lstrip()
    t_args = t1.strip()

    if len(t1) > 0:
        delimiter = t1[0]
    else:
        delimiter = ''
    # fi
    # Note: t0 + t1 = line. :) [Thus know how to do things in character variable substitution.]
#--    print_debug("compute_command_args - expand_line='{}' t0='{}' t1='{}'".format(expand_line,t0,t1))
#--    print_debug("                       command='{}' t_args='{}' delimiter='{}'".format(command,t_args,delimiter))

    return command, t_args, delimiter
# End of compute_command_args

# ----------------------------------------------------------------------------
# return True if going to be in a process upon exit. False for error.

def set_process_begin(token, next_tokens, original_line):
    global process_name
    global lmp_executing_number         # If processing process ... reading from process buffer.
    global lmp_executing_which          # Which process being executed. Means cannot reorder. *drats*
    global lmp_executing_args           # Argument given to process.
    global lmp_executing_line           # Line number in process array.
    global lmp_executing_i_line
    global i_line

#---    print_debug("set_process_begin '{}' '{}'".format(token, next_tokens))
    found_pn = None
    for pnumber in range(0, len(process_name)):
        if token == process_name[pnumber]:
            process = process_name[pnumber]
            found_pn = pnumber
            break
        # fi
    # fi
    if found_pn is None:
        print_error("process named '{}' not pre-defined.".format(token), original_line)
        return False
    # fi

    level = lmp_executing_number + 1                    # Create variables at next level.
    if not createlocalvar(process_argument[pnumber], None, level, 1, True):
        print_error("process {} unable to create variable {}".format(token, process_argument[pnumber][0]), original_line)
        return False
    # fi
    lmp_executing_which.append(pnumber)
    lmp_executing_type.append('process')                # Going into a new process.
    lmp_executing_args.append(None)                     # Save them, although no longer need them. :)
    lmp_executing_line.append(0)                        # First line in buffer.
    lmp_executing_rest_of_line.append(None)             # Rest of this line - set in run_process.

    t_line = i_line
    for i in range(0, len(t_line)):                      # Save current depth of line.
       t_line[i] = 'rmacr: ' + t_line[i]
    # rof
    lmp_executing_i_line.append(t_line)                 # Save current depth of line.
    lmp_executing_number = lmp_executing_number + 1
    return True
# End of set_process_begin

# ----------------------------------------------------------------------------
def set_process_quit():
    global in_process_already
    global running_process_already
    global lmp_executing_number
    global lmp_executing_which
    global lmp_executing_type
    global lmp_executing_args
    global lmp_executing_line
    global lmp_executing_i_line
    global lmp_executing_rest_of_line

    l = lmp_executing_number
    # Delete rest of process variables.
    del lmp_executing_which[l]
    del lmp_executing_type[l]
    del lmp_executing_args[l]
    del lmp_executing_line[l]
    del lmp_executing_i_line[l]
    del lmp_executing_rest_of_line[l]
    lmp_executing_number = lmp_executing_number - 1

#--     print_debug("set_process_quit - in_process_already='{}' running_process_already='{}'".format(in_process_already, running_process_already))
    in_process_already = False
    running_process_already = False
# End of set_process_quit

# ----------------------------------------------------------------------------
def run_process(token, next_tokens, original_line):
#--     print_debug("run_process - last_voice_staff='{}' token='{}' next_tokens='{}'".format(last_voice_staff, token, next_tokens))

    global process_argument                         # Array of the argument for process.
    global running_process_type
    global lmp_executing_number                     # If processing process ... reading from process buffer.
    global lmp_executing_which                      # Which process being executed. Means cannot reorder. *drats*
    global lmp_executing_args                       # Argument given to process.
    global lmp_executing_line                       # Line number in process array.
    global lmp_executing_i_line
    global lmp_executing_rest_of_line
    global lmp_executing_number
    global i_line
    # set to say that token is now the variable and we'll get next items from process.
    global running_process_already

#--     print_debug("run_process - in_process_already='{}' running_process_already='{}'".format(in_process_already, running_process_already))
    if lmp_executing_type[-1] != 'process':
        print_error("run_process -ERROR, not in a process", original_line)
        print_debug("            - lmp_executing_type='{}'".format(lmp_executing_type))
        print_debug("            - lmp_executing_number='{}'".format(lmp_executing_number))
        print_debug("            - lmp_executing_which='{}'".format(lmp_executing_which))
        print_debug("            - lmp_executing_args='{}'".format(lmp_executing_args))
        print_debug("            - lmp_executing_line='{}'".format(lmp_executing_line))
        print_debug("            - lmp_executing_rest_of_line='{}'".format(lmp_executing_rest_of_line))
        print_debug("            - running_process_already='{}'".format(running_process_already))
#--        print_debug("            - lmp_executing_i_line='{}'".format(lmp_executing_i_line))
        return
    # fi

    n = lmp_executing_number
    l = lmp_executing_which[n]

#--    lmp_executing_line[-1] = 0                      # First line in buffer.
#--    lmp_executing_rest_of_line[-1] = next_tokens    # Rest of this line.
#--    setvar(process_argument[-1], token, 1)
    lmp_executing_line[n] = 0                       # First line in buffer.
    lmp_executing_rest_of_line[n] = next_tokens     # Rest of this line.
#--     print_debug("   - lmp_executing_rest_of_line='{}'".format(lmp_executing_rest_of_line[n]))
    pan = process_argument[l]                       # process argument name
    wary = chkvar(pan)
    if wary is None or (len(wary[numarry_indexes]) > 1 and wary[numarry_indexes][0] > 1):
        # Does not exist, was deleted with end of last run.
        if not createlocalvar(pan, token, lmp_executing_number, 1, True):
            print_error("process {} unable to create variable {}".format(token, process_argument[pnumber][0]), original_line)
        # fi
    else:
        setvar(pan, token, 1)
    # fi
    running_process_already = True

#--     print_debug("run_process - lmp_executing_type='{}'".format(lmp_executing_type))
#--     print_debug("            - lmp_executing_number='{}'".format(lmp_executing_number))
#--     print_debug("            - lmp_executing_which='{}'".format(lmp_executing_which))
#--     print_debug("            - lmp_executing_args='{}'".format(lmp_executing_args))
#--     print_debug("            - lmp_executing_line='{}'".format(lmp_executing_line))
#--     print_debug("            - lmp_executing_rest_of_line='{}'".format(lmp_executing_rest_of_line))
#--     print_debug("            - running_process_already='{}'".format(running_process_already))
#-- #--        print_debug("            - lmp_executing_i_line='{}'".format(lmp_executing_i_line))
#--
#--     print_debug("            - lmp_executing_number='{}'".format(lmp_executing_number))
#--     print_debug("            - lmp_executing_which='{}'".format(lmp_executing_which))
#--     print_debug("            - process_name='{}'".format(process_name[l]))
#--     print_debug("            - process_argument='{}'".format(process_argument[l]))
#--    print_debug("run_process - argument process_argument='{}' wary='{}'".format(process_argument[l], getvar(process_argument[l])))

    return
# End of run_process

# ----------------------------------------------------------------------------
def keyword_midi(token, delimiter, next_tokens, original_line):
    command, t_args, delimiter = compute_command_args(next_tokens)
    print_error("NOTDONEYET - keyword midi '{}'".format(command), original_line)
    return t_args
# End of keyword_midi

# ----------------------------------------------------------------------------
def keyword_xpose(token, delimiter, next_tokens, original_line):
    print_error("NOTDONEYET - keyword xpose", original_line)
    return next_tokens
# End of keyword_xpose

# ----------------------------------------------------------------------------
def keyword_volumename(token, delimiter, next_tokens, original_line):
    global measure_on

#--     print_debug("keyword_volumename - token='{}' delimiter='{}' next_tokens='{}'".format(token,delimiter,next_tokens))

    if len(token) > 0 and token[0] == 'v':  # See if 'v' can be deleted.
        token = token[1:]
    # fi
    # See if name follows.
    if delimiter in [ '<', '>' ]:           # crescendo/decrescendo.
        print_warning("m:{} keyword_volumename - delimiter='{}' NOTDONEYET-crescendo/decrescendo.".format(measure_on, delimiter), original_line)
        delimiter = ' '
        next_tokens = next_tokens[1:]
    # fi
    if next_tokens is not None and next_tokens != '':
        next_tokens = 'vol(' + token + ') ' + next_tokens
    else:
        next_tokens = 'vol(' + token + ')'
    # fi
#--     if type(last_voice_staff) is int:
#--         strng = str(last_voice_staff) + ' ' + token
#--     elif type(last_voice_staff) is list:
#--         strng = ','.join(last_voice_staff) + ' ' + token
#--     else:
#--         strng = str(last_voice_staff) + ' ' + token
#--     # fi
#--     handle_volume_both(strng, "keyword_volumename", original_line)
    print_debug("keyword_volumename - NOTDONEYET - return next_tokens='{}'".format(next_tokens))
    return ''
    return next_tokens
# End of keyword_volumename

# ----------------------------------------------------------------------------
def keyword_crescendo(token, delimiter, next_tokens, original_line):
    print_error("NOTDONEYET - keyword crescendo", original_line)
    return next_tokens
# End of keyword_crescendo

# ----------------------------------------------------------------------------
def keyword_position(token, delimiter, next_tokens, original_line):
    print_error("NOTDONEYET - keyword position", original_line)
    return next_tokens
# End of keyword_position

# ----------------------------------------------------------------------------
# p(pos) or pan(pos)

def keyword_pan(token, delimiter, next_tokens, original_line):
#--    print_debug("keyword_pan - ENTERING token='{}' delimiter='{}' next_tokens='{}'".format(token, delimiter, next_tokens))
    if delimiter != '(':
        print_error("pan delimiter='{}' is not '('".format(delimiter), original_line)
        return None
    # fi
    command, t_args, delimiter = compute_command_args(next_tokens)
#--    print_debug("keyword_pan - #1 command='{}' t_args='{}' delimiter='{}'".format(command, t_args, delimiter))
    w = parens_match(')', next_tokens, 0, original_line)
    t_args = next_tokens[w:].strip()
#--    print_debug("keyword_pan - #2 w='{}' next_tokens='{}' t_args='{}'".format(w, next_tokens, t_args))
    strng = ",".join(last_voice_staff)
    do_pan(strng + ' ' + next_tokens[0:w], original_line)
    return t_args
# End of keyword_pan

# ----------------------------------------------------------------------------
def keyword_type(token, delimiter, next_tokens, original_line):
    print_error("NOTDONEYET - keyword type", original_line)
    return next_tokens
# End of keyword_type

# ----------------------------------------------------------------------------
def keyword_arp(token, delimiter, next_tokens, original_line):
    print_error("NOTDONEYET - keyword arp", original_line)
    return next_tokens
# End of keyword_arp

# ----------------------------------------------------------------------------
def keyword_fermata(token, delimiter, next_tokens, original_line):
    print_error("NOTDONEYET - keyword fermata", original_line)
    return next_tokens
# End of keyword_fermata

# ----------------------------------------------------------------------------
def keyword_key(token, delimiter, next_tokens, original_line):
    command, t_args, delimiter = compute_command_args(next_tokens)
    strng = str(last_voice_staff) + ': ' + command
    do_key(strng, original_line)
    return t_args
# End of keyword_key

# ----------------------------------------------------------------------------
def keyword_tremolo(token, delimiter, next_tokens, original_line):
    print_error("NOTDONEYET - tremolo '{}' '{}' '{}'".format(token, delimiter, next_tokens), original_line)
    return next_tokens
# End of keyword_tremolo

# ----------------------------------------------------------------------------
def keyword_note_modifier(token, delimiter, next_tokens, original_line):
    print_error("NOTDONEYET - keyword_note_modifier '{}' '{}' '{}'".format(token, delimiter, next_tokens), original_line)
    return next_tokens
# End of keyword_modifiers

# ----------------------------------------------------------------------------
def keyword_note_show(token, delimiter, next_tokens, original_line):
    print_error("NOTDONEYET - keyword_note_show '{}' '{}' '{}'".format(token, delimiter, next_tokens), original_line)
    return next_tokens
# End of keyword_note_show

# ----------------------------------------------------------------------------
def keyword_note_show1(token, delimiter, next_tokens, original_line):
    print_error("NOTDONEYET - keyword_note_show1 '{}' '{}' '{}'".format(token, delimiter, next_tokens), original_line)
    command, t_args, newdelimiter = compute_command_args(next_tokens)
    return t_args
# End of keyword_note_show

# ----------------------------------------------------------------------------
# lh is left hand (lower) of grand clef, rh is upper. Grand clef is two together.
# treble, bass, soproano, alto, tenor

def keyword_clefs(token, delimiter, next_tokens, original_line):
    command, t_args, delimiter = compute_command_args(next_tokens)
    strng = str(last_voice_staff) + ': ' + command
    do_clef(strng, original_line)
    return t_args
# End of keyword_clefs

# ----------------------------------------------------------------------------
def keyword_glide(token, delimiter, next_tokens, original_line):
    # There is a token after this keyword. Toss it.
    command, t_args, delimiter = compute_command_args(next_tokens)
    print_error("NOTDONEYET - keyword_glide '{}' '{}' '{}' ignore argument='{}'".format(token, delimiter, next_tokens, command), original_line)
    return t_args
# End of keyword_glide

# ----------------------------------------------------------------------------
def keyword_tie(token, delimiter, next_tokens, original_line):
    print_error("NOTDONEYET - keyword_tie '{}' '{}' '{}'".format(token, delimiter, next_tokens), original_line)
    return next_tokens
# End of keyword_tie

# ----------------------------------------------------------------------------
staff_keywords = {
    'midi': keyword_midi,
    # . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
    'xpose': keyword_xpose,
    'transpose': keyword_xpose,
    # . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
    'volumenumber': keyword_volumename,
    'volumename': keyword_volumename,
    'vfffff': keyword_volumename,
    'vffff': keyword_volumename,
    'vfff': keyword_volumename,
    'vff': keyword_volumename,
    'vf': keyword_volumename,
    'vmf': keyword_volumename,
    'vmp': keyword_volumename,
    'vp': keyword_volumename,
    'vpp': keyword_volumename,
    'vppp': keyword_volumename,
    'vpppp': keyword_volumename,
    'vppppp': keyword_volumename,
    'crescendo': keyword_crescendo,
    'position': keyword_position,
    'pan': keyword_pan,               'p': keyword_pan,
    'type': keyword_type,
    # . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
    'arp': keyword_arp,
    'fermata': keyword_fermata,
    # . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
    'key': keyword_key,
    # . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
    'trem0': keyword_tremolo,         'trem1': keyword_tremolo,
    'trem2': keyword_tremolo,         'trem3': keyword_tremolo,
    # . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
    'legato': keyword_note_modifier,  'staccato': keyword_note_modifier,
    'marcato': keyword_note_modifier, 'tie': keyword_note_modifier,
    'slur': keyword_note_modifier,
    # . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
    # percussion noteheads, nohead on note staff.
    'perc': keyword_note_show,        'nohead': keyword_note_show,
    # lozenge and harmonic noteheads
    'oloz': keyword_note_show,        'floz': keyword_note_show,
    'stemsoff': keyword_note_show,    'stemson': keyword_note_show,
    # open / full harmonics
    'oharm': keyword_note_show,       'fharm': keyword_note_show,
    # normal - undo above.
    'normal': keyword_note_show,
    # One argument example: rest
    'hide': keyword_note_show1,       'show': keyword_note_show1,
    # 1 complicated argument
    'beaming': keyword_note_show1,    'grouping': keyword_note_show1,
    # . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
    'lh': keyword_clefs,              'rh': keyword_clefs,
    'treble': keyword_clefs,          'bass': keyword_clefs,
    'soprano': keyword_clefs,         'alto': keyword_clefs,
    'tenor': keyword_clefs,
    # . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
    'glide': keyword_glide,
    'tie': keyword_tie,
}

# ----------------------------------------------------------------------------
# next_tokens = process_keyword(token, delimiter, next_tokens, original_line)
# Might take multiple tokens.

def process_keyword(token, delimiter, next_tokens, original_line):
#--     print_debug("process_keyword - token='{}' delimiter='{}' next_tokens='{}'".format(token, delimiter, next_tokens))
    next_tokens = staff_keywords[token](token, delimiter, next_tokens, original_line)
#--     print_debug("process_keyword - next_tokens='{}'".format(next_tokens))
    return next_tokens
# End of process_keyword

# ----------------------------------------------------------------------------
# Find number of voices in staff that are:
#       zero
#       a minimum non-zero value
#       number at that minimum value.

def find_mlth_values(stfs, m, original_line):
    global staff_name
    global mlth

    num0s = []
    minvalue = None
    nummins = []
    for v in staff_name[stfs]:              # voice numbers for staff.
        if m not in mlth[v]:
            print_error("NOTDONEYET - m='{}' not in mlth[{}]".format(m,v), original_line)
            mlth[v][m] = 0
        # fi
        f = float(mlth[v][m])
        if math.isclose(f, float(0)):
            num0s.append(v)
        elif minvalue is None:
            minvalue = f
            nummins = [v]
        else:
            if f < minvalue:
                minvalue = f
                nummins = [v]
            elif math.isclose(minvalue, f):
                nummins.append(v)
            # fi
        # fi
    # fi
    if minvalue is None:
        nummins = num0s                     # If no notes yet in measure, then use all of them.
    # fi
    return nummins
# End of find_mlth_values

# ----------------------------------------------------------------------------
# Must handle notes completely differently in staff notation format.
# A) In middle of collecting chord notes - put onto stack/list for each staff active.
# B) Not a chord, same as chord of length 1. Go to C.
# C) chords - ending.
#    1 - Put all voices in staff up to shortest mlth playing (non-zero).
#        Return # voices on staff at this shortest mlth note, and shortest mlth.
#        All if all at zero.
#    2 - Count notes playing for this chord.
#    4 - If number of voices this length < # notes in chord, error.
#    5 - Put notes from chord into voices for staff (ordered, highest note first).
#        Rests for rest of voices.
#    6 - Put all voices in staff up to shortest mlth playing (non-zero).
#
#    7 - Other staff/staves: must match length of shortest note, and have enough voices to hold notes for chord.
#        goto 4-ish.
#
# Input: #        notes_on_staff [] - array of chords on staff -- has staff internally.
#           staff_chords = [ [ [note], [note], ...],
#                            [ [note], [note], ...], ... ]
#            0        1           2
#   note: [pi, voiceon, measure_on,
#                    3-0      3-1         3-2       3-3
#              [ prenote, thenote, timeofnote, postnote ],
#                     4-0       4-1         4-2            4-3
#              [ prev_tie, tie_this, append_tie, append_legato ],
#                          5-0
#              [ onenotevolume ],
#                       6
#           original_line]
#   p_i = True for put_on_bufs(), False for instak()

def handle_staff_note(add_these_staff_chords, original_line):
    global last_voice_staff
    global measure_on

    # C) Find number of notes in chord.
    number_staff_chords = len(add_these_staff_chords)

    m = measure_on

    # Chords must all be on the same staff. (Else cannot find # voices on staff ... .)
    for numstaff in range(0,number_staff_chords):   # Go through staves
        number_notes_in_chord = len(add_these_staff_chords[numstaff])
        stfs = add_these_staff_chords[numstaff][0][1][0]
#--         print_debug("handle_staff_note - numstaff={}".format(numstaff))
#--         print_debug("handle_staff_note - add_these_staff_chords={}".format(add_these_staff_chords))
#--         print_debug("handle_staff_note - staff_name={}".format(staff_name))
#--         print_debug("handle_staff_note - stfs={}".format(stfs))
        nummins = find_mlth_values(stfs, m, find_mlth_values)
#--         print_debug("handle_staff_note - nummins={}".format(nummins))
        if number_notes_in_chord > len(nummins):
            print_error("handle_staff_note - number_notes_in_chord='{}' > number_voices_available='{}'".format(number_notes_in_chord,len(nummins)), original_line)
#??             return
        # fi
        newly_added = None;
        for numchords in range(0,number_notes_in_chord):
            n = add_these_staff_chords[numstaff][numchords]
            if len(n) != 7:
                print_error("handle_staff_note - input note[] is not 7 long. n='{}'".format(n), original_line)
                return
            # fi
            p_i = n[0]
            staffon = n[1]
            voiceon = nummins[numchords]
            m = n[2]
            if m != measure_on:
                print_error("handle_staff_note - current measure='{}' does not match that of note='{}'".format(measure_on,m), original_line)
            # fi
            notestuff = n[3]
            if len(notestuff) != 4:
                print_error("handle_staff_note - notestuff[] is not 4 long. notestuff='{}'".format(notestuff), original_line)
                return
            # fi
            prenote = notestuff[0]
            thenote = notestuff[1]
            timeofnote = notestuff[2]
            if p_i:                             # value is in clicks if ...
                added = timeofnote
            else:
                if args.midi1csv or args.fluidsynth:
                    added = int(round(timeofnote * MIDICLICKSPERQUARTER * 4))
                else:
                    added = timeofnote
                # fi
            # fi
            if newly_added is None or added < newly_added:
                newly_added = added
            # fi
            postnote = notestuff[3]
            suffixstuff = n[4]
            if len(suffixstuff) != 4:
                print_error("handle_staff_note - suffixstuff[] is not 4 long. suffixstuff='{}'".format(suffixstuff), original_line)
                return
            # fi
            prev_tie = suffixstuff[0]
            tie_this = suffixstuff[1]
            append_tie = suffixstuff[2]
            append_legato = suffixstuff[3]
            cresvols = n[5]
            if len(cresvols) != 1:
                print_error("handle_staff_note - cresvols[] is not 1 long. suffixstuff='{}'".format(suffixstuff), original_line)
                return
            # fi
            onenotevolume = cresvols[0]
            original_line = n[6]
            if prev_tie is not None:
                set_tie_on_previous_note(voiceon, prev_tie, original_line)
            # fi
            bufs_tie_next[voiceon] = tie_this
            bufs_legato_next[voiceon] = append_legato
            if p_i:
                put_on_bufs(voiceon, m, prenote, thenote, timeofnote, append_tie, onenotevolume, postnote, original_line)
            else:
                instak(voiceon, m, prenote, thenote, timeofnote, append_tie, onenotevolume, postnote, original_line)
            # fi
        # rof
        if len(nummins) > number_notes_in_chord and newly_added is not None:
            if args.midi1csv or args.fluidsynth:
                r = 0
            else:
                r = 'r'
            # fi
            for numchords in range(number_notes_in_chord, len(nummins)):   # Go through notes in chord.
                instak(nummins[numchords], m, '', r, newly_added, '', None, '', original_line)
            # rof
        # fi
    # rof
    return
# End of handle_staff_note

# ----------------------------------------------------------------------------
# Might take multiple tokens.
#   next_tokens = process_notes_for_staff(token, delimiter, next_tokens, original_line)

def process_notes_for_staff(token, delimiter, next_tokens, original_line):       # NOTDONDYET
    global last_voice_staff
    global measure_on

    if not measure_on or measure_on == '':          # no measure yet
        print_error("no measure processed yet - must have one before notes.", original_line)
        return ''
    # fi

    if delimiter == '':                             # End of line.
        send_these_notes = token + ' '+ next_tokens
    elif len(next_tokens) > 0 and next_tokens[0] == delimiter:
        send_these_notes = token + next_tokens
    else:
        send_these_notes = token + delimiter + next_tokens
    # fi
    a = separate_args(send_these_notes, False, False, original_line)
    nt = a[0]
    rest = " ".join(a[1:])

    initialize_set_voices(last_voice_staff, original_line)
    setvar('voice', ','.join(last_voice_staff), 1)

    next_tie = get_staff_arr(last_voice_staff, bufs_tie_next, 'process_notes_for_staff ' + original_line)
    next_legato = get_staff_arr(last_voice_staff, bufs_legato_next, 'process_notes_for_staff ' + original_line)
#--     print_debug("process_notes_for_staff - calling do_a_note({})".format(nt))
    do_break, note_add = do_a_note(nt, last_voice_staff, '', '', None, next_tie, next_legato, original_line)
#--     print_debug("do_a_note - nt='{}' note_add='{}'".format(nt, note_add))
    if not do_break:                                # Error occurred.
        return rest
    # fi
    middle = False
    err = False
    for st in last_voice_staff:                     # Go through staves
        if st in staff_chord and staff_chord[st] is not None:
            middle = True
        elif middle:
            print_error("staff {} not in middle of chord, but others ({}) are.".format(st, last_voice_staff),original_line)
            err = True
        # fi
    # rof
    if err:
        return ''
    # fi
    if note_add is None or note_add == '' or note_add == []:
        pass
    elif middle:
        for st in last_voice_staff:                 # Go through staves
            for na in note_add:
                q = copy.deepcopy(na)
                q[1] = [st]                         # Put onto staff_chord for this staff only.
                staff_chord[st].append(q)
            # rof
        # rof
    else:
        new_sc = []
        for st in last_voice_staff:
            q = copy.deepcopy(note_add)
            n = len(q)
            for i in range(0,n):
                q[i][1] = [st]
            # rof
            new_sc.append(q)
            # fi
        # rof
#--         print_debug("process_notes_for_staff - calling handle_staff_note")
        handle_staff_note(new_sc, original_line)    # Only one note/voice in chord. (can be trill/sequence).
    # fi
    return rest
# End of process_notes_for_staff

# ----------------------------------------------------------------------------
# The command coming in goes to the staff in and voices in:
#       last_voice_staff = sn
#       staff_name[sn] = v
# If there is a process active, need to get the next token, then set argument
# name for the process, then execute that process -- one line at a time, like
# a macro. Then next token, etc. for the line.
#
# If not in a process, then need to use the token to process it as:
#       1) staffname
#       2) keyward
#       3) note processing.
#       4) [ ] - chord ... with note processing ...
#           Chords are strange, notes may be different lengths, then shortest
#           one(s) are connected with the next note(s) [if the chord does not
#           have all notes with the same length].
#           So ...: staff   this: 1,2,3
#                   this: 3c4 [3c2 3e4 3g8] 3g8 [3e4 3g8] 3g8
#           means:  v1:   3c4, 3c2
#                   v2:    r4, 3e4,      3e4
#                   v3:    r4, 3g8, 3g8, 3g8, 3g8

# Okay... staff1,staff2,(m3='staff3'): 4c4 staff4:4e4
#
# This means gotta get first token:
#       1) c = first character
#           a) if [a-zA-Z_]: token name
#               get rest of token name [a-zA-Z0-9_]*
#           b) if ( then parenthesis and calculation and possible COMMA.
#           c) if [0-9]: note
#               do it.
#           d) If ':' error.
#`      2) after token name, delimiter matters: ',' or ':' gather tokens until possible ':' ( look-ahead ).
#
def process_staff_notes(command, delimiter, t_args, original_line):
    global measure_on
    global process
    global last_voice_staff
    global in_process_already
    global running_process_already

    token = command
    tdelim = delimiter
    next_tokens = t_args.strip()
#--     print_debug("process_staff_notes #1 - token='{}' tdelim='{}' next_tokens='{}'".format(token, tdelim, next_tokens))
    if token is None or token == '':
        if next_tokens is not None and len(next_tokens) > 0 and tdelim == next_tokens[0]:
            token = next_tokens
            tdelim = ''
            next_tokens = ''
        elif tdelim is not None and tdelim != '':
            token = tdelim
            tdelim = ''
        # fi
    # fi

#--     print_debug("process_staff_notes #1b - staff_name='{}'".format(staff_name))
    while ((token is not None and token != '') or
           (next_tokens is not None and next_tokens != '') or
           (tdelim is not None and tdelim != '')):
#--         print_debug("process_staff_notes #2 - token='{}'".format(token))
        if token in all_unique_macro_names:
#--             print_debug("process_staff_notes #3 - token='{}' in all_unique_macro_names='{}'".format(token,all_unique_macro_names))
            if tdelim in [' ', '\s']:
                next_tokens = (tdelim + next_tokens).strip()
            # fi
            if lmp_executing_number > MAX_NESTING:
                print_error("m:{} all_unique_macro_names#1 {} nesting to depth of more than {}".format(measure_on, token, MAX_NESTING), original_line)
                return                                      # Error ... ouch, many errors will follow. *sigh*
            # fi
            for cnumber in all_unique_macro_names[token]:
                # Need to put this line to be processed after macro...
                # NOTE: return from replace_macro of false means macro didn't match correctly.
                if replace_macro(cnumber, next_tokens, original_line):
                    return                                  # Henceforth get lines from macro_buffer.
                # fi
            # rof
            print_warning("m:{} macro {} did not match terminators correctly...".format(measure_on, token), original_line)
        # fi
        if token == 'begin':
#--             print_debug("process_staff_notes - begin - in_process_already='{}' running_process_already='{}'".format(in_process_already, running_process_already))
            if in_process_already:
                # Delete process from stack.
                set_process_quit()
            # fi
            token, next_tokens, tdelim = compute_command_args(next_tokens)
#--            print_debug("token was begin - token='{}' next_tokens='{}' tdelim='{}'".format(token, next_tokens, tdelim))
            in_process_already = set_process_begin(token, next_tokens, original_line)
            running_process_already = False
#--            print_debug("process_staff_notes #4 begin - in_process_already='{}' running_process_already='{}'".format(in_process_already,running_process_already))
        elif token == 'quit':
#--             print_debug("process_staff_notes - quit - in_process_already='{}' running_process_already='{}'".format(in_process_already, running_process_already))
            if in_process_already:
                # Delete process from stack.
                set_process_quit()
                in_process_already = False
#--                print_debug("process_staff_notes #5 - in_process_already='{}' running_process_already='{}'".format(in_process_already, running_process_already))
            else:
                print_error("quit without being in a process.", original_line)
            # fi
        elif token in staff_keywords:
#--             print_debug("process_staff_notes #6a - token='{}' in staff_keywords='{}'".format(token,staff_keywords))
            # process keyword - Might take multiple tokens.
            next_tokens = process_keyword(token, tdelim, next_tokens, original_line)
            if next_tokens is not None:
                next_tokens = next_tokens.strip()
            # fi
        elif token in staff_name and tdelim in [':', ',', ' ', "\t", '']:
#--             print_debug("process_staff_notes #6b - token='{}' in staff_name='{}' tdelim='{}'".format(token,staff_name,tdelim))
            next_staff = []
            while tdelim in [',', ' ', "\t", '']:
                next_staff.append(token)
#--                 print_debug("process_staff_notes #6c - next_tokens='{}'".format(next_tokens))
                if tdelim != '' and tdelim == next_tokens[0]:
                    next_tokens = next_tokens[1:].strip()
                # fi
#--                 print_debug("process_staff_notes #6d - next_tokens='{}'".format(next_tokens))
                token, next_tokens, tdelim = compute_command_args(next_tokens)
#--                 print_debug("process_staff_notes #6e - token='{}' next_tokens='{}' tdelim='{}'".format(token,next_tokens,tdelim))
                if token not in staff_name:
                    print_error("process_staff_notes - staff names must be followed by a colon (':') - token={} next_tokens='{}' tdelim='{}'".format(token,next_tokens,tdelim), original_line)
                    return
                # fi
            # elihw
            if tdelim != '' and tdelim == next_tokens[0]:
                next_staff.append(token)
                next_tokens = next_tokens[1:].strip()
            # fi
#--             print_debug("process_staff_notes #6e - next_staff='{}'".format(next_staff))
            last_voice_staff = next_staff                   # Switch to staff_name.
#--             print_debug("process_staff_notes #6 - last_voice_staff='{}'".format(last_voice_staff))
        elif in_process_already and not running_process_already:
#--             print_debug("process_staff_notes - #7a - in_process_already='{}' running_process_already='{}'".format(in_process_already, running_process_already))
#--             print_debug("process_staff_notes #7a - token='{}' tdelim='{}' next_tokens='{}'".format(token,tdelim,next_tokens))
            if token == '(':
                array_args = separate_args('(' + next_tokens, False, False, original_line)
#--                 print_debug("process_staff_notes #7b - array_args='{}'".format(array_args))
                if len(array_args) < 1:
                    print_error("token was (, but separate_args did not return anything", original_line)
                    return
                # fi
                token = array_args[0]
                if len(array_args) == 1:
                    tdelim = ''
                    next_tokens = ''
                else:
                    tdelim = ' '
                    next_tokens = ' '.join(array_args[1:])
                # fi
            else:
#--                 print_debug("process_staff_notes #7c - token='{}' tdelim='{}' next_tokens='{}'".format(token,tdelim,next_tokens))
                if tdelim != '' and len(next_tokens) > 0 and tdelim != next_tokens[0]:
                    array_args = separate_args(token + tdelim + next_tokens, False, False, original_line)
                elif tdelim == '' and len(next_tokens) > 0:
                    array_args = separate_args(token + ' ' + next_tokens, False, False, original_line)
                else:
                    array_args = separate_args(token + next_tokens, False, False, original_line)
                # fi
#--                 print_debug("process_staff_notes #7c - token='{}' tdelim='{}' next_tokens='{}'".format(token,tdelim,next_tokens))
                if len(array_args) < 1:
                    print_error("separate_args did not return anything", original_line)
                    return
                # fi
                token = array_args[0]
                if len(array_args) == 1:
                    tdelim = ''
                    next_tokens = ''
                else:
                    tdelim = ' '
                    next_tokens = ' '.join(array_args[1:])
                # fi
            # fi
#--             print_debug("process_staff_notes #7d - run_process(token='{}', next_tokens='{}')".format(token,next_tokens))
#? Need to change token/next_tokens in some manner
            run_process(token, next_tokens, original_line)
            return
        elif token == '[':
#--             print_debug("process_staff_notes #8 - start chord")
            err = False
            for st in last_voice_staff:                     # Go through staves
                if st in staff_chord:
                    if staff_chord[st] is not None:
                        print_error("Starting chord for staff {} and already in the middle of a chord({})".format(st,staff_chord[st]), original_line)
                        err = True
                    else:
                        staff_chord[st] = []
                    # fi
                else:
                    staff_chord[st] = []
                # fi
            # rof
            if err:
                return
            # fi
        elif token == ']':
#--             print_debug("process_staff_notes #9 - end chord")
            err = False
            new_sc = []
            for st in last_voice_staff:
                if st not in staff_chord or staff_chord[st] is None or staff_chord[st] == []:
                    print_error("Ending chord for staff {} but not in the middle of a chord".format(st), original_line)
                    err = True
                else:
                    q = copy.deepcopy(staff_chord[st])
                    n = len(q)
                    for i in range(0,n):
                        q[i][1] = [st]
                    # rof

                    if args.midi1csv or args.fluidsynth:    # Sort high to low.
                        swapped = False
                        # Traverse through all array elements
                        for i in range(n-1):
                            for j in range(0, n-i-1):
                                if q[j][3][1] < q[j + 1][3][1]:
                                    swapped = True
                                    tmp = q[j][3][1]
                                    q[j][3][1] = q[j + 1][3][1]
                                    q[j + 1][3][1] = tmp
                                # fi
                            # rof
                            if not swapped:
                                break
                            # fi
                        # rof
                    # fi
                    new_sc.append(q)
                # fi
            # rof
            if err:
                return
            # fi
#--             print_debug("process_staff_notes - calling handle_staff_note")
            handle_staff_note(new_sc, original_line)
            for st in last_voice_staff:                     # Go through staves
                staff_chord[st] = None
            # rof
        else:
            if token == '(':
                array_args = separate_args('(' + next_tokens, False, False, original_line)
#--                 print_debug("process_staff_notes #10a - array_args='{}'".format(array_args))
                if len(array_args) < 1:
                    print_error("token was (, but separate_args did not return anything", original_line)
                    return
                # fi
                token = array_args[0]
                if len(array_args) == 1:
                    tdelim = ''
                    next_tokens = ''
                else:
                    tdelim = ' '
                    next_tokens = ' '.join(array_args[1:])
                # fi
            # fi
#--             print_debug("process_staff_notes #10c - token='{}' tdelim='{}' next_tokens='{}'".format(token,tdelim,next_tokens))
            # Might take multiple tokens.
            next_tokens = process_notes_for_staff(token, tdelim, next_tokens, original_line)
            if next_tokens is not None:
                next_tokens = next_tokens.strip()
            #
#--             print_debug("process_staff_notes #11 - next_tokens='{}'".format(next_tokens))
        # fi
        # Get next token and tdelim.
#--         print_debug("process_staff_notes #12 - next_tokens='{}'".format(next_tokens))
        token, next_tokens, tdelim = compute_command_args(next_tokens)
#--         print_debug("process_staff_notes #13 - token='{}' tdelim='{}' next_tokens='{}'".format(token,tdelim,next_tokens))
        token = token.strip()
        tdelim = tdelim.strip()
        # Fix up for delimiter as first character in next_tokens before call to compute_command_args().
        if token is None or token == '':
            if tdelim is not None and tdelim != '' and tdelim == next_tokens[0]:
                token = tdelim
                next_tokens = next_tokens[1:]
                tdelim = ''
            elif tdelim is not None and tdelim != '':
                token = tdelim
                tdelim = ''
            # fi
        # fi
#--         print_debug("process_staff_notes #32 - token='{}' tdelim='{}' next_tokens='{}'".format(token,tdelim,next_tokens))
    # elihw
    return
# End of process_staff_notes

# ----------------------------------------------------------------------------
# Parse and process line.

def process_line(original_line):
    global iftest                       # check if after if or else.
    global ifdepth                      # level of if/else/endif
    global commands
    global cstop_processing
    global macro_defining               # If defining macro.
    global process_defining             # If defining process.
    global loop_defining                # If defining loop.
    global measure_on
    global i_line

    qline = original_line
#--     print_debug("        process_line-line='{}'".format(original_line))
    # Replace variables for rest of 'some' lines. :)
    numcharvar = 0
    while True:
        command, t_args, delimiter = compute_command_args(qline)
#--         print_debug("process_line - {} = command='{}' t_args='{}' delimiter='{}'".format(numcharvar, command, t_args, delimiter))

        if cstop_processing:
            # Read until cstart found (or end of file)
            if command in commands and commands[command][0] == do_cstopnow:
                return True                                     # End of file!
            elif command in commands and commands[command][1]:  # If flag to process while in cstop.
                commands[command][0](t_args, original_line)     # Process some commands while cstop-ped.
            # fi
            return False                    # Done with current cstop processing.
        elif macro_defining is not None:
            if command in commands and commands[command][0] == do_cstopnow:
                return True                                     # End of file!
            # fi
#--             print_debug("process_line - calling macro_define")
            macro_define(command, t_args, original_line)
            return False
        elif process_defining is not None:
            if command in commands and commands[command][0] == do_cstopnow:
                return True                                     # End of file!
            # fi
#--             print_debug("process_line - calling process_define")
            process_define(command, t_args, original_line)
            return False
        elif loop_defining is not None:
            if command in commands and commands[command][0] == do_cstopnow:
                return True                                     # End of file!
            # fi
#--             print_debug("process_line - calling loop_define")
            loop_define(command, t_args, original_line)
            return False
        # Do not do macros in false part of if/elif/else section.
        elif not(iftest[ifdepth] == -1 or iftest[ifdepth] == 1):
#--             print_debug("process_line - in if/else... ")
            if command in commands:
                if commands[command][0] == do_cstopnow:
                    return True                                 # End of file!
                elif commands[command][0] in (do_if, do_else, do_else_if, do_endif):
                    commands[command][0](t_args, original_line)
                # fi
            # fi
            return False
        # fi
        # Doing if section or else section or NORMAL processing.
        # Try to process command. If not a command, process notes.
        if args.lines:
            print("processed qline='{}'".format(qline), file=sys.stderr, flush=True)
        # fi
#--         print_debug("process_line #1a - command='{}' t_args='{}' delimiter='{}'".format(command,t_args,delimiter))
        if command is None:                                     # Ignore nothing given.
            return False
# Do NOT substitute variables for these commands: encode, calc, loop, calcs, calcc.
#   If it is a macro argument, let it SOMETIMES be changed (not for names of this macro arguments).
#   The next use changes.
        elif command in commands and commands[command][0] in \
             (do_calc, do_encode, do_calcs, do_calcc, do_loop, do_decode):
            commands[command][0](t_args, original_line)         # Process commands vars, encode, or calc's.
            return False                                        # There is a command to read after this.
        # fi
#--         print_debug("process_line #1A - command='{}' delimiter='{}' t_args='{}'".format(command,delimiter,t_args))
        if command is None or command == '':
            if t_args is not None and len(t_args) > 0 and delimiter == t_args[0]:
                command = t_args
                delimiter = ''
                t_args = ''
            elif delimiter is not None and delimiter != '':
                command = delimiter
                delimiter = ''
            # fi
        else:
            if t_args is not None and len(t_args) > 0 and delimiter == t_args[0]:
                delimiter = ''
        # fi
        # Replace variables here. Lots of checks above.
        qline = command + delimiter + t_args
#--         print_debug("process_line #1Ba - calling replace_character_variables, qline={}".format(qline))
        nline = replace_character_variables(qline, original_line).rstrip()
#--         print_debug("process_line #1Ba - after replace_character_variables, nline={}".format(nline))
        command, t_args, delimiter = compute_command_args(nline)
#--         print_debug("process_line #1Bb - command='{}' t_args='{}' delimiter='{}'".format(command,t_args,delimiter))
        if nline == qline:
            break
        # fi
        qline = nline
#--         print_debug("process_line #1C - command='{}' t_args='{}' delimiter='{}'".format(command,t_args,delimiter))
        numcharvar = numcharvar + 1
        if numcharvar > MAX_LOOP_VARIABLES:
            print_error("Over {} character variable substitutions done on arguments - loop?".format(MAX_LOOP_VARIABLES), original_line)
            break
        # fi
    # ehihw

#--     print_debug("process_line #1D - command='{}' t_args='{}' delimiter='{}'".format(command,t_args,delimiter))
    if command is None:
        return False
    elif command in all_unique_macro_names:
        if delimiter in [' ', '\s']:
            t_args = delimiter + t_args
        # fi
        if lmp_executing_number > MAX_NESTING:
            print_error("m:{} all_unique_macro_names#2 {} nesting to depth of more than {}".format(measure_on, command, MAX_NESTING), original_line)
            return False                                    # Error ... ouch, many errors will follow. *sigh*
        # fi
        for cnumber in all_unique_macro_names[command]:
            # NOTE: return from replace_macro of false means macro didn't match correctly.
            if replace_macro(cnumber, t_args, original_line):
                return False                                # Henceforth get lines from macro_buffer.
            # fi
        # rof
        print_warning("m:{} macro {} did not match terminators correctly...".format(measure_on, command), original_line)
    elif len(command) > 0 and command[0] == '%':            # Change single percent to double percent signs.
        command = '%%'
    # fi
    if command in commands:
#--         print_debug("process_line #1e - command='{}'".format(command))
        if commands[command][0] == do_cstopnow:
            return True                                     # End of file!
        # fi
        try:
            r = commands[command][0]                        # Had an error once ... thus try/expect.
        except:
            print_error("m:{} not found processing routine for command '{}'".format(measure_on), command)
            print("    ", sys.exc_info()[0], sys.exc_info, file=sys.stderr, flush=True)
        # fi
        r(t_args, original_line)
        return False
    elif measure_on in goto_table:
        print_error("Notes after a goto are not allowed. measure='{}'".format(measure_on), original_line)
        return False
    # fi
#--     print_debug("process_line #1f - staff_name='{}' command='{}'".format(staff_name,command))
#--     print_debug("process_line - staff_name='{}' '{}','{}','{}'".format(staff_name,command,delimiter,t_args))
    if staff_name == {}:                                    # Not running in staff mode.
        if delimiter in [' ', '\s']:
            nline = command + delimiter + t_args
        else:
            nline = command + t_args
        # fi
#--         print_debug("process_line - calling process_notes_oldway('{}', '{}')".format(nline, original_line))
        process_notes_oldway(nline, original_line)
        return False
    # fi
#--     print_debug("process_line - calling process_staff_notes('{}','{}','{}')".format(command,delimiter,t_args))
    process_staff_notes(command, delimiter, t_args, original_line)
    return False
# End of process_line

# ----------------------------------------------------------------------------
def readthefile():
    global last_voice_staff
    global commentonline
    global precomment
    global linecount
    global which_file_in
    global macro_defining
    global i_line
    global args
    global lmp_executing_number
    global lmp_executing_type
    global lmp_executing_which
    global lmp_executing_line
    global macro_name
    global loop_location
    global process_name
    global running_process_already

    ifdone = False
    precomment = ''
    while not ifdone:                       # Read the file loop.
        line, commentonline = read_next_line()
        if args.lines:
            if lmp_executing_number > 0:
                l = lmp_executing_number
                lt = lmp_executing_type[l]
                the_lmp = lmp_executing_which[l]
                if lt == 'macro':
                    name_mpl = macro_name[the_lmp]
                elif lt == 'loop':
                    name_mpl = str(loop_location[the_lmp])
                elif lt == 'process':
                    name_mpl = process_name[the_lmp]
                    if not running_process_already:
                        name_mpl = name_mpl + ' - Not_running'
                    # fi
                # fi
                ln = lmp_executing_line[l]
                extra = " l={} {} {} line#{}".format(l, lt, name_mpl, ln)
            else:
                extra = ''
            # fi
            print("linecount={}{} line='{}'".format(linecount,extra,line), file=sys.stderr, flush=True)
            # Below is variables in process trill in file P2.gcs.
#--             print_some_variable_values('   readthefile#1', [ 'A', 'ARG', 'DEF', 'NEW', 'octv', 'notenum', 'dur', 'secs' ] )
#--             print_some_variable_values('   readthefile#1', [ 'EVENT', 'U', 'beat', 'index' ] )
#--             print_some_variable_values('   readthefile#1', [ 'i', 'STFNAME', 'staffno', 'Voices', 'delay', 'pch' ] )
#--             print_some_variable_values('readthefile#1', [ 'temp', 'ARRAY', 'j', 'length', 'MULT', 'i', 'k', 'DUR', 'PCH', 'STEPS', 'REST', 'STFNAME', 'staffno', 'pch' ] )
#--             print_some_variable_values('readthefile#1', [ 'INSNO', 'PCH', 'DUR', 'SP', 'inv', 'vf', 'STFNAME' ] )
            print_some_variable_values('readthefile#1', [ 'ARG', 'a', 'i', 'TIMES', 'x', 'y' ] )
        # fi
        if line is None and commentonline is None:  # If end of file.
            return
        elif not line or len(line) <= 0 or line == '':
            continue
        # fi
        line = line.rstrip()
        if not line or len(line) <= 0 or line == '':
            continue
        # fi
        # If command == '*' ignore.
        if re.match(r'^\s*[*]', line):
            precomment = precomment + line + "\n"           # Comment line.
            continue
        # fi
        num_putd = 0
        while True:                         # Character variable substitution loop, etc. (till no more).
            if macro_defining is not None:
                # Replace any macro arguments - in macro definitions.
                nline = replace_macro_arguments(line, line).rstrip()
                if nline != line:
                    line = nline
                    numcharvar = numcharvar + 1
                    if numcharvar > MAX_LOOP_VARIABLES:
                        print_error("Over {} character variable substitutions done on line".format(MAX_LOOP_VARIABLES), line)
                        break
                    # fi
                    i_line.append('3chvs: ' + line)         # Line as fixed or whatever.
                    continue        # might have putd's or continuation line.
                # fi
                break
            elif line and (line[0] == "\t" or re.match(r'^        ', line)):
                # This is a continuation line.
# NOTDONEYET - may NOT have to do this? process_notes_oldway should take care of staff and voices?
                if last_voice_staff is not None:
                    if type(last_voice_staff) is int:
                        line = 'v' + str(last_voice_staff) + ': ' + line.strip()
                    # fi
                # fi
            # fi
            line = line.lstrip()
            if len(line) >= 1 and line[0] == '.' and (len(line) == 1 or (line[1] == "\t" or line[1] == ' ')):
                # Indentation (.\t) decremented (tossed).
                line = line[1:].lstrip()
                if len(line) == 0:
                    break
                # fi
                continue                                    # Try for continuation/indentation again.
            # fi
# CANNOT do this, it would be done before loop define, etc. This WILL replace calculated variables.
#--             nline = char_var_subst_first_token(line)        # First token could switch via variables to =, etc.
#--             print_some_variable_values('   readthefile#5', [ 'a', 'x', 'y', 'i', 'ARG', 'TIMES' ] )
#--             # fi
#--             line = nline
#--             print_debug('readthefile#7a - line after first token variables, line={}'.format(line))
            if line and line[0] == '=':
                nline = replace_macro_arguments(line, line).rstrip()
                nline = process_putd(nline)
                i_line.append('putd:  ' + nline)            # Line as fixed or whatever.
                line = nline
                if len(line) > 0 and line[0] == '=':
                    num_putd += 1
                    if num_putd > MAX_PUTDS:
                        print_error("Over {} putd's done on line".format(MAX_PUTDS), line)
                        break
                    # fi
                    continue                                # If more things that might change...
                # fi
            # fi
#--             print_debug('readthefile#9 - line after putd={}'.format(line))
            break
        # elihw
        if len(line) == 0:                                  # Ignore empty line.
            continue
        elif line[0] == "\t":
            line = (' ' * 8) + line[1:]
        # fi
        if line.startswith('^        '):
            line = line.rstrip()                            # Strip trailing spaces.
            rline = line.rstrip()
            if not rline or rline == '':                    # Ignore empty continuation lines.
                continue
            # fi
        else:
            line = line.strip()                             # Strip non-continuation leading and trailing spaces.
        # fi
        if len(line) == 0:                                  # Ignore empty line.
            continue
        # fi
        # If command == '*' -- ignore the "comment" line.
        if line[0] == '*':
            precomment = precomment + line + "\n"           # Comment line.
        elif line[0] == '#' and re.match('^# ([0-9]+) "([^"]+)".*$', line):  # Only process 1 type C preprocessor line.
            uxit = re.sub('^# ([0-9]+) "([^"]+)".*$', r"\1 \2", line)
            wxit = re.split(r' ', uxit, maxsplit = 1)
            linecount = int(wxit[0]) - 1
            which_file_in = wxit[1]
        else:                                               # Note: empty blank line NOT passed through.
            ifdone = process_line(line)
            precomment = ''
        # fi
    # elihw
    return
# End of readthefile

# ----------------------------------------------------------------------------
def parse_args():
    global args
    global pages_to_do
    global measures_to_do
    global voices_to_do

#--    def offset_value(v):
#--        if len(v) > 0:
#--            if v[0] == '=':
#--                v = v[1:]
#--            # fi
#--        # fi
#--        return v
#--    # End of offset_value

#--    for indx in range(len(sys.argv) - 1):
#--        if '--offset' in sys.argv[indx]:
#--            sys.argv[indx + 1] = '={0}'.format(sys.argv[indx + 1])
#--        # fi
#--    # rof
    parser = argparse.ArgumentParser(
        description=__doc__,
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog='this is the epilog')
    parser.add_argument('--vertical', '--vertica', '--vertic', '--verti', '--vert',
                        '--ver', '--ve', '--v', '-v',
                        action='store_true',
                        help = 'Vertical musicomp format output.')
    parser.add_argument('--horizontal', '--horizonta', '--horizont', '--horizon',
                        '--horizo', '--horiz', '--hori', '--hor', '--ho', '--h',
                        action='store_true',
                        help = 'Horizontal musicomp format output.')
    parser.add_argument('--midi1csv', '--midi1cs', '--midi1c', '--midi1', '--midi',
                        '--mid', '--mi', '--m', '--csv', '--cs', '--c', '-c', '-m', '-1',
                        action='store_true',
                        help = 'Output MIDI 1.0 music format output.')
    parser.add_argument('--abc', '-abc',
                        action='store_const', const=1, default=0,
                        help = 'ABC music format output - default.')
    parser.add_argument('--fluidsynth', '--fluidsynt', '--fluidsyn', '--fluidsy', '--fluids',
                        '--fluid', '--flui', '--flu', '--fl', '--f', '--fs',
                        '-fluidsynth', '-fluidsynt', '-fluidsyn', '-fluidsy', '-fluids',
                        '-fluid', '-flui', '-flu', '-fl', '-f', '-fs',
                        action='store_true',
                        help = 'Output fluidsynth music format output.')
    parser.add_argument('--nogoto', '--nogot', '--nogo', '--nog',
                        '-nogoto', '-nogot', '-nogo', '-nog',
                        action='store_true',
                        help = 'Do not parse goto commands, ignore them.')
    parser.add_argument('--noxpose', '--noxpos', '--noxpo', '--noxp', '--nox',
                        '-noxpose', '-noxpos', '-noxpo', '-noxp', '-nox',
                        action='store_true',
                        help = 'Do not parse xpose commands, ignore them.')
#--    parser.add_argument('--offset', default=0, action = 'store', type=offset_value,
#--                        help = 'Offset for midi instruments +1, -1, -12 -- because they CAN differ for playing.')
    parser.add_argument('--shift', type=float, default=0.0,
                        help = 'Shift all measures before printing (0.5 = 1/2 note to left/earlier measure).')
    parser.add_argument('--pages', '--page', '-pages', '-page',
                        default='', action = 'store',
                        help = 'Only parse page(s) specified. "1,2,5" or "1,2,5-8,114". (via cstart/cstop)')
    parser.add_argument('--measures', '--measure', '--measur', '--measu', '--meas', '--mea', '--me',
                        '-measures', '-measure', '-measur', '-measu', '-meas', '-mea', '-me',
                        default='', action = 'store',
                        help = 'Only parse measure(s) specified. "1,2,5" or "1,2,5-8,114a,115". (via cstart/cstop)')
    parser.add_argument('--voices', '--voice', '--voic', '--voi', '--vo',
                        '-voices', '-voice', '-voic', '-voi', '-vo',
                        default='', action = 'store',
                        help = 'Only print voice(s) specified. (parsing done) "1,2,5" or "1,2,5-8,15". (when writing output)')
    parser.add_argument('--wrongties', '--wrongtie', '--wrongti', '--wrongt', '--wrong', '--wron', '--wro', '--wr',
                        '-wrongties', '-wrongtie', '-wrongti', '-wrongt', '-wrong', '-wron', '-wro', '-wr',
                        default='', action = 'store_true',
                        help = 'When reading, ties for --vertical are on the latter note, move to front.')
    parser.add_argument('--nolegato', '--no-legato', action='store_true',
                        help = 'Do not do legatos.')
    parser.add_argument('--multiplemeasures', action='store_true',
                        help = 'If measure appears multiple times, do not fill in voices with rests.')
    parser.add_argument('--D', '-D', action='append', type=str,
                        help = 'Example: "-D WHICH=5" Define variable in calculator. (e.g. "if WHICH==5")')
    parser.add_argument('--two', '-two', '--2', '-2', action='store_true',
                        help = 'Use soundfont number 2.')
    parser.add_argument('--sf2', '-sf2', '--sf', '-sf', default='', action='store',
                        help = 'Use soundfont file.')
    parser.add_argument('--warn_octave_accidental', '-warn_octave_accidental', action='store_true',
                        help = 'Warn if accidental in other octave set/used.')
    parser.add_argument('--spaces', '-spaces', action='store_true',
                        help = 'Use spaces as note separators in addition to commas (input only, not printing vertical/horizontal).')
    parser.add_argument('--xpose', '-xpose',
                        default='', action='store',
                        help = 'Arguments to process as an xpose command before procssing first measure.')
    parser.add_argument('--lines', '-lines',
                        default='', action='store_true',
                        help = 'Print each line as it is read from file or macro or loop.')
    parser.add_argument('rest', nargs='*',
                        help='Optional command to execute')
    args = parser.parse_args()

#--    if args.offset is not None:
#--        args.offset = int(args.offset)
#--    # fi

    if args.pages is not None and args.pages != '':
        # global pages_to_do
        n = re.sub(r'\s*,\s*', ',', args.pages)
        n = re.sub(r'\s*,\s*', ',', n)
        pages_to_do = separate_args(n, True, True, 'parsing --pages')
    # fi

    if args.measures is not None and args.measures != '':
        n = re.sub(r'\s*,\s*', ',', args.measures)
        n = re.sub(r'\s*,\s*', ',', n)
        measures_to_do = separate_args(n, True, True, 'parsing --measures')
    # fi

    if args.voices is not None and args.voices != '':
        n = re.sub(r'\s*,\s*', ',', args.voices)
        n = re.sub(r'\s*,\s*', ',', n)
        voices_to_do = separate_args(n, True, True, 'parsing --voices')
    # fi

    if args.rest is not None:
        for indx in range(len(args.rest)):
            if args.rest[indx][0] == '=':
                nextargv = args.rest[indx]
                if len(nextargv) > 0:
                    nextargv = nextargv[1:]
                # fi
                args.rest[indx] = nextargv
            # fi
        # rof
    # fi
    if args.vertical:
        if args.horizontal or args.abc == 1 or args.midi1csv or args.fluidsynth:
            print_error_no_line("Only may have one of --vertical, --horizontal, --abc, --midi1" or --fluidsynth)
            sys.exit(1)
        # fi
    elif args.horizontal:
        if args.abc == 1 or args.midi1csv or args.fluidsynth:
            print_error_no_line("Only may have one of --vertical, --horizontal, --abc, --midi1 or --fluidsynth")
            sys.exit(1)
        # fi
    elif args.midi1csv:
        if args.abc == 1 or args.fluidsynth:
            print_error_no_line("Only may have one of --vertical, --horizontal, --abc, --midi1 or --fluidsynth")
            sys.exit(1)
        # fi
        setvar('play', -1, 0)    # compiling for playing
    elif args.fluidsynth:
        if args.abc == 1:
            print_error_no_line("Only may have one of --vertical, --horizontal, --abc, --midi1 or --fluidsynth")
            sys.exit(1)
        # fi
        setvar('play', -1, 0)    # compiling for playing
    else: # args.abc == 1
        setvar('print', -1, 0)   # compiling for printing
    # fi

    if args.D:
        for D in args.D:                    # If any defines, try to do them.
            sdefs = D.split('=')            # Quick check for assignment.
            if not sdefs or len(sdefs) < 2 or sdefs[0] == '' or sdefs[1] == '':
                print_error_no_line("Argument '-D {}' does not appear to be a variable assignment.".format(D))
                continue
            # fi
            sdef = sdefs[0].strip()
            typ = 0                         # Assume a numeric value (int or float).
            k = False
            for i in sdefs[1]:
                if i.isnumeric():
                    continue
                elif i == '.' and not k:
                    k = True
                    continue
                # fi
                typ = 1             # character string
                break
            # rof
            createlocalvar(sdef, sdefs[1], 0, typ, True)    # pre-define - macro level is global (zero).
        # rof
    return
# End of parse_args

# ----------------------------------------------------------------------------
# Main program follows.
def main():
    global header
    global measure_meter
    global measure_meter_value
    global args
    global file_name
    global output_name
    global meter
    global voices
    global measure_on
    global key_default
    global key_voice
    global which_file_in

    parse_args()
    if args.vertical or args.horizontal:
        header = ( "meter   4/4\n" )
        key_default = "c"                   # Default to key of c.
                                            # At the end of header, print out the key - then follows notes.
        measure_meter = { '': '4/4'}        # Each measure change can have a different meter.
        measure_meter_value = 1             # Computed value for measure.
        meter = '4/4'
    elif args.midi1csv or args.fluidsynth:
        header = []
        key_default = 0                     # Default to key of C.
        measure_meter = { '': '4/4'}        # Each measure change can have a different meter.
        measure_meter_value = 1             # Computed value for measure.
        meter = '4/4'
    else:           # ABC
        header = (  "X:1\n" +               # Song number 1 in the output file.
                    "M:none\n" )            # No meter supposedly means don't check.
        key_default = "C"                   # Default to key of C.
                                            # At the end of header, print out the key - then follows notes.
        measure_meter = { '': 'none'}       # Each measure change can have a different meter.
        measure_meter_value = 1             # Computed value for measure.
        meter = 'none'
    # fi
    for v in range(1, MAXVOICES+1):
        key_voice[v] = {}
        key_voice[v][''] = key_default
    # rof

    new_voice_initialize(voices, measure_on)    # Set a bunch of things for voice=1 so acc_m, etc. are set.

    output_name = sys.stdout
    if args.rest:
        if len(args.rest) >= 1:             # Input.
            file_name = open(args.rest[0], 'r')
            which_file_in = args.rest[0]
        # fi
        if len(args.rest) >= 2:             # Output.
            output_name = open(args.rest[1], 'w')
        # fi
        if len(args.rest) > 2:              # Too many.
            print_error_no_line("Too many arguments, input, output only.  {}".format(args.rest))
            sys.exit(1)
        # fi
    # fi

    readthefile()

    pass2()
    return
# End of main

# ----------------------------------------------------------------------------
if __name__ == '__main__':
    main()
# fi
# ----------------------------------------------------------------------------
sys.exit(errors_happened)
# ----------------------------------------------------------------------------
# End of program musicomp2abc
# ----------------------------------------------------------------------------

# Header:
# * X:          Reference number (think which track on CD, etc.).       First
# * T: Title of tune             (can have multiple)
#   C: Composer of song
#   M: meter    6/8              default common or "M: C"
#   L: 1/4                       length of default note (quarter)
#   K: key      C or D or ...                                           Last
#
#   Notes: follow Header
#       C, D, E, F, |G,A,B,C| D E F G|A B c d|e f g a|b c' d' e'|f' g' a' b'|]
#
#       ~A3 B3|gfe fdB|AFA B2c|dfe dcB|
#
#   Uppercase denote bottom octave (C = middle C on treble stave).
#   Comma after the letter means down an octave.
#   Apostrophe after the letter means up an octave. Multiple ' go up, as ,'s go down.
#   Lowercase letters are next octave above uppercase. four c's: "C, C c c' "
#   |  Vertical line means end of measure/bar -- || gives two lines.
#   ]  means thick bar.  [|  and |] thick/thin and thin/thick.
#   |: start of repeat. :| is end of repeat. Stop one and start another is :||: or "::".
#   Alternate repeats "[1", "[2". If by bar line, can omit the [. "|1" means "|[1". (no spaces)
#   To have notes with "beam"(lines together above/below) eliminate the "space".
#
#   Number after note changes duration. Number times default. B2=B twice as long therefore 1/4 because 1/2.
#   / means shorten, default is 2 or "/2".
#   > after a note, multiplying by 3/2 and removing from 2nd note. I.e. c8>c8 -> c8.c16 (dot means 1/16 extra)
#   < after a note, multiplying by 1/2 and adding rest on 2nd note. I.e. c8<c8 -> c16c8. means 1/16th extra
#
#   ~ is ornament -- roll or turn as in Irish music.
#   Default note lengths for common types of tunes: jig 1/8, reel 1/8, Schottische 1/8,
#       Waltz 1/4, Polka 1/8, Bourree 1/8
#   Time signagures typical: jig 6/8, reel 4/4, waltz 3/4.
#   L: can be used in the middle to change default note length.
#   Rests are lowercase z. Length follows.
#   ^C = C sharp. _B = B flat. ^^ = double sharp. The equals (=) naturalizes it.
#   G major scale: GABcde^fg            for K:C
#   G minor scale: GA_Bcd_efg           for K:C
#   K: automatically adds sharps or flats.      example K:G or K:Gmaj ... and K:Gm or K:Gmin
#   Also K:Bb and K:C#   (B flat and C sharp).
#   Other Modal keys exist: Lydian, Ionian, Mixolydian, Dorian, Aeolian, Phrygian, Locrian,
#       HP (bagpipe - no key signature), Hp (F#,C#,G natural) on printed.
#   K: can go in the middle of a song.   K:A =C -- A major, C natural -- F#,G#.
#   R: = rythm. ... R:reel, R:jig, R:schottische
#   Q: tempo    Example: Q: 120  # of default note length.  Q:1/8 = 120.
#   Can change in the middle of a line like (KRQ):
#       GABcdefg | [M:6/8 K:Gm] gfe dcB | AGB FED |
#   Optional:
#   C: composer
#   S: source of tune.
#   O: geographical origin
#   N: textual notes about the tune. (anything you want, multiple of them, etc.)
#   Z: identity of transcriber. # Z:Marshall Midden 2021-01-04
#   W: for song words           w:  also -- difficult syntax. :)
#   B: for book
#   A: geographical area
#   D: Discography -- D:New Victory Band, One More Dance And Then
#   F: File name (http://www.lesession.co.uk/woodenflute.abc)
#   G: Group -- used for indexing tunes in software.   G: Flute
#   H: history
#   I: Information -- used by some software packages.
#   P: Yuck.  Parts.
#
#   grace notes {GAGDG}G2 -- they can have no time values.
#   - minus sign between two notes of equal pitch "ties". () slurs or played legato.
#       |DEF-|FGA| and |DEF-FGA|
#       (DEF|GAB)
#   Triplets -- no spaces within:
#       Duplet:     (2GA                2 notes in the time of 3
#       Triplet:    (3GAB               3 notes in the time of 2
#       Quadruplet: (4GABA              4 notes in the time of 3
#       ...       : (5GABcd             5 notes in the time of n
#       ...       : (6GABcdc            6 notes in the time of 2
#       ...       : (7GABcdcB           7 notes in the time of n
#       ...       : (8GABcdcBA          8 notes in the time of 3
#       ...       : (9GABcdcBAG         9 notes in the time of n
#       n is 3 in compound time signatures (3/4, 3/8, 9/8 etc), and 2 in simple time signatures (C, 4/4, 2/4 etc.)
#       More complicated forms possible. (Yuck!)
#   [GB][Ac] [B2d2] | [Bd][Ac] [G2B2]   - multiple notes on a stem (chord/unisons)
#   Guitar chords:  "Dm7"               -- note accidental type/bass
#       note:       A to G
#       accidental: # or b
#       type:       m, min, maj, sus, dim, +, 7, 9, 11,#5, etc.
#       / bass:     Bass note
#   Fiddle bowing marks:  u=up-bow, v=down-bow.     v_Au=Bv^c   NOTE: flat A, natural B, sharp c.
#   Staccato, place dot before the note.            .G.A._B.c .d2.e.d.^c
#       H Fermata, L Accent, or emphasis, M Lower mordent (sometimes called mordent),
#       O Coda, P Upper mordent (sometimes called Pralltriller), S Segno, T Trill
#   or can enclose within exclamation marks (!):
#       !+!             Pizzicato for violins, rasp for brass
#       !0! to !5!      Fingerings
#       !D.C.!          Da capo
#       !D.S.!          Da segno
#       !accent!        Accent mark over the note
#       !breath!        Breath mark
#       !coda!          Coda mark
#       !crescendo(!    Start of a crescendo mark
#       !crescendo)!    End of a crescendo mark - this is placed AFTER the last note affected
#       !diminuendo(!   Start of a diminuendo mark
#       !diminuendo)!   End of a diminuendo mark - this is placed AFTER the last note affected
#       !downbow!       Down bow mark
#       !emphasis!      The same as !accent!
#       !fermata!       Fermata, or hold
#       !f!, !ff!, !fff! etc.   Dynamic markings - the more f -s, the louder
#       !fine!          Fine
#       !invertedfermata!   Inverted fermata / hold marking
#       !longphrase!    Vertical line on the upper part of the staff, extending 3/4 of the way down
#       !lowermordent!  Lower mordent, a.k.a. mordent
#       !mediumphrase!  Vertical line on the upper part of the staff, extending down to the centre line
#       !mf!            Dynamic marking for mezzoforte ('half-loud')
#       !mordent!       Lower mordent, a.k.a. mordent
#       !open!          Open string, or, harmonic
#       !p!, !pp!, !ppp!    Dynamic markings - the more p -s, the quieter
#       !pralltriller!  Upper mordent
#       !repeatbar!     Repeat whole of previous bar
#       !repeatbar2!    Repeat whole of previous two bars
#       !roll!          Roll mark
#       !segno!         Segno
#       !shortphrase!   Vertical line on the upper part of the staff
#       !snap!          Snap-pizzicato mark
#       !tenuto!        tenuto (hold note for full duration)
#       !thumb!         Cello thumb symbol
#       !trill!         Trill
#       !turn!          Turn
#       !upbow!         Up bow mark
#       !uppermordent!  Upper mordent, a.k.a. pralltriller
#       !wedge!         Wedge mark
#   As with the single letter symbols, the mark is placed before the note (or first note of a group) affected.
#       !trill!G4
#   V: voice number     V:1     V:20
#       M:6/8
#       L:1/8
#       K:G
#       V:1
#       B3 A3 | G6 | B3 A3 | G6 ||
#       V:2
#       BdB AcA | GAG D3 | BdB AcA | GAG D6 ||
#       V:3
#       D3 D3 | D6 | D3 D3 | D6 ||
#   or:
#       M:6/8
#       L:1/8
#       K:G
#       [V:1] B3 A3 | G6 | B3 A3 | G6 ||
#       [V:2] BdB AcA | GAG D3 | BdB AcA | GAG D3 ||
#       [V:3] D3 D3 | D6 | D3 D3 | D6 ||
#   Notes played at same time, but not a chord (two voices): AB BAG & D6 |
#       The & has the two same length.
#       x draws spaces (not rests).        GAB BAG & x3 G2x
#       Normally use [] for chords.
#  ------------------------------------------------------------------------------
#   General MIDI 1
#        24 channels/voices     Alternatively 16 melodic and 8 percussive - respond to note velocity.
#       channel 10 is percussion.
#       multiple notes on each channel (polyphony)
#       128 instruments sounds or "program" number - program change message.
#        47 percussion sounds
#       Channel messages/controller-number: 1,7,10,11,64,100,101,121,123
#   General MIDI 2
#        32 channels
#       2 percussion channels 10/11
#     16384 variation banks - each has 128 melodic sounds. Up to individual how to use.
#         9 Drum kits
# ------------------------------------------------------------------------------
# select chan sfont bank prog
#   000-000 Stereo Grand
#   000-001 Bright Grand
#   000-002 Electric Grand
#   000-003 Honky-Tonk
#   000-004 Tine Electric Piano
#   000-005 FM Electric Piano
#   000-006 Harpsichord
#   000-007 Clavinet
#   000-008 Celeste
#   000-009 Glockenspiel
#   000-010 Music Box
#   000-011 Vibraphone
#   000-012 Marimba
#   000-013 Xylophone
#   000-014 Tubular Bells
#   000-015 Dulcimer
#   000-016 Tonewheel Organ
#   000-017 Percussive Organ
#   000-018 Rock Organ
#   000-019 Pipe Organ
#   000-020 Reed Organ
#   000-021 Accordian
#   000-022 Harmonica
#   000-023 Bandoneon
#   000-024 Nylon Guitar
#   000-025 Steel Guitar
#   000-026 Jazz Guitar
#   000-027 Clean Guitar
#   000-028 Muted Guitar
#   000-029 Overdrive Guitar
#   000-030 Distortion Guitar
#   000-031 Guitar Harmonics
#   000-032 Acoustic Bass
#   000-033 Finger Bass
#   000-034 Pick Bass
#   000-035 Fretless Bass
#   000-036 Slap Bass 1
#   000-037 Slap Bass 2
#   000-038 Synth Bass 1
#   000-039 Synth Bass 2
#   000-040 Violin
#   000-041 Viola
#   000-042 Cello
#   000-043 Double Bass
#   000-044 Stereo Strings Trem
#   000-045 Pizzicato Strings
#   000-046 Orchestral Harp
#   000-047 Timpani
#   000-048 Stereo Strings Fast
#   000-049 Stereo Strings Slow
#   000-050 Synth Strings 1
#   000-051 Synth Strings 2
#   000-052 Concert Choir
#   000-053 Voice Oohs
#   000-054 Synth Voice
#   000-055 Orchestra Hit
#   000-056 Trumpet
#   000-057 Trombone
#   000-058 Tuba
#   000-059 Muted Trumpet
#   000-060 French Horns
#   000-061 Brass Section
#   000-062 Synth Brass 1
#   000-063 Synth Brass 2
#   000-064 Soprano Sax
#   000-065 Alto Sax
#   000-066 Tenor Sax
#   000-067 Baritone Sax
#   000-068 Oboe
#   000-069 English Horn
#   000-070 Bassoon
#   000-071 Clarinet
#   000-072 Piccolo
#   000-073 Flute
#   000-074 Recorder
#   000-075 Pan Flute
#   000-076 Bottle Blow
#   000-077 Shakuhachi
#   000-078 Irish Tin Whistle
#   000-079 Ocarina
#   000-080 Square Lead
#   000-081 Saw Lead
#   000-082 Synth Calliope
#   000-083 Chiffer Lead
#   000-084 Charang
#   000-085 Solo Vox
#   000-086 5th Saw Wave
#   000-087 Bass & Lead
#   000-088 Fantasia
#   000-089 Warm Pad
#   000-090 Polysynth
#   000-091 Space Voice
#   000-092 Bowed Glass
#   000-093 Metal Pad
#   000-094 Halo Pad
#   000-095 Sweep Pad
#   000-096 Ice Rain
#   000-097 Soundtrack
#   000-098 Crystal
#   000-099 Atmosphere
#   000-100 Brightness
#   000-101 Goblin
#   000-102 Echo Drops
#   000-103 Star Theme
#   000-104 Sitar
#   000-105 Banjo
#   000-106 Shamisen
#   000-107 Koto
#   000-108 Kalimba
#   000-109 Bagpipes
#   000-110 Fiddle
#   000-111 Shenai
#   000-112 Tinker Bell
#   000-113 Agogo
#   000-114 Steel Drums
#   000-115 Wood Block
#   000-116 Taiko Drum
#   000-117 Melodic Tom
#   000-118 Synth Drum
#   000-119 Reverse Cymbal
#   000-120 Fret Noise
#   000-121 Breath Noise
#   000-122 Seashore
#   000-123 Birds
#   000-124 Telephone 1
#   000-125 Helicopter
#   000-126 Applause
#   000-127 Gun Shot
#   001-038 Synth Bass 101
#   001-044 Mono Strings Trem
#   001-048 Mono Strings Fast
#   001-049 Mono Strings Slow
#   001-052 Concert Choir Mono
#   001-056 Trumpet 2
#   001-057 Trombone 2
#   001-059 Muted Trumpet 2
#   001-060 Solo French Horn
#   001-061 Brass Section Mono
#   001-080 Square Wave
#   001-081 Saw Wave
#   001-098 Synth Mallet
#   001-120 Cut Noise
#   001-121 Fl. Key Click
#   001-122 Rain
#   001-123 Dog
#   001-124 Telephone 2
#   001-125 Car-Engine
#   001-126 Laughing
#   001-127 Machine Gun
#   002-102 Echo Pan
#   002-120 String Slap
#   002-122 Thunder
#   002-123 Horse Gallop
#   002-124 Door Creaking
#   002-125 Car-Stop
#   002-126 Scream
#   002-127 Lasergun
#   003-122 Howling Winds
#   003-123 Bird 2
#   003-124 Door
#   003-125 Car-Pass
#   003-126 Punch
#   003-127 Explosion
#   004-122 Stream
#   004-123 Scratch
#   004-125 Car-Crash
#   004-126 Heart Beat
#   005-122 Bubbles
#   005-124 Windchime
#   005-125 Siren
#   005-126 Footsteps
#   006-125 Train
#   007-125 Jet Plane
#   008-004 Chorused Tine EP
#   008-005 Chorused FM EP
#   008-006 Coupled Harpsichord
#   008-014 Church Bells
#   008-016 Detuned Tnwl. Organ
#   008-017 Detuned Perc. Organ
#   008-019 Pipe Organ 2
#   008-021 Italian Accordian
#   008-024 Ukulele
#   008-025 12-String Guitar
#   008-026 Hawaiian Guitar
#   008-027 Chorused Clean Gt.
#   008-028 Funk Guitar
#   008-030 Feedback Guitar
#   008-031 Guitar Feedback
#   008-038 Synth Bass 3
#   008-039 Synth Bass 4
#   008-048 Orchestra Pad
#   008-050 Synth Strings 3
#   008-061 Brass Section 2
#   008-062 Synth Brass 3
#   008-063 Synth Brass 4
#   008-080 Sine Wave
#   008-081 Doctor Solo
#   008-107 Taisho Koto
#   008-115 Castanets
#   008-116 Concert Bass Drum
#   008-117 Melodic Tom 2
#   008-118 808 Tom
#   008-125 Starship
#   009-014 Carillon
#   009-125 Burst Noise
#   011-000 Piano & Str.-Fade
#   011-001 Piano & Str.-Sus
#   011-004 Tine & FM EPs
#   011-005 Piano & FM EP
#   011-008 Tinkling Bells
#   011-014 Bell Tower
#   011-038 Techno Bass
#   011-039 Pulse Bass
#   011-049 Stereo Strings Velo
#   011-050 Synth Strings 4
#   011-051 Synth Strings 5
#   011-061 Brass Section 3
#   011-078 Whistlin'
#   011-081 Sawtooth Stab
#   011-087 Doctor's Solo
#   011-088 Harpsi Pad
#   011-089 Solar Wind
#   011-096 Mystery Pad
#   011-098 Synth Chime
#   011-100 Bright Saw Stack
#   011-119 Cymbal Crash
#   011-121 Filter Snap
#   011-127 Interference
#   012-000 Bell Piano
#   012-004 Bell Tine EP
#   012-010 Christmas Bells
#   012-027 Clean Guitar 2
#   012-038 Mean Saw Bass
#   012-048 Full Orchestra
#   012-049 Mono Strings Velo
#   012-080 Square Lead 2
#   012-081 Saw Lead 2
#   012-088 Fantasia 2
#   012-089 Solar Wind 2
#   012-119 Tambourine
#   012-122 White Noise Wave
#   012-127 Shooting Star
#   013-048 Woodwind Choir
#   013-080 Square Lead 3
#   013-081 Saw Lead 3
#   013-088 Night Vision
#   016-025 Mandolin
#   120-000 Standard Drums
#   120-001 Standard 2 Drums
#   120-008 Room Drums
#   120-016 Power Drums
#   120-024 Electronic Drums
#   120-025 808/909 Drums
#   120-026 Dance Drums
#   120-032 Jazz Drums
#   120-040 Brush Drums
#   120-048 Orchestral Perc.
#   120-056 SFX Kit
#   128-000 Standard
#   128-001 Standard 2
#   128-008 Room
#   128-016 Power
#   128-024 Electronic
#   128-025 808/909
#   128-026 Dance
#   128-032 Jazz
#   128-040 Brush
#   128-048 Orchestral
#   128-056 SFX
# ------------------------------------------------------------------------------
#   Put in a V: section.
#   %%MIDI program 1 % Acoustic Grand Piano
#   Piano
#       0 Acoustic Grand Piano
#       1 Bright Acoustic Piano
#       2 Electric Grand Piano
#       3 Honky-tonk Piano
#       4 Electric Piano 1
#       5 Electric Piano 2
#       6 Harpsichord
#       7 Clavi
#   Chromatic Percussion
#       8 Celesta
#       9 Glockenspiel
#       10 Music Box
#       11 Vibraphone
#       12 Marimba
#       13 Xylophone
#       14 Tubular Bells
#       15 Dulcimer
#   Organ
#       16 Drawbar Organ
#       17 Percussive Organ
#       18 Rock Organ
#       19 Church Organ
#       20 Reed Organ
#       21 Accordion
#       22 Harmonica
#       23 Tango Accordion
#   Guitar
#       24 Acoustic Guitar (nylon)
#       25 Acoustic Guitar (steel)
#       26 Electric Guitar (jazz)
#       27 Electric Guitar (clean)
#       28 Electric Guitar (muted)
#       29 Overdriven Guitar
#       30 Distortion Guitar
#       31 Guitar Harmonics
#   Bass
#       32 Acoustic Bass
#       33 Electric Bass (finger)
#       34 Electric Bass (pick)
#       35 Fretless Bass
#       36 Slap Bass 1
#       37 Slap Bass 2
#       38 Synth Bass 1
#       39 Synth Bass 2
#   Strings
#       40 Violin
#       41 Viola
#       42 Cello
#       43 Contrabass
#       44 Tremolo Strings
#       45 Pizzicato Strings
#       46 Orchestral Harp
#       47 Timpani
#   Ensemble
#       48 String Ensemble 1
#       49 String Ensemble 2
#       50 Synth Strings 1
#       51 Synth Strings 2
#       52 Choir Aahs
#       53 Voice Oohs
#       54 Synth Voice
#       55 Orchestra Hit
#   Brass
#       56 Trumpet
#       57 Trombone
#       58 Tuba
#       59 Muted Trumpet
#       60 French Horn
#       61 Brass Section
#       62 Synth Brass 1
#       63 Synth Brass 2
#   Reed
#       64 Soprano Sax
#       65 Alto Sax
#       66 Tenor Sax
#       67 Baritone Sax
#       68 Oboe
#       69 English Horn
#       70 Bassoon
#       71 Clarinet
#   Pipe
#       72 Piccolo
#       73 Flute
#       74 Recorder
#       75 Pan Flute
#       76 Blown bottle
#       77 Shakuhachi
#       78 Whistle
#       79 Ocarina
#   Synth Lead
#       80 Lead 1 (square)
#       81 Lead 2 (sawtooth)
#       82 Lead 3 (calliope)
#       83 Lead 4 (chiff)
#       84 Lead 5 (charang)
#       85 Lead 6 (voice)
#       86 Lead 7 (fifths)
#       87 Lead 8 (bass + lead)
#   Synth Pad
#       88 Pad 1 (new age)
#       89 Pad 2 (warm)
#       90 Pad 3 (polysynth)
#       91 Pad 4 (choir)
#       92 Pad 5 (bowed)
#       93 Pad 6 (metallic)
#       94 Pad 7 (halo)
#       95 Pad 8 (sweep)
#   Synth Effects
#       96 FX 1 (rain)
#       97 FX 2 (soundtrack)
#       98 FX 3 (crystal)
#       99 FX 4 (atmosphere)
#       100 FX 5 (brightness)
#       101 FX 6 (goblins)
#       102 FX 7 (echoes)
#       103 FX 8 (sci-fi)
#   Ethnic
#       104 Sitar
#       105 Banjo
#       106 Shamisen
#       107 Koto
#       108 Kalimba
#       109 Bag pipe
#       110 Fiddle
#       111 Shanai
#   Percussive
#       112 Tinkle Bell
#       113 Agogo
#       114 Steel Drums
#       115 Woodblock
#       116 Taiko Drum
#       117 Melodic Tom
#       118 Synth Drum
#       119 Reverse Cymbal
#   Sound effects
#       120 Guitar Fret Noise
#       121 Breath Noise
#       122 Seashore
#       123 Bird Tweet
#       124 Telephone Ring
#       125 Helicopter
#       126 Applause
#       127 Gunshot
# ----------------------------------------------------------------------------
# timidity      000_Acoustic_Grand_Piano.pat
# timidity      001_Acoustic_Brite_Piano.pat
# timidity      002_Electric_Grand_Piano.pat
# timidity      004_Electric_Piano_1_Rhodes.pat
# timidity      005_Electric_Piano_2_Chorused_Yamaha_DX.pat
# timidity      006_Harpsichord.pat
# timidity      007_Clavinet.pat
# timidity      008_Celesta.pat
# timidity      009_Glockenspiel.pat
# timidity      013_Xylophone.pat
# timidity      014_Tubular_Bells.pat
# timidity      015_Dulcimer.pat
# timidity      016_Hammond_Organ.pat
# timidity      019_Church_Organ.pat
# timidity      021_Accordion.pat
# timidity      023_Tango_Accordion.pat
# timidity      024_Nylon_Guitar.pat
# timidity      025_Steel_Guitar.pat
# timidity      026_Jazz_Guitar.pat
# timidity      027_Clean_Electric_Guitar.pat
# timidity      028_Muted_Electric_Guitar.pat
# timidity      029_Overdriven_Guitar.pat
# timidity      030_Distortion_Guitar.pat
# timidity      032_Acoustic_Bass.pat
# timidity      033_Finger_Bass.pat
# timidity      034_Pick_Bass.pat
# timidity      035_Fretless_Bass.pat
# timidity      036_Slap_Bass_1.pat
# timidity      037_Slap_Bass_2.pat
# timidity      038_Synth_Bass_1.pat
# timidity      040_Violin.pat
# timidity      042_Cello.pat
# timidity      044_Tremolo_Strings.pat
# timidity      045_Pizzicato_Strings.pat
# timidity      046_Harp.pat
# timidity      047_Timpani.pat
# timidity      048_String_Ensemble_1_Marcato.pat
# timidity      053_Voice_Oohs.pat
# timidity      056_Trumpet.pat
# timidity      057_Trombone.pat
# timidity      058_Tuba.pat
# timidity      059_Muted_Trumpet.pat
# timidity      060_French_Horn.pat
# timidity      061_Brass_Section.pat
# timidity      064_Soprano_Sax.pat
# timidity      065_Alto_Sax.pat
# timidity      066_Tenor_Sax.pat
# timidity      067_Baritone_Sax.pat
# timidity      068_Oboe.pat
# timidity      069_English_Horn.pat
# timidity      070_Bassoon.pat
# timidity      071_Clarinet.pat
# timidity      072_Piccolo.pat
# timidity      073_Flute.pat
# timidity      074_Recorder.pat
# timidity      075_Pan_Flute.pat
# timidity      076_Bottle_Blow.pat
# timidity      079_Ocarina.pat
# timidity      080_Square_Wave.pat
# timidity      084_Charang.pat
# timidity      088_New_Age.pat
# timidity      094_Halo_Pad.pat
# timidity      095_Sweep_Pad.pat
# timidity      098_Crystal.pat
# timidity      101_Goblins--Unicorn.pat
# timidity      102_Echo_Voice.pat
# timidity      104_Sitar.pat
# timidity      114_Steel_Drums.pat
# timidity      115_Wood_Block.pat
# timidity      120_Guitar_Fret_Noise.pat
# timidity      122_Seashore.pat
# timidity      125_Helicopter.pat
# ----------------------------------------------------------------------------
# (Channel 10) MIDI Key Drum Sound
# 35 Acoustic Bass Drum
# 36 Bass Drum 1
# 37 Side Stick
# 38 Acoustic Snare
# 39 Hand Clap
# 40 Electric Snare
# 41 Low Floor Tom
# 42 Closed Hi Hat
# 43 High Floor Tom
# 44 Pedal Hi-Hat
# 45 Low Tom
# 46 Open Hi-Hat
# 47 Low-Mid Tom
# 48 Hi Mid Tom
# 49 Crash Cymbal 1
# 50 High Tom
# 51 Ride Cymbal 1
# 52 Chinese Cymbal
# 53 Ride Bell
# 54 Tambourine
# 55 Splash Cymbal
# 56 Cowbell
# 57 Crash Cymbal 2
# 58 Vibraslap
# 59 Ride Cymbal 2
# 60 Hi Bongo
# 61 Low Bongo
# 62 Mute Hi Conga
# 63 Open Hi Conga
# 64 Low Conga
# 65 High Timbale
# 66 Low Timbale
# 67 High Agogo
# 68 Low Agogo
# 69 Cabasa
# 70 Maracas
# 71 Short Whistle
# 72 Long Whistle
# 73 Short Guiro
# 74 Long Guiro
# 75 Claves
# 76 Hi Wood Block
# 77 Low Wood Block
# 78 Mute Cuica
# 79 Open Cuica
# 80 Mute Triangle
# 81 Open Triangle
# ----------------------------------------------------------------------------
# CC values have a range from 0-127, from minimum to maximum value. However, some parameters are (on/off), where 0 to 63 = Off, 64 to 127 = On.
# Most Common Parameters:
#     1 = Modulation wheel
#     2 = Breath Control
#     7 = Volume
#     10 = Pan
#     11 = Expression
#     64 = Sustain Pedal (on/off)
#     65 = Portamento (on/off)
#     71 = Resonance (filter)
#     74 = Frequency Cutoff (filter)
#
# NOTE: There is no standard CC value for Vibrato Amount or Vibrato Speed. Sometimes you can assign them (and other CC mappings) yourself in the software instrument you use.
# Complete List:
#     0 Bank Select (MSB)
#     1 Modulation Wheel
# x   2 Breath controller
# x   3 = Undefined
# x   4 Foot Pedal (MSB)
#     5 Portamento Time (MSB)
#     6 Data Entry (MSB)
#     7 Volume (MSB)
# x   8 Balance (MSB
#     9 = Undefined
#     10 Pan position (MSB)
#     11 Expression (MSB)
# x   12 Effect Control 1 (MSB)
# x   13 Effect Control 2 (MSB)
# x   14 = Undefined
# x   15 = Undefined
# x   16-19 = General Purpose
# x   20-31 = Undefined
# x   32-63 = Controller 0-31
#     64 Hold Pedal (on/off)
#     65 Portamento (on/off)
#     66 Sostenuto Pedal (on/off)
#     67 Soft Pedal (on/off)
#     68 Legato Pedal (on/off)
# x   69 Hold 2 Pedal (on/off)
# x   70 Sound Variation
# x   71 Resonance (Timbre)
# x   72 Sound Release Time
# x   73 Sound Attack Time
# x   74 Frequency Cutoff (Brightness)
# x   75 Sound Control 6
# x   76 Sound Control 7
# x   77 Sound Control 8
# x   78 Sound Control 9
# x   79 Sound Control 10
# x   80 Decay or General Purpose Button 1 (on/off) Roland Tone level 1
# x   81 Hi Pass Filter Frequency or General Purpose Button 2 (on/off) Roland Tone level 2
# x   82 General Purpose Button 3 (on/off) Roland Tone level 3
# x   83 General Purpose Button 4 (on/off) Roland Tone level 4
#     84 Portamento Amount
# x   85-90 = Undefined
#     91 Reverb Level
# x   92 Tremolo Level
#     93 Chorus Level
# x   94 Detune Level
# x   95 Phaser Level
# x   96 Data Button increment
# x   97 Data Button decrement
#     98 Non-registered Parameter (LSB)
#     99 Non-registered Parameter (MSB)
#     100 Registered Parameter (LSB)
#     101 Registered Parameter (MSB)
# x   102-119 = Undefined
#     120 All Sound Off
#     121 All Controllers Off
# x   122 Local Keyboard (on/off)
#     123 All Notes Off
#     124 Omni Mode Off
#     125 Omni Mode On
#     126 Mono Operation
#     127 Poly Mode
# ----------------------------------------------------------------------------
# End of file musicomp2abc
