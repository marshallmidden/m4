#!/usr/bin/python3 -B
# ----------------------------------------------------------------------------
# vim: tabstop=8 expandtab shiftwidth=4 softtabstop=4
# ----------------------------------------------------------------------------
import argparse
import os
import re
import readline
import sys
# ----------------------------------------------------------------------------
global errors_happened
errors_happened = 0

# ----------------------------------------------------------------------------
def print_eoln(strg):
    print(strg, file=sys.stderr, flush=True)
    return
# End of print_eoln

# ----------------------------------------------------------------------------
def print_debug(strg):
    print_eoln(strg)
    return
# End of print_debug

# ----------------------------------------------------------------------------
def print_error_no_line(strg):
    print("ERROR - " + strg, file=sys.stderr, flush=True)
    return
# End of print_error_no_line

# ----------------------------------------------------------------------------
def print_fs(strg):
    global array_of_fs

    if len(array_of_fs) > 0:
        last = array_of_fs[-1]
        if last[0:6] == 'sleep ' and strg[0:6] == 'sleep ':
            new_time1 = float(last[6:])
            new_time2 = float(strg[6:])
            array_of_fs[-1] = f'sleep {(new_time1 + new_time2):.3f}'
            return
        elif last == strg:                          # Delete duplicates.
            return
        # fi
    # fi
    array_of_fs.append(strg)
    return

# ----------------------------------------------------------------------------
def print_output(strg):
    print(strg.rstrip(), file=output_name, flush=True)
    return
# End of print_output

# ----------------------------------------------------------------------------
global args

# ----------------------------------------------------------------------------
def parse_args():
    global args

    parser = argparse.ArgumentParser(
        description=__doc__,
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog='this is the epilog')

    parser.add_argument('--lines', '-lines', action='store_true',
                        help='Print each line as it is read from file or macro or loop.')

    parser.add_argument('rest', nargs='*',
                        help='Optional command to execute')
    args = parser.parse_args()

    if args.rest is not None:
        for indx in range(len(args.rest)):
            if args.rest[indx][0] == '=':
                nextargv = args.rest[indx]
                if len(nextargv) > 0:
                    nextargv = nextargv[1:]
                # fi
                args.rest[indx] = nextargv
            # fi
        # rof
    # fi
    return
# End of parse_args

# ----------------------------------------------------------------------------
parse_args()

# ----------------------------------------------------------------------------
global which_file_in
which_file_in = 'stdin'
global linecount
linecount = 0
# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
global voices                       # Number of voices
voices = 1
# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
global file_name                    # None = use tty.
global output_name                  # File to print to (default is sys.stdout).
# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
global array_of_lines               # For input, have an array of lines.
array_of_lines = []
global array_of_fs                  # For fs first pass output.
array_of_fs = []

# ----------------------------------------------------------------------------
# Following does not do multiple sharps or flats, but that is crazy anyway. Neither naturals.
global key_sig
key_sig = { 'c+':7, 'f+':6, 'b':5, 'bn':5, 'e':4, 'en':4, 'a':3, 'an':3, 'd':2,
            'dn':2, 'g':1, 'gn':1, 'c':0, 'cn':0, 'f':-1, 'b-':-2, 'e-':-3,
            'a-':-4, 'd-':-5, 'g-':-6, 'c-':-7 }

global key_sig_int
key_sig_int = {}
for i in key_sig:
    if key_sig[i] not in key_sig_int:
        key_sig_int[key_sig[i]] = i
    # fi
# rof

# ----------------------------------------------------------------------------
global default_little_time
default_little_time = 0.1
# ----------------------------------------------------------------------------
def print_fluidsynth_header():
    # set audio.coreaudio.device coreaudio
    print_fs("set audio.driver coreaudio")
    print_fs("set midi.driver coremidi")
    print_fs("unload 1")
    print_fs("unload 2")
    print_fs("unload 3")
    print_fs("unload 4")
    print_fs("unload 5")
    print_fs("set synth.default-soundfont /Users/m4/src/GeneralUser/GeneralUser.sf2")
    print_fs("set synth.midi-channels 128")
    print_fs("set synth.verbose 0")
    print_fs("reset")
    print_fs("reset")
    print_fs("load /Users/m4/src/GeneralUser/GeneralUser.sf2")
    #
    print_fs('set synth.reverb.active 1')
    print_fs('set synth.reverb.room-size 0.61')
    print_fs('set synth.reverb.damp 0.23')
    print_fs('set synth.reverb.width 0.76')
    print_fs('set synth.reverb.level 0.57')
    #
    print_fs('set synth.chorus.active 1')
    print_fs('set synth.chorus.nr 3')
    print_fs('set synth.chorus.level 1.2')
    print_fs('set synth.chorus.speed 0.3')
    print_fs('set synth.chorus.depth 8')
    #
    print_fs("prog 00 000")
    #
    return
# End of print_fluidsynth_header

# ----------------------------------------------------------------------------
global fs_other_echo
fs_other_echo = ''
global this_time
this_time = []
global MIDICLICKSPERQUARTER
MIDICLICKSPERQUARTER = 480.0
# ----------------------------------------------------------------------------
def process_fs_check(what, lth, min_next, vtlines, tempo_s, tempo_l):
    global this_time
    global fs_other_echo
    global key_sig_int
    global voices
    global MIDICLICKSPERQUARTER

    for voice, lines in vtlines.items():
        v = int(voice)
        if this_time[v] >= len(lines):
            continue
        # fi
        t = lines[this_time[v]].split(' ', 1) # 2 elements
        t[0].strip()
        time = float(t[0])
        while time <= min_next:
            strg = t[1].rstrip()
            if strg == 'End_track':
                pass
            elif strg[0:lth] == what:
                if what != 'cc':
                    print_fs(strg)
                # fi
            elif strg[0:5] == 'echo ':           # echo "measure xxx"
                if strg[0:6] == 'echo "':
                    print_fs(f'{strg}')
                elif strg != fs_other_echo:
                    strg1 = strg.replace('"', "'")
                    if strg1[0:11] == 'echo meter ':
                        print_fs(f'echo "meter {strg1[11:]}"')
                    elif strg1[0:9] == 'echo key ':
                        x = strg1[9:]
                        y = x.split(' ', 1)          # Key number.
                        x = y[1]
                        y = int(y[0].replace(',', '').strip())
                        if y in key_sig_int:
                            y = key_sig_int[y].upper()
                        # fi
                        print_fs(f'echo "key {y} {x}"')
                    elif strg1[0:13] == 'echo Title_t ':
                        print_fs(f'echo "Title {strg1[13:]}"')
                    elif strg != fs_other_echo:
                        print_fs(f'echo "{strg1[5:]}"')
                    # fi
                    fs_other_echo = strg
                # fi
            elif strg[0:7] == 'select ':
                print_fs(f'{strg}')
            elif strg[0:4] == 'set ':
                print_fs(f'{strg}')
            elif strg[0:6] == 'reset ':
                print_fs(f'{strg}')
            elif strg[0:5] == 'load ':
                print_fs(f'{strg}')
            elif strg[0:7] == 'unload ':
                print_fs(f'{strg}')
            elif strg[0:5] == 'prog ':
                print_fs(f'{strg}')
            elif strg[0:11] == 'pitch_bend ':
                print_fs(f'{strg}')
            elif strg[0:6] == 'tempo ':
                x = strg[6:].split()
                if len(x) < 1 or len(x) > 2:
                    print_error_no_line("Tempo needs a speed - line='{}'".format(t))
                elif len(x) == 1:
                    #    1/(### / (60.0 * 1000000.0)) = 60.02400 = t              for l = 4 (quarter note).
                    tempo_s = int(1/(int(x[0]) / (60.0 * 1000000.0)))
                    tempo_l = 0.25
                else:
                    tempo_s, tempo_l = strg[6:].split()
                # fi
            elif strg[0:7] == 'Header ':
                # "0, 0, Header, 1, {}, {}".format(len(volume)+1, round(MIDICLICKSPERQUARTER)))
                h = strg[7:].split(', ')
                voices = int(h[1])
                MIDICLICKSPERQUARTER = int(h[2])
            elif strg[0:3] == 'cc ':
                break
            elif strg[0:8] == 'noteoff ':
                h = strg[8:].split(', ')
                break
            elif strg[0:7] == 'noteon ':
                h = strg[7:].split(', ')
                break
            else:
                print_error_no_line("Unrecognized - line='{}'".format(t))
#--                error_now = error_now + 1               # DIE NOW!
#--                break
            # fi
            this_time[v] += 1
            if this_time[v] >= len(lines):
                break
            # fi
            t = lines[this_time[v]].split(' ', 1) # 2 elements
            time = float(t[0])
        # elihw
    # rof
    return tempo_s, tempo_l
# End of process_fs_check

# ----------------------------------------------------------------------------
# Thinking if we get each of the tracks in csvmidi format, in array, then go
# through them and order by:
    # track, time: In array order for each track.
    #       controls
    #       noteoff
    #       noteon
    # ... is that all that is needed? (And obvious format change.)

def print_out_fluidsynth():
    global array_of_lines
    global this_time
    global default_little_time

    change_name = {
        'Text_t': 'echo',
        'Title_t': 'echo Title_t',
        'Time_signature': 'echo meter',
        'Key_signature': 'echo key',
        'Note_on_c': 'noteon',
        'Note_off_c': 'noteoff',
        'Tempo': 'tempo',
        'Control_c': 'cc',
        'Pitch_bend_c': 'pitch_bend',
        # Track, Time, MIDI_port, Number This meta-event specifies that subsequent events in
        # the Track should be sent to MIDI port (bus) Number, between 0 and 255. This meta-event
        # usually appears at the start of a track with Time zero, but may appear within a track
        # should the need arise to change the port while the track is being played.
    }
    ignore_these = {
        'Copyright_t',
        'Marker_t',
        'End_of_file',
    }
    okay_these = {
        'Header',
        'MIDI_port',
    }
    midi_port = 0

    v_t_lines = { }
    tempo_s = 60
    tempo_l = 0.5

    max_midi_time = 0

    voices = 0
    for i in array_of_lines:
        # "2, 5280, Note_on_c, 0, 43, 127"
        t = i.split(', ', 3)        # 4 elements.
        if len(t) < 3:
            print_die(f'line does not have MIDI format with voice, time, command - "{i}"')
        elif len(t) < 4:
            t.append('')
        # fi
        t[0] = t[0].strip()
        if t[0] not in v_t_lines:
            v_t_lines[t[0]] = []
        # fi
        if 2 > len(t) or t[2] == "Start_track":
            continue
        # fi
        t[1] = t[1].strip()
        t[2] = t[2].strip()
        if t[2] in change_name:
            t[2] = change_name[t[2]]
            t[3] = t[3].strip()
            if t[2] != 'echo':
                t[3] = t[3].replace(',', '').strip()
            # fi
            if t[2] == 'noteon':
                h = t[3].split(' ')
                if h[2] == '0':
                    t[2] = 'noteoff'
                # fi
            # fi
        elif t[2] in ignore_these:
            continue
        elif t[2] in okay_these:
            if t[2] == 'MIDI_port':
                midi_port = t[3]
                continue
            # fi
            pass
#--         elif t[2] == 'FS':
#--             t[3] = t[3].strip()
#--             t[2] = t[3]
#--             t[3] = ''
        elif t[2] == 'Program_c':
# select chan sfont bank prog
            t[2] = 'select'
            t[3] = t[3].strip()
            s = t[3].split(", ", 2)     # 3 elements - channel, bank, program.
            if len(s) < 3:
                s += midi_port
            # fi
            if s[0] != '9':
                t[3] = '{} 1 {} {}'.format(s[0], s[2], s[1])
            else:
#               select 9 2 128 0  Combination of bank-select and program-change
                t[3] = '{} 1 128 0'.format(s[0])
            # fi
            t[2] = 'select'
        elif t[2] == 'End_track':
            if max_midi_time < float(t[1]):
                max_midi_time = float(t[1])
            # fi
            t.append('')
        else:
            print_error_no_line("Unexpected midi command - t='{}'".format(t))
        # fi
        if voices < int(t[0]):
            voices = int(t[0])
        # fi
        if t[2] == '' and t[3] == '':
            xxx = t[1]
        elif t[3] == '':
            xxx = t[1] + ' ' + t[2]
        else:
            xxx = ' '.join(t[1:])
        # fi
#--         print_debug(f't[0]={t[0]} xxx={xxx}')
        v_t_lines[t[0]].append(xxx)
    # rof
    current_time = -1
    this_time = []
    for v in range(0, voices+1):
        this_time.append(0)
    # rof
    while current_time < max_midi_time:
        # Find smallest time difference.
        min_next = max_midi_time + 1
        for voice, lines in v_t_lines.items():
            v = int(voice)
            if this_time[v] >= len(lines):
                continue
            # fi
            t = lines[this_time[v]].split(' ', 1) # 2 elements
            time = float(t[0])
            if min_next > time:
                min_next = time
            # fi
        # rof
        if current_time >= 0 and (min_next - current_time) != 0:
            ms_1000 = float(min_next - current_time)
            if ms_1000 < default_little_time:
                ms_1000 = default_little_time
            else:
                # 480 => 250
                ms_1000 = ms_1000 * 1000.0
                ms_1000 = ms_1000 / ((float(tempo_s)/60.0) * (float(tempo_l) * 4.0))
                ms_1000 = int((ms_1000 / MIDICLICKSPERQUARTER) * 1000)
                ms_1000 = float(ms_1000) / 1000.0
            # fi
            print_fs("sleep {}".format(ms_1000))
        # fi
        current_time = min_next
        # Move all this_time voices forward past min_next.
    # . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
        tempo_s, tempo_l = process_fs_check('cc', 2, min_next, v_t_lines, tempo_s, tempo_l)
        tempo_s, tempo_l = process_fs_check('noteoff', 7, min_next, v_t_lines, tempo_s, tempo_l)
        tempo_s, tempo_l = process_fs_check('noteon', 6, min_next, v_t_lines, tempo_s, tempo_l)
    # elihw

    print_fs("quit")
    return
# End of print_out_fluidsynth

# ----------------------------------------------------------------------------
# Get the next line, file, or macro.
# Return:
#   line        - the line without trailing spaces.
#   None        - if End of File.

def read_next_line():
    global linecount
    global args
    global file_name
    global errors_happened

    while True:
        try:
            if args.rest and len(args.rest) >= 1:
                line = file_name.readline()
            else:
                if sys.stdin.isatty():
                    if sys.platform == 'darwin':
                        input('input> ')
                        line = readline.get_line_buffer()
                    else:
                        line = input('input> ')
                    # fi
                else:
                    line = sys.stdin.readline()
                # fi
            # fi
            if line is None or line == '':
                sys.exit(errors_happened)
            # fi
            linecount = linecount + 1
            if line:
                line = line.rstrip()                # trailing spaces gone.
                return line
            # fi
        except EOFError:
            pass            # print("Read gave EOF", file=sys.stderr, flush=True)
        except SystemExit:
            pass            # print("Read gave system exit", file=sys.stderr, flush=True)
        except KeyboardInterrupt:
            print_error_no_line("Read got keyboard interrupt")
        except:
            print_error_no_line("Read got a processing error")
            print_eoln("    " + sys.exc_info()[0] + sys.exc_info)
        # yrt
        break
    # elihw
    return None
# End of read_next_line

# ----------------------------------------------------------------------------
# Parse and process line.

def process_line(original_line):
    global array_of_lines

    qline = original_line
    array_of_lines.append(qline)

    return False
# End of process_line

# ----------------------------------------------------------------------------
def readthefile():
    global linecount
    global args

    ifdone = False
    while not ifdone:                       # Read the file loop.
        line = read_next_line()
        if args.lines:
            print_eoln("linecount={} line='{}'".format(linecount,line))
        # fi
        if line is None:  # If end of file.
            return
        elif not line or len(line) <= 0 or line == '':
            continue
        # fi
        line = line.rstrip()
        if not line or len(line) <= 0 or line == '':
            continue
        # fi
        line = line.strip()
        if len(line) == 0:                                  # Ignore empty line.
            continue
        # fi
        ifdone = process_line(line)
    # elihw
    return
# End of readthefile

# ----------------------------------------------------------------------------
# Main program follows.
def main():
    global args
    global file_name
    global output_name
    global voices
    global which_file_in

    output_name = sys.stdout
    if args.rest:
        if len(args.rest) >= 1:             # Input.
            file_name = open(args.rest[0], 'r')
            which_file_in = args.rest[0]
        # fi
        if len(args.rest) >= 2:             # Output.
            output_name = open(args.rest[1], 'w')
        # fi
        if len(args.rest) > 2:              # Too many.
            print_error_no_line("Too many arguments, input, output only.  {}".format(args.rest))
            sys.exit(1)
        # fi
    # fi

    readthefile()

    print_fluidsynth_header()
    print_out_fluidsynth()
    print_debug('\n'.join(array_of_fs))
    return
# End of main

# ----------------------------------------------------------------------------
if __name__ == '__main__':
    main()
# fi
# ----------------------------------------------------------------------------
sys.exit(errors_happened)
# ----------------------------------------------------------------------------
# End of program csv2fs
# ----------------------------------------------------------------------------
