#!/usr/bin/python3 -B
# ----------------------------------------------------------------------------
# vim: tabstop=8 expandtab shiftwidth=4 softtabstop=4
# ----------------------------------------------------------------------------
# TO DO:
# 1) vol(sf,0.25)    -- optional 2nd argument for length of sf.
#    vol(fp,0.25)    -- optional 2nd argument for length of "f" before returning to "p".
# 2) b-6 ... some 1/2 notes that are vol(sf) -- should they be shortened per above?
# 3) --fluidsynth input of a .csv file -- MIDI_port commands -- WTF?
# ----------------------------------------------------------------------------
#    A) Put in largo and ties and spaces for note tail groupings for:
#    +  One last check of printing - for correct notes.
#        B1 - 1 - Done largo, ties, spaces. Checking how it looks.
#        B1 - 2 - Not started.
#        B1 - 3 - Not started.
#        B1 - 4 - Not started.
#        B2 - 1	-- needs lots of work. - Not started for largo and ties.
#    *   B6     - Done. 2022-06-14_21-03-55
#      1812 -  getting notes put in before trying to fix things.
# ----------------------------------------------------------------------------
# TODO:
# 1) Select clef=treble or clef=bass by notes min and max notes on staff(s).
#       # NOTDONEYET - add ' clef=bass'  (after the number)
#       # clef can occur each measure (abc, horizontal, vertical format).
# 2) --vertical and --horizontal: voice xx yy,zz,ww,uu,... -- do not print, use instrument instead.
# 3) --vertical and --horizontal: Can save comments on measures? Lines? Like before measures? * ------
# ----------------------------------------------------------------------------
# Document: trills, legato on time means last note is legato.
# If no l on time, last note is unset if legato on note itself.
# i.e. t(3cl,3el,8)4   -> last 3e does not have legato set.
#      t(3cl,3el,8)4l  -> last 3e has legato set (which goes to next note).
# ----------------------------------------------------------------------------
# ./musicomp --midi1csv song.gcs song.csv   # Output midi1csv format.
# ./musicomp song.gcs song.abc              # Output ABC format.
# ./musicomp --vertical song.gcs song.v     # Either v or h (or mixed) input, vertical output.
# ./musicomp --horizontal song.gcs song.h   # Either v or h (or mixed) input, horizontal output.
# ./musicomp --fluidsynth song.gcs song.fs  # Input to fluidsynth.
# ./musicomp --fluidsynth song.csv song.fs  # Input can be CSV file, output can ONLY be fluidsynth.
# ----------------------------------------------------------------------------
# NOTDONEYET - Note processing:
#   print_error("NOTDONEYET - doing gsw_operand type of note", line)    - Not related to MIDI.
#   print_error("NOTDONEYET - do_temper", line)     -- no real need for this?
#   print_error("NOTDONEYET - do_sharp", line)      -- no real need for this?
#   print_error("NOTDONEYET - do_flat", line)       -- no real need for this?
#   print_error("NOTDONEYET - do_natural", line)    -- no real need for this?
# ----------------------------------------------------------------------------
# Note: Do not have blank lines in the file. Somehow python's readline() does
# not return them. Yeah, insanity.
# ----------------------------------------------------------------------------
# --fluidsynth.  2022-06-06
# MIDI channel is limited to 4 bits. 10 is reserved for drums.
# Thus, cannot have more than 0,1,2,3,4,5,6,7,8,9,11,12,13,14,15 (total 15).
# Cannot use the MIDI file format. MIDI 2.0 has no file format yet.
# ----------------------------------------------------------------------------
# A) To import an ABC into musescore, use the plugin "ABC Import".
#    Move "X:1" to the top of the file, before any other lines. The '%' confuses it.
# ----------------------------------------------------------------------------
# B) To export from musescore:
#     1) File->Export as MusicXML compressed (suffix .mxl).
#     2) Then use program 'xml2abc my.mxl > my.abc' to convert it to abc format.
# ----------------------------------------------------------------------------
# C) To grab from soundflower:
#     1) Make sure it is downloaded.
#     2) In "sound preferences->Output", select "Soundflower (2ch)".
#        Undo by selecting Headphones or Internal Speakers, etc.
#     3) Capture output via: QuickTime Player (or garageband -- dunno about last :) ).
#     4) New->Audio Audio Recording
#     5) Red record button when ready to record.
#     6) sleep 5; fluidsynth ...
#        Or: Open music playing program, and ready to "Start".
#     7) Click to get into quicktime, then press record.
#     8) click back to window for playing, start it.
#     9) When finished, click on quicktime and press record button again to stop it.
#        The "<<  >  >>" for playing it opens up.
#     10) If you save it, it saves it as a .aifc file. If you "Export as audio" it, it is an .m4a type file.
# Convert to .wav file.
#     1) Start audacity. File->Open ... select file of type: (aifc,m4a,wav, ...).
#     2) Select blank starting to delete. Press sissors to cut away. Same with trailing/end of song.
#     3) Export as ... many types may be chosen.
# Convert .wav (etc.) file to mp4.
#     1) Open imovie. Should/might be on "My Media" (left column, top).
#     2) In lower left column (bottom, or iMovie Library), right click and select 'New Event'.
#     3) Enter name. Click on the name (if not already there).
#     4) Click on down arrow with label "Import Media". Opens new window to find/select media.
#     5) Find the audio to be used.
#     6) Drag and drop the picture to be used during play.
#     7) There will be two icons for audio and picture in the Media section.
#     8) Click on audio icon and drag it to the lower 1/2 of screen where it says to put them there. :)
#     9) Align the audio to the left.
#     10) Click on the picture icon and drag to lower, align to left.
#     11) A "drag bar" on right, drag it to end of audio. (So image displays for all of audio.)
#     12) In the upper right there is an arrow above/through a box -- meaning share if you hover over it.
#     13) Click and select "Export File". The Format should be "Video and Audio".
#     14) Probably reduce Resolution to 540, quality "Best (ProRes)", and Compress "Better Quality".
#     15) Click "Next..." at bottom right. Select name and where to store it. Do so.
#     16) Done.  Double click on file in Finder and QuickTime player will pop up to play it.
#     17) Can upload to youtube / facebook / dropbox now.
# ----------------------------------------------------------------------------
# measures and gotos may be calculations using "m1" type variables, but not
# any other alphanumeric characters.
# ----------------------------------------------------------------------------
# Accidentals - A tied note doesn't cause the accidental to be carried over so
# much as it indicates the duration of the note rather than the pitch. If a tied
# note is followed by another note on the same staff position the accidental
# will not carry into that note (a courtesy accidental would often be helpful).
#
# In most cases, a sharp raises the pitch of a note one semitone while a flat lowers
# it one semitone. A natural is used to cancel the effect of a flat or sharp. This
# system of accidentals operates in conjunction with the key signature, whose effect
# continues throughout an entire piece, unless canceled by another key signature.
# An accidental can also be used to cancel a previous accidental or reinstate the flats
# or sharps of the key signature.
#
# Accidentals apply to subsequent notes on the same staff position for the remainder
# of the measure where they occur, unless explicitly changed by another accidental.
# Once a barline is passed, the effect of the accidental ends, except when a note
# affected by an accidental is tied to the same note across a barline. Subsequent notes
# at the same staff position in the second or later bars are not affected by the
# accidental carried through with the tied note.
# ............................................................................
# Courtesy accidentals - In modern scores, a barline cancels an accidental,
# with the exception of tied notes. Courtesy accidentals, also called cautionary
# accidentals or reminder accidentals are used to remind the musician of the
# correct pitch if the same note occurs in the following measure. The rules for
# applying courtesy accidentals (sometimes enclosed in parentheses) vary among
# publishers, though in a few situations they are customary:
#  - When the first note of a measure had an accidental in the previous measure.
#  - After a tie carries an accidental across a barline, and the same note
#    appears in the next measure.
#  - When a chord contains a diminished or augmented octave.
#  - When there is a cross relation with another part.
# ............................................................................
# While ties and phrasing slurs do look very similar, they are not the same thing at all.
# If the curved line is below the noteheads (written closest to the noteheads)
# and opposite the stems (if stems are ascending, the curved tie line is below;
# if stems are descending, the curved tie line is above).
#
# While the bar line cancels an accidental, the "Power of the Tie" is stronger.
#
#  - The composer would put a natural/flat/sharp on the second note of the tie.
#  - The composer would put the curved line above the stems, thus on OPPOSITE
#    side of the noteheads.
# (Remember - a curved line written closest to 2 noteheads in the same space or
# on the same line is a tie!)
# ----------------------------------------------------------------------------
# Additional note processing:
# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
# If the file format is in 'vertical' mode (i.e. 'v4: 3c8,3d8,3e8, 3f8,3g8'),
# Then for --abc format, the comma followed by a space means to separate the
# bars. (i.e. c,d,e have bar lines connected, and then there is a separation
# and lastly f and g have their bar lines connected.)
# This does not affect playing at all.
# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
# If a note's time (which may be optionally missing) is followed by a "l",
# then the note is legato (glided) to the next note. (i.e. there is no note
# attack section done when playing the note -- also considered slurred notes.)
# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
# vol(xxx) before a note sets volume for that note, and following notes ... .
# vol(sfp) before a note sets volume to f for that note only, and following p.
#   vol(p) 3c4, 3d4, vol(sfp) 3e4, 3f4, 3g4
#   (p,p,f,p,p)
# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
# cresc(xxx,yyy) xxx = ending volume. yyy = time (0.75 = three quarter notes).
# dimin(xxx,yyy) xxx = ending volume. yyy = time (0.75 = three quarter notes).
#   Like vol(), but does a volume change from present to xxx over time yyy.
# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
# Macro substitution during note processing.
# A line that looks like notes may use the macro whenever a complete note or
# vol(), cresc(),dimin() may appear. Example follows:
#   macro   abc,A,B,C
#      A4, B4
#      A8, C8
#   endm
#   measure 1
#   voice 2
#   0e4, 0g4
#   vol(ff) abc(1c,1e,1g) abc(2e,2c,2g) 3g4, vol(sf) 3a4
#
# The whole line is processed, left to right -- with the new lines from the
# macro inserted into place. NOTE: The "vol(ff)" refers to the next note in the
# line, but there is none, so it is tossed away. *NOTE*
#
# The first abc macro is done, then the second, then the two trailing notes.
# Correctly formatted line would have put the vol(ff) before the 3g4 (which
# would affect that note and subsequent for voice 1, but not the 2nd voice 3a4.
# vol(sf) affects the 3a4 and puts volume back to what it was before the "sf".
#
# This shows that no deliminators are used in substitution of arguments (all
# macros), and that intermixing of vertical 'v#:' format and horizontal format
# is allowed. Convert all to one type or the other via command line arguments:
# --horizontal or --vertical. (And it deletes macros too..., which may be useful
# when trying to figure out what a macro really did.)
#
#
# The above would then look like either:
#   measure 1
#   voice   2    0,0
#   v1: 0e4, 1c4, 1c8, 2e4, 2e8, 3g4
#   v2: 0g4, 1e4, 1g8, 2c4, 2g8, vol(sf) 3a4
# or:
#   voice   2    0,0
#      0e  4,  0g  4
#      1c  4,  1e  4
#      1c  8,  1g  8
#      2e  4,  2c  4
#      2e  8,  2g  8
#      3g  4,vol(sf) 3a  4
#
# If the second abc macro had been after 3g4, then there would be no second
# note for either 3g4 line (but comma would put in a r4 -- but the 3a4 would
# have been for voice 1 and without a second note for second voice, error!
#
#   vol(ff) abc(1c,1e,1g) 3g4, abc(2e,2c,2g) vol(sf) 3a4
#
# ./musicomp2abc --vert tv
#   ERROR - Not enough arguments on note line - want 2, have ['vol(sf)3a4']
#   Line 8 - vol(sf)3a4
#
# This shows that if not a command, spaces are eliminated for note processing.
# By the way, the arguments on the voice line for for instruments, 0=default.
# ----------------------------------------------------------------------------
# putd substitution lines are done in the order that they are defined. Once
# through the list, but only if '=' at start of line.
# ----------------------------------------------------------------------------
# xpose command is done for --vertical, --horizontal, and --midi1csv, but NOT abc format.
# ABC format thus will "print" right, but not "play" (abc2midi) right.
#       NOTDONEYET - so ABC format can print. NOTDONEYET - abc #
# ----------------------------------------------------------------------------
# instrument 1,2 flute            $$ voice, name or number.
#                                     v-- MIDI control number.
# intensity  1,2 84               $$  7 volume
# pan        1,2 8                $$ 10 pan
# reverb     1,2 52               $$ 91 Reverb level
# ----------------------------------------------------------------------------
#  10   Pan position   64 is center, 0 is hard left, and 127 is hard right.
#  Number: 10 (coarse) 42 (fine)
# Where within the stereo field the device's sound will be placed (assuming that it
# has stereo audio outputs). If a MultiTimbral device, then each Part usually has
# its own pan position. This is generally when Pan becomes useful, because then you
# can use Pan, Volume, and Balance controllers to internally mix all of the Parts to
# the device's stereo outputs. Pan should effect all notes on the channel, including
# notes that were triggered prior to pan message being received, and are still sustaining.
# 14-bit coarse/fine resolution. 16,384 possible positions, 0x0000 to 0x3FFF where 0x2000
# is center position, 0x0000 is hard left, and 0x3FFF is hard right. Some devices only
# respond to coarse adjust (128 positions) where 64 is center, 0 is hard left, and 127 is hard right.
# Note: Most all devices ignore the Fine adjust (#42) for Pan, and just implement Coarse
# adjust (#10) because 14-bit resolution isn't needed for this.
# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
# Expression, number 11 (course)
# Percentage of all playing instruments volume. 100% = all up.
# This is a percentage of Volume (ie, as set by Volume Controller). In other words,
# Expression divides the current volume into 16,384 steps (or 128 if 8-bit instead
# of 14-bit resolution is used). Volume Controller is used to set the overall volume
# of the entire musical part (on a given channel), whereas Expression is used for
# doing crescendos and decrescendos. By having both a master Volume and sub-Volume
# (ie, Expression), it makes possible to do crescendos and decrescendos without
# having to do algebraic calculations to maintain the relative balance between
# instruments. When Expression is at 100% (ie, the maximum of 0x3FFF), then the
# volume represents the true setting of Volume Controller. Lower values of
# Expression begin to subtract from the volume. When Expression is 0% (ie, 0x0000),
# then volume is off. When Expression is 50% (ie, 0x1FFF), then volume is cut in half.
#
# Here's how Expression is typically used. Let's assume only the coarse adjust is
# used (ie, #11) and therefore only 128 steps are possible. Set the Expression for
# every MIDI channel to one initial value, for example 100. This gives you some
# leeway to increase the expression percentage (ie, up to 127 which is 100%) or
# decrease it. Now, set the channel (ie, instrument) "mix" using Volume Controllers.
# Maybe you'll want the drums louder than the piano, so the former has a Volume
# Controller value of 110 whereas the latter has a value of 90, for example. Now if,
# at some point, you want to drop the volumes of both instruments to half of their
# current Main Volumes, then send Expression values of 64 (ie, 64 represents a 50%
# volume percentage since 64 is half of 128 steps). This would result in the drums
# now having an effective volume of 55 and piano having an effective volume of 45.
# If you wanted to drop the volumes to 25% of their current Main Volumes, then send
# Expression values of 32. This would result in the drums now having an effective
# volume of approximately 27 and piano having an effective volume of approximately
# 22. And yet, you haven't had to change their Volume settings, and therefore still
# maintain that relative mix between two instruments. So think of Volume Controllers
# as being the individual faders upon a mixing console. You set up the instrumental
# balance (ie, mix) using these values. Then you use Expression Controllers as
# "group faders", whereby you can increase or decrease the volumes of one or more
# tracks without upsetting the relative balance between them.
# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
# Can use legato for slur between notes -- i.e. no attack.
# Legato Pedal, Number: 68
# When on, this causes a legato effect between notes, which is usually achieved by
# skipping the attack portion of the VCA's envelope. Use of this controller allows
# a keyboard player to better simulate the phrasing of wind and brass players, who
# often play several notes with a single tonguing, or simulate guitar pull-offs and
# hammer-ons (ie, where secondary notes are not picked). If a MultiTimbral device,
# then each Part usually has its own Legato Pedal setting.
# Value Range: 0 (to 63) is off. 127 (to 64) is on.
# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
#  91   Reverb Level - Affects: this is usually the reverb or delay level.
#       If a MultiTimbral device, then each Part usually has its own effects level.
# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
# Tremulo Level, Number: 92
# The tremulo amount (ie, level) for the device. If a MultiTimbral device, then each
# part usually has its own tremulo level.
# Value Range: 0 to 127, with 0 being no tremulo applied at all.
# ----------------------------------------------------------------------------
# Note: New addition: second arguments on "voice" command is MIDI instruments.
# Suggest using instrument command instead.
#   %%MIDI program 6 % Harpsichord
#   %%MIDI program 57 % Trombone
#   %%MIDI program 56 % Trumpet
#   %%MIDI program 40 % Violin
#       voice   4       57,56,40,6
# ----------------------------------------------------------------------------
# clef  bass,treble,treble,treble
# clef  G clef = treble clef. 2nd line to the bottom is G pitch above middle C. 3C=1 line below printed.
# clef  C clef = Alto and Tenor clefs. The B points to the middle 3C line.  (viola)
# clef  F clef = Bass clef. The line between the two dots (?:) is F below middle 3C. 3c=1 line above printed.
# clef  Octave clef. Has a number under the G clef. 8=1 octave, 15=2 octaves higher.
# ----------------------------------------------------------------------------
# flats -> key:     B,E,A,D,G,C,F -- always this order. 2nd to last is Key-flat.
# sharps -> key:    F,C,G,D,A,E,B -- always this order. 2nd to last key Key-sharp.
#             vv - is key to use.
# 7 sharps is C# major or A# minor. f+,c+,g+,d+,a+,e+,b+
# 6 sharps is F# major or D# minor. f+,c+,g+,d+,a+,e+
# 5 sharps is B major or G# minor.  f+,c+,g+,d+,a+
# 4 sharps is E major or C# minor.  f+,c+,g+,d+
# 3 sharps is A major or F# minor.  f+,c+,g+
# 2 sharps is D major or B minor.   f+,c+
# 1 sharp  is G major or E minor.   f+
# None     is C major or A minor.
# 1 flat   is F major or D minor.   b-
# 2 flats  is B- major or G minor.  b-,e-
# 3 flats  is E- major or C minor.  b-,e-,a-
# 4 flats  is A- major or F minor.  b-,e-,a-,d-
# 5 flats  is D- major or B- minor. b-,e-,a-,d-,g-
# 6 flats  is G- major or E- minor. b-,e-,a-,d-,g-,c-
# 7 flats  is C- major or A- minor. b-,e-,a-,d-,g-,c-,f-
# ----------------------------------------------------------------------------
# For volume levels= { 0: 'ppp', 1: 'pp', 2: 'p', 3: 'mp', 4: 'mf', 5: 'f', 6: 'ff', 7: 'fff' }
# can use the numbers or names as above. NOTE: lower than 4 is difficult to hear.
# ----------------------------------------------------------------------------
# ABC header:
#     X: 1
#     ...
#     T: title
#     ...
#     K: C
# Empty lines separate tunes, headers (X: ... K:), and free text
# Line-breaks (new-lines, line feeds, carriage returns, end-of-lines) aids readability and breaks long lines.
#   Music code: end of lines means end of typeset sheet music score (lines). Use backslash to for continuation.
#       It continues through information fields, comments, and stylesheet directives.
# Information fields continue with +: at start of next line.
# ..............................................................................
#         V:1
#         a b cd
#     is the same as:
#         [V:1] a b cd
#     Can use [M:9/8]
# K: Key                K:G, K:Dm, K:AMix
# L: Unit Note Length   L:1/4, L:1/8
# M: Meter              M:3/4, M:4/4        Note present means free - no checking.
# Q: Tempo              Q:1/4=120
# T: Title              T:Name Of Song, whatever
# V: Voice              V:4 clef=bass               <----
# W: words              W: lyrics printed after the end of the tune
# w: words              w: lyrics printed aligned with the notes of tune
# ..............................................................................
# clef's can be on V: and K: lines
#       treble  Treble          <- normal treble clef.
#       bass    Bass            <- normal bass clef.
#       bass3   Baritone
#       tenor   Tenor           <- middle c on line above alto staff.
#       alto    Alto            <- middle c on middle staff line. (normal)
#       alto2   Mezzosoprano
#       alto1   Soprano
#       perc
#       none
# ----------------------------------------------------------------------------
# Pass 1
# Need the order of the measures.
# In a measure, want everything for that measure -- so that goto it works.
# Start with measure -1, and the default setup?
# Key, volume, note length, tempo
# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
#   Rests are lowercase z. Length follows.
#   Uppercase denote bottom octave (C = middle C on treble stave).
#   Comma after the letter means down an octave.
#   Apostrophe after the letter means up an octave. Multiple ' go up, as ,'s go down.
#   Lowercase letters are next octave above uppercase. four c's: "C, C c c' "
#   ^C = C sharp. _B = B flat. ^^ = double sharp. The equals (=) naturalizes it.
# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
#   Number after note changes duration. Number times default. B2=B twice as long therefore 1/4 because 1/2.
#   / means shorten, default is 2 or "/2".
#   > after a note, multiplying by 3/2 and removing from 2nd note. I.e. c8>c8 -> c8.c16 (dot means 1/16 extra)
#   < after a note, multiplying by 1/2 and adding rest on 2nd note. I.e. c8<c8 -> c16c8. means 1/16th extra
# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
#   print("   C,,     C,   c     c'   c''   z")
#             ++      +    -    --    n     r
#   print("   ^^C,,   ^C,  _c   __c'  =c''  z")
# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
# Have to think about the time ... if using simple ... then make "L: 1/64", and do multiples via:
#   2 = 32, 3 = 32d, 4 = 16, 6 = 16d, 8 = 8, 12 = 8d, 16 = 4, 24 = 4d, 32 = 2, 48 = 2d, 64 = 1, 96 = 1d, 128=2
# Trills, grace notes, staccato, and triplets, and ... *hmmm*
# staccato = .              (3.a.b.c = triplet staccato         (before note
# T = trill
# H = fermata
# . = staccato mark
# The order of abc constructs for a note is:
# <grace notes>, <chord symbols>, <annotations>/<decorations> (e.g. Irish roll, staccato marker or up/downbow),
#    ... <accidentals>, <note>, <octave>, <note length>, i.e. ~^c'3 or even "Gm7"v.=G,2.
#                                                           irish roll, c (down one, up one),
# syntax (p:q:r which means 'put p notes into the time of q for the next r notes'. If q is not given,
# it defaults as above. If r is not given, it defaults to p.
# For example, (3 is equivalent to (3:: or (3:2 , which in turn are equivalent to (3:2:3, whereas (3::2 is
# equivalent to (3:2:2.
# This can be useful to include notes of different lengths within a tuplet, for example (3:2:2 G4c2 or
# (3:2:4 G2A2Bc. It also describes more precisely how the simple syntax works in cases like (3 D2E2F2 or even
# (3 D3EF2. The number written over the tuplet is p.
# Spaces that appear between the tuplet specifier and the following notes are to be ignored.

# tie is minus (-) between two notes.   i.e. C-C3/2
# NOTE: 3 times normal note length divided by 2.  Or C-.C2
# Each tie symbol, -, should come immediately after a note group but may be followed by a space,
# i.e. =G,2- . Open and close chord delimiters, [ and ], should enclose entire note sequences (except for
# chord symbols), e.g.

# NOTE: spaces between notes means to not connect the notes when printed.
# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
# ----------------------------------------------------------------------------
import argparse
import os
import re
import readline
import shlex
import sys
import random
#-- import pprint
#-- # Usage:   pprint.pprint(v_t_lines, width=110, sort_dicts=False)

from fractions import Fraction

# ----------------------------------------------------------------------------
import math
# Log base 2
def Log2(x):
    x = float(x)
    if x == 0:
        return 0
    # fi
    return (math.log10(x) / math.log10(2))
#   End of Log2

# ----------------------------------------------------------------------------
import calculate
# ----------------------------------------------------------------------------
#++ import inspect
#++ print(inspect.currentframe().f_code.co_name, '#0', file=sys.stderr, flush=True)
# ----------------------------------------------------------------------------
MAXMIDICHANNELS = 32
# MAXABCVOICES = 32
MAXABCVOICES = 128
MAXVOICES = 128
NUMBER_BARS_PER_STAFF = 4
# NUMBER_BARS_PER_STAFF = 1
MIDICLICKSPERQUARTER = 480.0

# Let the notes 'release' after piece finishes.
#?? clicks_at_end_of_piece = 2 * MIDICLICKSPERQUARTER   # Half note.
clicks_at_end_of_piece = MIDICLICKSPERQUARTER   # Quarter note.

# Default MIDI control values.
default_reverb = 0
default_pan = 64
default_intensity = 127
default_volume = 120        # leave 7. :)

# For setperm and randp commands.
global array_of_random_numbers
array_of_random_numbers = [ ]

# When getting note, various things found:
sequence_note = 2
trill_note = 1
normal_note = 0
freqency_note = -1
gsw_operand = -2

# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
global allkeys
allkeys = [ 'c', 'd', 'e', 'f', 'g', 'a', 'b',
            'cn', 'dn', 'en', 'fn', 'gn', 'an', 'bn',
            'c-', 'd-', 'e-', 'f-', 'g-', 'a-', 'b-',
            'c--', 'd--', 'e--', 'f--', 'g--', 'a--', 'b--',
            'c+', 'd+', 'e+', 'f+', 'g+', 'a+', 'b+',
            'c++', 'd++', 'e++', 'f++', 'g++', 'a++', 'b++' ]
global accidentals
accidentals = { '':'', 'n':'=', '-':'_', '+':'^', '--':'__', '++':'^^' }

global legal_notes
legal_notes =   {
       '1/64': 0.015625,
      '3/128': 0.0234375,
       '1/32': 0.03125,
       '3/64': 0.046875,
      '7/128': 0.0546875,
       '1/16': 0.0625,
       '3/32': 0.09375,
       '7/64': 0.109375,
     '15/128': 0.1171875,
        '1/8': 0.125,
       '3/16': 0.1875,
       '7/32': 0.21875,
      '15/64': 0.234375,
     '31/128': 0.2421875,
        '1/4': 0.25,
        '3/8': 0.375,
       '7/16': 0.4375,
      '15/32': 0.46875,
      '31/64': 0.484375,
     '63/128': 0.4921875,
        '1/2': 0.5,
        '3/4': 0.75,
        '7/8': 0.875,
      '15/16': 0.9375,
      '31/32': 0.96875,
      '63/64': 0.984375,
    '127/128': 0.9921875,
          '1': 1.0,
        '3/2': 1.5,
        '7/4': 1.75,
       '15/8': 1.875,
      '31/16': 1.9375,
      '63/32': 1.96875,
     '127/64': 1.984375,
    '255/128': 1.9921875,
          '2': 2.0,
          '3': 3.0,
        '7/2': 3.5,
       '15/4': 3.75,
       '31/8': 3.875,
      '63/16': 3.9375,
     '127/32': 3.96875,
     '255/64': 3.984375,
    '511/128': 3.9921875,
       }

legal_mc_notes = {
        0.015625 : '64',
       0.0234375 : '64d',
         0.03125 : '32',
        0.046875 : '32d',
          0.0625 : '16',
         0.09375 : '16d',
           0.125 : '8',
          0.1875 : '8d',
            0.25 : '4',
           0.375 : '4d',
             0.5 : '2',
            0.75 : '2d',
             1.0 : '1',
             1.5 : '1d',
}

global legal_floating
legal_floating = dict((y, x) for x, y in legal_notes.items())
global legal_floating_times
legal_floating_times = sorted(legal_notes.values())

global DECORATIONS
DECORATIONS = '+'
# - DECORATIONS = '!'

global vlprint
vlprint = { 10: 'pppp',
            23: 'ppp',
            36: 'pp',
            49: 'p',
            62: 'mp',
            75: 'mf',
            88: 'f',
            101: 'ff',
            114: 'fff',
            127: 'ffff',
          }
global v_name_print
v_name_print = {}
for i in vlprint:
    v_name_print[ vlprint[ i ] ] = i
# rof
global pppp, ppp, pp, p, mp, mf, f, ff, fff, ffff
pppp = v_name_print[ 'pppp' ]
ppp = v_name_print[ 'ppp' ]
pp = v_name_print[ 'pp' ]
p = v_name_print[ 'p' ]
mp = v_name_print[ 'mp' ]
mf = v_name_print[ 'mf' ]
f = v_name_print[ 'f' ]
ff = v_name_print[ 'ff' ]
fff = v_name_print[ 'fff' ]
ffff = v_name_print[ 'ffff' ]

global S_vlprint                    # First is this note volume, 2nd is following note volumes.
S_vlprint = {
              'fffp':[ fff, p ],        # fff for one note, then p.
              'ffp':[ ff, p ],          # ff for one note, then p.
              'fp':[ f, p ],            # f for one note, then p.
              'fffpp':[ fff, pp ],      # fff for one note, then p.
              'ffpp':[ ff, pp ],        # ff for one note, then p.
              'fpp':[ f, pp ],          # f for one note, then p.
              'fffppp':[ fff, ppp ],    # fff for one note, then p.
              'ffppp':[ ff, ppp ],      # ff for one note, then p.
              'fppp':[ f, ppp ],        # f for one note, then p.

              'sfffp':[ -1, p ],        # much much louder for this note, then p.
              'sfffpp':[ -1, pp ],      # much much louder for this note, then p.
              'sfffppp':[ -1, ppp ],    # much much louder for this note, then p.
              'sffp':[ -2, p ],         # much louder for one note, then p.
              'sffpp':[ -2, pp ],       # much louder for one note, then p.
              'sffppp':[ -2, ppp ],     # much louder for one note, then p.
              'sfp':[ -3, p ],          # louder for one note, then p.
              'sfpp':[ -3, pp ],        # louder for one note, then p.
              'sfppp':[ -3, ppp ],      # much louder for one note, then p.

              'sfff':[ -1, -1 ],        # much much louder for this note, back to where it was.
              'sff':[ -2, -1 ],         # louder for then note, then back to where it was.
              'fz':[ -3, -1 ],          # f, then back to what it was (like sf, crazy).
              'sf':[ -3, -1 ],          # louder for then note, then back to where it was.
              'sfz':[ -3, -1 ],         # like sf.

              'smf':[ -4, -1 ],         # somewhat louder louder for one note, then back to where it was.
              'smfz':[ -4, -1 ],        # somewhat louder louder for one note, then back to where it was.

              'smp':[ -5, -1 ],         # somewhat louder for one note, then back to where it was.
              'smpz':[ -5, -1 ],        # somewhat louder for one note, then back to where it was.

              'sp':[ -6, -1 ],          # p then back to what it was.
              'spz':[ -6, -1 ],         # p then back to what it was.
              'spp':[ -7, -1 ],         # pp then back to what it was.
              'sppz':[ -7, -1 ],        # pp then back to what it was.
              'sppp':[ -8, -1 ],        # ppp then back to what it was.
              'spppz':[ -8, -1 ],       # ppp then back to what it was.

              'spf':[ -6, f ],          # p then to f.
              'sppf':[ -7, f ],         # pp then to f.
              'spppf':[ -8, f ],        # ppp then to f.
              'spff':[ -6, ff ],        # p then to ff.
              'sppff':[ -7, ff ],       # pp then to ff.
              'spppff':[ -8, ff ],      # ppp then to ff.
              'spfff':[ -6, fff ],      # p then to fff.
              'sppfff':[ -7, fff ],     # pp then to fff.
              'spppfff':[ -8, fff ],    # ppp then to fff.
            }

# ----------------------------------------------------------------------------
def vol_to_vlprint_round(j):
    global vlprint
    for i in vlprint:
        if i >= j:
            return i
            break
        # fi
    # rof
    return 127
# End of vol_to_vlprint_round

# ------------------------------------------------------------------------------
global instruments
# select chan sfont bank prog -      prog, bank.
instruments = {
    'Acoustic Grand Piano'.lower() : [0, 0],
    'Stereo Grand'.lower() : [0, 0],
    'Bright Acoustic Piano'.lower() : [1, 0],
    'Bright Grand'.lower() : [1, 0],
    'Electric Grand Piano'.lower() : [2, 0],
    'Electric Grand'.lower() : [2, 0],
    'Honky-tonk Piano'.lower() : [3, 0],
    'Honky-tonk'.lower() : [3, 0],
    'Electric Piano 1'.lower() : [4, 0],
    'Time Electric Piano 1'.lower() : [4, 0],
    'Electric Piano 2'.lower() : [5, 0],
    'FM Electric Piano'.lower() : [5, 0],
    'Harpsichord'.lower() : [6, 0],
    'Clavi'.lower() : [7, 0],
    'Clavinet'.lower() : [7, 0],
    'Celesta'.lower() : [8, 0],
    'Celeste'.lower() : [8, 0],
    'Glockenspiel'.lower() : [9, 0],
    'Music Box'.lower() : [10, 0],
    'Vibraphone'.lower() : [11, 0],
    'Marimba'.lower() : [12, 0],
    'Xylophone'.lower() : [13, 0],
    'Tubular Bells'.lower() : [14, 0],
    'Dulcimer'.lower() : [15, 0],
    'Drawbar Organ'.lower() : [16, 0],
    'Tonewheel Organ'.lower() : [16, 0],
    'Percussive Organ'.lower() : [17, 0],
    'Rock Organ'.lower() : [18, 0],
    'Church Organ'.lower() : [19, 0],
    'Pipe Organ'.lower() : [19, 0],
    'Reed Organ'.lower() : [20, 0],
    'Accordion'.lower() : [21, 0],
    'Harmonica'.lower() : [22, 0],
    'Tango Accordion'.lower() : [23, 0],
    'Bandoneon'.lower() : [23, 0],
    'Acoustic Guitar (nylon)'.lower() : [24, 0],
    'Nylon Guitar'.lower() : [24, 0],
    'Acoustic Guitar (steel)'.lower() : [25, 0],
    'Steel Guitar'.lower() : [25, 0],
    'Electric Guitar (jazz)'.lower() : [26, 0],
    'Jazz Guitar'.lower() : [26, 0],
    'Electric Guitar (clean)'.lower() : [27, 0],
    'Clean Guitar'.lower() : [27, 0],
    'Electric Guitar (muted)'.lower() : [28, 0],
    'Muted Guitar'.lower() : [28, 0],
    'Overdriven Guitar'.lower() : [29, 0],
    'Overdrive Guitar'.lower() : [29, 0],
    'Distortion Guitar'.lower() : [30, 0],
    'Guitar Harmonics'.lower() : [31, 0],
    'Acoustic Bass'.lower() : [32, 0],
    'Electric Bass (finger)'.lower() : [33, 0],
    'Finger Bass'.lower() : [33, 0],
    'Electric Bass (pick)'.lower() : [34, 0],
    'Pick Bass'.lower() : [34, 0],
    'Fretless Bass'.lower() : [35, 0],
    'Slap Bass 1'.lower() : [36, 0],
    'Slap Bass 2'.lower() : [37, 0],
    'Synth Bass 1'.lower() : [38, 0],
    'Synth Bass 2'.lower() : [39, 0],
    'Violin'.lower() : [40, 0],
    'Viola'.lower() : [41, 0],
    'Cello'.lower() : [42, 0],
    'Contrabass'.lower() : [43, 0],
    'Double Bass'.lower() : [43, 0],
    'Tremolo Strings'.lower() : [44, 0],
    'Stero Strings Trem'.lower() : [44, 0],
    'Pizzicato Strings'.lower() : [45, 0],
    'Orchestral Harp'.lower() : [46, 0],
    'Timpani'.lower() : [47, 0],
    'String Ensemble 1'.lower() : [48, 0],
    'Stereo Strings Fast'.lower() : [48, 0],
    'String Ensemble 2'.lower() : [49, 0],
    'Stereo Strings Slow'.lower() : [49, 0],
    'Synth Strings 1'.lower() : [50, 0],
    'Synth Strings 2'.lower() : [51, 0],
    'Choir Aahs'.lower() : [52, 0],
    'Concert Choir'.lower() : [52, 0],
    'Voice Oohs'.lower() : [53, 0],              # NOT RIGHT!
    'Synth Voice'.lower() : [54, 0],             # NOT RIGHT!
    'Orchestra Hit'.lower() : [55, 0],           # ?? strange sound. ??
    'Trumpet'.lower() : [56, 0],
    'Trombone'.lower() : [57, 0],
    'Tuba'.lower() : [58, 0],
    'Muted Trumpet'.lower() : [59, 0],
    'French Horn'.lower() : [60, 0],
    'French Horns'.lower() : [60, 0],
    'Brass Section'.lower() : [61, 0],
    'Synth Brass 1'.lower() : [62, 0],
    'Synth Brass 2'.lower() : [63, 0],
    'Soprano Sax'.lower() : [64, 0],
    'Alto Sax'.lower() : [65, 0],
    'Tenor Sax'.lower() : [66, 0],
    'Baritone Sax'.lower() : [67, 0],
    'Oboe'.lower() : [68, 0],
    'English Horn'.lower() : [69, 0],
    'Bassoon'.lower() : [70, 0],
    'Clarinet'.lower() : [71, 0],
    'Piccolo'.lower() : [72, 0],
    'Flute'.lower() : [73, 0],
    'Recorder'.lower() : [74, 0],
    'Pan Flute'.lower() : [75, 0],
    'Blown bottle'.lower() : [76, 0],
    'Bottle Blow'.lower() : [76, 0],
    'Shakuhachi'.lower() : [77, 0],
    'Whistle'.lower() : [78, 0],
    'Irish Tin Whistle'.lower() : [78, 0],
    'Ocarina'.lower() : [79, 0],
    'Lead 1 (square)'.lower() : [80, 0],
    'Square Lead'.lower() : [80, 0],
    'Lead 2 (sawtooth)'.lower() : [81, 0],
    'Saw Lead'.lower() : [81, 0],
    'Lead 3 (calliope)'.lower() : [82, 0],
    'Synth Calliope'.lower() : [82, 0],
    'Lead 4 (chiff)'.lower() : [83, 0],
    'Chiffer Lead'.lower() : [83, 0],
    'Lead 5 (charang)'.lower() : [84, 0],
    'Charang'.lower() : [84, 0],
    'Lead 6 (voice)'.lower() : [85, 0],
    'Solo Vox'.lower() : [85, 0],
    'Lead 7 (fifths)'.lower() : [86, 0],
    '5th Saw Wave'.lower() : [86, 0],
    'Lead 8 (bass + lead)'.lower() : [87, 0],
    'Bass & lead'.lower() : [87, 0],
    'Pad 1 (new age)'.lower() : [88, 0],
    'Fantasia'.lower() : [88, 0],
    'Pad 2 (warm)'.lower() : [89, 0],
    'Warm Pad'.lower() : [89, 0],
    'Pad 3 (polysynth)'.lower() : [90, 0],
    'Polysynth'.lower() : [90, 0],
    'Pad 4 (choir)'.lower() : [91, 0],
    'Space Voice'.lower() : [91, 0],
    'Pad 5 (bowed)'.lower() : [92, 0],
    'Bowed Glass'.lower() : [92, 0],
    'Pad 6 (metallic)'.lower() : [93, 0],
    'Metal Pad'.lower() : [93, 0],
    'Pad 7 (halo)'.lower() : [94, 0],
    'Halo Pad'.lower() : [94, 0],
    'Pad 8 (sweep)'.lower() : [95, 0],
    'Sweep Pad'.lower() : [95, 0],
    'FX 1 (rain)'.lower() : [96, 0],
    'Ice Rain'.lower() : [96, 0],
    'FX 2 (soundtrack)'.lower() : [97, 0],
    'Soundtrack'.lower() : [97, 0],
    'FX 3 (crystal)'.lower() : [98, 0],
    'Crystal'.lower() : [98, 0],
    'FX 4 (atmosphere)'.lower() : [99, 0],
    'Atmosphere'.lower() : [99, 0],
    'FX 5 (brightness)'.lower() : [100, 0],
    'Brightness'.lower() : [100, 0],
    'FX 6 (goblins)'.lower() : [101, 0],
    'Goblins'.lower() : [101, 0],
    'FX 7 (echoes)'.lower() : [102, 0],
    'Echo Drops'.lower() : [102, 0],
    'FX 8 (sci-fi)'.lower() : [103, 0],
    'Star Theme'.lower() : [103, 0],
    'Sitar'.lower() : [104, 0],
    'Banjo'.lower() : [105, 0],
    'Shamisen'.lower() : [106, 0],
    'Koto'.lower() : [107, 0],
    'Kalimba'.lower() : [108, 0],
    'Bag pipe'.lower() : [109, 0],
    'Bagpipes'.lower() : [109, 0],
    'Fiddle'.lower() : [110, 0],
    'Shanai'.lower() : [111, 0],
    'Shenai'.lower() : [111, 0],
    'Tinkle Bell'.lower() : [112, 0],
    'Tinker Bell'.lower() : [112, 0],
    'Agogo'.lower() : [113, 0],
    'Steel Drums'.lower() : [114, 0],
    'Woodblock'.lower() : [115, 0],
    'Wood Block'.lower() : [115, 0],
    'Taiko Drum'.lower() : [116, 0],
    'Melodic Tom'.lower() : [117, 0],
    'Synth Drum'.lower() : [118, 0],
    'Reverse Cymbal'.lower() : [119, 0],
    'Guitar Fret Noise'.lower() : [120, 0],
    'Fret Noise'.lower() : [120, 0],
    'Breath Noise'.lower() : [121, 0],
    'Seashore'.lower() : [122, 0],
    'Bird Tweet'.lower() : [123, 0],
    'Birds'.lower() : [123, 0],
    'Telephone Ring'.lower() : [124, 0],
    'Telephone 1'.lower() : [124, 0],
    'Helicopter'.lower() : [125, 0],
    'Applause'.lower() : [126, 0],
    'Gunshot'.lower() : [127, 0],
    'Gun Shot'.lower() : [127, 0],
    'Synth Bass 101'.lower() : [38, 1],
    'Mono Strings Trem'.lower() : [44, 1],
    'Mono Strings Fast'.lower() : [48, 1],
    'Mono Strings Slow'.lower() : [49, 1],
    'Concert Choir Mono'.lower() : [52, 1],
    'Trumpet 2'.lower() : [56, 1],
    'Trombone 2'.lower() : [57, 1],
    'Muted Trumpet 2'.lower() : [59, 1],
    'Solo French Horn'.lower() : [60, 1],
    'Brass Section Mono'.lower() : [61, 1],
    'Square Wave'.lower() : [80, 1],
    'Saw Wave'.lower() : [81, 1],
    'Synth Mallet'.lower() : [98, 1],
    'Cut Noise'.lower() : [120, 1],
    'Fl. Key Click'.lower() : [121, 1],
    'Rain'.lower() : [122, 1],
    'Dog'.lower() : [123, 1],
    'Telephone 2'.lower() : [124, 1],
    'Car-Engine'.lower() : [125, 1],
    'Laughing'.lower() : [126, 1],
    'Machine Gun'.lower() : [127, 1],
    'Echo Pan'.lower() : [102, 2],
    'String Slap'.lower() : [120, 2],
    'Thunder'.lower() : [122, 2],
    'Horse Gallop'.lower() : [123, 2],
    'Door Creaking'.lower() : [124, 2],
    'Car-Stop'.lower() : [125, 2],
    'Scream'.lower() : [126, 2],
    'Lasergun'.lower() : [127, 2],
    'Howling Winds'.lower() : [122, 3],
    'Bird 2'.lower() : [123, 3],
    'Door'.lower() : [124, 3],
    'Car-Pass'.lower() : [125, 3],
    'Punch'.lower() : [126, 3],
    'Explosion'.lower() : [127, 3],
    'Stream'.lower() : [122, 4],
    'Scratch'.lower() : [123, 4],
    'Car-Crash'.lower() : [125, 4],
    'Heart Beat'.lower() : [126, 4],
    'Bubbles'.lower() : [122, 5],
    'Windchime'.lower() : [124, 5],
    'Siren'.lower() : [125, 5],
    'Footsteps'.lower() : [126, 5],
    'Train'.lower() : [125, 6],
    'Jet Plane'.lower() : [125, 7],
    'Chorused Tine EP'.lower() : [4, 8],
    'Chorused FM EP'.lower() : [5, 8],
    'Coupled Harpsichord'.lower() : [6, 8],
    'Church Bells'.lower() : [14, 8],
    'Detuned Tnwl. Organ'.lower() : [16, 8],
    'Detuned Perc. Organ'.lower() : [17, 8],
    'Pipe Organ 2'.lower() : [19, 8],
    'Italian Accordian'.lower() : [21, 8],
    'Ukulele'.lower() : [24, 8],
    '12-String Guitar'.lower() : [25, 8],
    'Hawaiian Guitar'.lower() : [26, 8],
    'Chorused Clean Gt.'.lower() : [27, 8],
    'Funk Guitar'.lower() : [28, 8],
    'Feedback Guitar'.lower() : [30, 8],
    'Guitar Feedback'.lower() : [31, 8],
    'Synth Bass 3'.lower() : [38, 8],
    'Synth Bass 4'.lower() : [39, 8],
    'Orchestra Pad'.lower() : [48, 8],
    'Synth Strings 3'.lower() : [50, 8],
    'Brass Section 2'.lower() : [61, 8],
    'Synth Brass 3'.lower() : [62, 8],
    'Synth Brass 4'.lower() : [63, 8],
    'Sine Wave'.lower() : [80, 8],
    'Doctor Solo'.lower() : [81, 8],
    'Taisho Koto'.lower() : [107, 8],
    'Castanets'.lower() : [115, 8],
    'Concert Bass Drum'.lower() : [116, 8],
    'Melodic Tom 2'.lower() : [117, 8],
    '808 Tom'.lower() : [118, 8],
    'Starship'.lower() : [125, 8],
    'Carillon'.lower() : [14, 9],
    'Burst Noise'.lower() : [125, 9],
    'Piano & Str.-Fade'.lower() : [0, 11],
    'Piano & Str.-Sus'.lower() : [1, 11],
    'Tine & FM EPs'.lower() : [4, 11],
    'Piano & FM EP'.lower() : [5, 11],
    'Tinkling Bells'.lower() : [8, 11],
    'Bell Tower'.lower() : [14, 11],
    'Techno Bass'.lower() : [38, 11],
    'Pulse Bass'.lower() : [39, 11],
    'Stereo Strings Velo'.lower() : [49, 11],
    'Synth Strings 4'.lower() : [50, 11],
    'Synth Strings 5'.lower() : [51, 11],
    'Brass Section 3'.lower() : [61, 11],
    'Whistlin'.lower() : [78, 11],
    'Sawtooth Stab'.lower() : [81, 11],
    "Doctor's Solo".lower() : [87, 11],
    'Harpsi Pad'.lower() : [88, 11],
    'Solar Wind'.lower() : [89, 11],
    'Mystery Pad'.lower() : [96, 11],
    'Synth Chime'.lower() : [98, 11],
    'Bright Saw Stack'.lower() : [100, 11],
    'Cymbal Crash'.lower() : [119, 11],
    'Filter Snap'.lower() : [121, 11],
    'Interference'.lower() : [127, 11],
    'Bell Piano'.lower() : [0, 12],
    'Bell Tine EP'.lower() : [4, 12],
    'Christmas Bells'.lower() : [10, 12],
    'Clean Guitar 2'.lower() : [27, 12],
    'Mean Saw Bass'.lower() : [38, 12],
    'Full Orchestra'.lower() : [48, 12],
    'Mono Strings Velo'.lower() : [49, 12],
    'Square Lead 2'.lower() : [80, 12],
    'Saw Lead 2'.lower() : [81, 12],
    'Fantasia 2'.lower() : [88, 12],
    'Solar Wind 2'.lower() : [89, 12],
    'Tambourine'.lower() : [119, 12],
    'White Noise Wave'.lower() : [122, 12],
    'Shooting Star'.lower() : [127, 12],
    'Woodwind Choir'.lower() : [48, 13],
    'Square Lead 3'.lower() : [80, 13],
    'Saw Lead 3'.lower() : [81, 13],
    'Night Vision'.lower() : [88, 13],
    'Mandolin'.lower() : [25, 16],
    'Standard Drums'.lower() : [0, 120],
    'Standard 2 Drums'.lower() : [1, 120],
    'Room Drums'.lower() : [8, 120],
    'Power Drums'.lower() : [16, 120],
    'Electronic Drums'.lower() : [24, 120],
    '808/909 Drums'.lower() : [25, 120],
    'Dance Drums'.lower() : [26, 120],
    'Jazz Drums'.lower() : [32, 120],
    'Brush Drums'.lower() : [40, 120],
    'Orchestral Perc.'.lower() : [48, 120],
    'SFX Kit'.lower() : [56, 120],
    'Standard'.lower() : [0, 128],
    'Standard 2'.lower() : [1, 128],
    'Room'.lower() : [8, 128],
    'Power'.lower() : [16, 128],
    'Electronic'.lower() : [24, 128],
    '808/909'.lower() : [25, 128],
    'Dance'.lower() : [26, 128],
    'Jazz'.lower() : [32, 128],
    'Brush'.lower() : [40, 128],
    'Orchestral'.lower() : [48, 128],
    'SFX'.lower() : [56, 128],
}

global extrainfo
extrainfo = {
    #                           91   10    7
    # control_c            Reverb, Pan, Volume
      '73,0': ["flute",             52,  37, 120],
      '71,0': ["clarinet",          57,  60,  95],
      '68,0': ["oboe",              55,  64, 100],
      '60,0': ["french horn",       62,  46,  95],
      '48,0': ["string ensemble",   60,  48, 127],
      '40,0': ["violin",            60,  16, 105],
    '40-1,0': ["violin1",           60, 110, 105],
    '40-2,0': ["violin2",           60,  44, 105],
      '41,0': ["viola",             60,  64, 115],
      '42,0': ["cello",             60,  94, 100],
      '70,0': ["bassoon",           57,  89, 100],
      '44,0': ["tremola strings",   72, 112, 127],
      '45,0': ["pizzicato strings", 72, 112, 127],
      '43,0': ["contrabass",        72, 102, 100],
       '0,0': ["default",            0,  64, 100],
}

# ----------------------------------------------------------------------------
# ----------------------------------------------------------------------------
global args
global errors_happened
errors_happened = 0                 # system exit, 0 = okay, 1 = errors happened

global linecount
linecount = 0

global putds                        # "micro" and it's replacement/substitution.
putds    = { }                      # dictionary of from:to

global goto_table                   # Goto is ONLY at end of measure. (Put in extra measures.)
global goto_variables               # When processing gotos for output, the count of times hit.
goto_table = { '':[]}               # first index is measure number. Value is array of measures in goto.
goto_variables = { '':0}            # first index is measure number. Value is number of times goto is hit.

global meas                         # measure names.
meas = []
global last_m                       # Previous measure.
last_m = ''                         # Default to none.
global measure_on                   # The measure/unit are we are working on.
measure_on = ''                     # Default to none. This means we are in the header section.
global premeasurecomment            # Collect comments before a new measure for before new measure.
premeasurecomment = {}
premeasurecomment[measure_on] = ''
global measurelinecomment
measurelinecomment = {}
measurelinecomment[measure_on] = ''
global bars                         # number of bars per staff
bars = {}
bars[''] = NUMBER_BARS_PER_STAFF    # for abc notation, put new line in output, which ends staff.

global voices                       # number of voices
voices = 1
global cis                          # If cis active, non-zero. (CIS measure one voice #XX only.)
cis = 0

global vl                           # volume levels
vl = { }                            # vl[voice][m] = volumelevel
vl[1] = { }                         # vl[voice][m] = volumelevel
vl[1][''] = 127                     # vl[voice][m] = volumelevel
global running_vl                   # volume levels changing thru measures. (set vl to running_vl at measure.)
running_vl = { }                    # running_vl[voice][m] = volumelevel
running_vl[1] = { }                 # running_vl[voice][m] = volumelevel
running_vl[1][''] = 127             # running_vl[voice][m] = volumelevel

global xpose                        # The number of semitones to move up/down (positive=up).
xpose = {}
global xpose_new_key                # lowercase normal musicomp usage.
xpose_new_key = {}

global clef
clef = { }                          # no clef specified [measure][voice].
clef[''] = { }

global vinstrument
vinstrument = { }                   # no instruments specified [measure][voice].
vinstrument[''] = {}                # blank measure.

global percents
percents = { }                      # no %% passthru commands for start of [measure] (for abc).
percents[''] = []                   # blank measure.

global staves
staves = [ ]

global reverb
reverb = { }                        # Reverb value for voice.
reverb[''] = {}

global pan
pan = { }                           # Pan (balance 0=left, 126=right, 64=center) for voice.
pan[''] = {}

global intensity
intensity = { }                     # Instrument intensity (volume).
intensity[''] = {}

global pitch                        # Pitch change up or down by semitones.
pitch = {}                          # Index by measure.
pitch[''] = 0                       # Before first measure is no pitch.

global cresc_volume
cresc_volume = [ ]
global cresc_time
cresc_time = []
global cresc_direction
cresc_direction = []

global voices_having_notes
voices_having_notes = {}

for i in range(1, MAXVOICES+1):     # This is used as [1] .. [MAXVOICES]
    vinstrument[''][i] = [0, 0]     # No instrument. (measure, voice)
    reverb[''][i] = default_reverb
    pan[''][i] = default_pan
    intensity[''][i] = default_intensity
    clef[''][i] = {}
    clef[''][i] = 'treble'          # No clef.       (voice, measure)
    xpose[i] = 0
    xpose_new_key[i] = 'c'          # No new key.   Text!
    cresc_volume.append(0)
    cresc_time.append(0)
    cresc_direction.append(True)
# rof

global inst
inst = { }                          # track using instrument by instrument.

global oct                          # default octave
oct = { 1 : 0 }
global acc_v_init                   # Last accidental on a note in measure.
global acc_v_init_v_or_h            # Last accidental on a note in measure.
acc_v_init = { 'C':'', 'D':'', 'E':'', 'F':'', 'G':'', 'A':'', 'B':''}
acc_v_init_v_or_h = { 'c':'', 'd':'', 'e':'', 'f':'', 'g':'', 'a':'', 'b':''}
global acc_m
acc_m = { '': {''}}                 # voice: {notes:'+'/-/n}    For this measure, index is voice.
global last_acc_m
last_acc_m =  { '': {''}}           # Accidentals on previous measure.
                                    # acc_v_init or acc_v_init_v_or_h: note (a-g): last accidental in measure.
global acc_m_xpose
acc_m_xpose = { '': {''}}           # After xpose, the new key ... voice: {notes:'+'/-/n}

global time                         # set default note length (time)
time = { 1 : 0 }
global mlth                         # measure length dictionary
mlth = { 1 : { measure_on: 0} }     # nothing in measure working on -- voice 1.
global tlth                         # #or 60ths/voice
tlth = { 1 : 0 }                    # 60ths of a second in a voice -- nothing in measure working on.

global bufs                         # bufs[voice][measure] = text line.
#                                   # ABC format, or musicomp format separated by commas.
bufs = { 1 : {} }

global bufs_length                  # bufs_length[voice][measure][#] ... number= 0..#commas-1 above.
bufs_length = { 1 : {} }

global bufs_accidental              # bufs_length[voice][measure][#] ... number= 0..#commas-1 above.
bufs_accidentals = { 1: {} }

global bufs_tie_next                # The --horizontal and --verticle have "t" (ties) swapped on where
bufs_tie_next = { 1: '' }           #    the "t" goes on which notes.

global bufs_legato_next
bufs_legato_next = { 1: '' }

global bufs_vol
bufs_vol = { 1: {} }

global pages_to_do
pages_to_do = []                    # argument line limiting which pages to do.
global measures_to_do
measures_to_do = []                 # argument line limiting which measures to do.
global voices_to_do
voices_to_do = []                   # argument line limiting which voices to do.

global iftest                       # check if after if or else.
iftest = { 0:-1 }                   # -1 = processing in if, 0 = skip till else,
#                                   # 1 processing in else, 2 = skip till endif,
#                                   # 3 = skip both if and else.
global ifdepth                      # level of if/else/endif
ifdepth = 0

global cstop_processing
cstop_processing = False            # True if after a cstop.

global macro_internal               # Next internal macro.
macro_internal = 0                  # Number for internal macros (note processing internal macros).
global macro_defining               # If defining macro.
macro_defining = None
global macro_buffer                 # Name of macro, array of lines for macro.
macro_buffer = { '':''}
global macro_arguments              # Name of macro, array of arguments for macro.
macro_arguments = { '':''}
global macro_executing_depth        # If processing macro ... reading from macro buffer.
macro_executing_depth = []          # The macro name currently working on is the last name in the array.
global macro_executing_args         # Depth, array of arguments given to macro.
macro_executing_args = { 0:[] }
global macro_line                   # Depth, line in macro array.
macro_line = { 0:0 }                # Depth, macro name

global header                       # Header to print at top of file.

global meter
global measure_meter
global measure_meter_value          # Last computed value for above.

global key_default
key_default = None                  # First key applies globally, if not voice number arguments.
global key_voice                    # Running key by measure then voice.
key_voice = { '': {} }

# This should really be 'where it occurs'.
global tempo_speed_default          # beats per minute
tempo_speed_default = 150.0
global default_note_length          # length of a beat (note)
default_note_length = { '': 1.0 / 4.0 } # before a measure.
global tempo_speed_now              # beats per minute for each measure.
tempo_speed_now = { '': tempo_speed_default }
global tempo_now_note_length        # length of a beat (note)
tempo_now_note_length = { '': 1.0 / 4.0 } # before a measure.

global file_name                    # None = use tty.
global output_name                  # File to print to (default is sys.stdout).

global array_of_lines               # For fluidsynth output, have an array of lines.
array_of_lines = []

global fluidsynth_done
fluidsynth_done = False             # Set True if done with midi1csv printing into array and 'quit'.

global first_reset_voice
first_reset_voice = True            # Only do a reset controller with first voice.

global do_csv_read
do_csv_read = False                 # Set true if first line says it is a csv file. :)

# ----------------------------------------------------------------------------
# ----------------------------------------------------------------------------
def print_error(strg, line):
    global linecount
    global errors_happened

    errors_happened = 1             # When exiting, do 1 instead of 0

    print("ERROR -", strg, file=sys.stderr, flush=True)
    print("  Line {} - '{}'".format(linecount, line), file=sys.stderr, flush=True)
    return
# End of print_error

# ----------------------------------------------------------------------------
def print_warning(strg, line):
    global linecount

    print("WARNING -", strg, file=sys.stderr, flush=True)
    print("  Line {} - '{}'".format(linecount, line), file=sys.stderr, flush=True)
    return
# End of print_warning

# ----------------------------------------------------------------------------
def print_error_no_line(strg):
    print("ERROR -", strg, file=sys.stderr, flush=True)
    return
# End of print_error_no_line

# ----------------------------------------------------------------------------
def print_warning_no_line(strg):
    print("WARNING -", strg, file=sys.stderr, flush=True)
    return
# End of print_warning_no_line

# ----------------------------------------------------------------------------
def really_print_output(strg):
    global output_name

    print(strg, file=output_name, flush=True)
    return
# End of really_print_output

# ----------------------------------------------------------------------------
def print_debug(strg):
    print("DEBUG -", strg, file=sys.stderr, flush=True)
    return
# End of print_debug

# ----------------------------------------------------------------------------
def print_output(strg):
    global args
    global array_of_lines
    global fluidsynth_done

    if not args.fluidsynth and not fluidsynth_done:
        really_print_output(strg)
    else:
        if strg == "quit":
            fluidsynth_done = True
        else:
            array_of_lines.append(strg)
        # fi
    # fi
    return
# End of print_output

# ----------------------------------------------------------------------------
def print_output_no_eol(strg):
    global output_name

    print(strg, end='', file=output_name, flush=True)
    return
# End of print_output_no_eol

# ----------------------------------------------------------------------------
# Returns: lengthl - value given, like 4 for quarter note.
#          lengthf - value in floating, 0.25 for a quarter note.
#          ifokay  - True if everything is okay.
def get_time_stak(timeofnote, line, onvoice):
    global default_note_length          # length of a beat (note)
    global legal_floating_times
    global measure_on
    global args

    if timeofnote <= 0.0:
        print_error("timeofnote '{}' negative or zero -- cannot play a note backwards.".format(timeofnote), line)
        return timeofnote, 0, -1    # False
    # fi
    lengthl = []
    lengthf = []
    t = timeofnote
    for i in reversed(range(len(legal_floating_times))):
        f = legal_floating_times[i]
        while True:
            if f > t:
                break
            # fi
            if args.horizontal or args.vertical:
                v = f
                v = 1.0 / v
                if f in legal_mc_notes:
                    vv = legal_mc_notes[f]
                else:
                    vv = str(Fraction(v).limit_denominator(256))
                    if '/' in vv:
                        vv = '(' + str(f) + ')'
                    # fi
                # fi
                v = vv
            elif args.midi1csv or args.fluidsynth:
                v = round((f * 4.0) * MIDICLICKSPERQUARTER)
            else:       # ABC
                v = f / default_note_length[measure_on]
                v = str(Fraction(v).limit_denominator(256))
                if v[0:2] == '1/':
                    v = v[1:]
                # fi
            # fi
            lengthl.append(v)
            lengthf.append(f)
            t = t - f
            if t <= 0:                  # This isn't needed, but makes me more comfortable.
                break
            # fi
        # elihw
    # rof
    if t > 0:
        print_warning("voice={} timeofnote={} -> {} has left-over of t={}".format(onvoice, timeofnote, lengthl, t), line)
        return lengthl, lengthf, 1      # Problems
    # fi
    if not lengthl or len(lengthl) == 0:
        print_error("timeofnote '{}' not able to return a usable fraction - min of 1/64".format(timeofnote), line)
        return timeofnote, 0, -1    # False
    # fi
    return lengthl, lengthf, 0      # True
# End of get_time_stak

# ----------------------------------------------------------------------------
def default_note_text_fraction(m):
    global default_note_length
    global legal_notes

    l = str(Fraction(default_note_length[m]).limit_denominator(256))
    if l not in legal_notes:
        print_warning("#1 Time fraction '{}' is not a printable note. ({})".format(default_note_length[m], l), line)
    # fi
    return(l)
# End of default_note_text_fraction

# ----------------------------------------------------------------------------
def new_voice_initialize(voice, m):
    global vl                           # volume levels
    global vinstrument
    global reverb
    global pan
    global intensity
    global oct                          # default octave
    global time                         # set default note length (time)
    global mlth                         # measure length dictionary
    global tlth                         # #or 60ths/voice
    global bufs
    global bufs_length
    global bufs_accidentals
    global bufs_tie_next
    global bufs_legato_next
    global bufs_vol
    global acc_m
    global acc_m_xpose
    global acc_v_init                   # Last accidental on a note in measure.
    global acc_v_init_v_or_h            # Last accidental on a note in measure.
    global args
    global running_vl                   # volume levels changing thru measures.
    global key_default
    global key_voice
    global clef

    if voice not in vl:
        vl[voice] = { }                 # Dictionary
        running_vl[voice] = { }
    if voice not in oct:
        oct[voice] = 0                  # last octave starts at zero
    if voice not in time:
        time[voice] = 0                 # last time starts at zero
    if voice not in mlth:
        mlth[voice] = {}
    if voice not in tlth:
        tlth[voice] = 0                 # #or 60ths/voice
    if voice not in bufs:
        bufs[voice] = {}
        bufs_length[voice] = {}
        bufs_accidentals[voice] = {}
        bufs_tie_next[voice] = ''
        bufs_legato_next[voice] = ''
        bufs_vol[voice] = {}
    # fi

    if m not in vl[voice]:
        vl[voice][m] = 127              # start volume out at maximum
        running_vl[voice][m] = 127

    if m not in vinstrument:
        vinstrument[m] = {}
        reverb[m] = {}
        pan[m] = {}
        intensity[m] = {}
    # fi
    if voice not in vinstrument[m]:
        vinstrument[m][voice] = [0, 0]
        reverb[m][voice] = default_reverb
        pan[m][voice] = default_pan
        intensity[m][voice] = default_intensity

    if m not in key_voice:
        key_voice[m] = {}
    # fi
    if voice not in key_voice[m]:
        key_voice[m][voice] = key_default
    # fi

    if m not in mlth[voice]:
        mlth[voice][m] = 0              # measure length dictionary
    # fi
    if voice not in acc_m:
        if args.horizontal or args.vertical:
            acc_m[voice] =  {k: v for k, v in acc_v_init_v_or_h.items()}
            acc_m_xpose[voice] =  {k: v for k, v in acc_v_init_v_or_h.items()}
        elif args.midi1csv or args.fluidsynth:
            acc_m[voice] =  {k: v for k, v in acc_v_init_v_or_h.items()}
            acc_m_xpose[voice] =  {k: v for k, v in acc_v_init_v_or_h.items()}
        else:           # ABC
            acc_m[voice] =  {k: v for k, v in acc_v_init.items()}
            acc_m_xpose[voice] =  {k: v for k, v in acc_v_init.items()}
        # fi
    # fi

    for j in vl:
        if m not in clef:
            clef[m] = {}
        # fi
        if m not in clef or j not in clef[m]:
            for k in reversed(range(0, len(meas)-1)):
                mmm = meas[k]
                if mmm in clef and j in clef[mmm]:
                    nc = clef[mmm][j]
                    break
                # fi
            # rof
        else:
            nc = clef[m][j]
        # fi
        clef[m][j] = nc
    # rof
    return
# End of new_voice_initialize

# ----------------------------------------------------------------------------
# Get volume levels at measures -- the volume(s) commands work at that point..
def get_volume_level(m, voice):
    global vl                           # volume levels
    global vlprint
    global args
    global DECORATIONS

    new_voice_initialize(voice, m)
    j = vl[voice][m]                    # volume level for this voice/measure
    if args.horizontal or args.vertical:
        return j
    # fi
    if args.midi1csv or args.fluidsynth:
        return j
    # fi
    j = vol_to_vlprint_round(j)
    return (DECORATIONS + vlprint[j] + DECORATIONS)
# End of get_volume_level

# ----------------------------------------------------------------------------
def rests_in_empty_measure_voices(m, voice):
    global vl                               # volume levels
    global meas
    global mlth
    global bufs
    global bufs_length
    global bufs_accidentals
    global bufs_tie_next
    global bufs_legato_next
    global bufs_vol
    global args
    global running_vl

    if m in bufs[voice]:                    # Already present, then of right length.
        return
    # fi
    # No text for this voice, create rests to fill it out.
    l = 0
    for i in range(1, len(vl)+1):
        if m in mlth[i]:
            l = max(mlth[i][m], l)
        # fi
    # rof
    if m in mlth[voice]:
        l = l - mlth[voice][m]              # All measure lengths with voices are the same.
    # fi
    if m not in bufs[voice]:
        bufs_vol[voice][m] = []
        if args.horizontal or args.vertical or args.midi1csv or args.fluidsynth:
            bufs[voice][m] = []
            bufs_length[voice][m] = []
            bufs_accidentals[voice][m] = []
            bufs_tie_next[voice] = ''
            bufs_legato_next[voice] = ''
        else:       # ABC
            bufs[voice][m] = ''
        # fi
    # fi
    if voice in running_vl and m in running_vl[voice]:
        tt = running_vl[voice][m]
    else:
        tt = 127                            # Probably a rest, put as full volume.
    # fi
    bufs_vol[voice][m].append(tt)
    # Put out rests.
    if l <= 0:                              # if nothing to do.
        return
    # fi
    txt = ''
    if args.horizontal or args.vertical or args.midi1csv or args.fluidsynth:
        pass
    else:       # ABC
        lengthl, lengthf, ifokay = get_time_stak(l, 'pass2', voice)
        for i in range(len(lengthl)):
            txt = txt + ' z' + lengthl[i]       # entry in array
        # rof
        if txt == '':
            print_error('no music for voice {} in measure {}'.format(voice, m), 'pass2')
            return
        # fi
    # fi

    bufs_tie_next[voice] = ''
    bufs_legato_next[voice] = ''
    if args.horizontal or args.vertical:
        bufs[voice][m].append('r')
        bufs_length[voice][m].append(l)
        bufs_accidentals[voice][m].append('')
    elif args.midi1csv or args.fluidsynth:
        bufs[voice][m].append(0)
        bufs_length[voice][m].append(l)
        bufs_accidentals[voice][m].append('')
    else:       # ABC
        bufs[voice][m] = bufs[voice][m] + txt   # Append the sleeps.
    # fi
    return
# End of rests_in_empty_measure_voices

# ----------------------------------------------------------------------------
def print_measure_abc(m, voice, l_meter, l_tempo, l_dl, l_clef, l_instrument, l_vl, l_txt, l_ky, l_pitch):
    global bufs
    global measure_meter
    global clef
    global meas
    global vinstrument
    global reverb
    global pan
    global intensity
    global key_voice                        # Running key by voice.
    global tempo_speed_now
    global pitch

    if voice not in bufs:
        return "ERROR - bufs voice dictionary is hosed.", '', '', '', '', '', '', '', ''
    # fi
    pr = l_txt

    # if first measure, and doing voice, output V:# line.
    if m == meas[0] or (m in clef and voice in clef[m] and l_clef != clef[m][voice]):
        if pr != '' and pr[-1] != '\n':
            pr = pr + '\n'
        # fi
        pr = pr + "V:{}".format(voice)
        if m in clef and voice in clef[m]:
            if clef[m][voice] != l_clef:
                l_clef = clef[m][voice]
                pr = pr + ' clef={}'.format(l_clef)
            # fi
        # fi
        pr = pr + '\n'
    # fi

    if pitch[m] != l_pitch:
        if pr != '' and pr[-1] != '\n':
            pr = pr + '\n'
        # fi
        l_pitch = pitch[m]
        pr = pr + '%% pitch    {}'.format(l_pitch) + '\n'
    # fi

    if voice not in vinstrument[m]:
        vinstrument[m][voice] = [0, 0]
        reverb[m][voice] = default_reverb
        pan[m][voice] = default_pan
        intensity[m][voice] = default_intensity
    # fi

    if len(vinstrument[m]) >= voice and vinstrument[m][voice] != 0:
        if l_instrument != vinstrument[m][voice]:
            l_instrument = vinstrument[m][voice]
            if pr != '' and pr[-1] != '\n':
                pr = pr + '\\\n'
            # fi
            if vinstrument[m][voice][1] != 0:
                print_warning_no_line("print_measure_abc - voice#{} measure#{} instrument {} not acceptable!".format(voice, m, vinstrument[m][voice]))
            # fi
            pr = pr + "%%MIDI program {}\n".format(l_instrument[0])
        # fi
    # fi


    if m == meas[0]:
        flag = False
        for M in goto_table:
            for G in goto_table[M]:
                pr = pr + '|:'
                flag = True
                break
            # rof
            if flag:
                break
            # fi
        # rof
    # fi

    # if default note length != last one
    if l_dl != default_note_text_fraction(m):
        l_dl = default_note_text_fraction(m)
        if l_dl == '1':
            p_dl = '1/1'
        else:
            p_dl = l_dl
        # fi
        pr = pr + "[L:{}]".format(l_dl)
    # fi

    if l_tempo != tempo_speed_now[m]:
        l_tempo = tempo_speed_now[m]
        pr = pr + "[Q:{}={}]".format(l_dl, l_tempo)
    # fi

    vvv = voice
    if vvv in key_voice[m]:
        if l_ky != key_voice[m][vvv]:
            ky = key_voice[m][vvv]
            pr = pr + "[K:{}]".format(ky)
            l_ky = ky
        # fi
    # fi
    # if meter != last one
    if l_meter != measure_meter[m]:
        l_meter = measure_meter[m]
        pr = pr + "[M:{}]".format(l_meter)
    # fi
    j = get_volume_level(m, voice)
    v_vl = j

    if v_vl != l_vl:
        pr = pr + v_vl
        l_vl = v_vl
    # fi
    pr = pr + bufs[voice][m] + ' |'
    return pr, l_meter, l_tempo, l_dl, l_clef, l_instrument, l_vl, l_ky, l_pitch
# End of print_measure_abc

# ----------------------------------------------------------------------------
def print_out_abc():
    global vl                               # volume levels
    global meas                             # measures
    global bars                             # number of bars per staff
    global key_default
    global voices_to_do
    global args

    #-- for voice in reversed(range(1, len(vl)+1)):
    for voice in range(1, len(vl)+1):
        if args.voices and args.voices != '':
            if str(voice) not in voices_to_do:
                continue
            # fi
        # fi
        if voice > MAXABCVOICES:
            print_error_no_line("voice ({}) > {} abc voices".format(voice,MAXABCVOICES))
        # fi
        print_output("% --- voice " + str(voice) + '  ---')
        l_meter = l_dl = l_clef = l_instrument = l_vl = ''
        l_ky = key_default
        l_tempo = ''
        l_pitch = ''
        print_line = ''

        bar = 0
        bar_print = 0
        last_bar = bars['']
        print_output(print_line + "%abc %%barsperstaff {}".format(last_bar))
        first_goto = True
        for i in range(0, len(meas)):
            bar = bar + 1
            m = meas[i]
            if (bar > int(last_bar) + bar_print):                # Zero-th one is ''.
                if print_line != '' and print_line[-1] != '\n':
                    print_line = print_line + '\n'
                # fi
                print_output(print_line + "% measure {}".format(m))
                print_line = ''
                bar_print = i
            # fi
            if last_bar != bars[m]:            # Zero-th one is ''.
                if print_line != '' and print_line[-1] != '\n':
                    print_line = print_line + '\n'
                # fi
                last_bar = bars[m]
                print_line = print_line + "%abc %%barsperstaff {}\n".format(last_bar)
            # fi

            if m in percents:
                if print_line != '' and print_line[-1] != '\n':
                    print_line = print_line + '\\n'
                # fi
                for p in percents[m]:
                    print_line = print_line + p + '\n'
                # rof
            # fi

            print_line, l_meter, l_tempo, l_dl, l_clef, l_instrument, l_vl, l_ky, l_pitch = print_measure_abc(m,
                        voice, l_meter, l_tempo, l_dl, l_clef, l_instrument, l_vl, print_line, l_ky, l_pitch)

            if m in goto_table and goto_table[m] != '':
                print_warning_no_line("goto in measure {} not handled.".format(m))
                if print_line != '' and print_line[-1] != '\n' and print_line[-1] == '|' and first_goto:
                    print_line = print_line[:-1] + ':|'
                    first_goto = False
                # fi
            # fi

        # rof
        if print_line != '':
            print_line = print_line + ']'
            print_output(print_line)
        # fi
    # fi
    return
# End of print_out_abc

# ----------------------------------------------------------------------------
# input:
#   m               The measure.
#   l_meter         Last meter.
#   l_clef          Last clef for voices.
#   l_instrument    Last Instrument for voices.
#   l_vl            Last volume array for voices.
#   l_txt           (print_line entry)
#   l_ky            Last key for this voice.
#   l_tempo         Last tempo
#   l_t_n_l         Last tempo note length.
# returns:
#   print_line
#   l_meter
#   l_dl
#   l_clef
#   l_instrument
#   l_vl
#   l_ky
#   l_tempo
#   l_t_n_l

#   measure xyz
#   meter   x/y
#   clef    abc,def,ghi,jkl,mno,pqr
#   volume  4,5,6,7,6,5
#   tempo   100,4
#   voice   6   30,40,50,60,70,80           $$ needed if volume changes.
#   v1: 3c4, ...
#   vX: 3e4, ...

def print_measure_vh_header(m, l_meter, l_clef, l_instrument, l_vl, l_txt, l_ky, l_tempo, l_t_n_l, l_pitch):
    global vl
    global measure_meter
    global clef
    global vinstrument
    global key_voice
    global tempo_speed_now
    global tempo_now_note_length
    global pitch
    global args
    global voices_to_do

    pr = ''
    n_meter = ''
    n_clef = ''
    n_instrument = []
    n_vl = ''

    if premeasurecomment[m] != '':
        pr = pr + premeasurecomment[m]
    # fi
    pr = pr + "measure {}".format(m)
    if measurelinecomment[m] != '':
        pr = pr + '     ' + measurelinecomment[m]
    # fi
    pr = pr + "\n"

    n_meter = measure_meter[m]
    if l_meter != n_meter:
        pr = pr + 'meter   {}\n'.format(n_meter)
    # fi

    n_clef = ''
    for voice in range(1, len(vl)+1):
        if args.voices and args.voices != '':
            if str(voice) not in voices_to_do:
                continue
            # fi
        # fi
        if m in clef and voice in clef[m]:
            t = str(clef[m][voice])
            if n_clef == '':
                n_clef = t
            else:
                n_clef = n_clef + ',' + t
            # fi
        # fi
    # rof
    if l_clef != n_clef:
        pr = pr + 'clef    {}\n'.format(n_clef)
    # fi

    pv = False

    for voice in range(1, len(vl)+1):
        if args.voices and args.voices != '':
            if str(voice) not in voices_to_do:
                continue
            # fi
        # fi
        new_voice_initialize(voice, m)
        t = str(get_volume_level(m, voice))
        for j in vlprint:
            if t == str(j):
                t = vlprint[j]
                break
            # fi
        # rof
        if n_vl == '':
            n_vl = t
        else:
            n_vl = n_vl + ',' + t
        # fi
    # rof
    if l_vl != n_vl:
        p_vl = n_vl
        for j in vlprint:
            if n_vl == j:
                p_vl = vlprint[j]
                break
            # fi
        # rof
        pr = pr + 'volumes {}\n'.format(p_vl)
        pv = True
    # fi

    for voice in range(1, len(vl)+1):
        if args.voices and args.voices != '':
            if str(voice) not in voices_to_do:
                continue
            # fi
        # fi
        if voice in vinstrument[m]:
            stri = ''
            if vinstrument[m][voice] in instruments.values():
                for x in instruments:
                    if vinstrument[m][voice] == instruments[x]:
                        stri = x
                        break
                    # fi
                # rof
            else:
# Not tested for vinstrument change to have bank.
#--                print_debug("#87c vinstrument[m][voice]='{}'".format(vinstrument[m][voice]))
                if vinstrument[m][voice][1] != 0:
                    print_warning_no_line("print_measure_vh_header - voice#{} measure#{} instrument {} not acceptable!".format(voice, m, vinstrument[m][voice]))
                # fi
                stri = '{}'.format(vinstrument[m][voice][0])
            # fi
            n_instrument.append('instrument {} '.format(voice) + stri)
        else:
            n_instrument.append('instrument {} 0'.format(voice))
        # fi
    # rof

    if l_instrument != n_instrument or pv:
        if n_instrument != []:
            pr = pr + 'voice   {}\n'.format(len(vl))
            for x in range(0, len(vl)):
                if x >= len(l_instrument) or l_instrument[x] != n_instrument[x]:
                    pr = pr + '{}\n'.format(n_instrument[x])
                # fi
            # rof
        else:
            pr = pr + 'voice   {}\n'.format(len(vl))
        # fi
    # fi

    for voice in range(1, len(vl)+1):
        if args.voices and args.voices != '':
            if str(voice) not in voices_to_do:
                continue
            # fi
        # fi
        if voice in key_voice[m]:
            if l_ky[voice] != key_voice[m][voice]:
                l_ky[voice] = key_voice[m][voice]
                pr = pr + "key     {}  {}\n".format(voice, l_ky[voice])
            # fi
        # fi
    # rof

    if l_pitch != pitch[m]:
        l_pitch = pitch[m]
        pr = pr + "pitch   {}\n".format(l_pitch)
    # fi

    if l_tempo != tempo_speed_now[m] or l_t_n_l != tempo_now_note_length[m]:
        l_tempo = tempo_speed_now[m]
        l_t_n_l = tempo_now_note_length[m]
        l = str(Fraction(1.0 / l_t_n_l).limit_denominator(256))
        j = l_tempo
        k = int(l_tempo)
        if (j - float(k)) * 1000 == 0:
            p = str(k)
        else:
            p = l_tempo
        # fi
        pr = pr + "tempo   {},{}\n".format(p, l)
    # fi

    pr = l_txt + pr
    return pr, n_meter, n_clef, n_instrument, n_vl, l_ky, l_tempo, l_t_n_l, l_pitch
# End of print_measure_vh_header

# ----------------------------------------------------------------------------
def print_out_notes_v_or_h(m, print_line):
    global args
    global vl
    global bufs
    global bufs_length
    global bufs_accidentals
    global args
    global voices_to_do

    if args.vertical:
        txt = ''
        for voice in range(1, len(vl)+1):
            if args.voices and args.voices != '':
                if str(voice) not in voices_to_do:
                    continue
                # fi
            # fi
            if len(bufs[voice][m]) == 0:
                continue
            # fi
            txt = txt + "v{}: ".format(voice)
            for i in range(0, len(bufs[voice][m])):
                if i != 0:
                    txt = txt + ','
                # fi
                l =  bufs_length[voice][m][i]
                if l in legal_mc_notes:
                    lth = legal_mc_notes[l]
                else:
                    lth = str(Fraction(l).limit_denominator(256))
                    if '/' in lth:
                        lth = '(' + str(l) + ')'
                    # fi
                # fi
                txt = txt + bufs[voice][m][i] + lth + bufs_accidentals[voice][m][i].replace('c','')
            # rof
            txt = txt + '\n'
        # rof
        print_line = print_line + txt
        return print_line
    # fi
    # else - horizontal

    ml = mlth[1][m]
    for i in range(1, len(vl)+1):
        if args.voices and args.voices != '':
            if str(i) not in voices_to_do:
                continue
            # fi
        # fi
        if m in mlth[i]:
            if mlth[i][m] != ml:
                print_error_no_line("voice#{} measure#{} not same length({}) as 1st({})".format(i, m, mlth[i][m], ml))
            # fi
            ml = max(mlth[i][m], ml)
        else:
            print_error_no_line("voice#{} not in measure#{}".format(i, m))
        # fi
    # rof
    workingtime = [ 0 ]                         # Zero is ignored.
    working= [ 0 ]
    for voice in range(1, len(vl)+1):
        working.append(0)
        workingtime.append(0)
    # rof

    now = 0
    txt = ''
    while now < ml:
        for voice in range(1, len(vl)+1):
            if args.voices and args.voices != '':
                if str(voice) not in voices_to_do:
                    continue
                # fi
            # fi
            if txt != '':
                txt = txt + ','
            # fi
            i = workingtime[voice]
            if i <= now:
                j = working[voice]
                l =  bufs_length[voice][m][j]

                if l in legal_mc_notes:
                    lth = legal_mc_notes[l] + bufs_accidentals[voice][m][j].replace('c','')
                else:
                    lth = str(Fraction(l).limit_denominator(256))
                    if '/' in lth:
                        lth = '(' + str(l) + ')'
                    # fi
                    lth = lth + bufs_accidentals[voice][m][j].replace('c','')
                # fi
                txt = txt + bufs[voice][m][j] + lth
                workingtime[voice] = workingtime[voice] + l
                working[voice] = working[voice] + 1
            # fi
        # rof
        print_line = print_line + txt + '\n'
        txt = ''
        nextmin = 999999
        for voice in range(1, len(vl)+1):
            if args.voices and args.voices != '':
                if str(voice) not in voices_to_do:
                    continue
                # fi
            # fi
            if workingtime[voice] < nextmin:
                nextmin = workingtime[voice]
            # fi
        # rof
        now = nextmin
    # elihw
    return print_line
#   End of print_out_notes_v_or_h

# ----------------------------------------------------------------------------
# Vertical and horizontal have:
#   A header (meter, key, title, etc.)
#   voice   #
#   measure xyz
#   meter   x/y
#   clef    abc,def,ghi,jkl,mno,pqr
#   #-- volume  4,5,6,7,6,5
#   tempo   100,4
#   voice   6   30,40,50,60,70,80           $$ needed if volume changes.
#   v1: 3c4, ...
#   vX: ...
#
# NOTE: --voices does not affect this, otherwise it don't work.
def print_out_v_or_h():
    global vl                               # volume levels
    global meas                             # measures
    global args
    global key_default
    global tempo_speed_default
    global default_note_length
    global pitch

    print_output('voice   {}'.format(len(vl)))

    l_meter = ''
    l_clef = []
    l_vl = []
    l_instrument = []
    l_ky = [ '' ]
    for voice in range(1, len(vl)+1):
        l_ky.append(key_default)
    # fi
    l_tempo = tempo_speed_default
    l_t_n_l = default_note_length['']
    print_line = ''
    l_pitch = pitch['']

    bar_print = bars['']

    for i in range(0, len(meas)):
        m = meas[i]
        if args.horizontal and m == meas[0] and len(vl) > 1:
            print_line = print_line + "* 1"
            for j in range(2, len(vl)+1):
                print_line = print_line + ",{:>3s}".format(str(j))
            # rof
            print_line = print_line + '\n'
        # fi

        if m in percents:
            print_line = print_line + '\n'
            for p in percents[m]:
                print_line = print_line + p + '\n'
            # rof
        # fi

        print_line, l_meter, l_clef, l_instrument, l_vl, l_ky, l_tempo, l_t_n_l, l_pitch = print_measure_vh_header(m,
                    l_meter, l_clef, l_instrument, l_vl, print_line, l_ky, l_tempo, l_t_n_l, l_pitch)

        if bar_print != bars[m]:            # Zero-th one is ''.
            print_line = print_line + "bars    {}\n".format(bars[m])
            bar_print = bars[m]
        # fi

        # Print out notes for measure.
        print_line = print_out_notes_v_or_h(m, print_line)

        if m in goto_table and goto_table[m] != '':
            print_line = print_line + 'goto    ' + ','.join(goto_table[m]) + '\n'
        # fi
    # rof
    if print_line != '':
        print_output_no_eol(print_line)
    # fi
    return
# End of print_out_v_or_h

# ----------------------------------------------------------------------------
def print_out_midi1csv_start(voiceon):
    global first_reset_voice
    print_output('{}, 0, Start_track'.format(voiceon+1))
    if first_reset_voice:
        # 121   Reset all Controllers.
        print_output('{}, 0, Control_c, 0, 121, 0'.format(voiceon+1))
        first_reset_voice = False
    # fi
#   End of print_out_midi1csv_start

# ----------------------------------------------------------------------------
def print_out_midi1csv_end(voiceon, lthworkingmeasures):
    print_output('{}, {}, End_track'.format(voiceon+1, lthworkingmeasures + int(clicks_at_end_of_piece)))
#   End of print_out_midi1csv_end

# ----------------------------------------------------------------------------
# Time Signature / meter.
# returns lastmeter printed (which this routine may update).
def print_out_midi1csv_ts(m, voiceon, lthworkingmeasure, last_bar_meter):
    global meas
    global measure_meter

    if last_bar_meter != measure_meter[m]:
        last_bar_meter = measure_meter[m]
        l = last_bar_meter.split('/', 1)
        numerator = l[0]
        denominator = Log2(l[1])
        if denominator.is_integer():
            denominator = int(denominator)
        else:
            denominator = l[1]
            print_error_no_line("meter denominator is not a power of two, leave as {}".format(denominator))
        # fi
        print_output("{}, {}, Time_signature, {}, {}, 48, 8".format(
                voiceon+1, int(round(lthworkingmeasure)), numerator, denominator))
    # fi
    return last_bar_meter
# End of print_out_midi1csv_ts

# ----------------------------------------------------------------------------
# input   m_number, voiceon, lthworkingmeasure, last_instrument, channel, chan
# returns last_instrument_on printed (which this routine may update).
#         channel (which may be updated).
#         chan (which may be updated).
def print_out_midi1csv_instrument(m, voiceon, lthworkingmeasure, last_instrument_on, channel, chan):
    global vinstrument
    global reverb
    global pan
    global intensity
    global meas
    global inst
    global extrainfo
    global mlth
    global args
    global offset
    offset = 0

    if voiceon not in vinstrument[m]:
        vinstrument[m][voiceon] = [0, 0]
        reverb[m][voiceon] = default_reverb
        pan[m][voiceon] = default_pan
        intensity[m][voiceon] = default_intensity
    # fi
    if len(vinstrument[m]) >= voiceon:
        if last_instrument_on != vinstrument[m][voiceon]:
            last_instrument_on = vinstrument[m][voiceon]
            strlast_instrument_on = '{}, {}'.format(last_instrument_on[0], last_instrument_on[1])
            if strlast_instrument_on not in inst:
                inst[strlast_instrument_on] = {}
                chan = channel                              # New instrument & voice.
                inst[strlast_instrument_on][voiceon] = chan
                channel = channel + 1
                if channel == 9:
                    channel = 10
                elif channel >= MAXMIDICHANNELS and args.midi1csv:
                    print_error_no_line("channel ({}) > {} midi channels (0 based)".format(channel,MAXMIDICHANNELS))
                # fi
            elif voiceon not in inst[strlast_instrument_on]:
                chan = channel                              # New instrument & voice.
                inst[strlast_instrument_on][voiceon] = chan
                channel = channel + 1
                if channel == 9:
                    channel = 10
                elif channel >= MAXMIDICHANNELS and args.midi1csv:
                    print_error_no_line("channel ({}) > {} midi channels (0 based)".format(channel,MAXMIDICHANNELS))
                # fi
            else:
                chan = inst[strlast_instrument_on][voiceon]    # instrument used previously on this voice.
#--                if last_instrument_on < 0:
#--                    last_instrument_on = 0
#--                # fi
            # fi
            q = mlth[voiceon][m]
            print_output('{}, {}, Control_c, {}, 0, {}'.format(voiceon+1, lthworkingmeasure, chan, last_instrument_on[1] >> 5))
            print_output('{}, {}, Control_c, {}, 32, {}'.format(voiceon+1, lthworkingmeasure, chan, last_instrument_on[1] & 0x1f))
            print_output('{}, {}, Program_c, {}, {}'.format(voiceon+1, lthworkingmeasure, chan, last_instrument_on[0]))
            if strlast_instrument_on in extrainfo:
                print_output('{}, {}, Text_t, "{}"'.format(voiceon+1, lthworkingmeasure, extrainfo[strlast_instrument_on][0]))
            # fi
            # 125   Omni Mode On (and all notes off).
            print_output('{}, {}, Control_c, {}, 125, 0'.format(voiceon+1, lthworkingmeasure, chan))
            # 127   Set device mode to Polyphonic.
            print_output('{}, {}, Control_c, {}, 127, 0'.format(voiceon+1, lthworkingmeasure, chan))
            # 121   Reset all Controllers.
            # print_output('{}, {}, Control_c, {}, 121, 0'.format(voiceon+1, lthworkingmeasure, chan))
            #   7   Volume
            print_output('{}, {}, Control_c, {}, {}, {}'.format(voiceon+1, lthworkingmeasure, chan, 7,
                                                    intensity[m][voiceon]))
            #   5   Portamento Time to 0. (No slide between two notes subsequently, without off between.)
            print_output('{}, {}, Control_c, {}, 5, 0'.format(voiceon+1, lthworkingmeasure, chan))
            #  65   Portamento Off. Note: can still portamento - stupid standard.
            print_output('{}, {}, Control_c, {}, 65, 0'.format(voiceon+1, lthworkingmeasure, chan))
            #  68   Legato Off.
            print_output('{}, {}, Control_c, {}, 68, 0'.format(voiceon+1, lthworkingmeasure, chan))
            #  64   Hold Pedal Off
            print_output('{}, {}, Control_c, {}, {}, {}'.format(voiceon+1, lthworkingmeasure, chan, 64, 0))
            #  10   Pan position   64 is center, 0 is hard left, and 127 is hard right.
            print_output('{}, {}, Control_c, {}, {}, {}'.format(voiceon+1, lthworkingmeasure, chan, 10,
                                                    pan[m][voiceon]))
            #  91   Reverb Level
            print_output('{}, {}, Control_c, {}, {}, {}'.format(voiceon+1, lthworkingmeasure, chan, 91,
                                                    reverb[m][voiceon]))
        # fi
    # fi
    return last_instrument_on, channel, chan
# End of print_out_midi1csv_instrument

# ----------------------------------------------------------------------------
def print_out_midi1csv_tempo(m, voiceon, lthworkingmeasure, t, l):
    global tempo_speed_default
    global default_note_length
    global tempo_speed_now
    global tempo_now_note_length

    if (m in tempo_speed_now and t != tempo_speed_now[m]) or (m in tempo_now_note_length and l != tempo_now_note_length[m]):
        t = tempo_speed_now[m]
        l = tempo_now_note_length[m]
    else:
        return t, l
    # fi
    if args.fluidsynth:
        print_output("{}, {}, Tempo, {} {}".format(voiceon+1, lthworkingmeasure, t, l))
    else:
        X = int(round((60.0 * 1000000.0) / ((4.0 * l)) / t))
        print_output("{}, {}, Tempo, {}".format(voiceon+1, lthworkingmeasure, X))
    # fi
    return  t, l
# End of print_out_midi1csv_tempo

# ----------------------------------------------------------------------------
def print_out_midi1csv_keysignature(m, voiceon, lthworkingmeasure, last_keysig):
    global key_default
    global key_voice

    if lthworkingmeasure == 0 and m == '':
        last_keysig = key_default
        print_output('{}, {}, Key_signature, {}, "major"'.format(voiceon+1, lthworkingmeasure, last_keysig))
    else:
        if m in key_voice and voiceon in key_voice[m] and last_keysig != key_voice[m][voiceon]:
            last_keysig = key_voice[m][voiceon]
            print_output('{}, {}, Key_signature, {}, "major"'.format(voiceon+1, lthworkingmeasure, last_keysig))
        # fi
    # fi
    return  last_keysig
# End of print_out_midi1csv_keysignature

# ----------------------------------------------------------------------------
def print_header():
    global header
    global tempo_speed_default
    global default_note_length          # length of a beat (note)
    global args
    global vl
    global bars
    global key_voice
    global key_default
    global measure_meter
    global mlth

    if args.vertical or args.horizontal:
        l = str(Fraction(1.0 / default_note_length['']).limit_denominator(256))
        header = header + "bars    {}\n".format(bars[''])

        j = tempo_speed_default
        k = int(tempo_speed_default)
        if (j - float(k)) * 1000 == 0:
            p = str(k)
        else:
            p = tempo_speed_default
        # fi
        header = header + "tempo   {},{}\n".format(p, l)
        header = header + "key     {}".format(key_default)       # no \n, added when printed.
        for ve in range(1, len(vl) + 1):
            if ve in key_voice[''] and key_voice[''][ve] != key_default:
                header = header + "\nkey     {}  {}".format(ve, key_voice[''][ve]) # No terminating \n.
            # fi
        # rof
    elif args.midi1csv:
# 0, 0, Header, 1, 7, 480               # 480 = midi ticks per quarter note.
        print_output("0, 0, Header, 1, {}, {}".format(len(vl)+1, int(round(MIDICLICKSPERQUARTER))))
# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
# First track does all tempo's, time and key signatures, and titles.
        print_out_midi1csv_start(0)
# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
# 1, 0, Title_t, "promenade"
        for t in header:
            print_output('1, 0, Title_t, "{}"'.format(t))
        # rof
# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
# 1, 0, Key_signature, -2, "major"
        last_keysig = print_out_midi1csv_keysignature('' , 0, 0, '')
# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
        # Get the voice with the most notes.
        # Does not do goto's, but that's okay enough -- all voices should be filled.
        maxtimelth = 0
        voice = 1
        for i in tlth:
            if maxtimelth < tlth[i]:
                maxtimelth = tlth[i]
                voice = i
            # fi
        # rof
# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
# 1, 0, Time_signature, 4, 2, 48, 8
# 2, 0, Time_signature, 5, 2, 30, 8
# 2, 2400, Time_signature, 6, 2, 72, 8
#           FF 58 04 nn dd cc bb Time Signature
#       The time signature is expressed as four numbers. nn and dd represent the
#       numerator and denominator of the time signature as it would be notated.
#       The denominator is a negative power of two: 2 represents a quarter-note,
#       3 represents an eighth-note, etc.
#       The cc parameter expresses the number of MIDI clocks in a metronome click.
#       The bb parameter expresses the number of notated 32nd-notes in what MIDI
#       thinks of as a quarter-note (24 MIDI Clocks). This was added because there
#       are already multiple programs which allow the user to specify that what
#       MIDI thinks of as a quarter-note (24 clocks) is to be notated as, or
#       related to in terms of, something else. Therefore, the complete event for
#       6/8 time, where the metronome clicks every three eighth-notes, but there
#       are 24 clocks per quarter-note, 72 to the bar, would be (in hex):
#           FF 58 04 06 03 24 08
#    4/(2^2)   72
# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
        # length of each measure. Index via [voice][measure].
        lthworkingmeasure = 0
        lastmeter = ''
        lasttempospeed = ''
        lasttempo_n_l = ''
        last_keysig = ''

        for v in goto_table:
            goto_variables[v] = 0           # This voice hasn't done any goto's yet.
        # rof

        m_number = 0
        while m_number < len(meas):
            m = meas[m_number]

            lastmeter = print_out_midi1csv_ts(m, 0, lthworkingmeasure, lastmeter)
            lasttempospeed, lasttempo_n_l = print_out_midi1csv_tempo(m , 0, lthworkingmeasure, lasttempospeed, lasttempo_n_l)
            # Do not do instruments here.
            lthworkingmeasure = lthworkingmeasure + mlth[voice][m]

            if m in goto_table:             # If goto exists, process it.
                f = goto_variables[m]
                g = goto_table[m][f]
#++                print_warning_no_line("goto at end measure={} value={} new_measure={}".format(m, f, g))
                if f+1 >= len(goto_table[m]): # If should start over.
                    f = 0
                else:
                    f = f + 1
                # fi
                goto_variables[m] = f
                if g == 'x':
                    m_number = m_number + 1
                else:
                    m_number = meas.index(g)
                # fi
            else:
                m_number = m_number + 1
            # fi
        # elihw
# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
        print_out_midi1csv_end(0, lthworkingmeasure)
        return
    elif args.fluidsynth:
        # set audio.coreaudio.device coreaudio
        print_output("0, 0, FS, set audio.driver coreaudio")
        print_output("0, 0, FS, set midi.driver coremidi")
        # set synth.chorus.active off
        # set synth.cpu-cores 2
        print_output("0, 0, FS, set synth.default-soundfont /Users/m4/src/GeneralUser_GS/GeneralUser_GS.sf2")
        print_output("0, 0, FS, set synth.gain 0.5")
        print_output("0, 0, FS, set synth.midi-channels 128")
        print_output("0, 0, FS, set synth.verbose 0")
        print_output("0, 0, FS, reset")
        print_output("0, 0, FS, load /Users/m4/src/GeneralUser_GS/GeneralUser_GS.sf2")
        print_output("0, 0, FS, prog 00 000")

        for t in header:
            print_output('0, 0, FS, echo {}'.format(t))
        # rof
        return
# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
    else:                                   # ABC format
        header = "%abc\n" + header

        header += "%abc2mtex: yes\n"

        if '' in percents:
            for p in percents['']:
                header = header + p + '\n'
            # rof
        else:
            # Default printing stuff.
            header += "%%pageheight 10.5in\n"
            header += "%%staffwidth 7.0in\n"
            # header += "%%stretchlast no\n"
            header += "%%leftmargin .25in\n"
            header += "%%rightmargin .25in\n"
            header += "%%scale 0.42\n"
            header += "%%vocalfont Times-BoldItalic 13.0\n"
            header += "%%combinevoices 1\n"
        # fi
        # Must be a fraction.
        fdnl = default_note_text_fraction('')
        if fdnl == '1':
            fdnl = '1/1'
        # fi
        header = header + "L:{}\n".format(fdnl)
        header = header + "Q:{}={}\n".format(fdnl, tempo_speed_default)
        header = header + "K:{}".format(key_default)       # no \n, added when printed.
    # fi
    print_output(header)
    return
# End of print_header

# ----------------------------------------------------------------------------
def print_out_midi1csv_notes():
    global vl                                   # volume levels
    global meas                                 # measures
    global inst
    global key_default
    global tempo_speed_default
    global default_note_length                  # Default note length.
    global tempo_speed_now                      # Beats per minute for each measure.
    global tempo_now_note_length                # Note length for a beat.

    global bufs                                 # Notes.
    global bufs_length                          # Lengths for notes.
    global bufs_accidentals                     # Accidentals for notes.
    global bufs_vol                             # Volumes for notes.

    global goto_table
    global goto_variables

    global pitch                                # Offset note by this amount.

    global args
    global voices_to_do
    global voices_having_notes

    channel = 0                                 # Next midi instrument channel to use.
    chan = 0                                    # The midi channel using now (allows for repeated use).

    for voice in range(1, len(vl) + 1):
        if args.voices and args.voices != '':
            if str(voice) not in voices_to_do:
                continue
            # fi
        # fi
        if voice not in bufs:
            print_error_no_line("bufs voice dictionary is hosed (m={}, voice={}, lthworkingmeasures={})".format(m, voice, lthworkingmeasures))
            sys.exit(1)
        # fi

        # Nothing yet ...
        lastmeter = ''                          # Last meter put out.  l_instrument = 0 + args.offset
        l_instrument = -1                       # Last instrument for this voice.
        lt = ''                                 # Last tempo number of beats per minute.
        ll = ''                                 # Last tempo note type (whole,half,quarter,...).
        last_keysig = ''                        # Last key signature put out.

        print_out_midi1csv_start(voice)

        # A comment as to which musicomp voice being done.
        print_output('{}, 0, Text_t, "voice {}"'.format(voice+1, voice))

        m_number = 0                            # Start from absolute first (pre-first) measure.
        if m_number >= len(meas):
            print_error_no_line("No measures in song.")
            sys.exit(1)
        # fi
        lthworkingmeasures = 0                  # The time for event to occur.

        for v in goto_table:                    # All goto's in song.
            goto_variables[v] = 0               # This voice hasn't done any goto's yet.
        # rof

        legato_on = False                       # Legato is not on yet.
        last_note_on = ''                       # There is no note that is currently on.
        last_cc11 = 0                           # The last control 11 volume put out for voice.
        note_playing = 0                        # There is no note length to '4c4s' rest (staccato/portamento).
        note_length = 0                         # The length of the last note (4c4).
        last_acc = ''                           # No accidental to start with.

        l_instrument, channel, chan = print_out_midi1csv_instrument(meas[m_number], voice, lthworkingmeasures, l_instrument, channel, chan)
        lastmeter = print_out_midi1csv_ts(meas[m_number], voice, lthworkingmeasures, lastmeter)
        last_keysig = print_out_midi1csv_keysignature(meas[m_number], voice, lthworkingmeasures, last_keysig)
        lt, ll = print_out_midi1csv_tempo(meas[m_number], voice, lthworkingmeasures, lt, ll)

#-        # A comment as to which musicomp measure being done.
#-        print_output('{}, {}, Text_t, "measure {}"'.format(voice+1, lthworkingmeasures, meas[m_number]))
        while m_number < len(meas):             # While there are measures left to do.
            m = meas[m_number]

            if voice in vl and m in vl[voice]:
                v_vl = vl[voice][m]             # volume level for this voice/measure
            else:
                v_vl = 127                      # Probably a rest, put as full volume.
            # fi

            # Starting with first note in measure (i).
            i = 0
            while i < len(bufs[voice][m]):      # while there are notes in measure
                n = bufs[voice][m][i]           # note number
                v = bufs_vol[voice][m][i]       # volume for the next note.
                if note_length > 0:             # If there is a previous note to update length, or ...
                    # Crescendo needs current volume and next notes starting volume.
                    if 'c' in last_acc:
                        # Do crescendo between lthworkingmeasures and lthworkingmeasures+note_playing.
                        fvol = float(v_vl)      # Previous volume
                        dv = fvol - float(v)    # New volume
                        dinc = dv / float(note_length)
                        for T in range(lthworkingmeasures, lthworkingmeasures + note_playing):
                            # calculate crescendo number. If same as last, continue.
                            fvol = fvol - dinc
                            ivol = int(fvol)
                            if last_cc11 != ivol:
                                if last_note_on != '':
                                    print_output("{}, {}, Control_c, {}, 11, {}".format(voice+1, T, chan, ivol))
                                # fi
                                last_cc11 = ivol
                            # fi
                        # rof
                        if note_playing < note_length:
                            # Must turn off stacatto note before moving lthworkingmeasures.
                            if last_note_on != '':
                                print_output("{}, {}, Note_off_c, {}, {}, {}".format(voice+1, lthworkingmeasures + note_playing, chan, last_note_on, 0))
                            # fi
                            last_note_on = ''
                        # fi
                    # fi
                    lthworkingmeasures = lthworkingmeasures + note_length
                # fi

                if i == 0:
                    l_instrument, channel, chan = print_out_midi1csv_instrument(m, voice, lthworkingmeasures, l_instrument, channel, chan)
                    lastmeter = print_out_midi1csv_ts(m, voice, lthworkingmeasures, lastmeter)
                    last_keysig = print_out_midi1csv_keysignature(m, voice, lthworkingmeasures, last_keysig)
                    lt, ll = print_out_midi1csv_tempo(m, voice, lthworkingmeasures, lt, ll)
                # fi

                # If a rest - no accidentals/volumes/ can be on it.
                last_acc = bufs_accidentals[voice][m][i]    # accidental for the next note.
                note_length = bufs_length[voice][m][i]

                if n == '0' or n == 0:
                    # If a note is turned on, turn it off.
                    if last_note_on != '':
                        print_output("{}, {}, Note_off_c, {}, {}, {}".format(voice+1, lthworkingmeasures, chan, last_note_on, 0))
                        last_note_on = ''
                    # fi
                    if legato_on:
                        print_output("{}, {}, Control_c, {}, 68, {}".format(voice+1, lthworkingmeasures, chan, 0))
                        legato_on = False
                    # fi
                    # To next note. While loop checks for end of measure.
                    v_vl = bufs_vol[voice][m][i]
                    i = i + 1
                    continue
                # fi

                # The note to be turned on then off later.
                n = int(n) + pitch[m]

                if 't' in last_acc:    # This note is tied to previous.
                    if legato_on:
                        print_error_no_line("voice {} measure {} - tied note #{} ({}, {}) coming from a legato playing note ({}, {}).".format(voice, m, i+1, n, midi_value_to_note_sharp[n], last_note_on, midi_value_to_note_sharp[last_note_on]))
                        print_output("{}, {}, Control_c, {}, 68, {}".format(voice+1, lthworkingmeasures, chan, 0))
                        legato_on = False
                    # fi
                    if n != last_note_on:
                        if last_note_on == '':
                            print_error_no_line("voice {} measure {} - tied note #{} ({}, {}) is not same as '' note?.".format(voice, m, i+1, n, midi_value_to_note_sharp[n]))
                        else:
                            print_error_no_line("voice {} measure {} - tied note #{} ({}, {}) is not same as previous playing note ({}, {}).".format(voice, m, i+1, n, midi_value_to_note_sharp[n], last_note_on, midi_value_to_note_sharp[last_note_on]))
                            print_output("{}, {}, Note_off_c, {}, {}, {}".format(voice+1, lthworkingmeasures, chan, last_note_on, 0))
                        # fi
                        voices_having_notes[voice] = True
                        print_output("{}, {}, Note_on_c, {}, {}, {}".format(voice+1, lthworkingmeasures, chan, n, default_volume))
                        last_note_on = n
                    # fi
                    # Already on, good.
                else:
                    # We want a note-on here.
                    if legato_on:
                        voices_having_notes[voice] = True
                        print_output("{}, {}, Note_on_c, {}, {}, {}".format(voice+1, lthworkingmeasures, chan, n, default_volume))
                    # fi
                    if last_note_on != '':                  # If not a rest, or note off.
                        print_output("{}, {}, Note_off_c, {}, {}, {}".format(voice+1, lthworkingmeasures, chan, last_note_on, 0))
                    # fi
                    if not legato_on:
                        voices_having_notes[voice] = True
                        print_output("{}, {}, Note_on_c, {}, {}, {}".format(voice+1, lthworkingmeasures, chan, n, default_volume))
                    # fi
                    last_note_on = n
                    # fi
                # fi

                # If legato, turn it on, if not already on.
                if 'l' in last_acc:
                    if not legato_on:
                        print_output("{}, {}, Control_c, {}, 68, {}".format(voice+1, lthworkingmeasures, chan, 127))
                        legato_on = True
                    # fi
                else:
                    if legato_on:
                        print_output("{}, {}, Control_c, {}, 68, {}".format(voice+1, lthworkingmeasures, chan, 0))
                        legato_on = False
                    # fi
                # fi

                v_vl = bufs_vol[voice][m][i]
                if last_cc11 !=  v_vl:
                    if last_note_on != '':
                        print_output("{}, {}, Control_c, {}, 11, {}".format(voice+1, lthworkingmeasures, chan, v_vl))
                    # fi
                    last_cc11 = v_vl
                # fi

                # note_playing will eventually be when to turn note off.
                note_playing = note_length
                if 's' in last_acc:
                    if 'l' in last_acc:
                        # Really should be a fixed length from end of note? Might just work without?
                        # note_playing = int(round(29.0 * (note_playing / 30.0)))
                        # note_playing = note_playing - 8
                        note_playing = note_playing - 4
                        legato_on = False
                    else:
                        note_playing = int(note_playing / 2.0)
                    # fi
                # fi

                i = i + 1
            # elihw

            # Go to next measure (or wherever a goto says, if it exists).
            if m in goto_table:
                f = goto_variables[m]
                g = goto_table[m][f]
                f = f + 1
                if f >= len(goto_table[m]):         # If should start over.
                    f = 0
                # fi
                goto_variables[m] = f
                if g == 'x':
                    m_number = m_number + 1
                else:
                    m_number = meas.index(g)
                # fi
            else:
                m_number = m_number + 1
            # fi
            if m_number < len(meas):
                m = meas[m_number]
            else:
                m = 'EOF'
            # fi
#--            # A comment as to which musicomp measure being done.
#--            print_output('{}, {}, Text_t, "measure {}"'.format(voice+1, lthworkingmeasures, m))
        # elihw

        # No more notes to turn on -- might be one already on.
        if note_length > 0:             # If there is a previous note to update length, or ...
            # Cannot crescendo to last note - don't have volume -- or do we?
            # Crescendo needs current volume and next notes starting volume.
            if 'c' in last_acc:
                # Do crescendo between lthworkingmeasures and lthworkingmeasures+note_playing.
                fvol = float(v_vl)      # Previous volume
                # Use previous values for this one.
                for T in range(lthworkingmeasures, lthworkingmeasures + note_playing):
                    # calculate crescendo number. If same as last, continue.
                    fvol = fvol - dinc
                    if fvol < 1:
                        fvol = 0
                    elif fvol > 126.49:
                        fvol = 127
                    # fi
                    ivol = int(fvol)
                    if last_cc11 !=  ivol:
                        if last_note_on != '':
                            print_output("{}, {}, Control_c, {}, 11, {}".format(voice+1, T, chan, ivol))
                        # fi
                        last_cc11 = ivol
                    # fi
                # rof
                if note_playing < note_length:
                    # Must turn off stacatto note before moving lthworkingmeasures.
                    if last_note_on != '':
                        print_output("{}, {}, Note_off_c, {}, {}, {}".format(voice+1, lthworkingmeasures + note_playing, chan, last_note_on, 0))
                    # fi
                    last_note_on = ''
                # fi
            # fi
        # fi
        lthworkingmeasures = lthworkingmeasures + note_length

        if legato_on:
            legato_on = False
            print_output("{}, {}, Control_c, {}, 68, {}".format(voice+1, lthworkingmeasures, chan, 0))
        # fi
        if last_note_on != '':
            print_output("{}, {}, Note_off_c, {}, {}, {}".format(voice+1, lthworkingmeasures, chan, last_note_on, 0))
            last_note_on = ''
        # fi
        print_out_midi1csv_end(voice, lthworkingmeasures)
    # rof   voice in range
    return
#   End of print_out_midi1csv_notes

# ----------------------------------------------------------------------------
global default_little_time
default_little_time = 0.1
global this_time
this_time = []
# ----------------------------------------------------------------------------
def process_fs_check(what, lth, min_next, vtlines, tempo_s, tempo_l):
    global this_time

    for voice, lines in vtlines.items():
        v = int(voice)
        if this_time[v] >= len(lines):
            continue
        # fi
        t = lines[this_time[v]].split(' ', 1) # 2 elements
        time = float(t[0])
        while time <= min_next:
            str = t[1]
            if str == 'End_track ':
                pass
            elif str[0:lth] == what:
                really_print_output("{}".format(str))
            elif str[0:5] == 'echo ':
                really_print_output("{}".format(str))
            elif str[0:7] == 'select ':
                really_print_output("{}".format(str))
            elif str[0:4] == 'set ':
                really_print_output("{}".format(str))
            elif str[0:6] == 'reset ':
                really_print_output("{}".format(str))
            elif str[0:5] == 'load ':
                really_print_output("{}".format(str))
            elif str[0:5] == 'prog ':
                really_print_output("{}".format(str))
            elif str[0:6] == 'tempo ':
                x = str[6:].split()
                if len(x) < 1 or len(x) > 2:
                    print_error_no_line("Tempo needs a speed - line={}".format(t))
                elif len(x) == 1:
                    #    1/(### / (60.0 * 1000000.0)) = 60.02400 = t              for l = 4 (quarter note).
                    tempo_s = int(1/(int(x[0]) / (60.0 * 1000000.0)))
                    tempo_l = 4
                else:
                    tempo_s, tempo_l = str[6:].split()
                # fi
#--                really_print_output("echo tempo {} {}".format(tempo_s, tempo_l))
            elif str[0:3] == 'cc ':
                break
            elif str[0:8] == 'noteoff ':
                break
            elif str[0:7] == 'noteon ':
                break
            else:
                print_error_no_line("Unrecognized - line={}".format(t))
                error_now = error_now + 1
                break
            # fi
            this_time[v] += 1
            if this_time[v] >= len(lines):
                break
            # fi
            t = lines[this_time[v]].split(' ', 1) # 2 elements
            time = float(t[0])
        # elihw
    # rof
    return tempo_s, tempo_l
#   End of process_fs_check

# ----------------------------------------------------------------------------
# Thinking if we get each of the tracks in csvmidi format, in array, then go
# through them and order by:
    # track, time: In array order for each track.
    #       controls
    #       noteoff
    #       noteon
    # ... is that all that is needed? (And obvious format change.)

def print_out_fluidsynth():
    global array_of_lines
    global this_time
    global default_little_time

    change_name = {
        'Text_t': 'echo',
        'Note_on_c': 'noteon',
        'Note_off_c': 'noteoff',
        'Tempo': 'tempo',
        'Time_signature': 'echo meter',
        'Key_signature': 'echo key',
        'Control_c': 'cc',
        'End_of_file': 'echo End_of_file',
        'Title_t': 'echo Title_t',
        # Track, Time, MIDI_port, Number This meta-event specifies that subsequent events in
        # the Track should be sent to MIDI port (bus) Number, between 0 and 255. This meta-event 
        # usually appears at the start of a track with Time zero, but may appear within a track
        # should the need arise to change the port while the track is being played.
        'MIDI_port': 'echo MIDI_port',
    }

    v_t_lines = { }
    tempo_s = 60
    tempo_l = 0.5

    max_midi_time = 0

    voices = 0
    for i in array_of_lines:
        # "2, 5280, Note_on_c, 0, 43, 127"
        t = i.split(', ', 3)        # 4 elements.
        t[0] = t[0].strip()
        if t[0] not in v_t_lines:
            v_t_lines[t[0]] = []
        # fi
        if 2 > len(t) or t[2] == "Start_track":
            continue
        # fi
        t[1] = t[1].strip()
        t[2] = t[2].strip()
        if t[2] in change_name:
            t[2] = change_name[t[2]]
            if t[2][0:4] == 'echo' or t[3][0:9] == '"measure ' or t[3][0:7] == '"voice ':
                continue
            # fi
            t[3] = t[3].strip()
        elif t[2] == 'FS':
            t[3] = t[3].strip()
            t[2] = t[3]
            t[3] = ''
        elif t[2] == 'Program_c':
# select chan sfont bank prog
            t[2] = 'select'
            t[3] = t[3].strip()
            s = t[3].split(", ", 1) # 2 elements
            t[3] = s[0] + ' 1 0 ' + s[1]
        elif t[2] == 'End_track':
            if max_midi_time < float(t[1]):
                max_midi_time = float(t[1])
            # fi
            t.append('')
        else:
            print_error_no_line("Unexpected midi command - t={}".format(t))
        # fi
        if voices < int(t[0]):
            voices = int(t[0])
        # fi
        t[3] = t[3].replace(',', '').strip()
        v_t_lines[t[0]].append(t[1] + ' ' + t[2] + ' ' + t[3])
    # rof
    current_time = -1
    this_time = []
    for v in range(0, voices+1):
        this_time.append(0)
    # rof
    while current_time < max_midi_time:
        # Find smallest time difference.
        min_next = max_midi_time + 1
        for voice, lines in v_t_lines.items():
            v = int(voice)
            if this_time[v] >= len(lines):
                continue
            # fi
            t = lines[this_time[v]].split(' ', 1) # 2 elements
            time = float(t[0])
            str = t[1]
            if min_next > time:
                min_next = time
            # fi
        # rof
        if current_time >= 0 and (min_next - current_time) != 0:
            ms_1000 = float(min_next - current_time)
            if ms_1000 < default_little_time:
                ms_1000 = default_little_time
            else:
                # 480 => 250
                ms_1000 = ms_1000 * 1000.0
                ms_1000 = ms_1000 / ((float(tempo_s)/60.0) * (float(tempo_l) * 4.0))
                ms_1000 = int((ms_1000 / 480.0) * 1000)
                ms_1000 = float(ms_1000) / 1000.0
            # fi
            really_print_output("sleep {}".format(ms_1000))
        # fi
        current_time = min_next
        # Move all this_time voices forward past min_next.
# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
        tempo_s, tempo_l = process_fs_check('cc ', 3, min_next, v_t_lines, tempo_s, tempo_l)
        tempo_s, tempo_l = process_fs_check('noteoff ', 8, min_next, v_t_lines, tempo_s, tempo_l)
        tempo_s, tempo_l = process_fs_check('noteon ', 7, min_next, v_t_lines, tempo_s, tempo_l)
    # elihw

    really_print_output("quit")
    return
#   End of print_out_fluidsynth

# ----------------------------------------------------------------------------
def pre_move_note_before(prev_m, m, voice, l, n, a, v):
    global bufs
    global bufs_length
    global bufs_vol
    global bufs_accidentals
    global mlth                         # measure length dictionary
    global tlth

    bufs[voice][prev_m].append(n)
    bufs_length[voice][prev_m].append(l)
    bufs_accidentals[voice][prev_m].append(a)
    bufs_vol[voice][prev_m].append(v)

    tlth[voice] = tlth[voice] + l
    if prev_m not in mlth[voice]:
        mlth[voice][prev_m] = 0
    # fi
    mlth[voice][prev_m] = mlth[voice][prev_m] + l
    return
#   End of pre_move_note_before

# ----------------------------------------------------------------------------
def pre_shift_measure(prev_m, m):
    global args
    global vl
    global bufs
    global bufs_length
    global bufs_vol
    global bufs_accidentals
    global mlth                         # measure length dictionary
    global tlth

    for voice in range(1, len(vl)+1):
        s = args.shift
        if len(bufs[voice][m]) == 0:
            # If nothing in voice for this measure, go to next voice.
            continue
        # fi
        while s > 0:
            l =  bufs_length[voice][m][0]       # Length of note.
            n =  bufs[voice][m][0]              # Note (plus pre and post?).
            a = bufs_accidentals[voice][m][0]   # Accidentals -- oh my ...
            v = bufs_vol[voice][m][0]
            if l <= s:
                if prev_m is not None:
                    # Move to previous measure.
                    pre_move_note_before(prev_m, m, voice, l, n, a, v)
                else:
                    print_warning("pre_shift_measure - tossing voice={} m={} n={} l={} a={} v={}".  format(voice, m, n, l, a, v), 'pass2')
                # fi
                # Remove from current measure.
                bufs[voice][m].pop(0)
                bufs_length[voice][m].pop(0)
                bufs_accidentals[voice][m].pop(0)
                bufs_vol[voice][m].pop(0)
                tlth[voice] = tlth[voice] - l
                mlth[voice][m] = mlth[voice][m] - l
                s = s - l
                if s > 0:
                    continue
                # fi
                break
            # fi
            # l > s   : Need to break the note into two with a tie -- staccato? Trill? Sequence? *yuck*
            if 's' in a or 'b' in a:
                print_error("pre_shift_measure - cannot break up a staccato note: voice={} m={} n={} l={} a={} v={}".format(voice, m, n, l, a, v), 'pass2')
                return
            # fi
            if n[0] == 's' or n[0] == 't':
                print_error("pre_shift_measure - cannot break up a trill or sequence: voice={} m={} n={} l={} a={} v={}".format(voice, m, n, l, a, v), 'pass2')
                return
            # fi
            if n[0] == 'v' or n[0] == 'c' or n[0] == 'd':
                print_error("pre_shift_measure - cannot break up a vol(), cresc(), or dimin(): voice={} m={} n={} l={} a={} v={}".format(voice, m, n, l, a, v), 'pass2')
                return
            # fi
            if args.vertical:
                if 't' not in a:                    # if not tied, tie this one.
                    a = a + 't'
                # fi
            # fi
            pre_move_note_before(prev_m, m, voice, s, n, a, v)
            # Reduce length in current measure.
            # bufs[voice][m][0]                     # note remains the same.
            bufs_length[voice][m][0] = l - s        # Reduce note length.
            if args.horizontal:
                if 't' not in a:                    # if not tied, tie this one.
                    bufs_accidentals[voice][m][0] = a + 't'
                # fi
            # fi
            # bufs_vol[voice][m][0]                 # volume remains the same.
            tlth[voice] = tlth[voice] - s           # Length reduced.
            mlth[voice][m] = mlth[voice][m] - s
            return
        # elihw
    # rof
    return
#   End of pre_shift_measure

# ----------------------------------------------------------------------------
def pre_shift():
    '''
    This routine will shift measures forward (add rest at beginning of song),
    or remove notes/rests from beginning of song -- by args.shift value (float).
    '''
    global vl                               # volume levels
    global meas                             # measures
    global args
    global pitch

    if not args.vertical and not args.horizontal:
        return
    # fi
    if args.shift < 0:
        print_error('Shifting to left (upwards) not done yet -- args.shift={}'.format(args.shift), 'pass2')
    # fi
    # Only for outputting vertical and horizontal format.

    prev_m = None
    for i in range(0, len(meas)):
        m = meas[i]
        pre_shift_measure(prev_m, m)
        prev_m = m
    # rof
    return
#   End of pre_shift

# ----------------------------------------------------------------------------
def check_staves_notes_order():
    global staves
    global meas
    global mlth
    global vl
    global bufs_length
    global bufs
    global bufs_accidentals
    global key_voice
    global key_sig
    global args

    # The idea is to go through the voices in array staves, checking that the
    # first listed one(s) are higher notes than the latter listed ones.
    # This needs to occur something like with the --horizontal option.
    # Perhaps the --midi can be done.
    # I don't know if the --abc can be done.

    for i in range(0, len(meas)):
        m = meas[i]
        ml = mlth[1][m]
        for voice in range(1, len(vl)+1):
            if m in mlth[voice]:
                if mlth[voice][m] != ml:
                    print_error_no_line("voice#{} measure#{} not same length({}) as 1st({})".format(voice, m, mlth[voice][m], ml))
                # fi
                ml = max(mlth[voice][m], ml)
            else:
                print_error_no_line("voice#{} not in measure#{}".format(voice, m))
            # fi
        # rof

        workingtime = [ 0 ]                         # Zero is ignored.
        working= [ 0 ]
        for voice in range(1, len(vl)+1):
            working.append(0)
            workingtime.append(0)
        # rof

        now = 0
        while now < ml:
            notes = [ ]
            for voice in range(1, len(vl)+1):
                i = workingtime[voice]
                m4_note = ''
                if i <= now:
                    j = working[voice]
                    l =  bufs_length[voice][m][j]

                    if l in legal_mc_notes:
                        lth = legal_mc_notes[l] + bufs_accidentals[voice][m][j]
                    else:
                        lth = str(Fraction(l).limit_denominator(256))
                        if '/' in lth:
                            lth = '(' + str(l) + ')'
                        # fi
                        lth = lth + bufs_accidentals[voice][m][j]
                    # fi

                    m4_note = bufs[voice][m][j].strip()
                    if args.vertical or args.horizontal:
                        saveargsh = args.horizontal
                        saveargsv = args.vertical
                        saveargsm = args.midi1csv
                        saveargfluidsynth = args.fluidsynth
                        saveargabc = args.abc
                        savekeyvoice = key_voice[measure_on][1]
                        k = key_sig[savekeyvoice]      # Convert to number.
                        # Set to midi format -- so we have a value.
                        args.horizontal = False
                        args.vertical = False
                        args.midi1csv = True
                        args.fluidsynth = False
                        args.abc = False
                        key_voice[measure_on][1] = k
                        prenote = ''
                        postnote = ''
                        onenotevolume = None
                        m4_note, onenotevolume, prenote, postnote = do_vol_cresc(m4_note, voice, 'check_staves_notes_order', prenote, postnote, onenotevolume)
                        m4_therest, m4_thenote, m4_typenote = getnote(m4_note, 1, 'check_staves_notes_order')
                        args.horizontal = saveargsh
                        args.vertical = saveargsv
                        args.midi1csv = saveargsm
                        args.abc = saveargabc
                        args.fluidsynth = saveargfluidsynth
#                        if onenotevolume is None:
#                            return
#                        # fi
                        key_voice[measure_on][1] = savekeyvoice
                        if m4_typenote == normal_note:
                            m4_note = m4_thenote
                        else:
#--                            print_debug("m4_note={} m4_typenote={}".format(m4_note, m4_typenote))
                            m4_note = ''
                        # fi
                    #-- elif args.midi1csv or args.fluidsynth:
                    #-- else:       # ABC
                    #--     pass
                    # fi

                    workingtime[voice] = workingtime[voice] + l
                    working[voice] = working[voice] + 1
                # fi
                if m4_note == '0' or m4_note == 0:
                    m4_note = ''
                # fi
                notes.append(m4_note)
            # rof

            for l in range(0, len(staves)):
                first = -1
                for n in range(0, len(staves[l])):
                    o = int(staves[l][n]) -1
                    if o >= len(notes):
                        print_error_no_line("m:{} voice={} not in notes.".format(m, o+1))
                        continue
                    # fi
                    if notes[o] != '' and notes[o] != 0:
                        if first < 0:
                            first_note = int(notes[o]) - xpose[o+1]
                            if first_note not in midi_value_to_note_sharp:
                                print_error_no_line("not in midi_value_to_note_sharp")
                                break
                            # fi
                            n1 = midi_value_to_note_sharp[first_note]
                            first = o
                            continue
                        # fi
                        tn = int(notes[o]) - xpose[o+1]
                        if tn > first_note:
                            n2 = midi_value_to_note_sharp[tn]
                            print_warning_no_line("m:{} v{} note {}({}) is greater than v{} note {}({})".format(m, o+1, tn, n2, first+1, first_note, n1))
                            break
                    # fi
                # rof
            # rof

            nextmin = 999999
            for voice in range(1, len(vl)+1):
                if workingtime[voice] < nextmin:
                    nextmin = workingtime[voice]
                # fi
            # rof
            now = nextmin
        # elihw
    # rof
#   End of check_staves_notes_order

# ----------------------------------------------------------------------------
def check_voices_without_notes():
    global vl
    global voices_having_notes

    for v in vl:
        if v not in voices_having_notes:
            print_warning_no_line("voice {} does not have any notes.".format(v))
        # fi
    # rof
#   End of check_voices_without_notes

# ----------------------------------------------------------------------------
def do_pass2():
    global meas                             # measures
    global args
    global bufs_tie_next
    global bufs_legato_next
    global vl
    global ifdepth
    global macro_defining
    global macro_executing_depth
    global errors_happened
    global goto_table
    global staves

    # Check that song finishes 'reasonably'.
    if ifdepth > 0:
        print_warning_no_line("Inside an if block (depth={}) when end of file or cstop* reached".format(ifdepth))
    # fi
    if macro_defining is not None:
        print_error_no_line("Inside defining macro {}, no endm reached.".format(macro_defining))
    # fi
    if len(macro_executing_depth) > 0:
        print_error_no_line("Processing macro depth is {}.".format(macro_executing_depth))
    # fi

    e = False
    for m in goto_table:                # The measures with a goto in it.
        for g in goto_table[m]:         # The goto measures as arguments.
            if g != 'x':                # "x" is okay, goto next measure.
                if g not in meas:       # unknown measure ...
                    print_error_no_line("Checking goto's values, '{}' not in measures.".format(g))
                    e = True            # Error occurred.
                    errors_happened = errors_happened + 1
                # fi
            # fi
        # rof
    # rof
    if e:
        sys.exit(errors_happened)
    # fi

    # Fix other voices before continuing to process.
    fill_voice_mlth(True, "do_pass2")             # Need to make measure for other voices up to here "mlth".

    # First get the empty measures to have rests of appropriate length.
    # All measures have all voices with same length -- even if some are rests.
    for i in range(0, len(meas)):
        m = meas[i]
        for voice in range(1, len(vl) +1):
            rests_in_empty_measure_voices(m, voice)
            if bufs_tie_next[voice] != '':
                print_error_no_line("voice {} ends with a tie".format(voice))
                bufs_tie_next[voice] = ''
            # fi
            bufs_legato_next[voice] = ''
        # rof
    # rof

    if len(staves) != 0:
        if args.vertical or args.horizontal:
            check_staves_notes_order()
        elif args.midi1csv or args.fluidsynth:
            check_staves_notes_order()
        else:       # ABC
            pass
        # fi
    # fi

    if args.shift and args.shift != 0:
        pre_shift()
    # fi

    # Now print out the file.
    print_header()

    if args.vertical or args.horizontal:
        print_out_v_or_h()
    elif args.midi1csv or args.fluidsynth:
        if not do_csv_read:
            print_out_midi1csv_notes()
            check_voices_without_notes()
        # fi
    else:       # ABC
        print_out_abc()
        print_output("")
    # fi

    # End of song processing.
    if args.vertical or args.horizontal:
        print_output("cstop*")
    elif args.midi1csv:
        print_output("0, 0, End_of_file")
    elif args.fluidsynth:
        print_output("quit")
        print_out_fluidsynth()
    # else:     # ABC
    # fi
    sys.exit(errors_happened)
# End of do_pass2

# ----------------------------------------------------------------------------
# Get a line. Put it in "line" and return it.
def get_line():
    global linecount
    global args
    global file_name
    global macro_executing_depth
    global macro_executing_args
    global macro_line
    global macro_buffer                 # Name of macro, array of lines for macro.
    global macro_arguments              # Name of macro, array of arguments for macro.
    global errors_happened

    if macro_executing_depth != []:
        l = len(macro_executing_depth)
        the_macro = macro_executing_depth[-1]
        macrodepth = len(macro_executing_depth)
        linenumber = macro_line[macrodepth]
        lines = macro_buffer[the_macro]
        if linenumber >= len(lines):
            p = macro_executing_depth.pop()
            del macro_line[l]
            del macro_executing_args[l]
            return '', ''
        # fi
        line = macro_buffer[the_macro][linenumber]
        def_args = macro_arguments[the_macro]
        rep_args = macro_executing_args[l]
        for j in range(0, len(def_args)):
            line = line.replace(def_args[j], rep_args[j])
        # rof
        macro_line[macrodepth] = linenumber + 1
        line = line.replace("\t", ' ')              # tabs to spaces
        return line, ''
    # fi

    while True:
        try:
            if args.rest and len(args.rest) >= 1:
                line = file_name.readline()
            else:
                if sys.stdin.isatty():
                    if sys.platform == 'darwin':
                        input('input> ')
                        line = readline.get_line_buffer()
                    else:
                        line = input('input> ')
                    # fi
                else:
                    line = sys.stdin.readline()
                # fi
            # fi
            if line is None or line == '':
                sys.exit(errors_happened)
            # fi
            linecount = linecount + 1
            if line:
                commentdollardollar = ''
                if '$$' in line:
                    # delete anything from $$ onwards.
                    commentdollardollar = re.sub(r'^.*[$][$]', '$$', line, count=1)
                    commentdollardollar = commentdollardollar.rstrip()  # trailing spaces gone
                    line = re.sub(r'[$][$].*$', '', line)
                # fi
                # Convert tabs to spaces.
                line = line.replace("\t", ' ')
                line = line.rstrip()                                    # trailing spaces gone.
                # NOTDONEYET, the input from Plato Printouts where character ' is a shift.
                # Convert ' followed by something as a "shift".  '; = :   'a = A
                return line, commentdollardollar
            # fi
        except EOFError:
            pass            # print("Read gave EOF", file=sys.stderr, flush=True)
        except SystemExit:
            pass            # print("Read gave system exit", file=sys.stderr, flush=True)
        except KeyboardInterrupt:
            print_error_no_line("Read got keyboard interrupt")
        except:
            print_error_no_line("Read got a processing error")
            print("    ", sys.exc_info()[0], sys.exc_info, file=sys.stderr, flush=True)
        # yrt
        break
    # elihw
    do_pass2()
    sys.exit(errors_happened)
# End of get_line

# ----------------------------------------------------------------------------
def split_line(line):
    t = None
    if line:
        # Split line on spaces, then process line.
        while True:
            t = line.split(' ', 1)
            if t and t[0] and len(t) == 2 and t[1]:
                t[1] = t[1].strip()
            # fi
            if t and t[0] == '.':
                # If command == '.' toss '.'
                if len(t) == 2 and t[1]:
                    line = t[1]
                else:
                    t = None
                    line = None
                    break
                # fi
                continue
            # fi
            break
        # elihw
    # fi
    return(t, line)
# End of split_line

# ----------------------------------------------------------------------------
def get_list_sep_rem(string):
    strg = sep = rem = ''
    for i in range(0, len(string)):
        c = string[i]                       # Character in string
        if c.isalpha():                     # [a-zA-Z]
            if i != 0 and strg.replace('.', '', 1).isdigit():    # number followed by letter, stop.
                sep = None
                rem = string[i:]            # the rest of the string, including this character.
                break
            # fi
            strg = strg + c
        elif c.isdigit() or c == '.':       # current is a digit, see if rest are.
            if strg or strg == '':
                strg = strg + c
                continue
            elif strg.isdigit():             # number followed by number, good.
                strg = strg + c
                continue
            elif strg.replace('.', '', 1).isdigit() and c.isdigit():   # floating number followed by number, good.
                strg = strg + c
                continue
            else:
                print_error("Two periods in a number not allowed", string)
                return None, None, None
            # fi
        else:
            sep = c
            rem = string[i+1:]              # the rest of the string, including this character.
            break
        # fi
    # rof
    return(strg, sep, rem)
# End of get_list_sep_rem

# ----------------------------------------------------------------------------
# Calculate values here.
# Returns:
#   value   -- So far computed value
#   type_error -- type of error

def is_float(strg):
    tree = calculate.parse(strg)            # parse the string

    if tree is not None and len(tree) == 2:
        if tree[0] is not None and tree[0].startswith('ERROR'):
            sexpr = tree[0]
            return strg, sexpr
        # fi
        if tree[1] == '.':
            return strg, "bad input to calculator"
        # fi
        try:
            sexpr = float(tree[1])
            return sexpr, None
        except:
            return strg, "bad input to calculator"
    # fi
    return None, None
# End of is_float

# ----------------------------------------------------------------------------
def put_on_bufs(onvoice, p_meas, prenote, abc_note, timeofnote, append_tie, onetimevolume, postnote, line):
    global tlth
    global mlth
    global bufs
    global bufs_length
    global bufs_accidentals
    global bufs_tie_next
    global bufs_legato_next
    global running_vl
    global DECORATIONS
    global args
    global bufs_vol
    global cresc_direction
    global cresc_time
    global cresc_volume
    global vlprint

    if type(abc_note) is int:
        abc_note = str(abc_note)
    # fi
    if abc_note == 'r' and append_tie != '':
        print_warning("put_on_bufs - voice {} measure {} rest and accidentals={}".format(onvoice, p_meas, append_tie), line)
        append_tie = ''
    # fi
    tlth[onvoice] = tlth[onvoice] + timeofnote
    if p_meas not in mlth[onvoice]:
        mlth[onvoice][p_meas] = 0
    # fi
    mlth[onvoice][p_meas] = mlth[onvoice][p_meas] + timeofnote

    if onvoice not in bufs:
        bufs[onvoice] = {}
        bufs_length[onvoice] = {}
        bufs_accidentals[onvoice] = {}
        bufs_tie_next[onvoice] = ''
        bufs_legato_next[onvoice] = ''
        bufs_vol[onvoice] = {}
    # fi
    if onetimevolume is None:
        if onvoice in running_vl and p_meas in running_vl[onvoice]:
            onetimevolume = running_vl[onvoice][p_meas]
        else:
            onetimevolume = 127                 # Probably a rest, put as full volume.
        # fi
    # fi
    if p_meas not in bufs[onvoice]:
        bufs_vol[onvoice][p_meas] = [ onetimevolume ]
        if args.horizontal or args.vertical:
            bufs[onvoice][p_meas] = [prenote + abc_note]
            bufs_length[onvoice][p_meas] = [timeofnote]
            bufs_accidentals[onvoice][p_meas] = [append_tie]
        elif args.midi1csv or args.fluidsynth:
            bufs[onvoice][p_meas] = [abc_note]
            bufs_length[onvoice][p_meas] = [timeofnote]
            if cresc_time[onvoice] != 0:
                append_tie = append_tie + 'c'
            # fi
            bufs_accidentals[onvoice][p_meas] = [append_tie]
        else:           # ABC
            bufs[onvoice][p_meas] = prenote + abc_note + postnote
        # fi
    else:
        bufs_vol[onvoice][p_meas].append(onetimevolume)
        if args.vertical or args.horizontal:
            bufs[onvoice][p_meas].append(prenote + abc_note)
            bufs_length[onvoice][p_meas].append(timeofnote)
            bufs_accidentals[onvoice][p_meas].append(append_tie)
        elif args.midi1csv or args.fluidsynth:
            bufs[onvoice][p_meas].append(abc_note)
            bufs_length[onvoice][p_meas].append(timeofnote)
            if cresc_time[onvoice] != 0:
                append_tie = append_tie + 'c'
            # fi
            bufs_accidentals[onvoice][p_meas].append(append_tie)
        else:           # ABC
            bufs[onvoice][p_meas] = bufs[onvoice][p_meas] + prenote + abc_note + postnote
        # fi
    # fi

    # If crescendo happening, do it.
    if cresc_time[onvoice] == 0:
        return
    # fi

    if cresc_time[onvoice] <= timeofnote:
        running_vl[onvoice][p_meas] = cresc_volume[onvoice]
        cresc_time[onvoice] = 0
        if args.vertical or args.horizontal or args.midi1csv or args.fluidsynth:
            pass
        else:
            j = vol_to_vlprint_round(cresc_volume[onvoice])
            if cresc_direction[onvoice]:
                k = 'crescendo)'
            else:
                k = 'diminuendo)'
            # fi
            bufs[onvoice][p_meas] = bufs[onvoice][p_meas] + \
                                    DECORATIONS + vlprint[j] + DECORATIONS + \
                                    DECORATIONS + k + DECORATIONS
        # fi
        return
    # fi

    dt = cresc_time[onvoice] + 0.0
    if not args.vertical and not args.horizontal:
        v =  cresc_volume[onvoice] - running_vl[onvoice][p_meas] + 0.0
        x1 = v / dt                         # total  1920/48 = 4
        x2 = x1 * timeofnote                # x2 = x1 * timeofnote
        running_vl[onvoice][p_meas] = running_vl[onvoice][p_meas] + int(x2)
    # fi
    cresc_time[onvoice] = cresc_time[onvoice] - timeofnote

    return
# End of put_on_bufs

# ----------------------------------------------------------------------------
def instak(onvoice, p_meas, prenote, thenote, timeofnote, append_tie, line, onenotevolume, postnote):
    global args

    if args.midi1csv or args.fluidsynth:
        put_on_bufs(onvoice, p_meas, prenote, thenote,
                    int(round(timeofnote * MIDICLICKSPERQUARTER * 4)), append_tie, onenotevolume,
                    postnote, line)
        return
    # fi

    lengthl, lengthf, ifokay = get_time_stak(timeofnote, line, onvoice)
    if ifokay == -1:                    # if time is error
        return
    # fi

    j = 1
    q = 0
    if args.horizontal or args.vertical:
        if thenote == 'r':
            append_tie = ''
        # fi
        if ifokay == 1:                 # Did not fit properly.
            q = timeofnote
            put_on_bufs(onvoice, p_meas, prenote, thenote, q, append_tie, onenotevolume, postnote, line)
            return
        # fi
    # fi

    for l in lengthl:
        if args.horizontal:
            # Length done elsewise, and accidentals elsewise too.
            q = lengthf[j-1]
            if thenote == 'r':
                append_tie = ''
            # fi
            put_on_bufs(onvoice, p_meas, prenote, thenote, q, append_tie, onenotevolume, postnote, line)
            if thenote == 'r':
                append_tie = ''
            else:
                append_tie = 't'
            # fi
            j = j + 1
        elif args.vertical:
            q = lengthf[j-1]
            # tie goes on one before
            if j == len(lengthl):           # last one gets passed in append_tie note.
                put_on_bufs(onvoice, p_meas, prenote, thenote, q, append_tie, onenotevolume, postnote, line)
            elif j < len(lengthl):
                put_on_bufs(onvoice, p_meas, prenote, thenote, q, 't', onenotevolume, postnote, line)
            # fi
            if thenote == 'r':
                append_tie = ''
            else:
                append_tie = 't'
            # fi
            j = j + 1
        else:           # ABC
            if j != len(lengthl) and thenote != 'z':
                abc_note = thenote + l + '-'
            else:
                abc_note = thenote + l + append_tie
            # fi
            q = lengthf[j-1]
            put_on_bufs(onvoice, p_meas, prenote, abc_note, q, append_tie, onenotevolume, postnote, line)
            j = j + 1
        # fi
        prenote = ''
    # rof
    return
# End of instak

# ----------------------------------------------------------------------------
# Make all voices match with rests, etc. The ones we have are now to be processed.
# Need to make measure for all known voices up to here "mlth". (Add rests.)
def fill_voice_mlth(meter_check, line):
    global measure_meter_value
    global measure_on
    global vl
    global mlth
    global tlth
    global args
    global meas
    global cis

    maxvoice = len(vl) + 1
    for p_meas in meas:
        m = 0
        for i in range(1, maxvoice):
            if p_meas not in mlth[i]:
                mlth[i][p_meas] = 0
            # fi
            m = max(mlth[i][p_meas], m)
        # rof
        # Put out rests for smaller in measure.
        for i in range(1, maxvoice):
            x =  mlth[i][p_meas]            # time short
            l = m - x                       # time short
            nl = x / (MIDICLICKSPERQUARTER * 4.0)
            if meter_check and measure_on == p_meas and measure_meter_value != nl and x != 0 and (args.midi1csv or args.fluidsynth):
                print_warning("fill_voice_mlth - measure={} voice={} measure_meter_value={} nl={} x={}".format(measure_on, i, measure_meter_value, nl, x), line)
            # fi
            if l > 0 :                      # if short, need a rest.
                if cis == 0 and (args.midi1csv or args.fluidsynth):
                    nl = (MIDICLICKSPERQUARTER * 4) / l
                    print_warning("fill_voice_mlth - l={} ({}) voice={} measure={} cis={}".format(l, nl, i, p_meas, cis), line)
                # fi
                if args.horizontal or args.vertical:
                    instak(i, p_meas, '', 'r', l , '', line, None, '')
                elif args.midi1csv or args.fluidsynth:
                    instak(i, p_meas, '', 0, l / (MIDICLICKSPERQUARTER * 4) , '', line, None, '')
                else:           # ABC
                    instak(i, p_meas, '', 'z', l , '', line, None, '')
                # fi
            # fi
        # rof
    # rof
    # Set total for voice to max of all.
    t = 0
    for i in range(1, maxvoice):
        t = max(tlth[i], t)
    # rof
    for i in range(1, maxvoice):
        tlth[i] = t                     # Total for all voices is now max of all.
    # rof
    return
# End of fill_voice_mlth

# ----------------------------------------------------------------------------
# wline = 2..4
#          l
#           l+1
#            l+2
# Separate arguments for argument.
def arglist(wline, line, integers):
    newline = []
    # break into arguments.
    newstr = ''
    np = 0                              # ()
    nb = 0                              # []
    nc = 0                              # {}
    lth = len(wline)
    l = 0
    while (l < lth):
        c = wline[l]
        if c == ',' and np == 0 and nb == 0 and nc == 0:    # we want to split on commas
            if integers:
                n, msg = is_float(newstr)
                if msg is not None:
                    print_error("Range first number bad. {}".format(msg), line)
                    return ''
                # fi
                n = int(n)
                newline.append(str(n))
            else:
                newline.append(newstr)
            # fi
            l = l + 1
            if l < lth:
                newstr = ''
            else:
                newstr = None
            # fi
        elif c == '.' and integers:
            if (l+2) < lth and wline[l+1] == '.':
                # Range
                if newstr == '':
                    print_error("Range needs number before 'STARTING..ENDING'", line)
                    return ''
                # fi
                first, msg = is_float(newstr)
                if msg is not None:
                    print_error("Range first number bad. {}".format(msg), line)
                    return ''
                # fi
                # NOTE: comma looked for, not parenthesis/brackets/braces.
                try:
                    comma = wline.find(',', l+2)
                    if comma >= 0:
                        last = wline[l+2:comma]
                        l = comma + 1
                    else:
                        last = wline[l+2:]
                        l = lth + 1
                    # fi
                except:
                    last = wline[l+2:]
                    l = lth + 1
                # yrt
                last, msg = is_float(last)
                if last is None or last == '':
                    print_error("Range last number bad. {}".format(msg), line)
                    return ''
                # fi
                first = int(first)
                last = int(last)
                for n in range(first, last+1):
                    newline.append(str(n))
                # rof
                newstr = ''
                continue
            # fi
            print_error("Range needs number after 'STARTING..ENDING'", line)
            return ''
        #-- elif c == ' ' or c == "\t":
        #--     pass
        else:
            newstr = newstr + c
            if c == '(':
                np = np + 1
            elif c == ')':
                if np == 0:
                    print_error("too many right parenthesis", line)
                    return ''
                # fi
                np = np - 1
            elif c == '[':
                nb = nb + 1
            elif c == ']':
                if nb == 0:
                    print_error("too many right brackets", line)
                    return ''
                # fi
                nb = nb - 1
            elif c == '{':
                nc = nc + 1
            elif c == '}':
                if nc == 0:
                    print_error("too many right curly braces", line)
                    return ''
                # fi
                nc = nc - 1
            # fi
            l = l + 1
        # fi
    # elihw
    if np != 0:
        print_error("too many left (by {}) parenthesis".format(np), line)
        return ''
    # fi
    if nb != 0:
        print_error("too many left (by {}) brackets".format(nb), line)
        return ''
    # fi
    if nc != 0:
        print_error("too many left (by {}) curly braces".format(nc), line)
        return ''
    # fi
    if newstr is None:
        newline.append('')
    elif newstr != '':
        if integers:
            n, msg = is_float(newstr)
            if msg is not None:
                print_error("Range first number bad. {}".format(msg), line)
                return ''
            # fi
            n = int(n)
            newline.append(str(n))
        else:
            newline.append(newstr)
        # fi
    # elif not integers:
    #     newline.append(newstr)
    # fi

    return newline
# End of arglist

# ----------------------------------------------------------------------------
# change -- rename existing command or copy.
#         change  measure to unit   $$ or:
#         change  command measure to unit

def do_change(t_args, line):
    global macro_buffer
    global commands

    if t_args is None or len(t_args) == 0:
        print_error("change does not have three or four arguments.", line)
        return
    # fi
    t_args = t_args[0].split(' ')
    if t_args is None or len(t_args) < 3 or len(t_args) > 4:
        print_error("change -- there is not three or four arguments.", line)
        return
    # fi
    if len(t_args) == 4:
        if t_args[0] != 'command' or t_args[2] != 'to':
            print_error("change -- command is not first argument of four and to is not third.", line)
            return
        # fi
        t_args = t_args[1:]
    elif len(t_args) == 3:
        if t_args[1] != 'to':
            print_error("change -- to is not second argument.", line)
            return
        # fi
    # fi
    old = t_args[0]
    new = t_args[2]
    # make sure new name does not exist already. -- error
    if new in commands:
        if commands[new] == commands[old]:
            return
        # fi
        print_error("copy new name already exists as different command.", line)
    elif new in macro_buffer:
        print_error("change new name already exists as macro.", line)
        return
    if old not in commands:
        print_error("change old name does not exist.", line)
        return
    # fi
    commands[new] = commands[old]
    del commands[old]
    return
# End of do_change

# ----------------------------------------------------------------------------
# copy -- make another name for existing name/copy, replace existing with warning.
#         copy    measure to unit   $$ or:
#         copy    command measure to unit
def do_copy(t_args, line):
    global macro_buffer
    global commands

    if t_args is None or len(t_args) == 0:
        print_error("copy does not have three or four arguments.", line)
        return
    # fi
    t_args = t_args[0].split(' ')
    if t_args is None or len(t_args) < 3 or len(t_args) > 4:
        print_error("copy - there is not three or four arguments.", line)
        return
    # fi
    if len(t_args) == 4:
        if t_args[0] != 'command' or t_args[2] != 'to':
            print_error("copy - command is not first argument of four and to is not third.", line)
            return
        # fi
        t_args = t_args[1:]
    elif len(t_args) == 3:
        if t_args[1] != 'to':
            print_error("copy - to is not second argument.", line)
            return
        # fi
    # fi
    old = t_args[0]
    new = t_args[2]
    # make sure new name does not exist already. -- error
    if new in commands:
        if commands[new] == commands[old]:
            return
        # fi
        print_error("copy new name already exists as different command.", line)
    elif new in macro_buffer:
        print_error("copy new name already exists as macro.", line)
        return
    if old not in commands:
        print_error("copy old name does not exist.", line)
        return
    # fi
    commands[new] = commands[old]
    return
# End of do_copy

# ----------------------------------------------------------------------------
#   title promenade     $$ Gives a title to the song, multiple allowed.
def do_title(t_args, line):
    global header
    global args

    if t_args is None or len(t_args) == 0:
        #-- print_warning("Title does not have any text.", line)
        if args.vertical or args.horizontal:
            header = header + "title   \n"
        elif args.midi1csv or args.fluidsynth:
            pass
        else:           # ABC
            header = header + "T:\n"
        # fi
        return
    # fi
    # T: Title of tune        (can have multiple)
    t = line.split(' ', 1)
    if not t or len(t) < 2:
        t = [ ' ', ' ' ]
    # fi
    if args.vertical or args.horizontal:
        header = header + "title   {}\n".format(t[1])
    elif args.midi1csv or args.fluidsynth:
        header.append(t[1])
    else:           # ABC
        header = header + "T:{}\n".format(t[1])
    # fi
    return
# End of do_title

# ----------------------------------------------------------------------------
# tempo is measured according to beats per minute (bpm) and is divided into:
#       prestissimo (>200 bpm)
#       presto (168-200 bpm)
#       allegro (120-168 bpm)
#       moderato (108-120 bpm)
#       andante (76-108 bpm)
#       adagio (66-76 bpm)
#       larghetto (60-66 bpm)
#       and largo (40-60 bpm)
#   tempo  150,4        $$ Number of notes of given length in a minute.
#   tempo  30           $$ Number of frames (1/57.1429 seconds) per whole note.
def do_tempo(t_args, line):
    global tempo_speed_default          # beats per minute
    global default_note_length          # length of a beat (note)
    global tempo_speed_now
    global tempo_now_note_length
    global measure_on
    global mlth
    global vl

    if t_args is None or len(t_args) == 0:
        print_error("tempo does not have one or two arguments.", line)
        return
    # fi
    t_args = t_args[0].split(',')
    if t_args is None or len(t_args) == 0 or len(t_args) > 2:
        print_error("tempo - there is not one or two arguments.", line)
        return
    # fi

    fill_voice_mlth(False, line)                   # Need to make measure for other voices up to here "mlth".

    for ve in range(1, len(vl)+1):
        if mlth[ve][measure_on] != 0:
            print_error("tempo in the middle of a measure not allowed", line)
            return
        # fi
    # rof

    #   f1 is value   -- So far computed value
    #   type_error -- type of error
    f1, type_error = is_float(t_args[0])
    if type_error is not None:
        print_error("tempo does not have first argument as a floating number. {}".format(type_error), line)
        return
    # fi
    if f1 is None:
        print_error("tempo does not have first argument as a floating number.", line)
        return
    # fi
    if len(t_args) == 1:
        x = f1 / 60.0
        if measure_on == '':
            tempo_speed_default = x
        # fi
        default_note_length[measure_on] = 1.0               # whole note
        tempo_speed_now[measure_on] = x
        tempo_now_note_length[measure_on] = 1.0
        return
    # fi
    xxx = t_args[1].replace('d', '*1.5')
    # f2, type_error = is_float(t_args[1])
    f2, type_error = is_float(xxx)
    if type_error is not None:
        return
    # fi
    if f2 is None:
        print_error("tempo does not have second argument as a floating number.", line)
        return
    # fi
    if measure_on == '':
        tempo_speed_default = f1
    # fi
    default_note_length[measure_on] = (1.0 / f2)
    tempo_speed_now[measure_on] = f1
    tempo_now_note_length[measure_on] = (1.0 / f2)
    return
# End of do_tempo

# ----------------------------------------------------------------------------
def do_cstopnow(t_args, line):
    global errors_happened

    do_pass2()
    sys.exit(errors_happened)
# End of do_cstopnow

# ----------------------------------------------------------------------------
#   cstart              restart compiling.      (like #if 0 ... #endif // 0)
def do_cstart(t_args, line):
    global cstop_processing

    if not cstop_processing:
        print_error("Not in cstop processing and got a cstart", line)
    # fi
    cstop_processing = False
    return
# End of do_cstart

# ----------------------------------------------------------------------------
#   cstop               stop till cstart or cstop* found.
def do_cstop(t_args, line):
    global cstop_processing

    cstop_processing = True
    return
# End of do_cstop

# ----------------------------------------------------------------------------
def do_endm(t_args, line):
    global macro_defining

    if macro_defining is None:
        print_error("endm command while not defining a macro", line)
        return
    # fi
    macro_defining = None
    return
# End of do_endm

# ----------------------------------------------------------------------------
def replace_macro(command, t_args, line):
    global macro_arguments              # Name of macro, array of arguments for macro.
    global macro_executing_depth        # If processing macro ... reading from macro buffer.
    global macro_executing_args         # Depth, array of arguments given to macro.
    global macro_line                   # Depth, line in macro array.

    if t_args is None or len(t_args) == 0:
        if macro_arguments[command] != []:
            print_error("macro command does not have any arguments, but needs {}.".format(macro_arguments[command]), line)
            return
        # fi
        wargs = None
    else:
        wargs = arglist(t_args[0], line, False)
        if len(wargs) != len(macro_arguments[command]):
            print_error("macro command has {} arguments, but needs {}.".format(wargs, macro_arguments[command]), line)
            return
        # fi
    # fi
    macro_executing_depth.append(command)
    macrodepth = len(macro_executing_depth)
    macro_executing_args[macrodepth] = wargs
    macro_line[macrodepth] = 0             # First line in buffer.
# End of replace_macro

# ----------------------------------------------------------------------------
#   macro name,arg1,arg2,...,argn
#     body of macro
#   endm
#         Changes arg1 to passed in usage.
#   name  first,second arg,something    # example 3 arguments - spaces allowed.
#
# Macros must not be existing commands -- replace existing macro with warning.
def do_macro(t_args, line):
    global commands
    global macro_defining               # If defining macro.
    global macro_buffer                 # Name of macro, array of lines for macro.
    global macro_arguments              # Name of macro, array of arguments for macro.

    if t_args is None or len(t_args) == 0:
        print_error("macro command does not have any arguments.", line)
        return
    # fi

    wargs = arglist(t_args[0], line, False)
    if not wargs or len(wargs) < 1:
        print_error("no macro name.", line)
        return
    # fi

    name = wargs[0]
    args = wargs[1:]
    if name in commands:
        print_error("macro ({}) would replace existing command".format(name), line)
        return
    # fi
    if name in macro_buffer:
        print_warning("macro ({}) will replace existing macro".format(name), line)
    # fi

    macro_buffer[name] = []             # No lines in bujffer.
    macro_arguments[name] = args
    macro_defining = name
    return
# End of do_macro

# ----------------------------------------------------------------------------
def macro_define(command, t_args, line):
    global macro_defining               # If defining macro.
    global macro_buffer                 # Name of macro, array of lines for macro.

    if t_args and len(t_args) > 0:
        macro_buffer[macro_defining].append(command + ' ' + ' '.join(t_args))
    else:
        macro_buffer[macro_defining].append(command)
    # fi
    return
# End of macro_define

# ----------------------------------------------------------------------------
# putd ... if already existing, replace with warning.
#     putd   /cmajor/c,e,g/
#     =cmajor,b           # c,e,g,b       Note: do multiple putd's on this line.
def do_putd(t_args, line):
    if t_args is None or len(t_args) == 0:
        print_error("putd does not have an argument.", line)
        return
    # fi
    c = t_args[0][0]                    # The separation character.
    two = t_args[0].split(c)
    if len(two) != 4 or two[0] != '' or two[3] != '':
        print_error("putd should look like '/zzz/a,b,c/' - not right number of separators ({}).".format(c), line)
        return
    # fi
    putds[two[1]] = two[2]
    return
# End of do_putd

# ----------------------------------------------------------------------------
def process_putd(line):
    global putds

    newline = line[1:]                  # Toss '=' (putd) character.
    for a in putds:
        newline = newline.replace(a, putds[a])
    # rof
    return newline
# End of process_putd

# ----------------------------------------------------------------------------
def do_endif(t_args, line):
    global ifdepth

    if ifdepth == 0:
        print_error("endif command while not in an if command", line)
        return
    # fi
    # if iftest[ifdepth] == -1:           # already processing, handle as normal if.
    # if iftest[ifdepth] == 0:            # skipping if, want to do else.
    # if iftest[ifdepth] == 1:            # processing in else, want to do as normal if.
    # if iftest[ifdepth] == 2:            # skipping in else, ignore if and else processing, want endif.
    # if iftest[ifdepth] == 3:            # skip both if and else, want endif
    ifdepth = ifdepth - 1
    return
# End of do_endif

# ----------------------------------------------------------------------------
def do_else(t_args, line):
    global ifdepth
    global iftest

    if ifdepth == 0 or iftest[ifdepth] == 1 or iftest[ifdepth] == 2:
        print_error("else command while not in an if command", line)
        return
    # fi

    if iftest[ifdepth] == -1:           # already processing, handle as normal if.
        iftest[ifdepth] = 2             # Switch to skipping else.
        return
    # fi
    if iftest[ifdepth] == 0:            # skipping if, want to do else.
        iftest[ifdepth] = 1             # Switch to processing else.
        return
    # fi
    # if iftest[ifdepth] == 3:            # skip both if and else, want endif
    # NOTE: do not test for if/else/endif ... second else.
    return
# End of do_else

# ----------------------------------------------------------------------------
#   if/else/endif
def do_if(t_args, line):
    global iftest                       # check if after if or else.
    global ifdepth                      # level of if/else/endif

    if t_args is None or len(t_args) == 0:
        print_error("if command does not have exactly one argument.", line)
        return
    # fi
    # if iftest[ifdepth] == -1:           # already processing, handle as normal if.
    # if iftest[ifdepth] == 0:            # skipping if, want to do else.
    # if iftest[ifdepth] == 1:            # processing in else, want to do as normal if.
    # if iftest[ifdepth] == 2:            # skipping in else, ignore if and else processing, want endif.
    # if iftest[ifdepth] == 3:            # skip both if and else, want endif
    if iftest[ifdepth] == -1 or iftest[ifdepth] == 1:   # process this if normally.
        wargs = arglist(t_args[0], line, False)
        if not wargs or len(wargs) < 1:
            print_error("no if argument.", line)
            return
        # fi
        value, type_error = is_float(wargs[0])
        if type_error is not None:
            print_error("if unable to determine if value ({}).".format(wargs[0]), line)
            return
        # fi
        value =  -1 if value < 0 or value > 0 else 0   # 0 is false, otherwise everything is true.
    else:
        value = 3                           # Skip both if and else.
    # fi
    ifdepth = ifdepth + 1
    iftest[ifdepth] =  value
    return
# End of do_if

# ----------------------------------------------------------------------------
def do_marker(t_args, line):
    global args

    fill_voice_mlth(False, line)                   # Need to make measure for other voices up to here "mlth".

    if t_args is None or len(t_args) == 0:
        value = '0'
    else:
        value, type_error = is_float(t_args[0])
        if type_error is not None:
            print_warning("marker unable to compute value({}) - using text string.".format(t_args[0]), line)
            value = str(t_args[0])
        else:
            value = str(int(round(value)))      # Stupid python language upgrade incompatibility.
        # fi
    # fi

    if args.rest and len(args.rest) >= 2:
        outf = sys.stdout
    else:
        outf = sys.stderr
    # fi
    if args.rest and len(args.rest) >= 1:
        # Can get input from terminal.
        if sys.stdin.isatty():
            if sys.platform == 'darwin':
                input('marker ' + value + ' > ')
                line = readline.get_line_buffer()
            else:
                line = input('marker ' + value + ' > ')
            # fi
        else:
            print('marker ' + value + ' > ', file=outf, flush=True)
            line = sys.stdin.readline()
        # fi
    # fi
    return
# End of do_marker

# ----------------------------------------------------------------------------
# Not likely to ever do.
#   debug               ignore
def do_debug(t_args, line):
    print_error("debug command makes no sense for python or MIDI.", line)
    return
# End of do_debug

# ----------------------------------------------------------------------------
#   randp   m1          Assigned unduplicated random numbers from last setperm.
def do_randp(t_args, line):
    global array_of_random_numbers

    if t_args is None or len(t_args) == 0:
        print_error("randp command does not have exactly one argument.", line)
        return
    # fi
    wargs = arglist(t_args[0], line, False)
    if not wargs or len(wargs) < 1:
        print_error("no randp argument.", line)
        return
    # fi
    if len(array_of_random_numbers) <= 0:
        # print_error("randp needs a setperm before it runs.".format(wargs[0], value), line)
        ran = 0
    else:
        ran = array_of_random_numbers.pop()
    # fi
    computeit = wargs[0] + '=' + str(ran)       # Do the assignment.
    value, type_error = is_float(computeit)
    if type_error is not None:
        print_error("randp unable to assign value({}) to first argument({}).".format(wargs[0], value), line)
        return
    # fi
    return
# End of do_randp

# ----------------------------------------------------------------------------
#   setperm 44          Semi random numbers between 1 and 44, without duplication.
def do_setperm(t_args, line):
    global array_of_random_numbers

    if t_args is None or len(t_args) != 1 or t_args[0] == '':
        print_error("setperm command does not have any arguments.", line)
        return
    # fi
    wargs = arglist(t_args[0], line, False)
    if not wargs or len(wargs) != 1:
        print_error("Need exactly one setperm argument", line)
        return
    # fi

    value, type_error = is_float(wargs[0])     # From 1 to value.
    if type_error is not None or value < 1:
        print_error("setperm unable to compute reasonable value({}) for number of unique random numbers.".format(wargs[0]), line)
        return
    # fi
    value = int(round(value))                   # So, python2 and python3 do round differently. *SCREAM*
    array_of_random_numbers = random.sample(range(1, value+1), value)
    return
# End of do_setperm

# ----------------------------------------------------------------------------
#   randu   m1,10       $$ random number between 1 and 10.
def do_randu(t_args, line):
    if t_args is None or len(t_args) <= 0 or t_args[0] == '':
        print_error("randu command does not have any arguments.", line)
        return
    # fi
    wargs = arglist(t_args[0], line, False)
    if not wargs or len(wargs) < 1:
        print_error("no randu arguments", line)
        return
    # fi

    value, type_error = is_float(wargs[1])     # From 1 to value.
    if type_error is not None or value < 1:
        print_error("randu unable to compute reasonable value({}) to store in ({}).".format(wargs[1], wargs[0]), line)
        return
    # fi
    ran = random.randint(1, int(round(value)))  # Random value.
    computeit = wargs[0] + '=' + str(ran)       # Do the assignment.
    value, type_error = is_float(computeit)
    if type_error is not None:
        print_error("randu unable to assign value({}) to first argument({}).".format(wargs[0], value), line)
        return
    # fi
    return
# End of do_randu

# ----------------------------------------------------------------------------
# Not likely to ever do.
#   percus              does things with slide projector.
def do_percus(t_args, line):
    print_error("percus command makes no sense for python or MIDI.", line)
    return
# End of do_percus

# ----------------------------------------------------------------------------
# Not likely to ever do. Would do it differently for MIDI.
#   delay 15            delay in 1/60ths of a second. Like a fermate.  15=1/4th of a second
def do_delay(t_args, line):
    global voices                       # number of voices
    global cis                          # if cis active, non-zero.
    global tempo_speed_default
    global default_note_length
    global measure_on
    global tempo_speed_now
    global tempo_now_note_length

    fill_voice_mlth(False, line)               # Need to make measure for other voices up to here "mlth".

    if t_args is None or len(t_args) <= 0 or t_args[0] == '':
        print_error("delay command does not have any arguments.", line)
        return
    # fi
    wargs = arglist(t_args[0], line, False)
    if not wargs or len(wargs) < 1:
        print_error("no delay arguments", line)
        return
    # fi
    value, type_error = is_float(wargs[0])
    if type_error is not None:
        print_error("delay unable to compute value({}).".format(wargs[0]), line)
        return
    # fi

    # Convert value/60.0 to note_beats/minute (tempo).
    # tempo_speed_default = 120.0                 # beats per minute.
    # default_note_length[measure_on]     # length of a beat (note)
    # (tempo beats/minute) * (1/60.0 minutes/sec)
    #  (tempo/60.0  beats/sec) * (1/default_note_length[measure_on] = ?_note/beats)
    #  (tempo/(60.0*default_note_length[measure_on]) ?_note/sec)  * seconds
    if measure_on == '':
        rvalue = value * tempo_speed_default / (60.0*default_note_length[measure_on])
    else:
        rvalue = value * tempo_speed_now[measure_on] / (60.0*tempo_now_note_length[measure_on])
    # fi

    loopstart = 1 if cis == 0 else cis
    r = 'r({}/60.0)'.format(rvalue)
    for onvoice in range(loopstart+1, voices + 1):
        r = r + ',r({}/60.0)'.format(rvalue)
    # rof
    process_notes(r)
    return
# End of do_delay

# ----------------------------------------------------------------------------
# Not likely to ever do.
#   slide  from,to,length     Glissando - only can be used after voice 1 or cis n command.
def do_slide(t_args, line):
    print_error("slide command makes no sense for python or MIDI.", line)
    return
# End of do_slide

# ----------------------------------------------------------------------------
# This command raises or lowers the note pitch by the specified number of
# semitones. A semitone is one of the 12 notes in a scale from
#       c,c+,d,d+,e,f,f+,g,g+,a,a+,b,b+ and back to c one octave higher.
#   pitch -2            sets semitones lower
def do_pitch(t_args, line):
    global pitch
    global measure_on
    global mlth

    if t_args is None or len(t_args) <= 0 or t_args[0] == '':
        print_error("pitch does not have an expression to process", line)
        return
    # fi

    for ve in range(1, len(vl)+1):
        if mlth[ve][measure_on] != 0:
            print_error("pitch in the middle of a measure not allowed", line)
            return
        # fi
    # rof

    m = t_args[0]

    f, type_error = is_float(m)
    if type_error is not None:
        return
    # fi
    if f is None:
        print_error("pitch argument as a calculation did not return a value", line)
        return
    # fi
    pitch[measure_on] = int(round(f))
    return
# End of do_pitch

# ----------------------------------------------------------------------------
# Not likely to do. No idea what this does.
#   temper a            sets just intonation in the key.
def do_temper(t_args, line):
    print_error("NOTDONEYET - do_temper", line)
    return
# End of do_temper

# ----------------------------------------------------------------------------
# Not likely to ever do. Use key command.
#   sharp   f
def do_sharp(t_args, line):
    print_error("NOTDONEYET - do_sharp", line)
    return
# End of do_sharp

# ----------------------------------------------------------------------------
# Not likely to ever do. Use key command.
#   flat    b,e         flat/sharp are cumulative -- double flats, etc.
def do_flat(t_args, line):
    print_error("NOTDONEYET - do_flat", line)
    return
# End of do_flat

# ----------------------------------------------------------------------------
# Not likely to ever do. Use key command.
#   natural c           undo any flat/sharp.
def do_natural(t_args, line):
    print_error("NOTDONEYET - do_natural", line)
    return
# End of do_natural

# ----------------------------------------------------------------------------
#   goto    6.5,x,8,2,... $$ repeat and/or skip.  "x" = continue, forwards, backwards, max 8 args.
#                       counter is number of times reached.
def do_goto(t_args, line):
    global measure_on
    global goto_table
    global goto_variables

    if args.nogoto:
        print_warning("Ignoring goto parsing.", line)
        return
    # fi

    if measure_on in goto_table:
        print_error("Second goto in measure note allowed.", line)
        return
    # fi

    if t_args is None or len(t_args) == 0:
        print_error("goto needs at least one argument", line)
        return
    # fi
    wline = t_args[0]
    # Get rid of all white spoce.
    wline = ''.join(wline.split())
    wargs = arglist(wline, line, False)

    if len(wargs) == 0:
        print_error("goto needs at least one argument", line)
        return
    # fi

    g = []
    for i in range(1, len(wargs)+1):
        v = wargs[i - 1]

        if v is None:
            print_error("goto does not have argument as a measure.", line)
            return
        # fi

        f1 = None
        for a in v:
            if a in "abcdefghijklnopqrstuvwxyz_ABCDEFGHIJKLMNOPQRSTUVWXYZ":
                f1 = v
                break
            # fi
        # rof
        if f1 is None:
            f1, type_error = is_float(v)
            if type_error is not None or f1 is None:
                # Error, use it as string instead.
                f1 = str(v)
            else:
                tmp = int(round(f1))
                if (f1 - tmp) == 0:
                    f1 = tmp
                # fi
            # fi
        # fi
        v = str(f1)

        g.append(v)
    # rof
    fill_voice_mlth(True, line)               # Need to make measure for other voices up to here "mlth".
    goto_table[measure_on] = g
    return
# End of do_goto

# ----------------------------------------------------------------------------
def to_abc_note(note_number):
    if note_number <= 0 or note_number == '0':
        return 'z'
    # fi
    o = int(note_number / 12)                           # get octave
    n = note_number - (o * 12)                          # note is remainder
    octaves = { 0:',,,', 1:',,', 2:',', 3:'', 4:'', 5:"'", 6:"''", 7:"'''", 8:"''''" }
    notes = { 0:'a', 1:'^a', 2:'b', 3:'c', 4:'^c', 5:'d', 6:'^d', 7:'e', 8:'f', 9:'^f', 10:'g', 11:'^g' }
    n = notes[n]
    if o <= 3:                                          # uppercase letter
        n = n.upper()
    else:                                               # lowercase letter
        n = n.lower()
    # fi
    o = octaves[o]
    thenote = n + o
    return thenote
# End of to_abc_note

# ----------------------------------------------------------------------------
#   decode  m1,3c+      $$ note number for 3c+ into m1
#   decode  m1,m2,3c+4  $$ note number for 3c+ into m1, note length (4) in m2.
#   decode  m1,m2,m3,3c+4l  $$ note number for 3c+ into m1, note length (4) in m2, 16 into m3.
def do_decode(t_args, line):
    global args
    global measure_on
    global key_sig
    global key_voice

    if t_args is None or len(t_args) <= 0 or t_args[0] == '':
        print_error("decode command does not have any arguments.", line)
        return
    # fi
    wargs = arglist(t_args[0], line, False)

    if not wargs or len(wargs) < 1:
        print_error("no decode arguments", line)
        return
    # fi
    if len(wargs) > 4 or len(wargs) == 1:
        print_error("Not correct number of arguments for decode commmand", line)
        return
    # fi
    # Save what type of processing we are doing.
    saveargsh = args.horizontal
    saveargsv = args.vertical
    saveargsm = args.midi1csv
    saveargsf = args.fluidsynth
    saveargabc = args.abc
    savekeyvoice = key_voice[measure_on][1]
    # ------------------------------------------------------------------------------
    if args.vertical or args.horizontal:
        k = key_sig[savekeyvoice]      # Convert to number.
    elif args.midi1csv or args.fluidsynth:
        k = savekeyvoice
    else:                   # ABC
        # Convert to normal format.
        k = savekeyvoice.lower()
        k = k.replace('b', '-')             # Does multiple flats
        k = k.replace('#', '+')             # Does multiple sharps.
        k = k.replace('=', 'n')             # Does multiple naturals.
        k = key_sig[k]                  # Convert to number.
    # fi
    # ------------------------------------------------------------------------------
    # Set to midi format -- so we have a value.
    args.horizontal = False
    args.vertical = False
    args.midi1csv = True
    args.fluidsynth = False
    args.abc = False
    key_voice[measure_on][1] = k

    if len(wargs) == 2:
        w_note = wargs[1]
    elif len(wargs) == 3:
        w_note = wargs[2]
    else:                   # 4
        w_note = wargs[3]
    # fi
    # Ignore leading space.
    therest, thenote, typenote = getnote(w_note, 1, line)

    # Restore type of processing we are doing.
    args.horizontal = saveargsh
    args.vertical = saveargsv
    args.midi1csv = saveargsm
    args.fluidsynth = saveargsf
    args.abc = saveargabc
    key_voice[measure_on][1] = savekeyvoice

    if therest is None or thenote is None:
        print_warning("decode note had error with note {}".format(w_note), line)
        return
    # fi
    if therest and len(therest) > 0 and len(wargs) == 2:
        print_warning("decode note has information ({}) after the note {}".format(therest, w_note), line)
    # fi
    if typenote != normal_note:
        print_warning("decode note is not of type normal_note -- ({})".format(typenote), line)
        return
    # fi
    if thenote <= 12 + 12 - 3:
        computeit = wargs[0] + '=' + '0'                       # rest = 0
    else:
        computeit = wargs[0] + '=' + str(thenote) + '+3-12-12'  # Convert from midi note to musicomp value.
    # fi
    value, type_error = is_float(computeit)
    if type_error is not None:
        print_error("decode note unable to assign value({}) to first argument({}).".format(thenote, wargs[0]), line)
        return
    # fi
    if len(wargs) < 3:      # 3 or 4 arguments continue.
        return
    # fi

    # Get the time value for the note.
    timeofnote, r_accidentals, number_dots = get_time(therest, line)

    if r_accidentals is None or number_dots is None:
        print_error("decode - Error getting time for note", line)
        return
    # fi
    # accidental_legato = 16        -- glide to next note.
    # accidental_tied = 2           -- tied
    # accidental_stac = 1           -- staccato
    # accidental_dotted = -1
    # accidental_normal = 0
    # bits are $union$'ed together for multiple modifiers.
    # number_dots are how many "d" (dotted) were found.
    if timeofnote is None or timeofnote == 0:
        if number_dots != 0:
            print_error("cannot have dotted syntax on a default note length.", line)
            return
        # fi
        timeofnote = time[onvoice]      # Interesting - get last time used. :)
    # fi
    if number_dots != 0:
        p = timeofnote / 2.0
        for i in range(1, number_dots+1):
            timeofnote = timeofnote + p
            p = p / 2.0
        # rof
    # fi
    if typenote == gsw_operand:
        print_error("NOTDONEYET - doing decode of gsw operand type of note", line)
        return
    # fi
    if typenote == freqency_note:
        print_error("NOTDONEYET - doing decode of freqency type of note", line)
        return
    # fi
    if typenote == trill_note:
        print_error("NOTDONEYET - doing decode of trill of notes", line)
        return
    # fi
    if typenote == sequence_note:
        print_error("NOTDONEYET - doing decode of sequence of notes", line)
        return
    # fi

    computeit = wargs[1] + '=' + str(timeofnote)    # Should be floating number.
    value, type_error = is_float(computeit)
    if type_error is not None:
        print_error("decode note unable to assign value({}) to second argument({}).".format(timeofnote, wargs[1]), line)
        return
    # fi

    if len(wargs) == 3:      # 4 arguments, get accidentals after the note.
        if r_accidentals != 0:
            print_warning("decode note has information after the time, accidentals={}".format(r_accidentals), line)
        # fi
        return
    # fi

    computeit = wargs[2] + '=' + str(r_accidentals)
    value, type_error = is_float(computeit)
    if type_error is not None:
        print_error("decode note unable to assign value({}) to third argument({}).".format(r_accidentals, wargs[2]), line)
        return
    # fi
    return
# End of do_decode

# ----------------------------------------------------------------------------
def do_clef(t_args, line):
    global clef
    global measure_on

    if t_args is None or len(t_args) != 1:
        print_error("clef does not have arguments.", line)
        return
    # fi

    t_args[0] = re.sub(r'\s*,\s*', ',', t_args[0])

    vargs = t_args[0].split()
    if len(vargs) <= 0 or len(vargs) > 2:
        print_error("clef does not have correct number of arguments.", line)
        return
    # fi
    if len(vargs) == 1:
        wargs = arglist(t_args[0], line, False)
        if not wargs or len(wargs) < 1:
            print_error("no clef selection arguments", line)
            return
        # fi
        for i in range(1, len(wargs)+1):
            clef[measure_on][i] = wargs[i-1].strip()   # No checking.
        # rof
        return
    # fi
    clf = vargs[1]

    jkl = "".join(vargs[0])
    wargs = arglist(jkl, line, True)
    if not wargs or len(wargs) < 1:
        print_error("no voice arguments on clef line", line)
        return
    # fi
    for w in wargs:
        f1, type_error = is_float(w)
        if type_error is not None:
            return
        # fi
        if f1 is None:
            print_error("voice {} is not a number.".format(w), line)
            return
        # fi
        f1 = int(round(f1))
        clef[measure_on][f1] = clf
    # rof
    return
# End of do_clef

# ----------------------------------------------------------------------------
def do_bars(t_args, line):
    global bars
    global measure_on

    if t_args is None or len(t_args) <= 0 or t_args[0] == '':
        print_error("bars does not have an expression to process", line)
        return
    # fi

    m = t_args[0]

    f, type_error = is_float(m)
    if type_error is not None:
        return
    # fi
    if f is None:
        print_error("bars argument as a calculation did not return a value", line)
        return
    # fi
    bars[measure_on] = int(round(f))
    # fi
    return
# End of do_bars

# ----------------------------------------------------------------------------
def do_meter(t_args, line):
    global meter
    global measure_meter
    global measure_meter_value
    global measure_on
    global args
    global mlth

    if t_args is None or len(t_args) <= 0 or t_args[0] == '':
        print_error("meter does not have an expression to process", line)
        return
    # fi

    for ve in range(1, len(vl)+1):
        if mlth[ve][measure_on] != 0:
            print_error("meter in the middle of a measure not allowed", line)
            return
        # fi
    # rof

    m = t_args[0]

    f, type_error = is_float(m)
    if type_error is not None:
        return
    # fi
    if f is None:
        print_error("meter argument as a calculation did not return a value", line)
        return
    # fi
    meter = m
    measure_meter[measure_on] = m                       # Save text for meter.

    f, type_error = is_float(m)
    if type_error is not None:
        return
    # fi
    if f is None:
        print_error("calculating meter did not return a value", line)
        return
    # fi
    measure_meter_value = f
    return
# End of do_meter

# ----------------------------------------------------------------------------
#   calc m1=10          variables m1 to m9.  m(m2)=m9/5   # floating point.
#               Note: special variables stac, grace, frames, pause
def do_calc(t_args, line):
    if t_args is None or len(t_args) <= 0:
        print_error("calc does not have an expression to process", line)
        return
    # fi
    f, type_error = is_float(t_args[0])
    if type_error is not None:
        return
    # fi
    if f is None:
        print_error("calculate did not return a value", line)
        return
    # fi
    return
# End of do_calc

# ----------------------------------------------------------------------------
# 7 sharps is C# major or A# minor. f+,c+,g+,d+,a+,e+,b+
# 6 sharps is F# major or D# minor. f+,c+,g+,d+,a+,e+
# 5 sharps is B major or G# minor.  f+,c+,g+,d+,a+
# 4 sharps is E major or C# minor.  f+,c+,g+,d+
# 3 sharps is A major or F# minor.  f+,c+,g+
# 2 sharps is D major or B minor.   f+,c+
# 1 sharp  is G major or E minor.   f+
# None     is C major or A minor.
# 1 flat   is F major or D minor.   b-
# 2 flats  is B- major or G minor.  b-,e-
# 3 flats  is E- major or C minor.  b-,e-,a-
# 4 flats  is A- major or F minor.  b-,e-,a-,d-
# 5 flats  is D- major or B- minor. b-,e-,a-,d-,g-
# 6 flats  is G- major or E- minor. b-,e-,a-,d-,g-,c-
# 7 flats  is C- major or A- minor. b-,e-,a-,d-,g-,c-,f-

# Following does not do multiple sharps or flats, but that is crazy anyway. Neither naturals.
global key_sig
key_sig = { 'c+':7, 'f+':6, 'b':5, 'bn':5, 'e':4, 'en':4, 'a':3, 'an':3, 'd':2, 'dn':2, 'g':1, 'gn':1, 'c':0, 'cn':0,
            'f':-1, 'b-':-2, 'e-':-3, 'a-':-4, 'd-':-5, 'g-':-6, 'c-':-7 }

global key_sig_int
key_sig_int = {}
for i in key_sig:
    if key_sig[i] not in key_sig_int:
        key_sig_int[key_sig[i]] = i
    # fi
# rof

global key_convert
key_convert = {
    'c+':  {     # f+,c+,g+,d+,a+,e+,b+
        '0c-':None,  '0c':'0c+', '0cn':'0cn', '0c+':'0c+',   '0d-':'0d-', '0d':'0d+', '0dn':'0dn', '0d+':'0d+',
        '0e-':'0e-', '0e':'0e+', '0en':'0en', '0e+':'0f',    '0f-':'0e',  '0f':'0f+', '0fn':'0fn', '0f+':'0f+',
        '0g-':'0g-', '0g':'0g+', '0gn':'0gn', '0g+':'0g+',   '0a-':'0a-', '0a':'0a+', '0an':'0an', '0a+':'0a+',
        '0b-':'0b-', '0b':'0b+', '0bn':'0bn', '0b+':'1c',
        '1c-':'0b',  '1c':'1c+', '1cn':'1cn', '1c+':'1c+',   '1d-':'1d-', '1d':'1d+', '1dn':'1dn', '1d+':'1d+',
        '1e-':'1e-', '1e':'1e+', '1en':'1en', '1e+':'1f',    '1f-':'1e',  '1f':'1f+', '1fn':'1fn', '1f+':'1f+',
        '1g-':'1g-', '1g':'1g+', '1gn':'1gn', '1g+':'1g+',   '1a-':'1a-', '1a':'1a+', '1an':'1an', '1a+':'1a+',
        '1b-':'1b-', '1b':'1b+', '1bn':'1bn', '1b+':'2c',
        '2c-':'1b',  '2c':'2c+', '2cn':'2cn', '2c+':'2c+',   '2d-':'2d-', '2d':'2d+', '2dn':'2dn', '2d+':'2d+',
        '2e-':'2e-', '2e':'2e+', '2en':'2en', '2e+':'2f',    '2f-':'2e',  '2f':'2f+', '2fn':'2fn', '2f+':'2f+',
        '2g-':'2g-', '2g':'2g+', '2gn':'2gn', '2g+':'2g+',   '2a-':'2a-', '2a':'2a+', '2an':'2an', '2a+':'2a+',
        '2b-':'2b-', '2b':'2b+', '2bn':'2bn', '2b+':'3c',
        '3c-':'2b',  '3c':'3c+', '3cn':'3cn', '3c+':'3c+',   '3d-':'3d-', '3d':'3d+', '3dn':'3dn', '3d+':'3d+',
        '3e-':'3e-', '3e':'3e+', '3en':'3en', '3e+':'3f',    '3f-':'3e',  '3f':'3f+', '3fn':'3fn', '3f+':'3f+',
        '3g-':'3g-', '3g':'3g+', '3gn':'3gn', '3g+':'3g+',   '3a-':'3a-', '3a':'3a+', '3an':'3an', '3a+':'3a+',
        '3b-':'3b-', '3b':'3b+', '3bn':'3bn', '3b+':'4c',
        '4c-':'3b',  '4c':'4c+', '4cn':'4cn', '4c+':'4c+',   '4d-':'4d-', '4d':'4d+', '4dn':'4dn', '4d+':'4d+',
        '4e-':'4e-', '4e':'4e+', '4en':'4en', '4e+':'4f',    '4f-':'4e',  '4f':'4f+', '4fn':'4fn', '4f+':'4f+',
        '4g-':'4g-', '4g':'4g+', '4gn':'4gn', '4g+':'4g+',   '4a-':'4a-', '4a':'4a+', '4an':'4an', '4a+':'4a+',
        '4b-':'4b-', '4b':'4b+', '4bn':'4bn', '4b+':'5c',
        '5c-':'4b',  '5c':'5c+', '5cn':'5cn', '5c+':'5c+',   '5d-':'5d-', '5d':'5d+', '5dn':'5dn', '5d+':'5d+',
        '5e-':'5e-', '5e':'5e+', '5en':'5en', '5e+':'5f',    '5f-':'5e',  '5f':'5f+', '5fn':'5fn', '5f+':'5f+',
        '5g-':'5g-', '5g':'5g+', '5gn':'5gn', '5g+':'5g+',   '5a-':'5a-', '5a':'5a+', '5an':'5an', '5a+':'5a+',
        '5b-':'5b-', '5b':'5b+', '5bn':'5bn', '5b+':'6c',
        '6c-':'5b',  '6c':'6c+', '6cn':'6cn', '6c+':'6c+',   '6d-':'6d-', '6d':'6d+', '6dn':'6dn', '6d+':'6d+',
        '6e-':'6e-', '6e':'6e+', '6en':'6en', '6e+':'6f',    '6f-':'6e',  '6f':'6f+', '6fn':'6fn', '6f+':'6f+',
        '6g-':'6g-', '6g':'6g+', '6gn':'6gn', '6g+':'6g+',   '6a-':'6a-', '6a':'6a+', '6an':'6an', '6a+':'6a+',
        '6b-':'6b-', '6b':'6b+', '6bn':'6bn', '6b+':'7c',
        '7c-':'6b',  '7c':'7c+', '7cn':'7cn', '7c+':'7c+',   '7d-':'7d-', '7d':'7d+', '7dn':'7dn', '7d+':'7d+',
        '7e-':'7e-', '7e':'7e+', '7en':'7en', '7e+':'7f',    '7f-':'7e',  '7f':'7f+', '7fn':'7fn', '7f+':'7f+',
        '7g-':'7g-', '7g':'7g+', '7gn':'7gn', '7g+':'7g+',   '7a-':'7a-', '7a':'7a+', '7an':'7an', '7a+':'7a+',
        '7b-':'7b-', '7b':'7b+', '7bn':'7bn', '7b+':'8c',
        '8c-':'7b',  '8c':'8c+', '8cn':'8cn', '8c+':'8c+',   '8d-':'8d-', '8d':'8d+', '8dn':'8dn', '8d+':'8d+',
        '8e-':'8e-', '8e':'8e+', '8en':'8en', '8e+':'8f',    '8f-':'8e',  '8f':'8f+', '8fn':'8fn', '8f+':'8f+',
        '8g-':'8g-', '8g':'8g+', '8gn':'8gn', '8g+':'8g+',   '8a-':'8a-', '8a':'8a+', '8an':'8an', '8a+':'8a+',
        '8b-':'8b-', '8b':'8b+', '8bn':'8bn', '8b+':None,
    },
    'f+':  {     # f+,c+,g+,d+,a+,e+
        '0c-':None,  '0c':'0c+', '0cn':'0cn', '0c+':'0c+',   '0d-':'0d-', '0d':'0d+', '0dn':'0dn', '0d+':'0d+',
        '0e-':'0e-', '0e':'0e+', '0en':'0en', '0e+':'0f',    '0f-':'0e',  '0f':'0f+', '0fn':'0fn', '0f+':'0f+',
        '0g-':'0g-', '0g':'0g+', '0gn':'0gn', '0g+':'0g+',   '0a-':'0a-', '0a':'0a+', '0an':'0an', '0a+':'0a+',
        '0b-':'0b-', '0b':'0b', '0bn':'0b', '0b+':'1c',
        '1c-':'0b',  '1c':'1c+', '1cn':'1cn', '1c+':'1c+',   '1d-':'1d-', '1d':'1d+', '1dn':'1dn', '1d+':'1d+',
        '1e-':'1e-', '1e':'1e+', '1en':'1en', '1e+':'1f',    '1f-':'1e',  '1f':'1f+', '1fn':'1fn', '1f+':'1f+',
        '1g-':'1g-', '1g':'1g+', '1gn':'1gn', '1g+':'1g+',   '1a-':'1a-', '1a':'1a+', '1an':'1an', '1a+':'1a+',
        '1b-':'1b-', '1b':'1b', '1bn':'1b', '1b+':'2c',
        '2c-':'1b',  '2c':'2c+', '2cn':'2cn', '2c+':'2c+',   '2d-':'2d-', '2d':'2d+', '2dn':'2dn', '2d+':'2d+',
        '2e-':'2e-', '2e':'2e+', '2en':'2en', '2e+':'2f',    '2f-':'2e',  '2f':'2f+', '2fn':'2fn', '2f+':'2f+',
        '2g-':'2g-', '2g':'2g+', '2gn':'2gn', '2g+':'2g+',   '2a-':'2a-', '2a':'2a+', '2an':'2an', '2a+':'2a+',
        '2b-':'2b-', '2b':'2b', '2bn':'2b', '2b+':'3c',
        '3c-':'2b',  '3c':'3c+', '3cn':'3cn', '3c+':'3c+',   '3d-':'3d-', '3d':'3d+', '3dn':'3dn', '3d+':'3d+',
        '3e-':'3e-', '3e':'3e+', '3en':'3en', '3e+':'3f',    '3f-':'3e',  '3f':'3f+', '3fn':'3fn', '3f+':'3f+',
        '3g-':'3g-', '3g':'3g+', '3gn':'3gn', '3g+':'3g+',   '3a-':'3a-', '3a':'3a+', '3an':'3an', '3a+':'3a+',
        '3b-':'3b-', '3b':'3b', '3bn':'3b', '3b+':'4c',
        '4c-':'3b',  '4c':'4c+', '4cn':'4cn', '4c+':'4c+',   '4d-':'4d-', '4d':'4d+', '4dn':'4dn', '4d+':'4d+',
        '4e-':'4e-', '4e':'4e+', '4en':'4en', '4e+':'4f',    '4f-':'4e',  '4f':'4f+', '4fn':'4fn', '4f+':'4f+',
        '4g-':'4g-', '4g':'4g+', '4gn':'4gn', '4g+':'4g+',   '4a-':'4a-', '4a':'4a+', '4an':'4an', '4a+':'4a+',
        '4b-':'4b-', '4b':'4b', '4bn':'4b', '4b+':'5c',
        '5c-':'4b',  '5c':'5c+', '5cn':'5cn', '5c+':'5c+',   '5d-':'5d-', '5d':'5d+', '5dn':'5dn', '5d+':'5d+',
        '5e-':'5e-', '5e':'5e+', '5en':'5en', '5e+':'5f',    '5f-':'5e',  '5f':'5f+', '5fn':'5fn', '5f+':'5f+',
        '5g-':'5g-', '5g':'5g+', '5gn':'5gn', '5g+':'5g+',   '5a-':'5a-', '5a':'5a+', '5an':'5an', '5a+':'5a+',
        '5b-':'5b-', '5b':'5b', '5bn':'5b', '5b+':'6c',
        '6c-':'5b',  '6c':'6c+', '6cn':'6cn', '6c+':'6c+',   '6d-':'6d-', '6d':'6d+', '6dn':'6dn', '6d+':'6d+',
        '6e-':'6e-', '6e':'6e+', '6en':'6en', '6e+':'6f',    '6f-':'6e',  '6f':'6f+', '6fn':'6fn', '6f+':'6f+',
        '6g-':'6g-', '6g':'6g+', '6gn':'6gn', '6g+':'6g+',   '6a-':'6a-', '6a':'6a+', '6an':'6an', '6a+':'6a+',
        '6b-':'6b-', '6b':'6b', '6bn':'6b', '6b+':'7c',
        '7c-':'6b',  '7c':'7c+', '7cn':'7cn', '7c+':'7c+',   '7d-':'7d-', '7d':'7d+', '7dn':'7dn', '7d+':'7d+',
        '7e-':'7e-', '7e':'7e+', '7en':'7en', '7e+':'7f',    '7f-':'7e',  '7f':'7f+', '7fn':'7fn', '7f+':'7f+',
        '7g-':'7g-', '7g':'7g+', '7gn':'7gn', '7g+':'7g+',   '7a-':'7a-', '7a':'7a+', '7an':'7an', '7a+':'7a+',
        '7b-':'7b-', '7b':'7b', '7bn':'7b', '7b+':'8c',
        '8c-':'7b',  '8c':'8c+', '8cn':'8cn', '8c+':'8c+',   '8d-':'8d-', '8d':'8d+', '8dn':'8dn', '8d+':'8d+',
        '8e-':'8e-', '8e':'8e+', '8en':'8en', '8e+':'8f',    '8f-':'8e',  '8f':'8f+', '8fn':'8fn', '8f+':'8f+',
        '8g-':'8g-', '8g':'8g+', '8gn':'8gn', '8g+':'8g+',   '8a-':'8a-', '8a':'8a+', '8an':'8an', '8a+':'8a+',
        '8b-':'8b-', '8b':'8b', '8bn':'8b', '8b+':None,
    },
    'b':  {     # f+,c+,g+,d+,a+
        '0c-':None,  '0c':'0c+', '0cn':'0cn', '0c+':'0c+',   '0d-':'0d-', '0d':'0d+', '0dn':'0dn', '0d+':'0d+',
        '0e-':'0e-', '0e':'0e', '0en':'0e', '0e+':'0f',    '0f-':'0e',  '0f':'0f+', '0fn':'0fn', '0f+':'0f+',
        '0g-':'0g-', '0g':'0g+', '0gn':'0gn', '0g+':'0g+',   '0a-':'0a-', '0a':'0a+', '0an':'0an', '0a+':'0a+',
        '0b-':'0b-', '0b':'0b', '0bn':'0b', '0b+':'1c',
        '1c-':'0b',  '1c':'1c+', '1cn':'1cn', '1c+':'1c+',   '1d-':'1d-', '1d':'1d+', '1dn':'1dn', '1d+':'1d+',
        '1e-':'1e-', '1e':'1e', '1en':'1e', '1e+':'1f',    '1f-':'1e',  '1f':'1f+', '1fn':'1fn', '1f+':'1f+',
        '1g-':'1g-', '1g':'1g+', '1gn':'1gn', '1g+':'1g+',   '1a-':'1a-', '1a':'1a+', '1an':'1an', '1a+':'1a+',
        '1b-':'1b-', '1b':'1b', '1bn':'1b', '1b+':'2c',
        '2c-':'1b',  '2c':'2c+', '2cn':'2cn', '2c+':'2c+',   '2d-':'2d-', '2d':'2d+', '2dn':'2dn', '2d+':'2d+',
        '2e-':'2e-', '2e':'2e', '2en':'2e', '2e+':'2f',    '2f-':'2e',  '2f':'2f+', '2fn':'2fn', '2f+':'2f+',
        '2g-':'2g-', '2g':'2g+', '2gn':'2gn', '2g+':'2g+',   '2a-':'2a-', '2a':'2a+', '2an':'2an', '2a+':'2a+',
        '2b-':'2b-', '2b':'2b', '2bn':'2b', '2b+':'3c',
        '3c-':'2b',  '3c':'3c+', '3cn':'3cn', '3c+':'3c+',   '3d-':'3d-', '3d':'3d+', '3dn':'3dn', '3d+':'3d+',
        '3e-':'3e-', '3e':'3e', '3en':'3e', '3e+':'3f',    '3f-':'3e',  '3f':'3f+', '3fn':'3fn', '3f+':'3f+',
        '3g-':'3g-', '3g':'3g+', '3gn':'3gn', '3g+':'3g+',   '3a-':'3a-', '3a':'3a+', '3an':'3an', '3a+':'3a+',
        '3b-':'3b-', '3b':'3b', '3bn':'3b', '3b+':'4c',
        '4c-':'3b',  '4c':'4c+', '4cn':'4cn', '4c+':'4c+',   '4d-':'4d-', '4d':'4d+', '4dn':'4dn', '4d+':'4d+',
        '4e-':'4e-', '4e':'4e', '4en':'4e', '4e+':'4f',    '4f-':'4e',  '4f':'4f+', '4fn':'4fn', '4f+':'4f+',
        '4g-':'4g-', '4g':'4g+', '4gn':'4gn', '4g+':'4g+',   '4a-':'4a-', '4a':'4a+', '4an':'4an', '4a+':'4a+',
        '4b-':'4b-', '4b':'4b', '4bn':'4b', '4b+':'5c',
        '5c-':'4b',  '5c':'5c+', '5cn':'5cn', '5c+':'5c+',   '5d-':'5d-', '5d':'5d+', '5dn':'5dn', '5d+':'5d+',
        '5e-':'5e-', '5e':'5e', '5en':'5e', '5e+':'5f',    '5f-':'5e',  '5f':'5f+', '5fn':'5fn', '5f+':'5f+',
        '5g-':'5g-', '5g':'5g+', '5gn':'5gn', '5g+':'5g+',   '5a-':'5a-', '5a':'5a+', '5an':'5an', '5a+':'5a+',
        '5b-':'5b-', '5b':'5b', '5bn':'5b', '5b+':'6c',
        '6c-':'5b',  '6c':'6c+', '6cn':'6cn', '6c+':'6c+',   '6d-':'6d-', '6d':'6d+', '6dn':'6dn', '6d+':'6d+',
        '6e-':'6e-', '6e':'6e', '6en':'6e', '6e+':'6f',    '6f-':'6e',  '6f':'6f+', '6fn':'6fn', '6f+':'6f+',
        '6g-':'6g-', '6g':'6g+', '6gn':'6gn', '6g+':'6g+',   '6a-':'6a-', '6a':'6a+', '6an':'6an', '6a+':'6a+',
        '6b-':'6b-', '6b':'6b', '6bn':'6b', '6b+':'7c',
        '7c-':'6b',  '7c':'7c+', '7cn':'7cn', '7c+':'7c+',   '7d-':'7d-', '7d':'7d+', '7dn':'7dn', '7d+':'7d+',
        '7e-':'7e-', '7e':'7e', '7en':'7e', '7e+':'7f',    '7f-':'7e',  '7f':'7f+', '7fn':'7fn', '7f+':'7f+',
        '7g-':'7g-', '7g':'7g+', '7gn':'7gn', '7g+':'7g+',   '7a-':'7a-', '7a':'7a+', '7an':'7an', '7a+':'7a+',
        '7b-':'7b-', '7b':'7b', '7bn':'7b', '7b+':'8c',
        '8c-':'7b',  '8c':'8c+', '8cn':'8cn', '8c+':'8c+',   '8d-':'8d-', '8d':'8d+', '8dn':'8dn', '8d+':'8d+',
        '8e-':'8e-', '8e':'8e', '8en':'8e', '8e+':'8f',    '8f-':'8e',  '8f':'8f+', '8fn':'8fn', '8f+':'8f+',
        '8g-':'8g-', '8g':'8g+', '8gn':'8gn', '8g+':'8g+',   '8a-':'8a-', '8a':'8a+', '8an':'8an', '8a+':'8a+',
        '8b-':'8b-', '8b':'8b', '8bn':'8b', '8b+':None,
    },
    'e':  {     # f+,c+,g+,d+
        '0c-':None,  '0c':'0c+', '0cn':'0cn', '0c+':'0c+',   '0d-':'0d-', '0d':'0d+', '0dn':'0dn', '0d+':'0d+',
        '0e-':'0e-', '0e':'0e', '0en':'0e', '0e+':'0f',    '0f-':'0e',  '0f':'0f+', '0fn':'0fn', '0f+':'0f+',
        '0g-':'0g-', '0g':'0g+', '0gn':'0gn', '0g+':'0g+',   '0a-':'0a-', '0a':'0a', '0an':'0a', '0a+':'0a+',
        '0b-':'0b-', '0b':'0b', '0bn':'0b', '0b+':'1c',
        '1c-':'0b',  '1c':'1c+', '1cn':'1cn', '1c+':'1c+',   '1d-':'1d-', '1d':'1d+', '1dn':'1dn', '1d+':'1d+',
        '1e-':'1e-', '1e':'1e', '1en':'1e', '1e+':'1f',    '1f-':'1e',  '1f':'1f+', '1fn':'1fn', '1f+':'1f+',
        '1g-':'1g-', '1g':'1g+', '1gn':'1gn', '1g+':'1g+',   '1a-':'1a-', '1a':'1a', '1an':'1a', '1a+':'1a+',
        '1b-':'1b-', '1b':'1b', '1bn':'1b', '1b+':'2c',
        '2c-':'1b',  '2c':'2c+', '2cn':'2cn', '2c+':'2c+',   '2d-':'2d-', '2d':'2d+', '2dn':'2dn', '2d+':'2d+',
        '2e-':'2e-', '2e':'2e', '2en':'2e', '2e+':'2f',    '2f-':'2e',  '2f':'2f+', '2fn':'2fn', '2f+':'2f+',
        '2g-':'2g-', '2g':'2g+', '2gn':'2gn', '2g+':'2g+',   '2a-':'2a-', '2a':'2a', '2an':'2a', '2a+':'2a+',
        '2b-':'2b-', '2b':'2b', '2bn':'2b', '2b+':'3c',
        '3c-':'2b',  '3c':'3c+', '3cn':'3cn', '3c+':'3c+',   '3d-':'3d-', '3d':'3d+', '3dn':'3dn', '3d+':'3d+',
        '3e-':'3e-', '3e':'3e', '3en':'3e', '3e+':'3f',    '3f-':'3e',  '3f':'3f+', '3fn':'3fn', '3f+':'3f+',
        '3g-':'3g-', '3g':'3g+', '3gn':'3gn', '3g+':'3g+',   '3a-':'3a-', '3a':'3a', '3an':'3a', '3a+':'3a+',
        '3b-':'3b-', '3b':'3b', '3bn':'3b', '3b+':'4c',
        '4c-':'3b',  '4c':'4c+', '4cn':'4cn', '4c+':'4c+',   '4d-':'4d-', '4d':'4d+', '4dn':'4dn', '4d+':'4d+',
        '4e-':'4e-', '4e':'4e', '4en':'4e', '4e+':'4f',    '4f-':'4e',  '4f':'4f+', '4fn':'4fn', '4f+':'4f+',
        '4g-':'4g-', '4g':'4g+', '4gn':'4gn', '4g+':'4g+',   '4a-':'4a-', '4a':'4a', '4an':'4a', '4a+':'4a+',
        '4b-':'4b-', '4b':'4b', '4bn':'4b', '4b+':'5c',
        '5c-':'4b',  '5c':'5c+', '5cn':'5cn', '5c+':'5c+',   '5d-':'5d-', '5d':'5d+', '5dn':'5dn', '5d+':'5d+',
        '5e-':'5e-', '5e':'5e', '5en':'5e', '5e+':'5f',    '5f-':'5e',  '5f':'5f+', '5fn':'5fn', '5f+':'5f+',
        '5g-':'5g-', '5g':'5g+', '5gn':'5gn', '5g+':'5g+',   '5a-':'5a-', '5a':'5a', '5an':'5a', '5a+':'5a+',
        '5b-':'5b-', '5b':'5b', '5bn':'5b', '5b+':'6c',
        '6c-':'5b',  '6c':'6c+', '6cn':'6cn', '6c+':'6c+',   '6d-':'6d-', '6d':'6d+', '6dn':'6dn', '6d+':'6d+',
        '6e-':'6e-', '6e':'6e', '6en':'6e', '6e+':'6f',    '6f-':'6e',  '6f':'6f+', '6fn':'6fn', '6f+':'6f+',
        '6g-':'6g-', '6g':'6g+', '6gn':'6gn', '6g+':'6g+',   '6a-':'6a-', '6a':'6a', '6an':'6a', '6a+':'6a+',
        '6b-':'6b-', '6b':'6b', '6bn':'6b', '6b+':'7c',
        '7c-':'6b',  '7c':'7c+', '7cn':'7cn', '7c+':'7c+',   '7d-':'7d-', '7d':'7d+', '7dn':'7dn', '7d+':'7d+',
        '7e-':'7e-', '7e':'7e', '7en':'7e', '7e+':'7f',    '7f-':'7e',  '7f':'7f+', '7fn':'7fn', '7f+':'7f+',
        '7g-':'7g-', '7g':'7g+', '7gn':'7gn', '7g+':'7g+',   '7a-':'7a-', '7a':'7a', '7an':'7a', '7a+':'7a+',
        '7b-':'7b-', '7b':'7b', '7bn':'7b', '7b+':'8c',
        '8c-':'7b',  '8c':'8c+', '8cn':'8cn', '8c+':'8c+',   '8d-':'8d-', '8d':'8d+', '8dn':'8dn', '8d+':'8d+',
        '8e-':'8e-', '8e':'8e', '8en':'8e', '8e+':'8f',    '8f-':'8e',  '8f':'8f+', '8fn':'8fn', '8f+':'8f+',
        '8g-':'8g-', '8g':'8g+', '8gn':'8gn', '8g+':'8g+',   '8a-':'8a-', '8a':'8a', '8an':'8a', '8a+':'8a+',
        '8b-':'8b-', '8b':'8b', '8bn':'8b', '8b+':None,
    },
    'a':  {     # f+,c+,g+
        '0c-':None,  '0c':'0c+', '0cn':'0cn', '0c+':'0c+',   '0d-':'0d-', '0d':'0d', '0dn':'0d', '0d+':'0d+',
        '0e-':'0e-', '0e':'0e', '0en':'0e', '0e+':'0f',    '0f-':'0e',  '0f':'0f+', '0fn':'0fn', '0f+':'0f+',
        '0g-':'0g-', '0g':'0g+', '0gn':'0gn', '0g+':'0g+',   '0a-':'0a-', '0a':'0a', '0an':'0a', '0a+':'0a+',
        '0b-':'0b-', '0b':'0b', '0bn':'0b', '0b+':'1c',
        '1c-':'0b',  '1c':'1c+', '1cn':'1cn', '1c+':'1c+',   '1d-':'1d-', '1d':'1d', '1dn':'1d', '1d+':'1d+',
        '1e-':'1e-', '1e':'1e', '1en':'1e', '1e+':'1f',    '1f-':'1e',  '1f':'1f+', '1fn':'1fn', '1f+':'1f+',
        '1g-':'1g-', '1g':'1g+', '1gn':'1gn', '1g+':'1g+',   '1a-':'1a-', '1a':'1a', '1an':'1a', '1a+':'1a+',
        '1b-':'1b-', '1b':'1b', '1bn':'1b', '1b+':'2c',
        '2c-':'1b',  '2c':'2c+', '2cn':'2cn', '2c+':'2c+',   '2d-':'2d-', '2d':'2d', '2dn':'2d', '2d+':'2d+',
        '2e-':'2e-', '2e':'2e', '2en':'2e', '2e+':'2f',    '2f-':'2e',  '2f':'2f+', '2fn':'2fn', '2f+':'2f+',
        '2g-':'2g-', '2g':'2g+', '2gn':'2gn', '2g+':'2g+',   '2a-':'2a-', '2a':'2a', '2an':'2a', '2a+':'2a+',
        '2b-':'2b-', '2b':'2b', '2bn':'2b', '2b+':'3c',
        '3c-':'2b',  '3c':'3c+', '3cn':'3cn', '3c+':'3c+',   '3d-':'3d-', '3d':'3d', '3dn':'3d', '3d+':'3d+',
        '3e-':'3e-', '3e':'3e', '3en':'3e', '3e+':'3f',    '3f-':'3e',  '3f':'3f+', '3fn':'3fn', '3f+':'3f+',
        '3g-':'3g-', '3g':'3g+', '3gn':'3gn', '3g+':'3g+',   '3a-':'3a-', '3a':'3a', '3an':'3a', '3a+':'3a+',
        '3b-':'3b-', '3b':'3b', '3bn':'3b', '3b+':'4c',
        '4c-':'3b',  '4c':'4c+', '4cn':'4cn', '4c+':'4c+',   '4d-':'4d-', '4d':'4d', '4dn':'4d', '4d+':'4d+',
        '4e-':'4e-', '4e':'4e', '4en':'4e', '4e+':'4f',    '4f-':'4e',  '4f':'4f+', '4fn':'4fn', '4f+':'4f+',
        '4g-':'4g-', '4g':'4g+', '4gn':'4gn', '4g+':'4g+',   '4a-':'4a-', '4a':'4a', '4an':'4a', '4a+':'4a+',
        '4b-':'4b-', '4b':'4b', '4bn':'4b', '4b+':'5c',
        '5c-':'4b',  '5c':'5c+', '5cn':'5cn', '5c+':'5c+',   '5d-':'5d-', '5d':'5d', '5dn':'5d', '5d+':'5d+',
        '5e-':'5e-', '5e':'5e', '5en':'5e', '5e+':'5f',    '5f-':'5e',  '5f':'5f+', '5fn':'5fn', '5f+':'5f+',
        '5g-':'5g-', '5g':'5g+', '5gn':'5gn', '5g+':'5g+',   '5a-':'5a-', '5a':'5a', '5an':'5a', '5a+':'5a+',
        '5b-':'5b-', '5b':'5b', '5bn':'5b', '5b+':'6c',
        '6c-':'5b',  '6c':'6c+', '6cn':'6cn', '6c+':'6c+',   '6d-':'6d-', '6d':'6d', '6dn':'6d', '6d+':'6d+',
        '6e-':'6e-', '6e':'6e', '6en':'6e', '6e+':'6f',    '6f-':'6e',  '6f':'6f+', '6fn':'6fn', '6f+':'6f+',
        '6g-':'6g-', '6g':'6g+', '6gn':'6gn', '6g+':'6g+',   '6a-':'6a-', '6a':'6a', '6an':'6a', '6a+':'6a+',
        '6b-':'6b-', '6b':'6b', '6bn':'6b', '6b+':'7c',
        '7c-':'6b',  '7c':'7c+', '7cn':'7cn', '7c+':'7c+',   '7d-':'7d-', '7d':'7d', '7dn':'7d', '7d+':'7d+',
        '7e-':'7e-', '7e':'7e', '7en':'7e', '7e+':'7f',    '7f-':'7e',  '7f':'7f+', '7fn':'7fn', '7f+':'7f+',
        '7g-':'7g-', '7g':'7g+', '7gn':'7gn', '7g+':'7g+',   '7a-':'7a-', '7a':'7a', '7an':'7a', '7a+':'7a+',
        '7b-':'7b-', '7b':'7b', '7bn':'7b', '7b+':'8c',
        '8c-':'7b',  '8c':'8c+', '8cn':'8cn', '8c+':'8c+',   '8d-':'8d-', '8d':'8d', '8dn':'8d', '8d+':'8d+',
        '8e-':'8e-', '8e':'8e', '8en':'8e', '8e+':'8f',    '8f-':'8e',  '8f':'8f+', '8fn':'8fn', '8f+':'8f+',
        '8g-':'8g-', '8g':'8g+', '8gn':'8gn', '8g+':'8g+',   '8a-':'8a-', '8a':'8a', '8an':'8a', '8a+':'8a+',
        '8b-':'8b-', '8b':'8b', '8bn':'8b', '8b+':None,
    },
    'd':  {     # f+,c+
        '0c-':None,  '0c':'0c+', '0cn':'0cn', '0c+':'0c+',   '0d-':'0d-', '0d':'0d', '0dn':'0d', '0d+':'0d+',
        '0e-':'0e-', '0e':'0e', '0en':'0e', '0e+':'0f',    '0f-':'0e',  '0f':'0f+', '0fn':'0fn', '0f+':'0f+',
        '0g-':'0g-', '0g':'0g', '0gn':'0g', '0g+':'0g+',   '0a-':'0a-', '0a':'0a', '0an':'0a', '0a+':'0a+',
        '0b-':'0b-', '0b':'0b', '0bn':'0b', '0b+':'1c',
        '1c-':'0b',  '1c':'1c+', '1cn':'1cn', '1c+':'1c+',   '1d-':'1d-', '1d':'1d', '1dn':'1d', '1d+':'1d+',
        '1e-':'1e-', '1e':'1e', '1en':'1e', '1e+':'1f',    '1f-':'1e',  '1f':'1f+', '1fn':'1fn', '1f+':'1f+',
        '1g-':'1g-', '1g':'1g', '1gn':'1g', '1g+':'1g+',   '1a-':'1a-', '1a':'1a', '1an':'1a', '1a+':'1a+',
        '1b-':'1b-', '1b':'1b', '1bn':'1b', '1b+':'2c',
        '2c-':'1b',  '2c':'2c+', '2cn':'2cn', '2c+':'2c+',   '2d-':'2d-', '2d':'2d', '2dn':'2d', '2d+':'2d+',
        '2e-':'2e-', '2e':'2e', '2en':'2e', '2e+':'2f',    '2f-':'2e',  '2f':'2f+', '2fn':'2fn', '2f+':'2f+',
        '2g-':'2g-', '2g':'2g', '2gn':'2g', '2g+':'2g+',   '2a-':'2a-', '2a':'2a', '2an':'2a', '2a+':'2a+',
        '2b-':'2b-', '2b':'2b', '2bn':'2b', '2b+':'3c',
        '3c-':'2b',  '3c':'3c+', '3cn':'3cn', '3c+':'3c+',   '3d-':'3d-', '3d':'3d', '3dn':'3d', '3d+':'3d+',
        '3e-':'3e-', '3e':'3e', '3en':'3e', '3e+':'3f',    '3f-':'3e',  '3f':'3f+', '3fn':'3fn', '3f+':'3f+',
        '3g-':'3g-', '3g':'3g', '3gn':'3g', '3g+':'3g+',   '3a-':'3a-', '3a':'3a', '3an':'3a', '3a+':'3a+',
        '3b-':'3b-', '3b':'3b', '3bn':'3b', '3b+':'4c',
        '4c-':'3b',  '4c':'4c+', '4cn':'4cn', '4c+':'4c+',   '4d-':'4d-', '4d':'4d', '4dn':'4d', '4d+':'4d+',
        '4e-':'4e-', '4e':'4e', '4en':'4e', '4e+':'4f',    '4f-':'4e',  '4f':'4f+', '4fn':'4fn', '4f+':'4f+',
        '4g-':'4g-', '4g':'4g', '4gn':'4g', '4g+':'4g+',   '4a-':'4a-', '4a':'4a', '4an':'4a', '4a+':'4a+',
        '4b-':'4b-', '4b':'4b', '4bn':'4b', '4b+':'5c',
        '5c-':'4b',  '5c':'5c+', '5cn':'5cn', '5c+':'5c+',   '5d-':'5d-', '5d':'5d', '5dn':'5d', '5d+':'5d+',
        '5e-':'5e-', '5e':'5e', '5en':'5e', '5e+':'5f',    '5f-':'5e',  '5f':'5f+', '5fn':'5fn', '5f+':'5f+',
        '5g-':'5g-', '5g':'5g', '5gn':'5g', '5g+':'5g+',   '5a-':'5a-', '5a':'5a', '5an':'5a', '5a+':'5a+',
        '5b-':'5b-', '5b':'5b', '5bn':'5b', '5b+':'6c',
        '6c-':'5b',  '6c':'6c+', '6cn':'6cn', '6c+':'6c+',   '6d-':'6d-', '6d':'6d', '6dn':'6d', '6d+':'6d+',
        '6e-':'6e-', '6e':'6e', '6en':'6e', '6e+':'6f',    '6f-':'6e',  '6f':'6f+', '6fn':'6fn', '6f+':'6f+',
        '6g-':'6g-', '6g':'6g', '6gn':'6g', '6g+':'6g+',   '6a-':'6a-', '6a':'6a', '6an':'6a', '6a+':'6a+',
        '6b-':'6b-', '6b':'6b', '6bn':'6b', '6b+':'7c',
        '7c-':'6b',  '7c':'7c+', '7cn':'7cn', '7c+':'7c+',   '7d-':'7d-', '7d':'7d', '7dn':'7d', '7d+':'7d+',
        '7e-':'7e-', '7e':'7e', '7en':'7e', '7e+':'7f',    '7f-':'7e',  '7f':'7f+', '7fn':'7fn', '7f+':'7f+',
        '7g-':'7g-', '7g':'7g', '7gn':'7g', '7g+':'7g+',   '7a-':'7a-', '7a':'7a', '7an':'7a', '7a+':'7a+',
        '7b-':'7b-', '7b':'7b', '7bn':'7b', '7b+':'8c',
        '8c-':'7b',  '8c':'8c+', '8cn':'8cn', '8c+':'8c+',   '8d-':'8d-', '8d':'8d', '8dn':'8d', '8d+':'8d+',
        '8e-':'8e-', '8e':'8e', '8en':'8e', '8e+':'8f',    '8f-':'8e',  '8f':'8f+', '8fn':'8fn', '8f+':'8f+',
        '8g-':'8g-', '8g':'8g', '8gn':'8g', '8g+':'8g+',   '8a-':'8a-', '8a':'8a', '8an':'8a', '8a+':'8a+',
        '8b-':'8b-', '8b':'8b', '8bn':'8b', '8b+':None,
    },
    'g':  {     # f+
        '0c-':None,  '0c':'0c', '0cn':'0c', '0c+':'0c+',   '0d-':'0d-', '0d':'0d', '0dn':'0d', '0d+':'0d+',
        '0e-':'0e-', '0e':'0e', '0en':'0e', '0e+':'0f',    '0f-':'0e',  '0f':'0f+', '0fn':'0fn', '0f+':'0f+',
        '0g-':'0g-', '0g':'0g', '0gn':'0g', '0g+':'0g+',   '0a-':'0a-', '0a':'0a', '0an':'0a', '0a+':'0a+',
        '0b-':'0b-', '0b':'0b', '0bn':'0b', '0b+':'1c',
        '1c-':'0b',  '1c':'1c', '1cn':'1c', '1c+':'1c+',   '1d-':'1d-', '1d':'1d', '1dn':'1d', '1d+':'1d+',
        '1e-':'1e-', '1e':'1e', '1en':'1e', '1e+':'1f',    '1f-':'1e',  '1f':'1f+', '1fn':'1fn', '1f+':'1f+',
        '1g-':'1g-', '1g':'1g', '1gn':'1g', '1g+':'1g+',   '1a-':'1a-', '1a':'1a', '1an':'1a', '1a+':'1a+',
        '1b-':'1b-', '1b':'1b', '1bn':'1b', '1b+':'2c',
        '2c-':'1b',  '2c':'2c', '2cn':'2c', '2c+':'2c+',   '2d-':'2d-', '2d':'2d', '2dn':'2d', '2d+':'2d+',
        '2e-':'2e-', '2e':'2e', '2en':'2e', '2e+':'2f',    '2f-':'2e',  '2f':'2f+', '2fn':'2fn', '2f+':'2f+',
        '2g-':'2g-', '2g':'2g', '2gn':'2g', '2g+':'2g+',   '2a-':'2a-', '2a':'2a', '2an':'2a', '2a+':'2a+',
        '2b-':'2b-', '2b':'2b', '2bn':'2b', '2b+':'3c',
        '3c-':'2b',  '3c':'3c', '3cn':'3c', '3c+':'3c+',   '3d-':'3d-', '3d':'3d', '3dn':'3d', '3d+':'3d+',
        '3e-':'3e-', '3e':'3e', '3en':'3e', '3e+':'3f',    '3f-':'3e',  '3f':'3f+', '3fn':'3fn', '3f+':'3f+',
        '3g-':'3g-', '3g':'3g', '3gn':'3g', '3g+':'3g+',   '3a-':'3a-', '3a':'3a', '3an':'3a', '3a+':'3a+',
        '3b-':'3b-', '3b':'3b', '3bn':'3b', '3b+':'4c',
        '4c-':'3b',  '4c':'4c', '4cn':'4c', '4c+':'4c+',   '4d-':'4d-', '4d':'4d', '4dn':'4d', '4d+':'4d+',
        '4e-':'4e-', '4e':'4e', '4en':'4e', '4e+':'4f',    '4f-':'4e',  '4f':'4f+', '4fn':'4fn', '4f+':'4f+',
        '4g-':'4g-', '4g':'4g', '4gn':'4g', '4g+':'4g+',   '4a-':'4a-', '4a':'4a', '4an':'4a', '4a+':'4a+',
        '4b-':'4b-', '4b':'4b', '4bn':'4b', '4b+':'5c',
        '5c-':'4b',  '5c':'5c', '5cn':'5c', '5c+':'5c+',   '5d-':'5d-', '5d':'5d', '5dn':'5d', '5d+':'5d+',
        '5e-':'5e-', '5e':'5e', '5en':'5e', '5e+':'5f',    '5f-':'5e',  '5f':'5f+', '5fn':'5fn', '5f+':'5f+',
        '5g-':'5g-', '5g':'5g', '5gn':'5g', '5g+':'5g+',   '5a-':'5a-', '5a':'5a', '5an':'5a', '5a+':'5a+',
        '5b-':'5b-', '5b':'5b', '5bn':'5b', '5b+':'6c',
        '6c-':'5b',  '6c':'6c', '6cn':'6c', '6c+':'6c+',   '6d-':'6d-', '6d':'6d', '6dn':'6d', '6d+':'6d+',
        '6e-':'6e-', '6e':'6e', '6en':'6e', '6e+':'6f',    '6f-':'6e',  '6f':'6f+', '6fn':'6fn', '6f+':'6f+',
        '6g-':'6g-', '6g':'6g', '6gn':'6g', '6g+':'6g+',   '6a-':'6a-', '6a':'6a', '6an':'6a', '6a+':'6a+',
        '6b-':'6b-', '6b':'6b', '6bn':'6b', '6b+':'7c',
        '7c-':'6b',  '7c':'7c', '7cn':'7c', '7c+':'7c+',   '7d-':'7d-', '7d':'7d', '7dn':'7d', '7d+':'7d+',
        '7e-':'7e-', '7e':'7e', '7en':'7e', '7e+':'7f',    '7f-':'7e',  '7f':'7f+', '7fn':'7fn', '7f+':'7f+',
        '7g-':'7g-', '7g':'7g', '7gn':'7g', '7g+':'7g+',   '7a-':'7a-', '7a':'7a', '7an':'7a', '7a+':'7a+',
        '7b-':'7b-', '7b':'7b', '7bn':'7b', '7b+':'8c',
        '8c-':'7b',  '8c':'8c', '8cn':'8c', '8c+':'8c+',   '8d-':'8d-', '8d':'8d', '8dn':'8d', '8d+':'8d+',
        '8e-':'8e-', '8e':'8e', '8en':'8e', '8e+':'8f',    '8f-':'8e',  '8f':'8f+', '8fn':'8fn', '8f+':'8f+',
        '8g-':'8g-', '8g':'8g', '8gn':'8g', '8g+':'8g+',   '8a-':'8a-', '8a':'8a', '8an':'8a', '8a+':'8a+',
        '8b-':'8b-', '8b':'8b', '8bn':'8b', '8b+':None,
    },
    'c':  {     # No sharps or flats.
        '0c-':None,  '0c':'0c', '0cn':'0c', '0c+':'0c+',   '0d-':'0d-', '0d':'0d', '0dn':'0d', '0d+':'0d+',
        '0e-':'0e-', '0e':'0e', '0en':'0e', '0e+':'0f',    '0f-':'0e',  '0f':'0f', '0fn':'0f', '0f+':'0f+',
        '0g-':'0g-', '0g':'0g', '0gn':'0g', '0g+':'0g+',   '0a-':'0a-', '0a':'0a', '0an':'0a', '0a+':'0a+',
        '0b-':'0b-', '0b':'0b', '0bn':'0b', '0b+':'1c',
        '1c-':'0b',  '1c':'1c', '1cn':'1c', '1c+':'1c+',   '1d-':'1d-', '1d':'1d', '1dn':'1d', '1d+':'1d+',
        '1e-':'1e-', '1e':'1e', '1en':'1e', '1e+':'1f',    '1f-':'1e',  '1f':'1f', '1fn':'1f', '1f+':'1f+',
        '1g-':'1g-', '1g':'1g', '1gn':'1g', '1g+':'1g+',   '1a-':'1a-', '1a':'1a', '1an':'1a', '1a+':'1a+',
        '1b-':'1b-', '1b':'1b', '1bn':'1b', '1b+':'2c',
        '2c-':'1b',  '2c':'2c', '2cn':'2c', '2c+':'2c+',   '2d-':'2d-', '2d':'2d', '2dn':'2d', '2d+':'2d+',
        '2e-':'2e-', '2e':'2e', '2en':'2e', '2e+':'2f',    '2f-':'2e',  '2f':'2f', '2fn':'2f', '2f+':'2f+',
        '2g-':'2g-', '2g':'2g', '2gn':'2g', '2g+':'2g+',   '2a-':'2a-', '2a':'2a', '2an':'2a', '2a+':'2a+',
        '2b-':'2b-', '2b':'2b', '2bn':'2b', '2b+':'3c',
        '3c-':'2b',  '3c':'3c', '3cn':'3c', '3c+':'3c+',   '3d-':'3d-', '3d':'3d', '3dn':'3d', '3d+':'3d+',
        '3e-':'3e-', '3e':'3e', '3en':'3e', '3e+':'3f',    '3f-':'3e',  '3f':'3f', '3fn':'3f', '3f+':'3f+',
        '3g-':'3g-', '3g':'3g', '3gn':'3g', '3g+':'3g+',   '3a-':'3a-', '3a':'3a', '3an':'3a', '3a+':'3a+',
        '3b-':'3b-', '3b':'3b', '3bn':'3b', '3b+':'4c',
        '4c-':'3b',  '4c':'4c', '4cn':'4c', '4c+':'4c+',   '4d-':'4d-', '4d':'4d', '4dn':'4d', '4d+':'4d+',
        '4e-':'4e-', '4e':'4e', '4en':'4e', '4e+':'4f',    '4f-':'4e',  '4f':'4f', '4fn':'4f', '4f+':'4f+',
        '4g-':'4g-', '4g':'4g', '4gn':'4g', '4g+':'4g+',   '4a-':'4a-', '4a':'4a', '4an':'4a', '4a+':'4a+',
        '4b-':'4b-', '4b':'4b', '4bn':'4b', '4b+':'5c',
        '5c-':'4b',  '5c':'5c', '5cn':'5c', '5c+':'5c+',   '5d-':'5d-', '5d':'5d', '5dn':'5d', '5d+':'5d+',
        '5e-':'5e-', '5e':'5e', '5en':'5e', '5e+':'5f',    '5f-':'5e',  '5f':'5f', '5fn':'5f', '5f+':'5f+',
        '5g-':'5g-', '5g':'5g', '5gn':'5g', '5g+':'5g+',   '5a-':'5a-', '5a':'5a', '5an':'5a', '5a+':'5a+',
        '5b-':'5b-', '5b':'5b', '5bn':'5b', '5b+':'6c',
        '6c-':'5b',  '6c':'6c', '6cn':'6c', '6c+':'6c+',   '6d-':'6d-', '6d':'6d', '6dn':'6d', '6d+':'6d+',
        '6e-':'6e-', '6e':'6e', '6en':'6e', '6e+':'6f',    '6f-':'6e',  '6f':'6f', '6fn':'6f', '6f+':'6f+',
        '6g-':'6g-', '6g':'6g', '6gn':'6g', '6g+':'6g+',   '6a-':'6a-', '6a':'6a', '6an':'6a', '6a+':'6a+',
        '6b-':'6b-', '6b':'6b', '6bn':'6b', '6b+':'7c',
        '7c-':'6b',  '7c':'7c', '7cn':'7c', '7c+':'7c+',   '7d-':'7d-', '7d':'7d', '7dn':'7d', '7d+':'7d+',
        '7e-':'7e-', '7e':'7e', '7en':'7e', '7e+':'7f',    '7f-':'7e',  '7f':'7f', '7fn':'7f', '7f+':'7f+',
        '7g-':'7g-', '7g':'7g', '7gn':'7g', '7g+':'7g+',   '7a-':'7a-', '7a':'7a', '7an':'7a', '7a+':'7a+',
        '7b-':'7b-', '7b':'7b', '7bn':'7b', '7b+':'8c',
        '8c-':'7b',  '8c':'8c', '8cn':'8c', '8c+':'8c+',   '8d-':'8d-', '8d':'8d', '8dn':'8d', '8d+':'8d+',
        '8e-':'8e-', '8e':'8e', '8en':'8e', '8e+':'8f',    '8f-':'8e',  '8f':'8f', '8fn':'8f', '8f+':'8f+',
        '8g-':'8g-', '8g':'8g', '8gn':'8g', '8g+':'8g+',   '8a-':'8a-', '8a':'8a', '8an':'8a', '8a+':'8a+',
        '8b-':'8b-', '8b':'8b', '8bn':'8b', '8b+':None,
    },
    'cn':  {     # No sharps or flats.
        '0c-':None,  '0c':'0c', '0cn':'0c', '0c+':'0c+',   '0d-':'0d-', '0d':'0d', '0dn':'0d', '0d+':'0d+',
        '0e-':'0e-', '0e':'0e', '0en':'0e', '0e+':'0f',    '0f-':'0e',  '0f':'0f', '0fn':'0f', '0f+':'0f+',
        '0g-':'0g-', '0g':'0g', '0gn':'0g', '0g+':'0g+',   '0a-':'0a-', '0a':'0a', '0an':'0a', '0a+':'0a+',
        '0b-':'0b-', '0b':'0b', '0bn':'0b', '0b+':'1c',
        '1c-':'0b',  '1c':'1c', '1cn':'1c', '1c+':'1c+',   '1d-':'1d-', '1d':'1d', '1dn':'1d', '1d+':'1d+',
        '1e-':'1e-', '1e':'1e', '1en':'1e', '1e+':'1f',    '1f-':'1e',  '1f':'1f', '1fn':'1f', '1f+':'1f+',
        '1g-':'1g-', '1g':'1g', '1gn':'1g', '1g+':'1g+',   '1a-':'1a-', '1a':'1a', '1an':'1a', '1a+':'1a+',
        '1b-':'1b-', '1b':'1b', '1bn':'1b', '1b+':'2c',
        '2c-':'1b',  '2c':'2c', '2cn':'2c', '2c+':'2c+',   '2d-':'2d-', '2d':'2d', '2dn':'2d', '2d+':'2d+',
        '2e-':'2e-', '2e':'2e', '2en':'2e', '2e+':'2f',    '2f-':'2e',  '2f':'2f', '2fn':'2f', '2f+':'2f+',
        '2g-':'2g-', '2g':'2g', '2gn':'2g', '2g+':'2g+',   '2a-':'2a-', '2a':'2a', '2an':'2a', '2a+':'2a+',
        '2b-':'2b-', '2b':'2b', '2bn':'2b', '2b+':'3c',
        '3c-':'2b',  '3c':'3c', '3cn':'3c', '3c+':'3c+',   '3d-':'3d-', '3d':'3d', '3dn':'3d', '3d+':'3d+',
        '3e-':'3e-', '3e':'3e', '3en':'3e', '3e+':'3f',    '3f-':'3e',  '3f':'3f', '3fn':'3f', '3f+':'3f+',
        '3g-':'3g-', '3g':'3g', '3gn':'3g', '3g+':'3g+',   '3a-':'3a-', '3a':'3a', '3an':'3a', '3a+':'3a+',
        '3b-':'3b-', '3b':'3b', '3bn':'3b', '3b+':'4c',
        '4c-':'3b',  '4c':'4c', '4cn':'4c', '4c+':'4c+',   '4d-':'4d-', '4d':'4d', '4dn':'4d', '4d+':'4d+',
        '4e-':'4e-', '4e':'4e', '4en':'4e', '4e+':'4f',    '4f-':'4e',  '4f':'4f', '4fn':'4f', '4f+':'4f+',
        '4g-':'4g-', '4g':'4g', '4gn':'4g', '4g+':'4g+',   '4a-':'4a-', '4a':'4a', '4an':'4a', '4a+':'4a+',
        '4b-':'4b-', '4b':'4b', '4bn':'4b', '4b+':'5c',
        '5c-':'4b',  '5c':'5c', '5cn':'5c', '5c+':'5c+',   '5d-':'5d-', '5d':'5d', '5dn':'5d', '5d+':'5d+',
        '5e-':'5e-', '5e':'5e', '5en':'5e', '5e+':'5f',    '5f-':'5e',  '5f':'5f', '5fn':'5f', '5f+':'5f+',
        '5g-':'5g-', '5g':'5g', '5gn':'5g', '5g+':'5g+',   '5a-':'5a-', '5a':'5a', '5an':'5a', '5a+':'5a+',
        '5b-':'5b-', '5b':'5b', '5bn':'5b', '5b+':'6c',
        '6c-':'5b',  '6c':'6c', '6cn':'6c', '6c+':'6c+',   '6d-':'6d-', '6d':'6d', '6dn':'6d', '6d+':'6d+',
        '6e-':'6e-', '6e':'6e', '6en':'6e', '6e+':'6f',    '6f-':'6e',  '6f':'6f', '6fn':'6f', '6f+':'6f+',
        '6g-':'6g-', '6g':'6g', '6gn':'6g', '6g+':'6g+',   '6a-':'6a-', '6a':'6a', '6an':'6a', '6a+':'6a+',
        '6b-':'6b-', '6b':'6b', '6bn':'6b', '6b+':'7c',
        '7c-':'6b',  '7c':'7c', '7cn':'7c', '7c+':'7c+',   '7d-':'7d-', '7d':'7d', '7dn':'7d', '7d+':'7d+',
        '7e-':'7e-', '7e':'7e', '7en':'7e', '7e+':'7f',    '7f-':'7e',  '7f':'7f', '7fn':'7f', '7f+':'7f+',
        '7g-':'7g-', '7g':'7g', '7gn':'7g', '7g+':'7g+',   '7a-':'7a-', '7a':'7a', '7an':'7a', '7a+':'7a+',
        '7b-':'7b-', '7b':'7b', '7bn':'7b', '7b+':'8c',
        '8c-':'7b',  '8c':'8c', '8cn':'8c', '8c+':'8c+',   '8d-':'8d-', '8d':'8d', '8dn':'8d', '8d+':'8d+',
        '8e-':'8e-', '8e':'8e', '8en':'8e', '8e+':'8f',    '8f-':'8e',  '8f':'8f', '8fn':'8f', '8f+':'8f+',
        '8g-':'8g-', '8g':'8g', '8gn':'8g', '8g+':'8g+',   '8a-':'8a-', '8a':'8a', '8an':'8a', '8a+':'8a+',
        '8b-':'8b-', '8b':'8b', '8bn':'8b', '8b+':None,
    },
    'f':  {     # b-
        '0c-':None,  '0c':'0c', '0cn':'0c', '0c+':'0c+',   '0d-':'0d-', '0d':'0d', '0dn':'0d', '0d+':'0d+',
        '0e-':'0e-', '0e':'0e', '0en':'0e', '0e+':'0f',    '0f-':'0e',  '0f':'0f', '0fn':'0f', '0f+':'0f+',
        '0g-':'0g-', '0g':'0g', '0gn':'0g', '0g+':'0g+',   '0a-':'0a-', '0a':'0a', '0an':'0a', '0a+':'0a+',
        '0b-':'0b-', '0b':'0b-', '0bn':'0bn', '0b+':'1c',
        '1c-':'0b',  '1c':'1c', '1cn':'1c', '1c+':'1c+',   '1d-':'1d-', '1d':'1d', '1dn':'1d', '1d+':'1d+',
        '1e-':'1e-', '1e':'1e', '1en':'1e', '1e+':'1f',    '1f-':'1e',  '1f':'1f', '1fn':'1f', '1f+':'1f+',
        '1g-':'1g-', '1g':'1g', '1gn':'1g', '1g+':'1g+',   '1a-':'1a-', '1a':'1a', '1an':'1a', '1a+':'1a+',
        '1b-':'1b-', '1b':'1b-', '1bn':'1bn', '1b+':'2c',
        '2c-':'1b',  '2c':'2c', '2cn':'2c', '2c+':'2c+',   '2d-':'2d-', '2d':'2d', '2dn':'2d', '2d+':'2d+',
        '2e-':'2e-', '2e':'2e', '2en':'2e', '2e+':'2f',    '2f-':'2e',  '2f':'2f', '2fn':'2f', '2f+':'2f+',
        '2g-':'2g-', '2g':'2g', '2gn':'2g', '2g+':'2g+',   '2a-':'2a-', '2a':'2a', '2an':'2a', '2a+':'2a+',
        '2b-':'2b-', '2b':'2b-', '2bn':'2bn', '2b+':'3c',
        '3c-':'2b',  '3c':'3c', '3cn':'3c', '3c+':'3c+',   '3d-':'3d-', '3d':'3d', '3dn':'3d', '3d+':'3d+',
        '3e-':'3e-', '3e':'3e', '3en':'3e', '3e+':'3f',    '3f-':'3e',  '3f':'3f', '3fn':'3f', '3f+':'3f+',
        '3g-':'3g-', '3g':'3g', '3gn':'3g', '3g+':'3g+',   '3a-':'3a-', '3a':'3a', '3an':'3a', '3a+':'3a+',
        '3b-':'3b-', '3b':'3b-', '3bn':'3bn', '3b+':'4c',
        '4c-':'3b',  '4c':'4c', '4cn':'4c', '4c+':'4c+',   '4d-':'4d-', '4d':'4d', '4dn':'4d', '4d+':'4d+',
        '4e-':'4e-', '4e':'4e', '4en':'4e', '4e+':'4f',    '4f-':'4e',  '4f':'4f', '4fn':'4f', '4f+':'4f+',
        '4g-':'4g-', '4g':'4g', '4gn':'4g', '4g+':'4g+',   '4a-':'4a-', '4a':'4a', '4an':'4a', '4a+':'4a+',
        '4b-':'4b-', '4b':'4b-', '4bn':'4bn', '4b+':'5c',
        '5c-':'4b',  '5c':'5c', '5cn':'5c', '5c+':'5c+',   '5d-':'5d-', '5d':'5d', '5dn':'5d', '5d+':'5d+',
        '5e-':'5e-', '5e':'5e', '5en':'5e', '5e+':'5f',    '5f-':'5e',  '5f':'5f', '5fn':'5f', '5f+':'5f+',
        '5g-':'5g-', '5g':'5g', '5gn':'5g', '5g+':'5g+',   '5a-':'5a-', '5a':'5a', '5an':'5a', '5a+':'5a+',
        '5b-':'5b-', '5b':'5b-', '5bn':'5bn', '5b+':'6c',
        '6c-':'5b',  '6c':'6c', '6cn':'6c', '6c+':'6c+',   '6d-':'6d-', '6d':'6d', '6dn':'6d', '6d+':'6d+',
        '6e-':'6e-', '6e':'6e', '6en':'6e', '6e+':'6f',    '6f-':'6e',  '6f':'6f', '6fn':'6f', '6f+':'6f+',
        '6g-':'6g-', '6g':'6g', '6gn':'6g', '6g+':'6g+',   '6a-':'6a-', '6a':'6a', '6an':'6a', '6a+':'6a+',
        '6b-':'6b-', '6b':'6b-', '6bn':'6bn', '6b+':'7c',
        '7c-':'6b',  '7c':'7c', '7cn':'7c', '7c+':'7c+',   '7d-':'7d-', '7d':'7d', '7dn':'7d', '7d+':'7d+',
        '7e-':'7e-', '7e':'7e', '7en':'7e', '7e+':'7f',    '7f-':'7e',  '7f':'7f', '7fn':'7f', '7f+':'7f+',
        '7g-':'7g-', '7g':'7g', '7gn':'7g', '7g+':'7g+',   '7a-':'7a-', '7a':'7a', '7an':'7a', '7a+':'7a+',
        '7b-':'7b-', '7b':'7b-', '7bn':'7bn', '7b+':'8c',
        '8c-':'7b',  '8c':'8c', '8cn':'8c', '8c+':'8c+',   '8d-':'8d-', '8d':'8d', '8dn':'8d', '8d+':'8d+',
        '8e-':'8e-', '8e':'8e', '8en':'8e', '8e+':'8f',    '8f-':'8e',  '8f':'8f', '8fn':'8f', '8f+':'8f+',
        '8g-':'8g-', '8g':'8g', '8gn':'8g', '8g+':'8g+',   '8a-':'8a-', '8a':'8a', '8an':'8a', '8a+':'8a+',
        '8b-':'8b-', '8b':'8b-', '8bn':'8bn', '8b+':None,
    },
    'b-':  {     # b-,e-
        '0c-':None,  '0c':'0c', '0cn':'0c', '0c+':'0c+',   '0d-':'0d-', '0d':'0d', '0dn':'0d', '0d+':'0d+',
        '0e-':'0e-', '0e':'0e-', '0en':'0en', '0e+':'0f',    '0f-':'0e',  '0f':'0f', '0fn':'0f', '0f+':'0f+',
        '0g-':'0g-', '0g':'0g', '0gn':'0g', '0g+':'0g+',   '0a-':'0a-', '0a':'0a', '0an':'0a', '0a+':'0a+',
        '0b-':'0b-', '0b':'0b-', '0bn':'0bn', '0b+':'1c',
        '1c-':'0b',  '1c':'1c', '1cn':'1c', '1c+':'1c+',   '1d-':'1d-', '1d':'1d', '1dn':'1d', '1d+':'1d+',
        '1e-':'1e-', '1e':'1e-', '1en':'1en', '1e+':'1f',    '1f-':'1e',  '1f':'1f', '1fn':'1f', '1f+':'1f+',
        '1g-':'1g-', '1g':'1g', '1gn':'1g', '1g+':'1g+',   '1a-':'1a-', '1a':'1a', '1an':'1a', '1a+':'1a+',
        '1b-':'1b-', '1b':'1b-', '1bn':'1bn', '1b+':'2c',
        '2c-':'1b',  '2c':'2c', '2cn':'2c', '2c+':'2c+',   '2d-':'2d-', '2d':'2d', '2dn':'2d', '2d+':'2d+',
        '2e-':'2e-', '2e':'2e-', '2en':'2en', '2e+':'2f',    '2f-':'2e',  '2f':'2f', '2fn':'2f', '2f+':'2f+',
        '2g-':'2g-', '2g':'2g', '2gn':'2g', '2g+':'2g+',   '2a-':'2a-', '2a':'2a', '2an':'2a', '2a+':'2a+',
        '2b-':'2b-', '2b':'2b-', '2bn':'2bn', '2b+':'3c',
        '3c-':'2b',  '3c':'3c', '3cn':'3c', '3c+':'3c+',   '3d-':'3d-', '3d':'3d', '3dn':'3d', '3d+':'3d+',
        '3e-':'3e-', '3e':'3e-', '3en':'3en', '3e+':'3f',    '3f-':'3e',  '3f':'3f', '3fn':'3f', '3f+':'3f+',
        '3g-':'3g-', '3g':'3g', '3gn':'3g', '3g+':'3g+',   '3a-':'3a-', '3a':'3a', '3an':'3a', '3a+':'3a+',
        '3b-':'3b-', '3b':'3b-', '3bn':'3bn', '3b+':'4c',
        '4c-':'3b',  '4c':'4c', '4cn':'4c', '4c+':'4c+',   '4d-':'4d-', '4d':'4d', '4dn':'4d', '4d+':'4d+',
        '4e-':'4e-', '4e':'4e-', '4en':'4en', '4e+':'4f',    '4f-':'4e',  '4f':'4f', '4fn':'4f', '4f+':'4f+',
        '4g-':'4g-', '4g':'4g', '4gn':'4g', '4g+':'4g+',   '4a-':'4a-', '4a':'4a', '4an':'4a', '4a+':'4a+',
        '4b-':'4b-', '4b':'4b-', '4bn':'4bn', '4b+':'5c',
        '5c-':'4b',  '5c':'5c', '5cn':'5c', '5c+':'5c+',   '5d-':'5d-', '5d':'5d', '5dn':'5d', '5d+':'5d+',
        '5e-':'5e-', '5e':'5e-', '5en':'5en', '5e+':'5f',    '5f-':'5e',  '5f':'5f', '5fn':'5f', '5f+':'5f+',
        '5g-':'5g-', '5g':'5g', '5gn':'5g', '5g+':'5g+',   '5a-':'5a-', '5a':'5a', '5an':'5a', '5a+':'5a+',
        '5b-':'5b-', '5b':'5b-', '5bn':'5bn', '5b+':'6c',
        '6c-':'5b',  '6c':'6c', '6cn':'6c', '6c+':'6c+',   '6d-':'6d-', '6d':'6d', '6dn':'6d', '6d+':'6d+',
        '6e-':'6e-', '6e':'6e-', '6en':'6en', '6e+':'6f',    '6f-':'6e',  '6f':'6f', '6fn':'6f', '6f+':'6f+',
        '6g-':'6g-', '6g':'6g', '6gn':'6g', '6g+':'6g+',   '6a-':'6a-', '6a':'6a', '6an':'6a', '6a+':'6a+',
        '6b-':'6b-', '6b':'6b-', '6bn':'6bn', '6b+':'7c',
        '7c-':'6b',  '7c':'7c', '7cn':'7c', '7c+':'7c+',   '7d-':'7d-', '7d':'7d', '7dn':'7d', '7d+':'7d+',
        '7e-':'7e-', '7e':'7e-', '7en':'7en', '7e+':'7f',    '7f-':'7e',  '7f':'7f', '7fn':'7f', '7f+':'7f+',
        '7g-':'7g-', '7g':'7g', '7gn':'7g', '7g+':'7g+',   '7a-':'7a-', '7a':'7a', '7an':'7a', '7a+':'7a+',
        '7b-':'7b-', '7b':'7b-', '7bn':'7bn', '7b+':'8c',
        '8c-':'7b',  '8c':'8c', '8cn':'8c', '8c+':'8c+',   '8d-':'8d-', '8d':'8d', '8dn':'8d', '8d+':'8d+',
        '8e-':'8e-', '8e':'8e-', '8en':'8en', '8e+':'8f',    '8f-':'8e',  '8f':'8f', '8fn':'8f', '8f+':'8f+',
        '8g-':'8g-', '8g':'8g', '8gn':'8g', '8g+':'8g+',   '8a-':'8a-', '8a':'8a', '8an':'8a', '8a+':'8a+',
        '8b-':'8b-', '8b':'8b-', '8bn':'8bn', '8b+':None,
    },
    'e-':  {     # b-,e-,a-
        '0c-':None,  '0c':'0c', '0cn':'0c', '0c+':'0c+',   '0d-':'0d-', '0d':'0d', '0dn':'0d', '0d+':'0d+',
        '0e-':'0e-', '0e':'0e-', '0en':'0en', '0e+':'0f',    '0f-':'0e',  '0f':'0f', '0fn':'0f', '0f+':'0f+',
        '0g-':'0g-', '0g':'0g', '0gn':'0g', '0g+':'0g+',   '0a-':'0a-', '0a':'0a-', '0an':'0an', '0a+':'0a+',
        '0b-':'0b-', '0b':'0b-', '0bn':'0bn', '0b+':'1c',
        '1c-':'0b',  '1c':'1c', '1cn':'1c', '1c+':'1c+',   '1d-':'1d-', '1d':'1d', '1dn':'1d', '1d+':'1d+',
        '1e-':'1e-', '1e':'1e-', '1en':'1en', '1e+':'1f',    '1f-':'1e',  '1f':'1f', '1fn':'1f', '1f+':'1f+',
        '1g-':'1g-', '1g':'1g', '1gn':'1g', '1g+':'1g+',   '1a-':'1a-', '1a':'1a-', '1an':'1an', '1a+':'1a+',
        '1b-':'1b-', '1b':'1b-', '1bn':'1bn', '1b+':'2c',
        '2c-':'1b',  '2c':'2c', '2cn':'2c', '2c+':'2c+',   '2d-':'2d-', '2d':'2d', '2dn':'2d', '2d+':'2d+',
        '2e-':'2e-', '2e':'2e-', '2en':'2en', '2e+':'2f',    '2f-':'2e',  '2f':'2f', '2fn':'2f', '2f+':'2f+',
        '2g-':'2g-', '2g':'2g', '2gn':'2g', '2g+':'2g+',   '2a-':'2a-', '2a':'2a-', '2an':'2an', '2a+':'2a+',
        '2b-':'2b-', '2b':'2b-', '2bn':'2bn', '2b+':'3c',
        '3c-':'2b',  '3c':'3c', '3cn':'3c', '3c+':'3c+',   '3d-':'3d-', '3d':'3d', '3dn':'3d', '3d+':'3d+',
        '3e-':'3e-', '3e':'3e-', '3en':'3en', '3e+':'3f',    '3f-':'3e',  '3f':'3f', '3fn':'3f', '3f+':'3f+',
        '3g-':'3g-', '3g':'3g', '3gn':'3g', '3g+':'3g+',   '3a-':'3a-', '3a':'3a-', '3an':'3an', '3a+':'3a+',
        '3b-':'3b-', '3b':'3b-', '3bn':'3bn', '3b+':'4c',
        '4c-':'3b',  '4c':'4c', '4cn':'4c', '4c+':'4c+',   '4d-':'4d-', '4d':'4d', '4dn':'4d', '4d+':'4d+',
        '4e-':'4e-', '4e':'4e-', '4en':'4en', '4e+':'4f',    '4f-':'4e',  '4f':'4f', '4fn':'4f', '4f+':'4f+',
        '4g-':'4g-', '4g':'4g', '4gn':'4g', '4g+':'4g+',   '4a-':'4a-', '4a':'4a-', '4an':'4an', '4a+':'4a+',
        '4b-':'4b-', '4b':'4b-', '4bn':'4bn', '4b+':'5c',
        '5c-':'4b',  '5c':'5c', '5cn':'5c', '5c+':'5c+',   '5d-':'5d-', '5d':'5d', '5dn':'5d', '5d+':'5d+',
        '5e-':'5e-', '5e':'5e-', '5en':'5en', '5e+':'5f',    '5f-':'5e',  '5f':'5f', '5fn':'5f', '5f+':'5f+',
        '5g-':'5g-', '5g':'5g', '5gn':'5g', '5g+':'5g+',   '5a-':'5a-', '5a':'5a-', '5an':'5an', '5a+':'5a+',
        '5b-':'5b-', '5b':'5b-', '5bn':'5bn', '5b+':'6c',
        '6c-':'5b',  '6c':'6c', '6cn':'6c', '6c+':'6c+',   '6d-':'6d-', '6d':'6d', '6dn':'6d', '6d+':'6d+',
        '6e-':'6e-', '6e':'6e-', '6en':'6en', '6e+':'6f',    '6f-':'6e',  '6f':'6f', '6fn':'6f', '6f+':'6f+',
        '6g-':'6g-', '6g':'6g', '6gn':'6g', '6g+':'6g+',   '6a-':'6a-', '6a':'6a-', '6an':'6an', '6a+':'6a+',
        '6b-':'6b-', '6b':'6b-', '6bn':'6bn', '6b+':'7c',
        '7c-':'6b',  '7c':'7c', '7cn':'7c', '7c+':'7c+',   '7d-':'7d-', '7d':'7d', '7dn':'7d', '7d+':'7d+',
        '7e-':'7e-', '7e':'7e-', '7en':'7en', '7e+':'7f',    '7f-':'7e',  '7f':'7f', '7fn':'7f', '7f+':'7f+',
        '7g-':'7g-', '7g':'7g', '7gn':'7g', '7g+':'7g+',   '7a-':'7a-', '7a':'7a-', '7an':'7an', '7a+':'7a+',
        '7b-':'7b-', '7b':'7b-', '7bn':'7bn', '7b+':'8c',
        '8c-':'7b',  '8c':'8c', '8cn':'8c', '8c+':'8c+',   '8d-':'8d-', '8d':'8d', '8dn':'8d', '8d+':'8d+',
        '8e-':'8e-', '8e':'8e-', '8en':'8en', '8e+':'8f',    '8f-':'8e',  '8f':'8f', '8fn':'8f', '8f+':'8f+',
        '8g-':'8g-', '8g':'8g', '8gn':'8g', '8g+':'8g+',   '8a-':'8a-', '8a':'8a-', '8an':'8an', '8a+':'8a+',
        '8b-':'8b-', '8b':'8b-', '8bn':'8bn', '8b+':None,
    },
    'a-':  {     # b-,e-,a-,d-
        '0c-':None,  '0c':'0c', '0cn':'0c', '0c+':'0c+',   '0d-':'0d-', '0d':'0d-', '0dn':'0dn', '0d+':'0d+',
        '0e-':'0e-', '0e':'0e-', '0en':'0en', '0e+':'0f',    '0f-':'0e',  '0f':'0f', '0fn':'0f', '0f+':'0f+',
        '0g-':'0g-', '0g':'0g', '0gn':'0g', '0g+':'0g+',   '0a-':'0a-', '0a':'0a-', '0an':'0an', '0a+':'0a+',
        '0b-':'0b-', '0b':'0b-', '0bn':'0bn', '0b+':'1c',
        '1c-':'0b',  '1c':'1c', '1cn':'1c', '1c+':'1c+',   '1d-':'1d-', '1d':'1d-', '1dn':'1dn', '1d+':'1d+',
        '1e-':'1e-', '1e':'1e-', '1en':'1en', '1e+':'1f',    '1f-':'1e',  '1f':'1f', '1fn':'1f', '1f+':'1f+',
        '1g-':'1g-', '1g':'1g', '1gn':'1g', '1g+':'1g+',   '1a-':'1a-', '1a':'1a-', '1an':'1an', '1a+':'1a+',
        '1b-':'1b-', '1b':'1b-', '1bn':'1bn', '1b+':'2c',
        '2c-':'1b',  '2c':'2c', '2cn':'2c', '2c+':'2c+',   '2d-':'2d-', '2d':'2d-', '2dn':'2dn', '2d+':'2d+',
        '2e-':'2e-', '2e':'2e-', '2en':'2en', '2e+':'2f',    '2f-':'2e',  '2f':'2f', '2fn':'2f', '2f+':'2f+',
        '2g-':'2g-', '2g':'2g', '2gn':'2g', '2g+':'2g+',   '2a-':'2a-', '2a':'2a-', '2an':'2an', '2a+':'2a+',
        '2b-':'2b-', '2b':'2b-', '2bn':'2bn', '2b+':'3c',
        '3c-':'2b',  '3c':'3c', '3cn':'3c', '3c+':'3c+',   '3d-':'3d-', '3d':'3d-', '3dn':'3dn', '3d+':'3d+',
        '3e-':'3e-', '3e':'3e-', '3en':'3en', '3e+':'3f',    '3f-':'3e',  '3f':'3f', '3fn':'3f', '3f+':'3f+',
        '3g-':'3g-', '3g':'3g', '3gn':'3g', '3g+':'3g+',   '3a-':'3a-', '3a':'3a-', '3an':'3an', '3a+':'3a+',
        '3b-':'3b-', '3b':'3b-', '3bn':'3bn', '3b+':'4c',
        '4c-':'3b',  '4c':'4c', '4cn':'4c', '4c+':'4c+',   '4d-':'4d-', '4d':'4d-', '4dn':'4dn', '4d+':'4d+',
        '4e-':'4e-', '4e':'4e-', '4en':'4en', '4e+':'4f',    '4f-':'4e',  '4f':'4f', '4fn':'4f', '4f+':'4f+',
        '4g-':'4g-', '4g':'4g', '4gn':'4g', '4g+':'4g+',   '4a-':'4a-', '4a':'4a-', '4an':'4an', '4a+':'4a+',
        '4b-':'4b-', '4b':'4b-', '4bn':'4bn', '4b+':'5c',
        '5c-':'4b',  '5c':'5c', '5cn':'5c', '5c+':'5c+',   '5d-':'5d-', '5d':'5d-', '5dn':'5dn', '5d+':'5d+',
        '5e-':'5e-', '5e':'5e-', '5en':'5en', '5e+':'5f',    '5f-':'5e',  '5f':'5f', '5fn':'5f', '5f+':'5f+',
        '5g-':'5g-', '5g':'5g', '5gn':'5g', '5g+':'5g+',   '5a-':'5a-', '5a':'5a-', '5an':'5an', '5a+':'5a+',
        '5b-':'5b-', '5b':'5b-', '5bn':'5bn', '5b+':'6c',
        '6c-':'5b',  '6c':'6c', '6cn':'6c', '6c+':'6c+',   '6d-':'6d-', '6d':'6d-', '6dn':'6dn', '6d+':'6d+',
        '6e-':'6e-', '6e':'6e-', '6en':'6en', '6e+':'6f',    '6f-':'6e',  '6f':'6f', '6fn':'6f', '6f+':'6f+',
        '6g-':'6g-', '6g':'6g', '6gn':'6g', '6g+':'6g+',   '6a-':'6a-', '6a':'6a-', '6an':'6an', '6a+':'6a+',
        '6b-':'6b-', '6b':'6b-', '6bn':'6bn', '6b+':'7c',
        '7c-':'6b',  '7c':'7c', '7cn':'7c', '7c+':'7c+',   '7d-':'7d-', '7d':'7d-', '7dn':'7dn', '7d+':'7d+',
        '7e-':'7e-', '7e':'7e-', '7en':'7en', '7e+':'7f',    '7f-':'7e',  '7f':'7f', '7fn':'7f', '7f+':'7f+',
        '7g-':'7g-', '7g':'7g', '7gn':'7g', '7g+':'7g+',   '7a-':'7a-', '7a':'7a-', '7an':'7an', '7a+':'7a+',
        '7b-':'7b-', '7b':'7b-', '7bn':'7bn', '7b+':'8c',
        '8c-':'7b',  '8c':'8c', '8cn':'8c', '8c+':'8c+',   '8d-':'8d-', '8d':'8d-', '8dn':'8dn', '8d+':'8d+',
        '8e-':'8e-', '8e':'8e-', '8en':'8en', '8e+':'8f',    '8f-':'8e',  '8f':'8f', '8fn':'8f', '8f+':'8f+',
        '8g-':'8g-', '8g':'8g', '8gn':'8g', '8g+':'8g+',   '8a-':'8a-', '8a':'8a-', '8an':'8an', '8a+':'8a+',
        '8b-':'8b-', '8b':'8b-', '8bn':'8bn', '8b+':None,
    },
    'd-':  {     # b-,e-,a-,d-,g-
        '0c-':None,  '0c':'0c', '0cn':'0c', '0c+':'0c+',   '0d-':'0d-', '0d':'0d-', '0dn':'0dn', '0d+':'0d+',
        '0e-':'0e-', '0e':'0e-', '0en':'0en', '0e+':'0f',    '0f-':'0e',  '0f':'0f', '0fn':'0f', '0f+':'0f+',
        '0g-':'0g-', '0g':'0g-', '0gn':'0gn', '0g+':'0g+',   '0a-':'0a-', '0a':'0a-', '0an':'0an', '0a+':'0a+',
        '0b-':'0b-', '0b':'0b-', '0bn':'0bn', '0b+':'1c',
        '1c-':'0b',  '1c':'1c', '1cn':'1c', '1c+':'1c+',   '1d-':'1d-', '1d':'1d-', '1dn':'1dn', '1d+':'1d+',
        '1e-':'1e-', '1e':'1e-', '1en':'1en', '1e+':'1f',    '1f-':'1e',  '1f':'1f', '1fn':'1f', '1f+':'1f+',
        '1g-':'1g-', '1g':'1g-', '1gn':'1gn', '1g+':'1g+',   '1a-':'1a-', '1a':'1a-', '1an':'1an', '1a+':'1a+',
        '1b-':'1b-', '1b':'1b-', '1bn':'1bn', '1b+':'2c',
        '2c-':'1b',  '2c':'2c', '2cn':'2c', '2c+':'2c+',   '2d-':'2d-', '2d':'2d-', '2dn':'2dn', '2d+':'2d+',
        '2e-':'2e-', '2e':'2e-', '2en':'2en', '2e+':'2f',    '2f-':'2e',  '2f':'2f', '2fn':'2f', '2f+':'2f+',
        '2g-':'2g-', '2g':'2g-', '2gn':'2gn', '2g+':'2g+',   '2a-':'2a-', '2a':'2a-', '2an':'2an', '2a+':'2a+',
        '2b-':'2b-', '2b':'2b-', '2bn':'2bn', '2b+':'3c',
        '3c-':'2b',  '3c':'3c', '3cn':'3c', '3c+':'3c+',   '3d-':'3d-', '3d':'3d-', '3dn':'3dn', '3d+':'3d+',
        '3e-':'3e-', '3e':'3e-', '3en':'3en', '3e+':'3f',    '3f-':'3e',  '3f':'3f', '3fn':'3f', '3f+':'3f+',
        '3g-':'3g-', '3g':'3g-', '3gn':'3gn', '3g+':'3g+',   '3a-':'3a-', '3a':'3a-', '3an':'3an', '3a+':'3a+',
        '3b-':'3b-', '3b':'3b-', '3bn':'3bn', '3b+':'4c',
        '4c-':'3b',  '4c':'4c', '4cn':'4c', '4c+':'4c+',   '4d-':'4d-', '4d':'4d-', '4dn':'4dn', '4d+':'4d+',
        '4e-':'4e-', '4e':'4e-', '4en':'4en', '4e+':'4f',    '4f-':'4e',  '4f':'4f', '4fn':'4f', '4f+':'4f+',
        '4g-':'4g-', '4g':'4g-', '4gn':'4gn', '4g+':'4g+',   '4a-':'4a-', '4a':'4a-', '4an':'4an', '4a+':'4a+',
        '4b-':'4b-', '4b':'4b-', '4bn':'4bn', '4b+':'5c',
        '5c-':'4b',  '5c':'5c', '5cn':'5c', '5c+':'5c+',   '5d-':'5d-', '5d':'5d-', '5dn':'5dn', '5d+':'5d+',
        '5e-':'5e-', '5e':'5e-', '5en':'5en', '5e+':'5f',    '5f-':'5e',  '5f':'5f', '5fn':'5f', '5f+':'5f+',
        '5g-':'5g-', '5g':'5g-', '5gn':'5gn', '5g+':'5g+',   '5a-':'5a-', '5a':'5a-', '5an':'5an', '5a+':'5a+',
        '5b-':'5b-', '5b':'5b-', '5bn':'5bn', '5b+':'6c',
        '6c-':'5b',  '6c':'6c', '6cn':'6c', '6c+':'6c+',   '6d-':'6d-', '6d':'6d-', '6dn':'6dn', '6d+':'6d+',
        '6e-':'6e-', '6e':'6e-', '6en':'6en', '6e+':'6f',    '6f-':'6e',  '6f':'6f', '6fn':'6f', '6f+':'6f+',
        '6g-':'6g-', '6g':'6g-', '6gn':'6gn', '6g+':'6g+',   '6a-':'6a-', '6a':'6a-', '6an':'6an', '6a+':'6a+',
        '6b-':'6b-', '6b':'6b-', '6bn':'6bn', '6b+':'7c',
        '7c-':'6b',  '7c':'7c', '7cn':'7c', '7c+':'7c+',   '7d-':'7d-', '7d':'7d-', '7dn':'7dn', '7d+':'7d+',
        '7e-':'7e-', '7e':'7e-', '7en':'7en', '7e+':'7f',    '7f-':'7e',  '7f':'7f', '7fn':'7f', '7f+':'7f+',
        '7g-':'7g-', '7g':'7g-', '7gn':'7gn', '7g+':'7g+',   '7a-':'7a-', '7a':'7a-', '7an':'7an', '7a+':'7a+',
        '7b-':'7b-', '7b':'7b-', '7bn':'7bn', '7b+':'8c',
        '8c-':'7b',  '8c':'8c', '8cn':'8c', '8c+':'8c+',   '8d-':'8d-', '8d':'8d-', '8dn':'8dn', '8d+':'8d+',
        '8e-':'8e-', '8e':'8e-', '8en':'8en', '8e+':'8f',    '8f-':'8e',  '8f':'8f', '8fn':'8f', '8f+':'8f+',
        '8g-':'8g-', '8g':'8g-', '8gn':'8gn', '8g+':'8g+',   '8a-':'8a-', '8a':'8a-', '8an':'8an', '8a+':'8a+',
        '8b-':'8b-', '8b':'8b-', '8bn':'8bn', '8b+':None,
    },
    'g-':  {     # b-,e-,a-,d-,g-,c-
        '0c-':None,  '0c':'0c-', '0cn':'0cn', '0c+':'0c+',   '0d-':'0d-', '0d':'0d-', '0dn':'0dn', '0d+':'0d+',
        '0e-':'0e-', '0e':'0e-', '0en':'0en', '0e+':'0f',    '0f-':'0e',  '0f':'0f', '0fn':'0f', '0f+':'0f+',
        '0g-':'0g-', '0g':'0g-', '0gn':'0gn', '0g+':'0g+',   '0a-':'0a-', '0a':'0a-', '0an':'0an', '0a+':'0a+',
        '0b-':'0b-', '0b':'0b-', '0bn':'0bn', '0b+':'1c',
        '1c-':'0b',  '1c':'1c-', '1cn':'1cn', '1c+':'1c+',   '1d-':'1d-', '1d':'1d-', '1dn':'1dn', '1d+':'1d+',
        '1e-':'1e-', '1e':'1e-', '1en':'1en', '1e+':'1f',    '1f-':'1e',  '1f':'1f', '1fn':'1f', '1f+':'1f+',
        '1g-':'1g-', '1g':'1g-', '1gn':'1gn', '1g+':'1g+',   '1a-':'1a-', '1a':'1a-', '1an':'1an', '1a+':'1a+',
        '1b-':'1b-', '1b':'1b-', '1bn':'1bn', '1b+':'2c',
        '2c-':'1b',  '2c':'2c-', '2cn':'2cn', '2c+':'2c+',   '2d-':'2d-', '2d':'2d-', '2dn':'2dn', '2d+':'2d+',
        '2e-':'2e-', '2e':'2e-', '2en':'2en', '2e+':'2f',    '2f-':'2e',  '2f':'2f', '2fn':'2f', '2f+':'2f+',
        '2g-':'2g-', '2g':'2g-', '2gn':'2gn', '2g+':'2g+',   '2a-':'2a-', '2a':'2a-', '2an':'2an', '2a+':'2a+',
        '2b-':'2b-', '2b':'2b-', '2bn':'2bn', '2b+':'3c',
        '3c-':'2b',  '3c':'3c-', '3cn':'3cn', '3c+':'3c+',   '3d-':'3d-', '3d':'3d-', '3dn':'3dn', '3d+':'3d+',
        '3e-':'3e-', '3e':'3e-', '3en':'3en', '3e+':'3f',    '3f-':'3e',  '3f':'3f', '3fn':'3f', '3f+':'3f+',
        '3g-':'3g-', '3g':'3g-', '3gn':'3gn', '3g+':'3g+',   '3a-':'3a-', '3a':'3a-', '3an':'3an', '3a+':'3a+',
        '3b-':'3b-', '3b':'3b-', '3bn':'3bn', '3b+':'4c',
        '4c-':'3b',  '4c':'4c-', '4cn':'4cn', '4c+':'4c+',   '4d-':'4d-', '4d':'4d-', '4dn':'4dn', '4d+':'4d+',
        '4e-':'4e-', '4e':'4e-', '4en':'4en', '4e+':'4f',    '4f-':'4e',  '4f':'4f', '4fn':'4f', '4f+':'4f+',
        '4g-':'4g-', '4g':'4g-', '4gn':'4gn', '4g+':'4g+',   '4a-':'4a-', '4a':'4a-', '4an':'4an', '4a+':'4a+',
        '4b-':'4b-', '4b':'4b-', '4bn':'4bn', '4b+':'5c',
        '5c-':'4b',  '5c':'5c-', '5cn':'5cn', '5c+':'5c+',   '5d-':'5d-', '5d':'5d-', '5dn':'5dn', '5d+':'5d+',
        '5e-':'5e-', '5e':'5e-', '5en':'5en', '5e+':'5f',    '5f-':'5e',  '5f':'5f', '5fn':'5f', '5f+':'5f+',
        '5g-':'5g-', '5g':'5g-', '5gn':'5gn', '5g+':'5g+',   '5a-':'5a-', '5a':'5a-', '5an':'5an', '5a+':'5a+',
        '5b-':'5b-', '5b':'5b-', '5bn':'5bn', '5b+':'6c',
        '6c-':'5b',  '6c':'6c-', '6cn':'6cn', '6c+':'6c+',   '6d-':'6d-', '6d':'6d-', '6dn':'6dn', '6d+':'6d+',
        '6e-':'6e-', '6e':'6e-', '6en':'6en', '6e+':'6f',    '6f-':'6e',  '6f':'6f', '6fn':'6f', '6f+':'6f+',
        '6g-':'6g-', '6g':'6g-', '6gn':'6gn', '6g+':'6g+',   '6a-':'6a-', '6a':'6a-', '6an':'6an', '6a+':'6a+',
        '6b-':'6b-', '6b':'6b-', '6bn':'6bn', '6b+':'7c',
        '7c-':'6b',  '7c':'7c-', '7cn':'7cn', '7c+':'7c+',   '7d-':'7d-', '7d':'7d-', '7dn':'7dn', '7d+':'7d+',
        '7e-':'7e-', '7e':'7e-', '7en':'7en', '7e+':'7f',    '7f-':'7e',  '7f':'7f', '7fn':'7f', '7f+':'7f+',
        '7g-':'7g-', '7g':'7g-', '7gn':'7gn', '7g+':'7g+',   '7a-':'7a-', '7a':'7a-', '7an':'7an', '7a+':'7a+',
        '7b-':'7b-', '7b':'7b-', '7bn':'7bn', '7b+':'8c',
        '8c-':'7b',  '8c':'8c-', '8cn':'8cn', '8c+':'8c+',   '8d-':'8d-', '8d':'8d-', '8dn':'8dn', '8d+':'8d+',
        '8e-':'8e-', '8e':'8e-', '8en':'8en', '8e+':'8f',    '8f-':'8e',  '8f':'8f', '8fn':'8f', '8f+':'8f+',
        '8g-':'8g-', '8g':'8g-', '8gn':'8gn', '8g+':'8g+',   '8a-':'8a-', '8a':'8a-', '8an':'8an', '8a+':'8a+',
        '8b-':'8b-', '8b':'8b-', '8bn':'8bn', '8b+':None,
    },
    'c-':  {     # b-,e-,a-,d-,g-,c-,f-
        '0c-':None,  '0c':'0c-', '0cn':'0cn', '0c+':'0c+',   '0d-':'0d-', '0d':'0d-', '0dn':'0dn', '0d+':'0d+',
        '0e-':'0e-', '0e':'0e-', '0en':'0en', '0e+':'0f',    '0f-':'0e',  '0f':'0f-', '0fn':'0fn', '0f+':'0f+',
        '0g-':'0g-', '0g':'0g-', '0gn':'0gn', '0g+':'0g+',   '0a-':'0a-', '0a':'0a-', '0an':'0an', '0a+':'0a+',
        '0b-':'0b-', '0b':'0b-', '0bn':'0bn', '0b+':'1c',
        '1c-':'0b',  '1c':'1c-', '1cn':'1cn', '1c+':'1c+',   '1d-':'1d-', '1d':'1d-', '1dn':'1dn', '1d+':'1d+',
        '1e-':'1e-', '1e':'1e-', '1en':'1en', '1e+':'1f',    '1f-':'1e',  '1f':'1f-', '1fn':'1fn', '1f+':'1f+',
        '1g-':'1g-', '1g':'1g-', '1gn':'1gn', '1g+':'1g+',   '1a-':'1a-', '1a':'1a-', '1an':'1an', '1a+':'1a+',
        '1b-':'1b-', '1b':'1b-', '1bn':'1bn', '1b+':'2c',
        '2c-':'1b',  '2c':'2c-', '2cn':'2cn', '2c+':'2c+',   '2d-':'2d-', '2d':'2d-', '2dn':'2dn', '2d+':'2d+',
        '2e-':'2e-', '2e':'2e-', '2en':'2en', '2e+':'2f',    '2f-':'2e',  '2f':'2f-', '2fn':'2fn', '2f+':'2f+',
        '2g-':'2g-', '2g':'2g-', '2gn':'2gn', '2g+':'2g+',   '2a-':'2a-', '2a':'2a-', '2an':'2an', '2a+':'2a+',
        '2b-':'2b-', '2b':'2b-', '2bn':'2bn', '2b+':'3c',
        '3c-':'2b',  '3c':'3c-', '3cn':'3cn', '3c+':'3c+',   '3d-':'3d-', '3d':'3d-', '3dn':'3dn', '3d+':'3d+',
        '3e-':'3e-', '3e':'3e-', '3en':'3en', '3e+':'3f',    '3f-':'3e',  '3f':'3f-', '3fn':'3fn', '3f+':'3f+',
        '3g-':'3g-', '3g':'3g-', '3gn':'3gn', '3g+':'3g+',   '3a-':'3a-', '3a':'3a-', '3an':'3an', '3a+':'3a+',
        '3b-':'3b-', '3b':'3b-', '3bn':'3bn', '3b+':'4c',
        '4c-':'3b',  '4c':'4c-', '4cn':'4cn', '4c+':'4c+',   '4d-':'4d-', '4d':'4d-', '4dn':'4dn', '4d+':'4d+',
        '4e-':'4e-', '4e':'4e-', '4en':'4en', '4e+':'4f',    '4f-':'4e',  '4f':'4f-', '4fn':'4fn', '4f+':'4f+',
        '4g-':'4g-', '4g':'4g-', '4gn':'4gn', '4g+':'4g+',   '4a-':'4a-', '4a':'4a-', '4an':'4an', '4a+':'4a+',
        '4b-':'4b-', '4b':'4b-', '4bn':'4bn', '4b+':'5c',
        '5c-':'4b',  '5c':'5c-', '5cn':'5cn', '5c+':'5c+',   '5d-':'5d-', '5d':'5d-', '5dn':'5dn', '5d+':'5d+',
        '5e-':'5e-', '5e':'5e-', '5en':'5en', '5e+':'5f',    '5f-':'5e',  '5f':'5f-', '5fn':'5fn', '5f+':'5f+',
        '5g-':'5g-', '5g':'5g-', '5gn':'5gn', '5g+':'5g+',   '5a-':'5a-', '5a':'5a-', '5an':'5an', '5a+':'5a+',
        '5b-':'5b-', '5b':'5b-', '5bn':'5bn', '5b+':'6c',
        '6c-':'5b',  '6c':'6c-', '6cn':'6cn', '6c+':'6c+',   '6d-':'6d-', '6d':'6d-', '6dn':'6dn', '6d+':'6d+',
        '6e-':'6e-', '6e':'6e-', '6en':'6en', '6e+':'6f',    '6f-':'6e',  '6f':'6f-', '6fn':'6fn', '6f+':'6f+',
        '6g-':'6g-', '6g':'6g-', '6gn':'6gn', '6g+':'6g+',   '6a-':'6a-', '6a':'6a-', '6an':'6an', '6a+':'6a+',
        '6b-':'6b-', '6b':'6b-', '6bn':'6bn', '6b+':'7c',
        '7c-':'6b',  '7c':'7c-', '7cn':'7cn', '7c+':'7c+',   '7d-':'7d-', '7d':'7d-', '7dn':'7dn', '7d+':'7d+',
        '7e-':'7e-', '7e':'7e-', '7en':'7en', '7e+':'7f',    '7f-':'7e',  '7f':'7f-', '7fn':'7fn', '7f+':'7f+',
        '7g-':'7g-', '7g':'7g-', '7gn':'7gn', '7g+':'7g+',   '7a-':'7a-', '7a':'7a-', '7an':'7an', '7a+':'7a+',
        '7b-':'7b-', '7b':'7b-', '7bn':'7bn', '7b+':'8c',
        '8c-':'7b',  '8c':'8c-', '8cn':'8cn', '8c+':'8c+',   '8d-':'8d-', '8d':'8d-', '8dn':'8dn', '8d+':'8d+',
        '8e-':'8e-', '8e':'8e-', '8en':'8en', '8e+':'8f',    '8f-':'8e',  '8f':'8f-', '8fn':'8fn', '8f+':'8f+',
        '8g-':'8g-', '8g':'8g-', '8gn':'8gn', '8g+':'8g+',   '8a-':'8a-', '8a':'8a-', '8an':'8an', '8a+':'8a+',
        '8b-':'8b-', '8b':'8b-', '8bn':'8bn', '8b+':None,
    },
}
#   key   a             key of a major.
def do_key(t_args, line):
    global args
    global measure_on
    global key_sig
    global key_default
    global key_voice
    global mlth
    global vl

    if t_args is None or len(t_args) != 1:
        print_error("key command does not have arguments", line)
        return
    # fi

    t_args[0] = re.sub(r'\s*,\s*', ',', t_args[0])
    t_args[0] = re.sub(r'\s*\.\.\s*', '..', t_args[0])
    # Voice numbers, followed by instrument name.
    vargs = t_args[0].split()

    if len(vargs) <= 0 or len(vargs) > 2:
        print_error("key command does not have correct number of arguments", line)
        return
    # fi

    k = vargs[0] if len(vargs) < 2 else vargs[1]
    k = k.lower()                           # Technically should not have to do this.
    if k not in key_sig:
        print_error("key '{}' not recognized.".format(k), line)
        return
    # fi
    if args.vertical or args.horizontal:
        pass                                # printing and used are the same.
    elif args.midi1csv or args.fluidsynth:
        k = key_sig[k]                      # Key number extracted.
    else:                   # ABC
        k = k.upper()
        k = k.replace('-', 'b')             # Does multiple flats
        k = k.replace('+', '#')             # Does multiple sharps.
        k = k.replace('n', '=')             # Does multiple naturals.
    # fi
    # k = value to store in key_voice, key_default, etc. -- used for printing, etc.

    #-- fill_voice_mlth(line)                   # Need to make measure for other voices up to here "mlth".
    # By not doing this, we allow vertical format to specify keys for voices in the first measure (or any).

    if len(vargs) == 1:                     # One argument, all voices change.
        for ve in range(1, len(vl)+1):
            if mlth[ve][measure_on] != 0:
                print_error("key with one argument not allowed in the middle of a measure", line)
                return
            # fi
        # rof
        if measure_on == '':
            key_default = k                 # Used in xpose, and when printing midicsv output.
        # fi
        for ve in range(1, MAXVOICES+1):
            key_voice[measure_on][ve] = k   # Running key by voice.
        # rof
        return
    # fi                # multiple arguments, voices first.

    jkl = "".join(vargs[0])
    wargs = arglist(jkl, line, True)
    if not wargs or len(wargs) < 1:
        print_error("no voice arguments on key line", line)
        return
    # fi
    for w in wargs:
        f1, type_error = is_float(w)
        if type_error is not None:
            return
        # fi
        if f1 is None:
            print_error("voice {} is not a number.".format(w), line)
            return
        # fi
        f1 = int(round(f1))
        if f1 not in mlth:
            print_error("key with too many voices not allowed, voice {} is too many".format(f1), line)
            return
        # fi
        if mlth[f1][measure_on] != 0:
            for ve in range(1, len(vl)+1):
                print_error_no_line("mlth[{}][{}]={}".format(ve, measure_on, mlth[ve][measure_on]))
            # rof
            print_error("key with two arguments not allowed in the middle of a measure, voice {}".format(f1), line)
            return
        # fi
        key_voice[measure_on][f1] = k       # key by measure and voice.
    # rof
    return
# End of do_key

# ----------------------------------------------------------------------------
#   cis   2             $$ only voice 2 follows. sets volume too.
def do_cis(t_args, line):
    global voices               # number of voices
    global cis                  # cis ...
    global vinstrument
    global reverb
    global pan
    global intensity
    global measure_on
    global instruments

    if t_args is None or len(t_args) != 1:
        print_error("cis does not have one or two arguments.", line)
        return
    # fi

    t_args[0] = re.sub(r'\s*,\s*', ',', t_args[0])

    vargs = t_args[0].split()

    f1, type_error = is_float(vargs[0])
    if type_error is not None:
        return
    # fi
    if f1 is None:
        print_error("cis does not have first argument as a number.", line)
        return
    # fi
    f1 = int(round(f1))
    if f1 < 1  or f1 > MAXVOICES:       # If out of range.
        print_error("number of cis must between 1 and {} inclusive. Not ({})".format(MAXVOICES, f1), line)
        return
    # fi

    voices = f1                         # Max voices.
    cis = f1                            # Doing just one voice from now on.

    for i in range(1, cis + 1):
        new_voice_initialize(i, measure_on)
    # rof

    # If there is a second argument, choose instrument for the voice.
    if len(vargs) > 1:
        i = str(vargs[1]).lower()
# NOTDONEYET - Not tested cis and instrument.
#--        print_debug("#1 i={}".format(i))
        if [i,0] in instruments:
# NOTDONEYET - Not tested cis and instrument.
#--            print_debug("#1 instruments[{}][0]={}".format(i,instruments[i][0]))
            vinstrument[measure_on][cis] = instruments[i][0]
            vinstrument[measure_on][cis][0] += args.offset
            reverb[measure_on][cis] = default_reverb
            pan[measure_on][cis] = default_pan
            intensity[measure_on][cis] = default_intensity
        else:
            f1, type_error = is_float(i)
            if type_error is not None:
                return
            # fi
            if f1 is None:
                print_error("cis does not have instrument argument as a number.", line)
                return
            # fi
            f1 = int(round(f1))
# NOTDONEYET - Not tested cis and instrument.
#--            print_debug("#2 f1={}".format(f1))
#--            print_debug("#2 instruments[{}][0]={}".format(f1,instruments[f1][0]))
            if [f1,0] not in instruments.values():
                print_error("instrument value {} not in instrument table.".format(f1), line)
                return
            # fi
            vinstrument[measure_on][cis][0] = f1 + args.offset
            reverb[measure_on][cis] = default_reverb
            pan[measure_on][cis] = default_pan
            intensity[measure_on][cis] = default_intensity
        # fi
    # fi
    fill_voice_mlth(False, line)               # Need to make measure for all voices up to here "mlth".
    return
# End of do_cis

# ----------------------------------------------------------------------------
def get_volume_number(name, line, command_name):
    global vlprint

    v, type_error = is_float(name)
    if type_error is not None:
        for j in vlprint:
            if name == vlprint[j]:
                v = j
                type_error = None
                break
            # fi
        # rof
        if type_error is not None:
            print_error(command_name + " did not get have a number or volume name. {}".format(type_error), line)
            return None
        # fi
        # Fall through, because we found it via letters.
    # fi
    if v is None:
        print_error(command_name + " does not have argument as a number.", line)
        return None
    # fi
    v = int(round(v))
    if v < 0:                       # If error or bad value
        print_error(command_name + " for voice {} not good {}, making it zero.".format(i, v), line)
        v = 0
    # fi
    if command_name == 'volumes':
        if v > 127:                 # If error or bad value
            print_error(command_name + " {} ({}) not good, making it 127.".format(name,v), line)
            v = 127
        # fi
    elif command_name == 'volume' and v > 7:    # If error or bad value
        print_error(command_name + " {} ({}) not good, making it 7 (127 for midi).".format(name,v), line)
        v = 127
    else:
        v = int((v * 16) + 15)      # Convert to 0 to 127.
    # fi
    return v
#   End of get_volume_number

# ----------------------------------------------------------------------------
#   volume  4,7,5                       $$ for 3 voices; mf and fff, and a touch louder.
#       The volume is a number between 0 and 7, inclusive.
#       Caution: you should use only volumes 5 through 7
#   volumes mf,fff,f                    $$ for 3 voices; mf and fff, and a touch louder.
#       The volumes are a number between 0 and 127, inclusive.
def do_volume_both(t_args, line, command_name):
    global vl                           # volume levels
    global measure_on
    global vlprint
    global args
    global cresc_direction
    global cresc_time
    global cresc_volume
    global running_vl

    if t_args is None or len(t_args) == 0:
        print_error(command_name + " needs at least one argument", line)
        return
    # fi
    # All spaces before or after commas is gone.
    t_args[0] = re.sub(r'\s*,\s*', ',', t_args[0])
    vargs = t_args[0].split()
    if len(vargs) <= 0 or len(vargs) > 2:
        print_error("{} does not have correct number of arguments.".format(command_name), line)
        return
    # fi
    # . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
    if len(vargs) == 1:
        # 1 or 1,2,3 ... .
        wargs = arglist(vargs[0], line, False)
        if len(wargs) == 0 or len(wargs) > MAXVOICES:
            print_error(command_name + " needs from one to {} arguments".format(MAXVOICES), line)
            return
        # fi
        for i in range(1, len(wargs)+1):
            v = get_volume_number(wargs[i - 1], line, command_name)
            if v is None:
                return
            # fi
            if not i in vl:
                new_voice_initialize(i, measure_on)
            # fi
            vl[i][measure_on] = v           # Change volume for voice.
            running_vl[i][measure_on] = v   # Force running change - also stop crescendo.
            cresc_volume[i] = 0
            cresc_time[i] = 0
            cresc_direction[i] = True
        # rof
    else:
    # . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
        wargs = arglist(vargs[0], line, True)
        v = get_volume_number(vargs[1], line, command_name)
        for i in range(1, len(wargs)+1):
            f1, type_error = is_float(wargs[i-1])
            if type_error is not None:
                return
            # fi
            if f1 is None:
                print_error("voice {} is not a number.".format(wargs[i-1]), line)
                return
            # fi
            f1 = int(round(f1))

            vl[f1][measure_on] = v           # Change volume for voice.
            running_vl[f1][measure_on] = v   # Force running change - also stop crescendo.
            cresc_volume[f1] = 0
            cresc_time[f1] = 0
            cresc_direction[f1] = True
        # rof
    # fi

    fill_voice_mlth(False, line)               # Need to make measure for other voices up to here "mlth".
    return
# End of do_volume_both

# ----------------------------------------------------------------------------
def do_volume(t_args, line):
    do_volume_both(t_args, line, "volume")
    return
# End of do_volume

# ----------------------------------------------------------------------------
# This allows numbers 1 to 128.
def do_volumes(t_args, line):
    do_volume_both(t_args, line, "volumes")
    return
# End of do_volumes

# ----------------------------------------------------------------------------
def do_set_voices(f1, line):
    global voices                       # number of voices
    global measure_on

    for i in range(1, f1+1):
        new_voice_initialize(i, measure_on)
    # rof
    voices = f1                         # Max voices.
    return
# End of do_set_voices

# ----------------------------------------------------------------------------
#   voice 4                             $$ number of voices from now onwards.   sets volume too. Default 4?
#   voice 4   50,60,70,80               $$ Set the instruments %%MIDI program 50 ...
def do_voice(t_args, line):
    global cis                          # non-zero if doing one voice only.
    global vinstrument
    global reverb
    global pan
    global intensity
    global measure_on
    global instruments

    if t_args is None or len(t_args) != 1:
        print_error("voice does not have one argument.", line)
        return
    # fi

    for ve in range(1, len(vl)+1):
        if mlth[ve][measure_on] != 0:
            print_error("voice in the middle of a measure not allowed", line)
            return
        # fi
    # rof

    t_args[0] = re.sub(r'\s*,\s*', ',', t_args[0])

    vargs = t_args[0].split()
    f1, type_error = is_float(vargs[0])
    if type_error is not None:
        return
    # fi
    if f1 is None:
        print_error("voice does not have first argument as a number.", line)
        return
    # fi
    f1 = int(round(f1))
    if f1 < 1  or f1 > MAXVOICES:       # If out of range.
        print_error("number of voices must between 1 and {} inclusive. Not ({})".format(MAXVOICES, f1), line)
        return
    # fi

    do_set_voices(f1, line)

    fill_voice_mlth(False, line)               # Need to make measure for other voices up to here "mlth".

    # If there are more arguments, choose instruments for the voices.
    if len(vargs) > 1:
        jkl = "".join(vargs[1:])
        wargs = arglist(jkl, line, False)
        if not wargs or len(wargs) < 1:
            print_error("no instrument selection arguments on voice line", line)
            return
        # fi
        if len(wargs) > f1:
            print_error("number instruments ({}) greater than voices ({})".format(len(wargs), f1), line)
        # fi
        for i in range(0, len(wargs)):
            j = str(wargs[i])    # No checking.
            j = str(j).lower()
            if j in instruments:
                vinstrument[measure_on][i+1] = instruments[j]
                vinstrument[measure_on][i+1][0] += args.offset
                reverb[measure_on][i+1] = default_reverb
                pan[measure_on][i+1] = default_pan
                intensity[measure_on][i+1] = default_intensity
            else:
                f1, type_error = is_float(j)
                if type_error is not None:
                    return
                # fi
                if f1 is None:
                    print_error("voice does not have instrument argument {} as a number.".format(j), line)
                    return
                # fi
                f1 = int(round(f1))
                if f1 != 0 and [f1,0] not in instruments.values():
                    print_error("instrument value {} not in instrument table.".format(f1), line)
                    return
                # fi
                vinstrument[measure_on][i+1] = [f1, 0]
                vinstrument[measure_on][i+1][0] += args.offset
                reverb[measure_on][i+1] = default_reverb
                pan[measure_on][i+1] = default_pan
                intensity[measure_on][i+1] = default_intensity
            # fi
        # rof
    # fi

    cis = 0                             # No longer doing just one voice.
    return
# End of do_voice

# ----------------------------------------------------------------------------
def do_page(t_args, line):
    global cstop_processing
    global pages_to_do
    global args

    if t_args is None or len(t_args) != 1:
        print_error("Page missing argument.", line)
        return
    # fi

    vargs = t_args[0]
    n, mesg = is_float(vargs)
    if mesg is not None or n is None:
        print_error("Page does not have a number. {}".format(msg), line)
        return
    # fi
    n = int(n)
    n = str(n)
    calculate.variables['page'] = n

    if args.pages == None or args.pages == '':
        return
    # fi
    if n not in pages_to_do:
        cstop_processing = True
        return
    # fi
    # Do cstart.
    cstop_processing = False
    return
# End of do_page

# ----------------------------------------------------------------------------
#   measure 6.5         $$ need not be integers
def do_measure(t_args, line):
    global measure_on
    global last_m
    global meas
    global vl
    global running_vl
    global default_note_length
    global vinstrument
    global reverb
    global pan
    global intensity
    global acc_m                            # Last accidental on a note in measure.
    global last_acc_m                       # Last accidental on a note in previous measure.
    global acc_m_xpose
    global acc_v_init                       # Last accidental on a note in measure.
    global acc_v_init_v_or_h                # Last accidental on a note in measure.
    global meter
    global measure_meter
    global clef
    global bars
    global mlth                             # measure length dictionary
    global args
    global key_voice
    global tempo_now_note_length
    global tempo_speed_now
    global pitch
    global premeasurecomment                # Collected comments before a new measure for before new measure.
    global measurelinecomment               # Collected comments before a new measure for before new measure.
    global precomment
    global commentonline
    global measures_to_do
    global cstop_processing

    fill_voice_mlth(True, line)                   # Need to make measure for other voices up to here "mlth".

    if t_args is None or len(t_args) != 1:
        print_error("Measure missing argument.", line)
        return
    # fi

    vargs = t_args[0]
    f1 = None
    for a in vargs:
        if a in "abcdefghijklnopqrstuvwxyz_ABCDEFGHIJKLMNOPQRSTUVWXYZ":
            f1 = vargs
            break
        # fi
    # rof
    if f1 is None:
        f1, type_error = is_float(vargs)
        if type_error is not None or f1 is None:
            # Error, use it as string instead.
            f1 = str(vargs)
        else:
            tmp = int(round(f1))
            if (f1 - tmp) == 0:
                f1 = str(tmp)
            # fi
        # fi
    # fi

    if f1 in meas:
        print_error("Measure {} already exists.".format(f1), line)
        return
    # fi

    # Check if in measures_to_do
    if args.measures and args.measures != '':
        if f1 not in measures_to_do:
            cstop_processing = True
            return
        # fi
        # Do cstart.
        cstop_processing = False
    # fi

    calculate.variables['measure'] = n

    # Last note length ... continue to this measure, until it changes.
    last_m = measure_on
    for i in range(1, len(vl)+1):
        last_acc_m[i] = acc_m[i]
    # rof

    measure_on = str(f1)
    meas.append(measure_on)
    for i in range(1, len(vl)+1):
        if measure_on not in vinstrument:
            vinstrument[measure_on] = {}
            reverb[measure_on] = {}
            pan[measure_on] = {}
            intensity[measure_on] = {}
            key_voice[measure_on] = {}
        # fi
        if i not in vl:
            vl[i] = {}
            running_vl[i] = {}
        # fi
        for j in vl:
            if measure_on not in clef:
                clef[measure_on] = {}
            # fi
            if j not in clef[measure_on]:
                clef[measure_on][j] = {}
            # fi
            if last_m not in clef or j not in clef[last_m]:
                for k in reversed(range(0, len(meas)-1)):
                    mmm = meas[k]
                    if mmm in clef and j in clef[mmm]:
                        nc = clef[mmm][j]
                        break
                    # fi
                # rof
            else:
                nc = clef[last_m][j]
            # fi
            clef[measure_on][j] = nc
        # rof
        new_voice_initialize(i, measure_on)
        mlth[i][measure_on] = 0
        # last instrument continues - might change shortly.
        vinstrument[measure_on][i] = vinstrument[last_m][i]
        pan[measure_on][i] = pan[last_m][i]
        reverb[measure_on][i] = reverb[last_m][i]
        intensity[measure_on][i] = intensity[last_m][i]
        key_voice[measure_on][i] = key_voice[last_m][i]
        # Carry forward.
        vl[i][measure_on] = vl[i][last_m]
        running_vl[i][measure_on] = running_vl[i][last_m]
        # Initialize the accidental for each note in measure.
        if args.horizontal or args.vertical:
            acc_m[i] =  {k: v for k, v in acc_v_init_v_or_h.items()}
            acc_m_xpose[i] =  {k: v for k, v in acc_v_init_v_or_h.items()}
        elif args.midi1csv or args.fluidsynth:
            acc_m[i] =  {k: v for k, v in acc_v_init_v_or_h.items()}
            acc_m_xpose[i] =  {k: v for k, v in acc_v_init_v_or_h.items()}
        else:           # ABC
            acc_m[i] =  {k: v for k, v in acc_v_init.items()}
            acc_m_xpose[i] =  {k: v for k, v in acc_v_init.items()}
        # fi
    # rof
    premeasurecomment[measure_on] = precomment
    measurelinecomment[measure_on] = commentonline
    # default note length continues with current - might change shortly.
    default_note_length[measure_on] = default_note_length[last_m]
    bars[measure_on] = bars[last_m]
    tempo_speed_now[measure_on] = tempo_speed_now[last_m]
    tempo_now_note_length[measure_on] = tempo_now_note_length[last_m]
    measure_meter[measure_on] = meter       # Each measure change can have a different meter.
    pitch[measure_on] = pitch[last_m]       # continue pitch from measure before.
    return
# End of do_measure

# ----------------------------------------------------------------------------
#   instrument 1,2 flute                $$ voices for an instrument.
def do_instrument(t_args, line):
    global vinstrument
    global reverb
    global pan
    global intensity
    global measure_on
    global instruments
    global extrainfo
    global mlth

    if t_args is None or len(t_args) != 1:
        print_error("instrument does not have arguments.", line)
        return
    # fi

    # Want a list of number separated by commas, followed by a space and an instrument name/number.
    t_args[0] = re.sub(r'\s*,\s*', ',', t_args[0])
    t_args[0] = re.sub(r'\s*\.\.\s*', '..', t_args[0])
    # Voice numbers, followed by instrument name.
    vargs = t_args[0].split()

    INST = " ".join(vargs[1:]).lower()
    if INST in instruments:
        INST = instruments[INST]        # Convert to number.
    else:
        f1, type_error = is_float(INST)
        if type_error is not None:
            return
        # fi
        if f1 is None:
            print_error("voice does not have instrument argument {} as a number.".format(INST), line)
            return
        # fi
        f1 = int(round(f1))
        if f1 not in instruments.values():
            print_error("instrument value {} not in instrument table.".format(f1), line)
            return
        # fi
        INST = [f1,0]
    # fi

    jkl = "".join(vargs[0])
    wargs = arglist(jkl, line, True)
    if not wargs or len(wargs) < 1:
        print_error("no voice arguments on instrument line", line)
        return
    # fi
    for w in wargs:
        f1, type_error = is_float(w)
        if type_error is not None:
            return
        # fi
        if f1 is None:
            print_error("voice {} is not a number.".format(w), line)
            return
        # fi
        f1 = int(round(f1))
        if f1 not in mlth:
            print_error("instrument with too many voices not allowed, voice {} is too many".format(f1), line)
            return
        # fi
        if mlth[f1][measure_on] != 0:
            print_error("instrument in the middle of measure '{}' not allowed, voice '{}'".format(measure_on, f1), line)
            return
        # fi

        strINST = '{}, {}'.format(INST[0], INST[1])
        if strINST not in extrainfo:
            extrainfo[strINST] = []
            j = None
            for k in instruments:
                strk = '{}, {}'.format(instruments[k][0], instruments[k][1])
                if strk == strINST:
                    j = k
                    break
                # fi
            # rof
            if j is None:
                print_error("instrument not in dictionary instruments {}".format(INST), line)
                return
            # fi
            extrainfo[strINST].append(j)       # The instrument number
            extrainfo[strINST].append(0)       # The reverb setting.
            extrainfo[strINST].append(64)      # The pan setting (left/right % for stereo).
            extrainfo[strINST].append(100)     # The intensity (volume, kind of) setting.
        # fi
        vinstrument[measure_on][f1] = INST
        vinstrument[measure_on][f1][0] += args.offset
        reverb[measure_on][f1] = extrainfo[strINST][1]
        intensity[measure_on][f1] = extrainfo[strINST][3]
        pan[measure_on][f1] = extrainfo[strINST][2]
    # rof

    return
# End of do_instrument

# ----------------------------------------------------------------------------
def do_reverb(t_args, line):
    global reverb
# - MUST NOT CHANGE FOR OTHER VOICES    global extrainfo
    global measure_on
#--    global vinstrument

    if t_args is None or len(t_args) != 1:
        print_error("reverb does not have arguments.", line)
        return
    # fi

    t_args[0] = re.sub(r'\s*,\s*', ',', t_args[0])

    vargs = t_args[0].split()
    if len(vargs) <= 0 or len(vargs) > 2:
        print_error("reverb does not have correct number of arguments.", line)
        return
    # fi
    if len(vargs) == 1:
        r = 0
    else:
        r = vargs[1]
        f1, type_error = is_float(r)
        if type_error is not None:
            return
        # fi
        if f1 is None:
            print_error("voice does not have reverb argument {} as a number.".format(r), line)
            return
        # fi
        r = int(round(f1))
    # fi
    if r < 0 or r > 127:
        print_error("reverb value {} not in range 0to 127.".format(r), line)
        return
    # fi

    jkl = "".join(vargs[0])
    wargs = arglist(jkl, line, True)

    if not wargs or len(wargs) < 1:
        print_error("no voice arguments on reverb line", line)
        return
    # fi
    for w in wargs:
        f1, type_error = is_float(w)
        if type_error is not None:
            return
        # fi
        if f1 is None:
            print_error("voice {} is not a number.".format(w), line)
            return
        # fi
        f1 = int(round(f1))

#--        INST = vinstrument[measure_on][f1]
# - MUST NOT CHANGE FOR OTHER VOICES        extrainfo[INST][1] = r
        reverb[measure_on][f1] = r
    # rof
    return
# End of do_reverb

# ----------------------------------------------------------------------------
def do_intensity(t_args, line):
    global intensity
# - MUST NOT CHANGE FOR OTHER VOICES    global extrainfo
    global measure_on
#--    global vinstrument

    if t_args is None or len(t_args) != 1:
        print_error("intensity does not have arguments.", line)
        return
    # fi

    t_args[0] = re.sub(r'\s*,\s*', ',', t_args[0])

    vargs = t_args[0].split()
    if len(vargs) <= 0 or len(vargs) > 2:
        print_error("intensity does not have correct number of arguments.", line)
        return
    # fi
    if len(vargs) == 1:
        intens = 0
    else:
        intens = vargs[1]
        f1, type_error = is_float(intens)
        if type_error is not None:
            return
        # fi
        if f1 is None:
            print_error("voice does not have intensity argument {} as a number.".format(intens), line)
            return
        # fi
        intens = int(round(f1))
    # fi
    if intens < 0 or intens > 127:
        print_error("intensity value {} not in range 0 to 127".format(intens), line)
        return
    # fi

    jkl = "".join(vargs[0])
    wargs = arglist(jkl, line, True)
    if not wargs or len(wargs) < 1:
        print_error("no voice arguments on intensity line", line)
        return
    # fi
    for w in wargs:
        f1, type_error = is_float(w)
        if type_error is not None:
            return
        # fi
        if f1 is None:
            print_error("voice {} is not a number.".format(w), line)
            return
        # fi
        f1 = int(round(f1))
        if f1 not in mlth:
            print_error("intensity with too many voices not allowed, voice {} is too many".format(f1), line)
            return
        # fi
#--        INST = vinstrument[measure_on][f1]
# - MUST NOT CHANGE FOR OTHER VOICES        extrainfo[INST][1] = intens
        intensity[measure_on][f1] = intens
    # rof
    return
# End of do_intensity

# ----------------------------------------------------------------------------
def do_pan(t_args, line):
    global pan
# - MUST NOT CHANGE FOR OTHER VOICES    global extrainfo
    global measure_on
#--    global vinstrument

    if t_args is None or len(t_args) != 1:
        print_error("pan does not have arguments.", line)
        return
    # fi

    t_args[0] = re.sub(r'\s*,\s*', ',', t_args[0])

    vargs = t_args[0].split()
    if len(vargs) <= 0 or len(vargs) > 2:
        print_error("pan does not have correct number of arguments.", line)
        return
    # fi
    if len(vargs) == 1:
        p = 0
    else:
        p = vargs[1]
        f1, type_error = is_float(p)
        if type_error is not None:
            return
        # fi
        if f1 is None:
            print_error("voice does not have pan argument {} as a number.".format(p), line)
            return
        # fi
        p = int(round(f1))
        if p < 0 or p > 127:
            print_error("pan value {} not in range 0 to 127.".format(p), line)
            return
        # fi
    # fi
    jkl = "".join(vargs[0])
    wargs = arglist(jkl, line, True)
    if not wargs or len(wargs) < 1:
        print_error("no voice arguments on pan line", line)
        return
    # fi
    for w in wargs:
        f1, type_error = is_float(w)
        if type_error is not None:
            return
        # fi
        if f1 is None:
            print_error("voice {} is not a number.".format(w), line)
            return
        # fi
        f1 = int(round(f1))

#--        INST = vinstrument[measure_on][f1]
# - MUST NOT CHANGE FOR OTHER VOICES        extrainfo[INST][1] = p
        pan[measure_on][f1] = p
    # rof
    return
# End of do_pan

# ----------------------------------------------------------------------------
def do_xpose(t_args, line):
    global xpose
    global xpose_new_key
    global measure_on
    global key_sig
    global key_sig_int
    global key_default
    global key_voice

    if args.noxpose:
        print_warning("Ignoring xpose parsing.", line)
        return
    # fi

    if t_args is None or len(t_args) != 1:
        print_error("xpose does not have arguments.", line)
        return
    # fi

    t_args[0] = re.sub(r'\s*,\s*', ',', t_args[0])

    vargs = t_args[0].split()
    if len(vargs) <= 0 or len(vargs) > 3:
        print_error("xpose does not have correct number of arguments.", line)
        return
    # fi
    if len(vargs) == 1:
        x = 0
    else:
        x = vargs[1]
        f1, type_error = is_float(x)
        if type_error is not None:
            return
        # fi
        if f1 is None:
            print_error("voice does not have xpose argument {} as a number.".format(x), line)
            return
        # fi
        x = int(round(f1))
    # fi
#--    if x < -12 or x > 12:
#--        print_error("xpose value {} not in range -12 to 12.".format(x), line)
#--        return
#--    # fi
    if len(vargs) <= 2:
        k = kl = key_default
        if args.midi1csv or args.fluidsynth:
            # Convert kl from integer to lowercase normal musicomp usage.
            kl = key_sig_int[kl]
        # fi
    else:
        k = kl = vargs[2]
        if kl not in key_sig:
            print_error("no key {} in key_sig({})".format(kl, key_sig), line)
            return
        # fi
        if args.midi1csv or args.fluidsynth:
            # Convert kl from normal musicomp to midi1csv format (integer).
            k = key_sig[kl]
        # fi
    # fi
    # k is used for key_voice
    # kl is used in getnote via xpose_new_key (musicomp text)

    if args.vertical or args.horizontal or args.midi1csv or args.fluidsynth:
        pass                                # printing and used are the same.
    else:                   # ABC
        k = k.upper()
        k = k.replace('-', 'b')             # Does multiple flats
        k = k.replace('+', '#')             # Does multiple sharps.
        k = k.replace('n', '=')             # Does multiple naturals.
    # fi
    # k = value to store in key_voice, key_default, etc. -- used for printing, etc.

    jkl = "".join(vargs[0])
    wargs = arglist(jkl, line, True)
    if not wargs or len(wargs) < 1:
        print_error("no voice arguments on xpose line", line)
        return
    # fi
    for w in wargs:
        f1, type_error = is_float(w)
        if type_error is not None:
            return
        # fi
        if f1 is None:
            print_error("voice {} is not a number.".format(w), line)
            return
        # fi
        xpose_new_key[f1] = kl
        f1 = int(round(f1))
        xpose[f1] = x
# NOTDONEYET - keys   This doesn't make sense? Why set key_voice?  2021-06-18_21-33-56
        key_voice[measure_on][f1] = k
    # rof
    return
# End of do_xpose

# ----------------------------------------------------------------------------
def do_staves(line):
    global staves

    line = line.strip()
    line = ' '.join(line.split())
    line = line.replace('[', '')
    line = line.replace(']', '')
    line = line.replace(' )', ')')
    line = line.replace(' (', '(')
    line = line.replace(') ', ')')
    z = line.split(')')
    # Now, any array entry that starts with ( is a list of voices to order.
    #     Check for more than 1 number.
    # else ignore the numbers -- they are on separate staves.
    for x in z:
        if x == '' or x[0] != '(':
            continue
        # fi
        x = x[1:]
        y = x.split()
        if len(y) <= 1:
            continue
        # fi
        staves.append(y)
    # rof
# End of do_staves

# ----------------------------------------------------------------------------
# '%%'      : do_percents,
def do_percents(t_args, line):
    global measure_on
    global percents

    if line[0:9] == '%%staves ':
        do_staves(line[9:])
    # fi
    if measure_on not in percents:
        percents[measure_on] = []
    # fi
    percents[measure_on].append(line)
    return
# End of do_percents

# ----------------------------------------------------------------------------
# dictionary commandname : routine. execute via(?): globals()['do_cstopnow'](t_args, line)
global commands
commands = {
             'bars'    : do_bars,
             'calc'    : do_calc,
             'change'  : do_change,
             'cis'     : do_cis,
             'clef'    : do_clef,
             'copy'    : do_copy,
             'cstart'  : do_cstart,
             'cstop'   : do_cstop,
             'cstop*'  : do_cstopnow,
             'debug'   : do_debug,
             'decode'  : do_decode,
             'delay'   : do_delay,
             'else'    : do_else,
             'end'     : do_cstopnow,
             'endif'   : do_endif,
             'endm'    : do_endm,
             'flat'    : do_flat,
             'goto'    : do_goto,
             'if'      : do_if,
             'key'     : do_key,
             'macro'   : do_macro,
             'marker'  : do_marker,
             'measure' : do_measure,
             'unit'    : do_measure,
             'meter'   : do_meter,
             'natural' : do_natural,
             'page'    : do_page,
             'percus'  : do_percus,
             'pitch'   : do_pitch,
             'putd'    : do_putd,
             'randu'   : do_randu,
             'randp'   : do_randp,
             'setperm' : do_setperm,
             'sharp'   : do_sharp,
             'slide'   : do_slide,
             'start'   : do_cstart,
             'stop'    : do_cstop,
             'stop*'   : do_cstopnow,
             'tempo'   : do_tempo,
             'temper'  : do_temper,
             'title'   : do_title,
             'voice'   : do_voice,
             'volume'  : do_volume,
             'volumes' : do_volumes,
             'reverb'  : do_reverb,
             'pan'     : do_pan,
             'intensity' : do_intensity,
             'instrument' : do_instrument,
             'xpose'   : do_xpose,
             '%%'      : do_percents,
             # '.' -- handled specially.
           }

# ----------------------------------------------------------------------------
# For plato calc command processing :)
# w=1,h=2,q=4,e=8,th=+0k        # for plato calc command
# s=(1),d=(1),b=(1),t=(1)       # for plato calc command
# m1, m2, m3, m4, m5, m6, m7, m8, m9
# freq(A) = 968000/A
# nearest(A)      = int(round(ln(A/27.5)*12/0.693147))
# framlth = 60*(20/21)          # frames per second
# tempo(a,b)      = 60*framlth*b*[1./a]
# min2(a,b)       = (a+b-abs(a-b))/2      $$ by Dan Sleator
# min4(l,a,b,d)   = min2(min2(l,a),min2(b,d))
# max2(a,b)       = (a+b+abs(a-b))/2      $$ note, no < or > ops
# max4(l,a,b,d)   = max2(max2(l,a),max2(b,d))
# ----------------------------------------------------------------------------
# Notes and comma for separating voices.
# Length of note in 1/60ths of a second.   r[1]    = 1/57.1429 frames per second
# Length of notes as floating number.      (0.25)  = 1/4 = quarter note.
# variable: pause = break between two identical notes, or "broken notes".
# Note: variables in () and [].
# ----------------------------------------------------------------------------
# rests
# Notes: 3c4,4c4,r2     $$ 3 voices, last is a rest.
#        3a8,,4c8       $$ voice 2 is still playing
# ONALM
# O = octave. default to most recently used for this voice. from 1 to 8.  Middle C = octave 3.
# N = note itself a through g. Probably allow upper or lower case. :) "r" = rest.
# A = Default to normal key value. accidental -> +, -, ++, --, n. Do not carry to next note. (n=natural)
# L = Default to most recently used for this voice. note length. Like 16 for sixteenth note. Can do 16th.
#       w, h, q -> whole, half, quarter.
#       3(4) -> 3 notes in the time of a quarter note. (triplets)
#       (.25) -> 1/4 note.
#       [12] -> number of output frames ... 1/57.1429 of a second.
#   Example:    4b-3(4)         $$ beginning of a triplet
# M = modifier. Normal note. Any combination: d = dotted, s=staccato, b = broken by pause from next, t = tie.
#   3a16t           $$ lengthens previous by 1/16th ... must be same note.

# Special note forms (replace O and N):  (13) - note number. [440] = frequency in Hz. {317} GSW - ignore.
#     t(3a,3g,7)4  = ON,ON,number,LM   - example, 7 notes, quarter note length.
#        NOTE: in 60ths of a second, be careful using it.
#     s4(4a,b,a,g) = sLM(ONA,ONA,...)  - play all notes as grace notes, length of staccato, LM=length
#               last note lasts until LM (quarter note in example) is reached.
# ----------------------------------------------------------------------------
# For octave 3c = 60.
note_in_octave_value = {
   'c-':59,
   'c':60, 'cn':60,
   'c+':61, 'd-':61,
   'd':62, 'dn':62,
   'd+':63, 'e-':63,
   'e':64, 'en':64, 'f-':64,
   'e+':65, 'f':65, 'fn':65,
   'f+':66, 'g-':66,
   'g':67, 'gn':67,
   'g+':68, 'a-':68,
   'a':69, 'an':69,
   'a+':70, 'b-':70,
   'b':71, 'bn':71,
   'b+':72
}

global note_to_midi_value
note_to_midi_value = { }
global midi_value_to_note_flat
midi_value_to_note_flat = { }
global midi_value_to_note_sharp
midi_value_to_note_sharp = { }

for o in range(0, 9):        # 0 thru 8
    for n in note_in_octave_value:
        x = str(o) + n
        v = (note_in_octave_value[n] - (60-24)) + 12*o      # 60-36=24 = '0c'
        note_to_midi_value[x] = v
        if len(n) == 2:     # accidental
            if n[1] == '+':
                if v not in midi_value_to_note_sharp:   # Prefer no sharp/flat.
                    midi_value_to_note_sharp[v] = x
                # fi
            # fi
            if n[1] == '-':
                if v not in midi_value_to_note_flat:    # Prefer no sharp/flat.
                    midi_value_to_note_flat[v] = x
                # fi
            # fi
        else:
            midi_value_to_note_sharp[v] = x             # Prefer no sharp/flag.
            midi_value_to_note_flat[v] = x
        # fi
    # rof
# rof

# ----------------------------------------------------------------------------
# return:
#       therest (for time)
#       thenote         Convert to abc format for note, octave.
#       typenote:       -2 gsw oprnd, -1 freq, 0 note, 1 trill, 2 sequence

def getnote(note_to_decode, voice, line):
    global oct                                  # default octave
    global accidentals
    global allkeys
    global acc_m                                # Last accidental on a note in measure.
    global acc_m_xpose
    global measure_on
    global args
    global note_to_midi_value
    global midi_value_to_note_flat
    global midi_value_to_note_sharp
    global key_sig
    global key_sig_int
    global key_convert
    global key_default
    global key_voice
    global xpose
    global xpose_new_key

    leading_space = False
    if note_to_decode and len(note_to_decode) > 0:
        if note_to_decode[0] == '\t' or note_to_decode[0] == ' ':
            note_to_decode = note_to_decode[1:]
            leading_space = True
        # fi
    # fi
    temp3 = 0                                   # character pointer
    if note_to_decode == '0':
        return '', 0, normal_note
    # fi
    if not note_to_decode or note_to_decode == '':
        return '', '', normal_note
    # fi
    if note_to_decode[0] == '{' or note_to_decode[0] == '[' or note_to_decode[0] == '(':
        if note_to_decode[0] == '{':            # gsw oprnd     { }
            typenote = gsw_operand              # set gsw-opnd flag
        elif note_to_decode[0] == '[':          # frequency     [ ]
            typenote = freqency_note            # set freq flag
        else:
            typenote = normal_note              # return normal note
        # fi
        work3 = 1
        #  must balance parens since note is followed by time
        #  [440]4
        # balance parens
        for temp2 in range(temp3 + 1, len(note_to_decode)):
            work4 = note_to_decode[temp2]
            if work4 == '(' or work4 == '[' or work4 == '{':
                work3 = work3 + 1               # count ('s
            elif work4 == ')' or work4 == ']' or work4 == '}':
                work3 = work3 - 1               # subtract  )'s
                if work3 < 1:
                    temp3 = temp2 + 1           # temp2 has last matched )
                    therest = note_to_decode[temp3:]
                    note_to_decode = note_to_decode[0:temp3]
                    thenote, type_error = is_float(note_to_decode)
                    if type_error is not None:
                        return therest, thenote, type_error
                    # fi
                    if thenote is None:
                        print_error("Note is not legal '{}', computation failed".format(note_to_decode), line)
                        return therest, thenote, type_error
                    # fi
                    thenote = int(round(thenote))
                    if typenote == freqency_note:  # if freq calculate it
                        #-- thenote = freq(thenote)
                        thenote = 968000/thenote    # NOT handled anywhere.
                    elif typenote == normal_note:
                        if thenote != 0 and (args.midi1csv or args.fluidsynth):
                            thenote = thenote + 12 + 12 - 3     # 3c -> 39 must be 60 for midi.
                        # fi
                        if thenote != 0:
                            thenote = thenote + xpose[voice]
                        # fi
                    # fi
                    # get ready for time computation
                    return therest, thenote, typenote
                # fi
            # fi
        # rof
        print_error("Note is not legal '{}', unbalanced parenthesis".format(note_to_decode), line)
        return '', None, normal_note
    # fi
    if note_to_decode[0] in [ '0', '1', '2', '3', '4', '5', '6', '7', '8' ]:    # check octave
        oct[voice] = int(note_to_decode[0])                                     # save octave
        temp3 = temp3 + 1
    # fi
    if len(note_to_decode) <= temp3 or note_to_decode[temp3] is None:
        print_error("no note_to_decode '{}' temp3={} len(note_to_decode)={}".format(note_to_decode, temp3, len(note_to_decode)), line)
        return '', None, normal_note
    # fi
    thenote = note_to_decode[temp3]
    if thenote not in [ 'a', 'b', 'c', 'd', 'e', 'f', 'g' ]:      # if not note -- reset, etc.
        if temp3 != 0:
            print_error("Not a note (sequence/trill?) has an octave before it", line)
            return '', None, None                # ???
        # fi
        if note_to_decode[0] == 's':            # check for sequence
            if note_to_decode[1] == '(':        # if time given
                print_error("sequence does not have the number of notes before parenthesis", line)
                return '', None, None                # ???
            # fi
            #       from, from_character, to, to_character, optionallength
            note_to_decode = note_to_decode[1:]
            sc = note_to_decode.find('(')
            if sc < 0:
                print_error("Sequence is not legal '{}' no parenthesis found.".format(note_to_decode), line)
                return '', None, normal_note
            # fi
            number_in_sequence = note_to_decode[0:sc]
            number_in_sequence, type_error = is_float(number_in_sequence)
            if type_error is not None:
                print_error(type_error, line)
                return '', None, None                # ???
            # fi
            if number_in_sequence is None:
                print_error("sequence does not have a number of notes before parenthesis", line)
                return '', None, None                # ???
            # fi
            number_in_sequence = int(round(number_in_sequence))
            therest = note_to_decode[sc:]
            if leading_space:
                therest = ' ' + therest             # Flag for later processing.
            # fi
            return therest, number_in_sequence, sequence_note
        # fi
        if note_to_decode[0] == 't':            # check for trill
            if len(note_to_decode) > 1:
                if note_to_decode[1] != '(':    # check for parenthesis
                    print_error("Note is not legal '{}', no parenthesis for trill.".format(note_to_decode), line)
                    return '', None, normal_note
                # fi
            else:
                print_error("Note is not legal '{}'".format(note_to_decode), line)
                return '', None, normal_note
            # fi
            #-- if typenote == trill_note:
            #--     print_error("Note is not legal '{}' double trill".format(note_to_decode), line)
            #--     return '', None, normal_note
            #-- # fi
            therest = note_to_decode[2:]
            if leading_space:
                therest = ' ' + therest         # Flag for later processing.
            # fi
            return therest, 't(', trill_note
        # fi
        if note_to_decode[0] == 'r':            # check for rest
            # Rest follows.
            if args.horizontal or args.vertical:
                thenote = 'r'
            elif args.midi1csv or args.fluidsynth:
                thenote = 0
            else:       # ABC
                thenote = 'z'                   # Convert to abc format rest.
            # fi
            temp3 = temp3 + 1
            # get ready for time computation
            therest = note_to_decode[temp3:]
            if leading_space:
                therest = ' ' + therest         # Flag for later processing.
            # fi
            return therest, thenote, normal_note
        # fi
        print_error("Note is not legal '{}' unknown".format(note_to_decode), line)
        return '', None, normal_note
    # fi
    temp3 = temp3 + 1
    if len(note_to_decode) <= temp3:
        temp4 = ''
    else:
        temp4 = note_to_decode[temp3]
    # fi
    if temp4 == 'n':                            # natural special
        temp3 = temp3 + 1
        thenote = thenote + temp4               # construct  dn
        if thenote not in allkeys:
            print_error("Note is not legal '{}' not good decode={}  n".format(note_to_decode, thenote), line)
            return '', None, normal_note
        # fi
        therest = note_to_decode[temp3:]
    elif temp4 == '+' or temp4 == '-':          # check special note
        thenote = thenote + temp4               # construct  d+ or d-
        temp3 = temp3 + 1
        if len(note_to_decode) <= temp3:
            temp4 = ''
        else:
            temp4 = note_to_decode[temp3]
        # fi
        if temp4 == '+' or temp4 == '-':        # check special note
            thenote = thenote + temp4           # construct  d++ or d--
            temp3 = temp3 + 1
        # fi
        if thenote not in allkeys:
            print_error("Note is not legal '{}' not good decode={} +/-".format(note_to_decode, thenote), line)
            return '', None, normal_note
        # fi
        therest = note_to_decode[temp3:]
    else:
        if thenote not in allkeys:
            print_error("Note is not legal '{}' uh-ish {}".format(note_to_decode, thenote), line)
            return '', None, normal_note
        # fi
    # fi

    #   thenote             Convert to abc format for note, octave.
    n = thenote[0].lower()
    if args.horizontal or args.vertical or args.midi1csv or args.fluidsynth:
        N = n.lower()
    else:               # ABC format
        N = n.upper()
    # fi
    if len(thenote) > 1:
        a = thenote[1:]
        if a not in accidentals:
            print_error("sharp/flat/natural is not legal '{}'".format(a), line)
            return '', None, normal_note
        # fi
        if args.horizontal or args.vertical:
            A = a
        elif args.midi1csv or args.fluidsynth:
            A = a
        else:       # ABC
            A = accidentals[a]
        # fi
    else:
        A = a = ''
    # fi
    octaves = { 0:',,,', 1:',,', 2:',', 3:'', 4:'', 5:"'", 6:"''", 7:"'''", 8:"'''" }
    o = oct[voice]
    if o not in octaves:
        print_error("Note is not legal '{}' oct strange {}".format(note_to_decode, o), line)
        return '', None, normal_note
    # fi
    if a not in accidentals:
        print_error("Note is not legal '{}' accidentals strange {}".format(note_to_decode, a), line)
        return '', None, normal_note
    # fi

    if a == '' and voice in acc_m and N in acc_m[voice] and acc_m[voice][N] != '' and line != 'check_staves_notes_order':
        # Check if default from last potential problem.
        print_warning("previous note '{}' voice {} in measure {} was '{}' and this note is default - FIXING".format(n, voice, measure_on, acc_m[voice][N]), line)
        a = acc_m[voice][N]
        if args.horizontal or args.vertical:
            A = a
        elif args.midi1csv or args.fluidsynth:
            A = a
        else:       # ABC
            A = accidentals[a]          # Convert to abc format.
        # fi
    # if
    acc_m[voice][N] = a                 # Save for next note for voice.
    # . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
    # Have o(ctave),a(ccidental),and n(ote).
    # Convert for key.

    ky = key_voice[measure_on][voice]
    if args.horizontal or args.vertical:
        if ky not in key_sig:
            print_error("key name='{}' not in key_sig.".format(ky), line)
            sys.exit(1)
        # fi
        thenote = "{}".format(o) + n + a
        thenote = thenote.lower()
        if thenote not in key_convert[ky]:
            print_error("thenote='{}' not in key_sig={} dictionary.".format(thenote, key_sig.keys()), line)
            sys.exit(1)
        # fi
        #-- thenote = key_convert[ky][thenote]
        #-- o = thenote[0]
        #-- n = thenote[1].lower()
        #-- if len(thenote) > 2:
        #--     A = a = thenote[2]
        #-- else:
        #--     A = a = ''
        #-- # fi
        # Do not convert it in musicomp format.
    elif args.midi1csv or args.fluidsynth:
        if ky not in key_sig_int:
            print_error("key number='{}' not in key_sig_int={}".format(ky, key_sig_int.keys()), line)
            sys.exit(1)
        # fi
        if a != '':
            thenote = "{}".format(o) + n + a
        else:
            thenote = "{}".format(o) + n + a
            ky = key_sig_int[ky]
            if thenote not in key_convert[ky]:
                print_error("thenote={} not in key_convert[{}] dictionary.".format(thenote, ky), line)
                sys.exit(1)
            # fi
            thenote = key_convert[ky][thenote]
        # fi
        o = thenote[0]
        n = thenote[1].lower()
        if len(thenote) > 2:
            A = a = thenote[2]
        else:
            A = a = ''
        # fi
    else:           # ABC
        # ky = ky.lower()
        # ky = ky.replace('b', '-')           # Does multiple flats
        # ky = ky.replace('#', '+')           # Does multiple sharps.
        # ky = ky.replace('=', 'n')           # Does multiple naturals.
        # if ky not in key_sig:
        #     print_error("key name='{}' not in key_sig.".format(ky.lower()), line)
        #     sys.exit(1)
        # # fi
        # Do not convert it in ABC format.
        pass
    # fi
    # . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
    # Have translated key of o(ctave),a(ccidental),and n(ote). -- Original for ABC.

    # 1) xpose added to the note.
    # 2) xpose_new_key converted back to o/n/a

    if (args.midi1csv or args.horizontal or args.vertical or args.fluidsynth) and xpose[voice] != 0:      # So can print.
        jkl = str(o) + str(n) + a
        if jkl not in note_to_midi_value:
            print_error("note {} for xpose is not in note_to_midi_value".format(jkl), line)
            return '', None, normal_note
        # fi
        lkj = note_to_midi_value[jkl] + xpose[voice]
        new_lkj = lkj
        if xpose_new_key[voice] == 'cn':
            lkj = midi_value_to_note_sharp[lkj]
        elif key_sig[xpose_new_key[voice]] <= 0:
            if lkj not in midi_value_to_note_flat:
                print_error_no_line("voice={} lkj='{}'".format(voice, lkj))
                print_error_no_line("  line={}".format(line))
            # fi
            lkj = midi_value_to_note_flat[lkj]
        else:
            lkj = midi_value_to_note_sharp[lkj]
        # fi
        # Convert lkj to new_o, new_n, new_a.
        new_o = int(lkj[0])
        new_n = lkj[1].lower()

        if args.horizontal or args.vertical or args.midi1csv or args.fluidsynth:
            new_N = new_n.lower()
        else:               # ABC format
            new_N = new_n.upper()
        # fi
        if len(lkj) > 2:
            new_a = lkj[2]
            new_A = new_a
        else:
            new_a = 'n'
            new_A = 'n'
        # fi

        # If new_a == '', then need check with new_a == n too.
        # IDEA: go through all notes in key, checking for [], and append().
        #   If only one found, check if 'n':
        #       if acc_m_xpose[voice][new_N] == ''
        #           then got the note, without the 'n'.
        #       else:
        #           the note needs the 'n'.
        #       # fi
        #   else: == multiple matches. Put out the accidental.

        k = []
        t = str(new_o) + new_n + new_a
        new_key = xpose_new_key[voice]
        if new_key in key_convert:
            for i in key_convert[new_key.lower()]:
                j = key_convert[new_key.lower()][i]
                if j == t:
                    k.append(i)
                # fi
            # rof
        # fi

        if len(k) == 1:
            j = key_convert[new_key.lower()][t]
            if j == t:          # 3 chars match 3 chars.
                acc_m_xpose[voice][new_N] = new_A
            else:
                if acc_m_xpose[voice][new_N] != '':
                    acc_m_xpose[voice][new_N] = new_A
                # fi
            # fi
        else:
            if acc_m_xpose[voice][new_N] != '':
                acc_m_xpose[voice][new_N] = new_A
            else:
                new_A = new_a = ''
            # fi
        # fi

        # . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
        # Need to know the key, and if various +/- and acc_m_xpose == '', don't need the +/-.
        #   (Reverse of key.)

        # If do not need the n/= for this voice and measure ...
        if acc_m_xpose[voice][new_N] == '':
            if new_a == 'n':
                new_A = ''
                new_a = ''
            else:
                acc_m_xpose[voice][new_N] = new_A
            # fi
        else:
            acc_m_xpose[voice][new_N] = new_A
        # fi
        o = new_o
        n = new_n
        a = new_a
        N = new_N
        A = new_A
    # else:             # ABC format - do nothing.
    #    pass
    # fi
    # .............................................................................
    # Convert to right format.
    if args.horizontal or args.vertical:
        n = n.lower()
    elif args.midi1csv or args.fluidsynth:
        n = n.lower()
    else:                           # ABC
        if o <= 3:                                      # uppercase letter
            n = n.upper()
        else:                                           # lowercase letter
            n = n.lower()
        # fi
    # fi
    if args.horizontal or args.vertical:
        thenote = "{}".format(o) + n + a
        if leading_space:
            thenote = ' ' + thenote
        # fi
    elif args.midi1csv or args.fluidsynth:
        if a != '':
            thenote = "{}".format(o) + n + a
        else:
            thenote = "{}".format(o) + n + a
        # fi
        k = ky if xpose[voice] == 0 else xpose_new_key[voice]
        if type(k) is str:
            nthenote = key_convert[k.lower()][thenote]
        else:
            nthenote = key_convert[key_sig_int[k]][thenote]
        # fi
        abc = note_to_midi_value[nthenote]
        thenote = abc
    else:           # ABC
        # Do not convert it in ABC format.
        thenote = A + n + octaves[o]
        if leading_space:
            thenote = ' ' + thenote
        # fi
    # fi
# .............................................................................
    therest = note_to_decode[temp3:]
    return therest, thenote, normal_note
# End of getnote

# ----------------------------------------------------------------------------
# compute time
# Returns:
#   timeofnote      computed length in 60ths
#   accidentals     Union of bits for accidentals.
#   number_dots     Number of "dots".

global accidental_marcato
global accidental_tied
global accidental_stac
global accidental_broken
global accidental_legato
global accidental_normal
accidental_legato = 16      # glide to next note - no note attack on start of note.
accidental_broken = 8       # broken - ignored - break between notes ... because gsw didn't have it.
accidental_marcato = 4      # ignored   -- use vol(sf), etc.
accidental_tied = 2         # tied
accidental_stac = 1         # staccato
accidental_dotted = -1      # dotted
accidental_normal = 0

# Staccato, tied, break, dotted.
global bit_from_character
bit_from_character = {
   'l': accidental_legato,
   'b': accidental_broken,
   'm': accidental_marcato,
   't': accidental_tied,
   's': accidental_stac,
   'd': accidental_dotted
   #-- hidden for crescendo ... 'c'.
}

def get_time(therest, line):
    whqe = { 'w':'1', 'h':'2', 'q':'4', 'e':'8' }
    global bit_from_character

    vwork = 0
    # Must exist. If not alphanumeric or if "whqe".
    if therest and therest[0] in whqe:          # convert whqe to 1,2,4,8.
        w_t = whqe[therest[0]]
        therest = therest[:0] + w_t + therest[1:]
    # fi
    if not therest:
        pass
    elif not therest[0].isalpha():    # if not a note or modifier (computable)
        vwork, type_error = is_float(therest)
        # errorrest = everything after value -- if error occurs.
        # vwork = value calculated before error (even if not error).
        # type_error = message of error type.
        if type_error is not None:
            print_error(type_error, line)
            return 0, None, None                # ???
        # fi
        if vwork is None:
            vwork = 0
        # fi
    else:
        for i in therest:
            if i not in bit_from_character:
                print_error("time field has unrecognizable character ({})".format(i), line)
                return 0, None, None                # ???
            # fi
        # rof
    # fi
    if vwork == 0:
        work = 0                                # No time given
    else:
        if therest[0]  == "[":                  # number of 1/60ths
            work = (1.0/64.0) * vwork           # Number of 64th notes
        elif therest[0]  == "(":                # (.25) = 1/4 note (or like "4")
            work = vwork
        else:
            work = 1.0 / vwork
        # fi
    # fi
    work4 = accidental_normal                   # No incidentals yet.
    number_dots = 0
    if therest and therest != '':
        for i in reversed(range(0, len(therest))):
            temp4 = therest[i]
            if temp4 not in bit_from_character:
                break
            # fi
            temp4 = bit_from_character[temp4]
            if temp4 == accidental_dotted:
                number_dots = number_dots + 1
            else:
                work4 = work4 | temp4
            # fi
        # rof
    # fi
    if ((work4 & accidental_legato) != 0 and (
         (work4 & accidental_tied) != 0)):
        print_error("b) Multiple accidentals that cannot occur together, work4=({})".format(work4), line)
        return 0, None, None
    # fi
    return work, work4, number_dots
    if ((work4 & accidental_tied) != 0 and (
         (work4 & accidental_stac) != 0)):
        print_error("c) Multiple accidentals that cannot occur together, work4=({})".format(work4), line)
        return 0, None, None
    # fi
    return work, work4, number_dots
# End of get_time

# ----------------------------------------------------------------------------
def do_tie_on_previous_note(onvoice, line, what):
    global measure_on                   # The measure we are on.
    global meas                         # volume levels
    global bufs
    global bufs_accidentals

    m = measure_on
    if m not in bufs[onvoice] or bufs[onvoice][m] == '':
        # Do measure before.
        w = len(meas) - 1               # current measure number in array.
        if w == 0:
            print_error("no previous measure to tie note to.", line)
            return ''
        else:
            m = meas[w-1]
        # fi
    # fi
    if args.horizontal or args.vertical:
        bufs_accidentals[onvoice][m][-1] += what
    elif args.midi1csv or args.fluidsynth:
        bufs_accidentals[onvoice][m].append(what)
    else:                   # abc format
        bufs[onvoice][m] = bufs[onvoice][m] + '-'
    # fi
    return
# End of do_tie_on_previous_note

# ----------------------------------------------------------------------------
def do_tie_abc(onvoice, vnumber, line):
    if vnumber is not None:             # If vertical input format.
        return '-'
    # fi
    do_tie_on_previous_note(onvoice, line, '-')
    return ''
# End of do_tie_abc

# ----------------------------------------------------------------------------
def determine_s_vol(f1, onvoice, line):
    global pppp, ppp, pp, p, mp, mf, f, ff, fff, ffff
    global running_vl
    global measure_on

    if f1 == -1:                        # -1 for fff
        return fff                      # Cannot get any louder.
    elif f1 == -2:                      # -2 for ff
        if running_vl[onvoice][measure_on] >= ff :
            return fff
        # fi
        return ff
    elif f1 == -3:                      # -3 for f
        if running_vl[onvoice][measure_on] >= f :
            if running_vl[onvoice][measure_on] >= ff :
                return fff
            # fi
            return ff
        # fi
        return f
    elif f1 == -4:                      # -4 for mf
        if running_vl[onvoice][measure_on] >= mf:
            if running_vl[onvoice][measure_on] >= f :
                if running_vl[onvoice][measure_on] >= ff :
                    return fff
                # fi
                return ff
            # fi
            return f
        # fi
        return mf
    elif f1 == -5:                      # -5 for mp
        if running_vl[onvoice][measure_on] >= mp :
            if running_vl[onvoice][measure_on] >= mf:
                if running_vl[onvoice][measure_on] >= f :
                    if running_vl[onvoice][measure_on] >= ff :
                        return fff
                    # fi
                    return ff
                # fi
                return f
            # fi
            return mf
        # fi
        return mp
    elif f1 == -6:                      # -6 for p
        if running_vl[onvoice][measure_on] >= p :
            if running_vl[onvoice][measure_on] >= mp :
                if running_vl[onvoice][measure_on] >= mf:
                    if running_vl[onvoice][measure_on] >= f :
                        if running_vl[onvoice][measure_on] >= ff :
                            return fff
                        # fi
                        return ff
                    # fi
                    return f
                # fi
                return mf
            # fi
            return mp
        # fi
        return p
    elif f1 == -7:                      # -7 for pp
        return pp                       # Not really something you'll see.
    elif f1 == -8:                      # -8 for ppp
        return ppp                      # Cannot get any quieter.
    else:
        print_error("determine_s_vol - volume with 's' out of range. ({})".format(f1), line)
        return fff
    # fi
# End of determine_s_vol

# ----------------------------------------------------------------------------
# therest,new_one_note_volume,newvolume,text_str = get_vol_note(temp1, line)
def get_vol_note(temp1, onvoice, line):
    global S_vlprint
    global vlprint

    if temp1[0] == ' ':
        therest = temp1[5:]
    else:
        therest = temp1[4:]
    # fi
    sc = therest.find(')')
    if sc < 0 or sc == 0:
        print_error("A 'vol(' needs a number followed by a ')' -- ')' or number is missing", line)
        return '', None, None, None
    # fi
    f2 = -1                         # No volume setting after the "vol"
    s1 = therest[0:sc]
    therest = therest[sc+1:]
    f1, type_error = is_float(s1)
    if type_error is not None:
        for j in vlprint:
            if s1 == vlprint[j]:
                f1 = j
                f2 = int(round(f1)) # flag same after setting it.
                type_error = None
                break
            # fi
        # rof
        if type_error is not None:
            for j in S_vlprint:
                if j == s1:
                    f1 = S_vlprint[j][0]
                    f2 = S_vlprint[j][1]
                    type_error = None
                    if f1 < 0 and not args.horizontal and not args.vertical:
                        f1 = determine_s_vol(f1, onvoice, line)
                    # fi
                    break
                # fi
            # rof
            if type_error is not None:
                print_error("vol(xxx) did not get have a number or volume name. {}".format(type_error), line)
                return '', None, None, None
            # fi
        # fi
    else:
        f2 = int(round(f1))         # flag same after setting it.
    # fi
    if f1 is None:
        print_error("volume is not a number.", line)
        return '', None, None, None
    # fi
    if not args.horizontal and not args.vertical:
        f1 = int(round(f1))
        if f1 < 1  or f1 > 127:       # If out of range.
            print_error("volume number must be between 1 and 127 inclusive. Not ({})".format(f1), line)
            return '', None, None, None
        # fi
    # fi
    return therest, f1, f2, s1
# End of get_vol_note

# ----------------------------------------------------------------------------
# therest,newvolume,newtime = get_cresc(temp1, line)
def get_cresc(temp1, line):
    if temp1[0] == ' ':
        therest = temp1[7:]
    else:
        therest = temp1[6:]
    # fi
    sc = therest.find(',')
    if sc < 0 or sc == 0:
        print_error("A 'cresc(' needs a number followed by a ',' -- ',' or number is missing", line)
        return '', None, None
    # fi
    s1 = therest[0:sc]
    s2 = therest[sc+1:]
    sc = s2.find(')')
    if sc < 0 or sc == 0:
        print_error("A 'cresc(' needs a number followed by a ',' and ')' -- ')' or time missing", line)
        return '', None, None
    # fi
    therest = s2[sc+1:]
    s2 = s2[0:sc]
    # . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
    f1, type_error = is_float(s1)
    if type_error is not None:
        for j in vlprint:
            if s1 == vlprint[j]:
                f1 = j
                type_error = None
                break
            # fi
        # rof
        if type_error is not None:
            print_error("cresc(xxx,yyy) did not get have a number or volume name. {}".format(type_error), line)
            return '', None, None
        # fi
    # fi
    if f1 is None:
        print_error("volume is not a number.", line)
        return '', None, None
    # fi
    f1 = int(round(f1))
    if f1 < 1  or f1 > 127:       # If out of range.
        print_error("volume number must be between 1 and 127 inclusive. Not ({})".format(f1), line)
        return '', None, None
    # fi
    if args.vertical or args.horizontal:
        f1 = s1
    # fi
    # . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
    f2, type_error = is_float(s2)
    if type_error is not None:
        print_error("cresc(xxx,yyy) did not get have a time value - {}".format(type_error), line)
        return '', None, None
    # fi
    if f2 is None:
        print_error("time value is not a number.", line)
        return '', None, None
    # fi
    if f2 <= 0:                     # If out of range.
        print_error("time value must be greater than 0. Not ({})".format(f2), line)
        return '', None, None
    # fi
    # . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
    return therest, f1, f2
# End of get_cresc

# ----------------------------------------------------------------------------
# Returns:
#   prenote - things to put in front of a note.
#   postnote - things to put after the note
def do_vol_cresc(temp1, onvoice, line, prenote, postnote, onenotevolume):
    global running_vl
    global args
    global measure_on
    global vlprint

    while True:
        if temp1[0:4] == 'vol(' or temp1[0:5] == ' vol(':
            therest, onenotevolume, f2, s1 = get_vol_note(temp1, onvoice, line)
            # onenotevolume for midi1csv format.
            if onenotevolume is None:
                return temp1, None, prenote, postnote
            # fi
            if f2 != -1:
                running_vl[onvoice][measure_on] = f2
            # fi
            if args.vertical or args.horizontal or args.midi1csv or args.fluidsynth:
                prenote = prenote + 'vol(' + str(s1) + ') '
                # onenotevole already set for below.
            else:           # ABC
                # Cannot do sfp and such. Boo His.
                j = vol_to_vlprint_round(onenotevolume)
                prenote = prenote + DECORATIONS + vlprint[j] + DECORATIONS
                if f2 == -1:
                    j = vol_to_vlprint_round(running_vl[onvoice][measure_on])
                    postnote = postnote + DECORATIONS + vlprint[j] + DECORATIONS
                elif f2 != onenotevolume:
                    j = vol_to_vlprint_round(f2)
                    postnote = postnote + DECORATIONS + vlprint[j] + DECORATIONS
                # fi
            # fi
            temp1 = therest
            continue
        # fi
        if (temp1[0:5] == 'cres(' or temp1[0:4] == 'cre(' or temp1[0:3] == 'cr(' or
            temp1[0:6] == ' cres(' or temp1[0:5] == ' cre(' or temp1[0:4] == ' cr(' or
            temp1[0:5] == 'dimi(' or temp1[0:4] == 'dim(' or temp1[0:3] == 'di(' or
            temp1[0:6] == ' dimi(' or temp1[0:5] == ' dim(' or temp1[0:4] == ' di('):
            print_error("cresc() and dimin() are incorrectly written.", line)
            return temp1, None, prenote, postnote
        # fi

        if (temp1[0:6] == 'cresc(' or temp1[0:6] == 'dimin(' or
            temp1[0:7] == ' cresc(' or temp1[0:7] == ' dimin('):
            # cresc(ff,5.25)    # volume to go to, 5.25 = time in floating.
            therest, newvolume, newtime = get_cresc(temp1, line)
            if newvolume is None:
                return temp1, None, prenote, postnote
            # fi
            cresc_volume[onvoice] = newvolume
            if args.vertical or args.horizontal:
                prenote = prenote + 'cresc(' + str(newvolume) + ',' + str(newtime) + ') '
                cresc_time[onvoice] = newtime + 0.0
            elif args.midi1csv or args.fluidsynth:
                cresc_time[onvoice] = int(round(newtime * MIDICLICKSPERQUARTER * 4))
            else:           # ABC
                if newvolume > running_vl[onvoice][measure_on]:
                    cresc_direction[onvoice] = True
                    prenote = prenote + DECORATIONS + 'crescendo(' + DECORATIONS
                else:
                    cresc_direction[onvoice] = False
                    prenote = prenote + DECORATIONS + 'diminuendo(' + DECORATIONS
                # fi
                cresc_time[onvoice] = newtime + 0.0
            # fi
            temp1 = therest
            continue
        # fi
        break
    # elihw
    return temp1, onenotevolume, prenote, postnote
#   End of do_vol_cresc

# ----------------------------------------------------------------------------
# Parse and process possible notes line.
# All have ,'s as separators.
# old way is: voice1,voice2,voice3,voice4   -- 3c4, 3e4, 3g4, 4c4
# new way: v#:3c4,d,e,f,g,a,b,4c
# Both have measure terminate them.

# - unit notego
def process_notes(line):
    global voices                       # number of voices
    global cis                          # if cis active, non-zero.
    global time                         # set default note length (time) dictionary
    global measure_on                   # The measure we are on.
    global legal_notes
    global mlth                         # measure length dictionary
    global args
    global bufs_accidentals
    global bufs_tie_next
    global bufs_legato_next
    global bufs
    global DECORATIONS
    global macro_buffer                 # Name of macro, array of lines for macro.
    global macro_internal               # Next internal macro.
    global cresc_direction
    global cresc_time
    global cresc_volume
    global macro_arguments              # Name of macro, array of arguments for macro.
    global macro_executing_args
    global macro_executing_depth
    global macro_line
    global meas
    global running_vl
    global vlprint


    if not measure_on or measure_on == '':  # no measure yet
        print_error("no measure processed yet - must have one before notes.", line)
        return
    # fi
    wline = re.sub(r'\s+', ' ', line)           # multiple spaces to single space, multiple times.
    wline = re.sub(r'([^,]) ', r'\1', wline)    # ', ' left alone, elsewise strip spaces.
    wline = re.sub(r'^  *v', 'v', wline)          # 'no ' left alone, elsewise strip spaces.
    wargs = arglist(wline, line, False)

    if not wargs or len(wargs) < 1:
        print_error("no arguments on note line", line)
        return
    # fi
# ...........................................................................
    # Check if 'v#' or 'v(#)'
    vnumber = None
    if wargs[0]:
        if (wargs[0])[0] == 'v' and (wargs[0])[1] != 'o':
            s1 = (wargs[0])[1:]
            sc = s1.find(':')
            if sc < 0:
                print_error("A 'v' needs a number followed by a colon -- colon is missing", line)
                return
            # fi
            if sc == 0:
                print_error("A 'v' needs a number followed by a colon -- number is missing", line)
                return
            # fi
            s1 = s1[0:sc]

            f1, type_error = is_float(s1)
            if type_error is not None:
                return
            # fi
            if f1 is None:
                print_error("voice number is not a number.", line)
                return
            # fi
            f1 = int(round(f1))
            if f1 < 1  or f1 > MAXVOICES:       # If out of range.
                print_error("voice number must be between 1 and {} inclusive. Not ({})".format(MAXVOICES, f1), line)
                return
            # fi
            do_set_voices(f1, line)
            cis = f1
            wargs[0] = (wargs[0])[sc+2:]
            if wargs[0] == '' and len(wargs) > 1:
                print_error("Cannot have a blank argument after v{}".format(cis), line)
                return
            # fi
            vnumber = 0
        # fi
    # fi
# ...........................................................................
    if cis == 0:                        # if not doing only one voice continuously for a while...
        if len(wargs) > voices:
            print_error("too many arguments ({}), greater than voices (>{})".format(len(wargs), voices), line)
            return
        # fi
        measlth = 0
        for i in range(0, len(wargs)):
            if not(wargs[i] == '' or wargs[i] == ' '):
                measlth = max(measlth, mlth[i+1][measure_on])
            # fi
        # rof
        for i in range(0, len(wargs)):
            if not(wargs[i] == '' or wargs[i] == ' '):
                l = measlth - mlth[i+1][measure_on]
                if l > 0:
                    nl = (MIDICLICKSPERQUARTER * 4) / l
                    print_warning("process_notes - missing rests l={} ({}) voice={} measure={}".format(l, nl, i+1, measure_on), line)
                    if args.horizontal or args.vertical:
                        instak(i+1, measure_on, '', 'r', l, '', line, None, '')
                    elif args.midi1csv or args.fluidsynth:
                        instak(i+1, measure_on, '', 0, l / (MIDICLICKSPERQUARTER * 4) , '', line, None, '')
                    else:           # ABC
                        instak(i+1, measure_on, '', 'z', l, '', line, None, '')
                    # fi
                # fi
            # fi
        # rof
    # fi
# ...........................................................................
    # Decode and stack the notes.
    loopstart = 1 if cis == 0 else cis
    for onvoice in range(loopstart, voices + 1):
        while True:
            
            if cis == 0 and len(wargs) < onvoice:
                print_error("Not enough arguments on note line - want {}, have {}".format(onvoice, wargs), line)
                return
            # fi
            if vnumber is None:
                temp1 = wargs[onvoice - loopstart]          # loopstart fixes "cis" being used.
                rest_wargs_on_line = wargs[onvoice - loopstart +1:]
            else:
                if vnumber >= len(wargs):
                    break
                # fi
                temp1 = wargs[vnumber]
                rest_wargs_on_line = wargs[vnumber +1:]
            # fi
            prenote = ''
            postnote = ''
            onenotevolume = None
            while True:
                for c in macro_buffer:
                    t = temp1[0:len(c) + 1]
                    if c != '' and c + '(' == t:
                        therest = temp1[len(c)+1:]
                        f = therest.find(')')
                        if f < 0:
                            print_error("macro {} does not have a closing parenthesis".format(c), line)
                            return
                        # fi
                        margs = [ therest[0:f] ]
                        temp1 = therest[f+1:]
                        # 1) Create and put in a temporary macro with no arguments for temp1
                        #    (rest of line), if anything in temp1 (not None, nor '').
                        # 2) Put in this macro with arguments.
                        if temp1 is not None and temp1 != '':
                            m_name = 'Internal_Macro_{}'.format(macro_internal)
                            if rest_wargs_on_line == []:
                                macro_buffer[m_name] = [ temp1 ]        # lines in bujffer.
                            else:
                                macro_buffer[m_name] = [ temp1 + "," + ",".join(rest_wargs_on_line) ]
                            # fi
                            # macro_defining = m_name               # No need, we did it.
                            macro_arguments[m_name] = []
                            macro_internal = macro_internal + 1     # Next internal macro.
                            macro_executing_depth.append(m_name)    # Add in the name.
                            macrodepth = len(macro_executing_depth) # one more to do.
                            macro_executing_args[macrodepth] = []   # No arguments
                            macro_line[macrodepth] = 0              # First line in buffer.
                        # fi
                        replace_macro(c, margs, line)
                        return                                      # Go out and read line for macro.
                    # fi
                # rof

                temp1, onenotevolume, prenote, postnote = do_vol_cresc(temp1, onvoice, line, prenote, postnote, onenotevolume)
                break
            # elihw
            therest, thenote, typenote = getnote(temp1, onvoice, line) # get next note

            if thenote is None:
                print_error("no note? therest='{}' thenote='{}' typenote='{}'".format(therest, thenote, typenote), line)
                break
            # fi

            if type(thenote) == str and thenote == '':
                break
            # fi
            if type(thenote) is int and typenote != sequence_note:
                #-- if thenote == 0:                        # return nothing, ignore.
                #--     break
                #-- # fi
                if args.vertical or args.horizontal:
                    thenote = "({})".format(thenote)        # Put back as a number.
                elif args.midi1csv or args.fluidsynth:
                    if thenote <= 0:
                        thenote = 0
                    else:
                        if thenote >= 128:
                            thenote = 127
                        # fi
                    # fi
                else:           # ABC
                    thenote = to_abc_note(thenote)          # Convert number to abc text.
                # fi
            # fi
            if typenote == trill_note:
                therest, thenote, typenote = getnote(therest, onvoice, line)
                leading_space = False
                if thenote and type(thenote) is str and len(thenote) > 0 and thenote[0] == ' ':
                    thenote = thenote[1:]
                    leading_space = True
                # fi
                if thenote is None or thenote == 0 or thenote == '':
                    print_error("trill is not legal, no first note", line)
                    return
                # fi

                if typenote == gsw_operand:                                 # 2**16 gsw opnd
                    quotes = thenote - (1 << 16)
                else:
                    quotes = thenote
                # fi
                staccato = ''
                legato = ''
                if therest is not None and therest != '':   # Check for staccato/legato after note.
                    if therest[0] == 's':
                        staccato = 's'
                        therest = therest[1:]
                    # fi
                    if therest[0] == 'l':
                        legato = 'l'
                        therest = therest[1:]
                    # fi
                # fi
                if therest is None or therest == '' or therest[0] != ',':
                    print_error("trill is not legal, no comma after first note", line)
                    return
                # fi
                therest = therest[1:]                                       # comma removed
                therest, thenote, typenote = getnote(therest, onvoice, line) # get second note
                if thenote is None or thenote == 0 or thenote == '':
                    print_error("trill is not legal, second note missing", line)
                    return
                # fi
                if typenote == gsw_operand:                                 # 2**16 gsw opnd
                    # quotes1 = thenote - (1 << 16)
                    print_error("trill is not legal, first note not correct", line)
                    return
                elif typenote == freqency_note or typenote == trill_note or typenote == sequence_note:
                    print_error("trill is not legal, first note not correct", line)
                    return
                # fi
                quotes1 = thenote
                if therest is None or therest == '':
                    print_error("trill is not legal, missing number of notes", line)
                    return
                # fi
                staccato1 = ''
                legato1 = ''
                if therest is not None and therest != '':   # Check for staccato/legato after note.
                    if therest[0] == 's':
                        staccato1 = 's'
                        therest = therest[1:]
                    # fi
                    if therest[0] == 'l':
                        legato1 = 'l'
                        therest = therest[1:]
                    # fi
                # fi
                if therest is None or therest == '' or therest[0] != ',':
                    print_error("trill is not legal, no comma after second note", line)
                # fi
                therest = therest[1:]                                       # comma removed
                np = temp1 = 0
                f = therest.find(')')
                if f < 0:
                    print_error("trill is not legal, missing closing parenthesis", line)
                    return
                # fi
                num = therest[0:f]
                if len(therest) <= f:
                    print_error("trill is not legal, missing length after parenthesis", line)
                    return
                # fi
                therest = therest[f+1:]
                np, type_error = is_float(num)
                if np is None or np == 0 or type_error is not None:
                    print_error("trill is not legal, number of notes to play", line)
                    return
                # fi
                timeofnote, r_accidentals, number_dots = get_time(therest, line)
                if r_accidentals is None or number_dots is None or (
                   r_accidentals != accidental_normal and r_accidentals != accidental_legato):
                    print_error("trill is not legal - r_accidentals={}".format(r_accidentals), line)
                    return
                # fi
                if timeofnote == 0:
                    timeofnote = time[onvoice]
                # fi
                if number_dots != 0:
                    p = timeofnote / 2.0
                    for i in range(1, number_dots+1):
                        timeofnote = timeofnote + p
                        p = p / 2.0
                    # rof
                # fi
                time[onvoice] = timeofnote

    #   t(3a,3g,7)4 =>  '(7:4:2 3a3g'

                # vwork = float(timeofnote) / float(np)

                # t(quotes, quotes1, np)lengthl
                if args.horizontal or args.vertical or args.midi1csv or args.fluidsynth:
                    lengthf = [ timeofnote ]
                else:           # ABC
                    lengthl, lengthf, ifokay = get_time_stak(timeofnote, line, onvoice)
                    if ifokay != 0 or len(lengthl) != 1:         # if time is error
                        print_warning("trill time must be a printable note length, not '{}'".format(lengthl), line)
                        t = 0
                        for l in range(0, len(lengthl)):
                            t = t + lengthf[l]
                        # fi
                        lengthf = [ t ]
                        print_warning("trill time remade '{}'".format(lengthf), line)
                    # fi
                    l = str(Fraction(lengthf[0]).limit_denominator(256))
                    where = l.find('/')
                    lth = '1'
                    if where > 0:                               # / in fraction
                        numerator = l[0:where]
                        if numerator != '1':
                            lth = numerator
                            l = '1' + l[where:]
                        # fi
                    # fi
                    if l not in legal_notes:
                        print_warning("#2 Time fraction '{}' is not a printable note. ({})".format(lengthf[0], l), line)
                    # fi
                    if l == '1':
                        l = '1/1'
                    # fi
                # fi
# NOTDONEYET - check --vertical and not --wrongties. (But that is not the use for this argument.)
                append_tie = bufs_tie_next[onvoice]
                bufs_tie_next[onvoice] == ''
                if args.horizontal or args.vertical:
                    np = int(round(np))
                    abc_note = "t({}{}{},{}{}{},{})".format(quotes, staccato, legato, quotes1, staccato1, legato1, np)
                    if leading_space:
                        abc_note = ' ' + abc_note
                    # fi
                    if (r_accidentals & accidental_legato) != 0:
                        append_tie = append_tie + 'l'
                    # fi

                    put_on_bufs(onvoice, measure_on, prenote, abc_note, lengthf[0], append_tie, onenotevolume, '', line)
                    if vnumber is None:
                        break                                       # normal old way.
                    # fi
                    vnumber = vnumber + 1
                    continue
                elif args.midi1csv or args.fluidsynth:
                    # lthtrill = int(round((lengthf[0] / int(np)) * MIDICLICKSPERQUARTER * 4.0))
                    # Need to have left-over fractions work.
                    numerator = lengthf[0] * MIDICLICKSPERQUARTER * 4.0
                    lth_so_far = 0
                    np_to_do = int(np)
                    last_legato = False
                    if (r_accidentals & accidental_legato) != 0:
                        last_legato = True
                    # fi
                    for i in range(0, int(np)):
                        put_on_lth = int(round(numerator/np_to_do))
                        np_to_do = np_to_do - 1
                        numerator = numerator - put_on_lth
                        if (i % 2) == 0:
                            abc_note = quotes
                            if np_to_do != 0:
                                sn = append_tie + staccato + legato
                            elif last_legato:
                                sn = append_tie + staccato + 'l'
                            else:
                                sn = append_tie + staccato
                            # fi
                        else:
                            abc_note = quotes1
                            if np_to_do != 0:
                                sn = append_tie + staccato1 + legato1
                            elif last_legato:
                                sn = append_tie + staccato1 + 'l'
                            else:
                                sn = append_tie + staccato1
                            # fi
                        # fi

                        put_on_bufs(onvoice, measure_on, prenote, abc_note, put_on_lth, sn, onenotevolume, '', line)
                        append_tie = ''
                    # rof
                    if vnumber is None:
                        break                                       # normal old way.
                    # fi
                    vnumber = vnumber + 1
                    continue
                else:           # ABC
                    abc_note = "[L:{}]".format(l)
                    abc_note = abc_note + '(' + str(int(np)) + ':' + lth + ':' + str(int(np))
                    if leading_space:
                        abc_note = ' ' + abc_note
                    # fi
                    last_legato = False
                    if (r_accidentals & accidental_legato) != 0:
                        last_legato = True
                    # fi
                    for i in range(0, int(np)):
                        if (i % 2) == 0:
                            if i != (int(np) - 1):
                                leg = legato
                            elif last_legato:
                                leg = 'l'
                            else:
                                leg = ''
                            # fi
                            sta = staccato
                            quo = quotes
                        else:
                            if i != (int(np) - 1):
                                leg = legato1
                            elif last_legato:
                                leg = 'l'
                            else:
                                leg = ''
                            # fi
                            sta = staccato1
                            quo = quotes1
                        # fi

                        if leg != '':
                            if bufs_legato_next[onvoice] != 'l':
                                abc_note = abc_note + '('             # ( before the note for glide/legato
                            # fi
                            bufs_legato_next[onvoice] = 'l'
                        # fi
                        if sta == 's':
                            abc_note = abc_note + '.' + quo
                        else:
                            abc_note = abc_note + quo
                        # fi
                        if leg == '' and bufs_legato_next[onvoice] == 'l':
                            abc_note = abc_note + ')'
                            bufs_legato_next[onvoice] = ''
                        # fi
                    # rof
                    l_dl = default_note_text_fraction(measure_on)
                    if l_dl == '1':
                        l_dl = '1/1'
                    # fi
                    abc_note = abc_note + "[L:{}]".format(l_dl)

                    put_on_bufs(onvoice, measure_on, prenote, abc_note, lengthf[0], '', onenotevolume, postnote, line)
                    if vnumber is None:
                        break                                       # normal old way.
                    # fi
                    vnumber = vnumber + 1
                    continue
                # fi
            elif typenote == sequence_note:
                leading_space = False
                if therest and len(therest) > 0 and therest[0] == ' ':
                    therest = therest[1:]
                    leading_space = True
                # fi
                number_in_sequence = thenote
                if therest[0] != '(':
                    print_error("sequence is not legal, no parenthesis after number {}".format(number_in_sequence), line)
                    return
                # fi
                therest = therest[1:]                                       # parenthesis removed
                notes = []
                vols_prenote = []               # for abc, vertical, horizontal.
                vols_postnote = []              # for abc.
                vols_onenote = []               # For midi1csv, volume for this note.
                stacs = []
                glides = []
                for sn in range(0, number_in_sequence):
                    s_postnote = ''
                    s_prenote = ''
                    if therest[0:4] == 'vol(' or therest[0:5] == ' vol(':
                        therest, onenotevolume, f2, s1 = get_vol_note(therest, onvoice, line)
                        # onenotevolume for midi1csv format.
                        if onenotevolume is None:
                            return
                        # fi
                        if f2 != -1:
                            running_vl[onvoice][measure_on] = f2
                        # fi
                        if args.vertical or args.horizontal or args.midi1csv or args.fluidsynth:
                            s_prenote = s_prenote + 'vol(' + str(s1) + ') '
                            # onenotevole already set for below.
                        else:           # ABC
                            # Cannot do sfp and such. Boo His.
                            j = vol_to_vlprint_round(onenotevolume)
                            s_prenote = s_prenote + DECORATIONS + vlprint[j] + DECORATIONS
                            if f2 == -1:
                                j = vol_to_vlprint_round(running_vl[onvoice][measure_on])
                                s_postnote = s_postnote + DECORATIONS + vlprint[j] + DECORATIONS
                            elif f2 != onenotevolume:
                                j = vol_to_vlprint_round(f2)
                                s_postnote = s_postnote + DECORATIONS + vlprint[j] + DECORATIONS
                            # fi
                        # fi
                    # fi

                    therest, thenote, typenote = getnote(therest, onvoice, line)
                    if thenote is None or thenote == '':
                        print_error("sequence is not legal, no note", line)
                        return
                    # fi
                    if typenote == gsw_operand:                                 # 2**16 gsw opnd
                        quotes = thenote - (1 << 16)
                    else:
                        quotes = thenote
                    # fi
                    staccato = ''
                    legato = ''
                    if therest is not None and therest != '':   # Check for staccato after note.
                        if therest[0] == 's':
                            staccato = 's'
                            therest = therest[1:]
                        # fi
                        if therest[0] == 'l':
                            legato = 'l'
                            therest = therest[1:]
                        # fi
                    # fi
                    if sn != number_in_sequence - 1:
                        if therest is None or therest == '' or therest[0] != ',':
                            print_error("sequence is not legal, no comma after note", line)
                            return
                        # fi
                    elif therest[0] != ')':
                        print_error("sequence is not legal, no right parenthesis after last note", line)
                        return
                    # fi
                    therest = therest[1:]                                       # parenthesis removed
                    notes.append(quotes)
                    vols_prenote.append(s_prenote)
                    vols_postnote.append(s_postnote)
                    vols_onenote.append(onenotevolume)
                    onenotevolume = None                # We used the last one.
                    stacs.append(staccato)
                    glides.append(legato)
                # rof
                timeofnote, r_accidentals, number_dots = get_time(therest, line)
                if r_accidentals is None or r_accidentals != accidental_normal or number_dots is None:
                    print_error("sequence is not legal, r_accidentals={} number_dots={}".format(r_accidentals, number_dots), line)
                    return
                # fi
                if timeofnote == 0:
                    timeofnote = time[onvoice]
                # fi
                if number_dots != 0:
                    p = timeofnote / 2.0
                    for i in range(1, number_dots+1):
                        timeofnote = timeofnote + p
                        p = p / 2.0
                    # rof
                # fi
                time[onvoice] = timeofnote

                if args.horizontal or args.vertical:
                    lengthf = [ timeofnote ]
                    n_s = ''
                    for i in range(0, len(notes)):
                        if i == 0:
                            n_s = vols_prenote[i] + notes[i] + stacs[i] + glides[i] + vols_postnote[i]
                        else:
                            n_s = n_s + ',' + vols_prenote[i] + notes[i] + stacs[i] + glides[i] + vols_postnote[i]
                        # fi
                    # rof
                    abc_note = "s{}({})".format(number_in_sequence, n_s)
                    if leading_space:
                        abc_note = ' ' + abc_note
                    # fi

                    put_on_bufs(onvoice, measure_on, prenote, abc_note, lengthf[0], '', onenotevolume, '', line)
                    if vnumber is None:
                        break                                       # normal old way.
                    # fi
                    vnumber = vnumber + 1
                elif args.midi1csv or args.fluidsynth:
                    lengthf = [ timeofnote ]
                    # lthseq = int(round((lengthf[0] / number_in_sequence) * MIDICLICKSPERQUARTER * 4.0))
                    numerator = lengthf[0] * MIDICLICKSPERQUARTER * 4.0
                    lth_so_far = 0
                    seq_num_so_far = number_in_sequence
                    for i in range(0, len(notes)):
                        if i == 0 and vols_prenote[i] == '':
                            prn = prenote
                        else:
                            prn = vols_prenote[i]
                        # fi
                        put_on_lth = int(round(numerator/seq_num_so_far))
                        seq_num_so_far = seq_num_so_far - 1
                        numerator = numerator - put_on_lth

# NOTDONEYET - check --vertical and not --wrongties. (But that is not the use of this argument.)
                        extra_t = 't' if bufs_tie_next[onvoice] == 't' else ''
                        bufs_tie_next[onvoice] = ''
                        # Tie from previous needs to go on first one, else blank it out.

                        put_on_bufs(onvoice, measure_on, prn, notes[i], put_on_lth, stacs[i] + glides[i] + extra_t, vols_onenote[i], '', line)
                    # rof
                    if vnumber is None:
                        break                                       # normal old way.
                    # fi
                    vnumber = vnumber + 1
                else:           # ABC
                    if number_in_sequence == 2 or number_in_sequence == 3:
                        dnl = timeofnote / 2
                        l_time = int(round(timeofnote / dnl - 0.5))
                    elif number_in_sequence == 4 or number_in_sequence == 6:
                        dnl = timeofnote / 4
                        l_time = int(round(timeofnote / dnl - 0.5))
                    elif number_in_sequence == 8:
                        dnl = timeofnote / 8
                        l_time = int(round(timeofnote / dnl - 0.5))
                    else:
                        print_error("number in sequence ({}) not 2,3,4,6,8.".format(number_in_sequence), line)
                        return
                    # fi
                    dnl_str = str(Fraction(dnl).limit_denominator(256))

                    lengthl, lengthf, ifokay = get_time_stak(timeofnote, line, onvoice)
                    if ifokay != 0 or len(lengthl) != 1:         # if time is error
                        print_warning("sequence time must be a printable note length, not '{}'".format(lengthl), line)
                        t = 0
                        for l in range(0, len(lengthl)):
                            t = t + lengthf[l]
                        # fi
                        lengthf = [ t ]
                        print_warning("sequence time remade '{}'".format(lengthf), line)
                    # fi

                    if dnl_str == '1':
                        dnl_str = '1/1'
                    # fi
                    abc_note = ''
                    if leading_space:
                        abc_note = ' ' + abc_note
                    # fi
                    abc_note = abc_note + "[L:{}]".format(dnl_str)
                    abc_note = abc_note + '(' + str(number_in_sequence) + ':' + str(l_time) + ':' + str(number_in_sequence) + ' '
                    for l in range(0, len(notes)):
                        if l == 0 and vols_prenote[l] == '':
                            prn = prenote
                            psn = postnote
                        else:
                            prn = vols_prenote[l]
                            psn = vols_postnote[l]
                        # fi
                        abc_note = abc_note + prn
                        if glides[l] != '':
                            if bufs_legato_next[onvoice] != 'l':
                                abc_note = abc_note + '('             # ( before the note for glide/legato
                            # fi
                            bufs_legato_next[onvoice] = 'l'
                        # fi
                        if stacs[l] == 's':
                            abc_note = abc_note + '.'
                        # fi
                        abc_note = abc_note + notes[l] + psn
                        if glides[l] == '' and bufs_legato_next[onvoice] == 'l':
                            abc_note = abc_note + ')'
                            bufs_legato_next[onvoice] = ''
                        # fi
                    # rof
                    l_dl = default_note_text_fraction(measure_on)
                    if l_dl == '1':
                        l_dl = '1/1'
                    # fi
                    abc_note = abc_note + "[L:{}]".format(l_dl)

                    put_on_bufs(onvoice, measure_on, '', abc_note, lengthf[0], '', onenotevolume, '', line)
                    if vnumber is None:
                        break                                       # normal old way.
                    # fi
                    vnumber = vnumber + 1
                # fi
                continue
            # end of sequence processing above.

            timeofnote, r_accidentals, number_dots = get_time(therest, line)

            if r_accidentals is None or number_dots is None:
                print_error("Error getting time for note - ({} -> timeofnote={} r_accidentals={} number_dots={}".format(therest,timeofnote,r_accidentals,number_dots), line)
                return
            # fi
            # accidental_legato = 16        -- glide to next note.
            # accidental_tied = 2           -- tied
            # accidental_stac = 1           -- staccato
            # accidental_dotted = -1
            # accidental_normal = 0
            # bits are $union$'ed together for multiple modifiers.
            # number_dots are how many "d" (dotted) were found.
            if timeofnote is None or timeofnote == 0:
                if number_dots != 0:
                    print_error("cannot have dotted syntax on a default note length.", line)
                    return
                # fi
                timeofnote = time[onvoice]
            # fi
            if number_dots != 0:
                p = timeofnote / 2.0
                for i in range(1, number_dots+1):
                    timeofnote = timeofnote + p
                    p = p / 2.0
                # rof
            # fi
            time[onvoice] = timeofnote

            if typenote == gsw_operand:
                print_error("NOTDONEYET - doing gsw_operand type of note", line)
                return
            # fi

            append_tie = bufs_tie_next[onvoice]
            bufs_tie_next[onvoice] = ''
            # Tied note
            if (r_accidentals & accidental_tied) != 0:
                if vnumber is not None:         # vertical input format
                    if args.horizontal:                     # horizontal output
                        if not args.wrongties:
                            # put tie on following note.
                            bufs_tie_next[onvoice] = 't'
                        else:
                            append_tie = 't'
                        # fi
                    elif args.midi1csv or args.fluidsynth:                     # midi1csv output
                        if not args.wrongties:
                            bufs_tie_next[onvoice] = 't'
                        else:
                            append_tie = 't'
                        # fi
                    elif args.vertical:                     # vertical output
                        if not args.wrongties:
                            append_tie = 't'
                        else:
                            do_tie_on_previous_note(onvoice, line, 't')
                        # fi
                    else:           # ABC
                        if not args.wrongties:
                            append_tie = do_tie_abc(onvoice, vnumber, line)
                        else:
                            do_tie_on_previous_note(onvoice, line, '-')
                        # fi
                    # fi
                else:                           # horizontal input format
                    if args.vertical:                       # vertical output
                        # put tie on previous note.
                        if measure_on not in bufs[onvoice] or bufs[onvoice][measure_on] == '':
                            # Do measure before.
                            w = len(meas) - 1               # current measure number in array.
                            if w == 0:
                                print_error("no previous measure to tie note to.", line)
                                return ''
                            else:
                                m = meas[w-1]
                            # fi
                        else:
                            m = measure_on
                        # fi
                        i = len(bufs_accidentals[onvoice][m]) - 1
                        bufs_accidentals[onvoice][m][i] = bufs_accidentals[onvoice][m][i] + 't'
                        append_tie = ''                     # Nothing on this note, on previous.
                    elif args.horizontal or args.midi1csv or args.fluidsynth:  # horizontal output
                        append_tie = 't'
                    else:           # ABC
                        append_tie = do_tie_abc(onvoice, vnumber, line)
                    # fi
                # fi
            # fi

            # Staccato
            if (r_accidentals & accidental_stac) != 0:
                if args.horizontal or args.vertical or args.midi1csv or args.fluidsynth:
                    append_tie = append_tie + 's'
                else:           # ABC
                    # thenote = '.' + thenote                 # . before the note for staccato
                    if len(thenote) > 0 and thenote[0] == ' ':  # Special leading space!
                        thenote = ' .' + thenote[1:]        # . before the note for staccato
                    else:
                        thenote = '.' + thenote             # . before the note for staccato
                # fi
            # fi

            # Legato
            if (r_accidentals & accidental_legato) != 0:
                if args.horizontal or args.vertical or args.midi1csv or args.fluidsynth:
                    append_tie = append_tie + 'l'
                else:           # ABC
                    if bufs_legato_next[onvoice] != 'l':
                        thenote = '(' + thenote             # ( before the note for glide/legato
                    # fi
                # fi
                bufs_legato_next[onvoice] = 'l'
            else:
                if bufs_legato_next[onvoice] == 'l':
                    if args.horizontal or args.vertical or args.midi1csv or args.fluidsynth:
                        pass
                    else:           # ABC
                        append_tie = ')' + append_tie
                    # fi
                # fi
                bufs_legato_next[onvoice] = ''
            # fi

            instak(onvoice, measure_on, prenote, thenote, timeofnote, append_tie, line, onenotevolume, postnote)

            if vnumber is None:
                break                                       # normal old way.
            else:
                vnumber = vnumber + 1
            # fi
        # elihw
    # rof
    return
# End of process_notes

# ============================================================================
def read_csv_file(l):
    global array_of_lines

    array_of_lines.append(l)
    return
# End of read_csv_file

# ============================================================================
# Parse and process line.
def process_line(t, line):
    global iftest                       # check if after if or else.
    global ifdepth                      # level of if/else/endif
    global commands
    global cstop_processing
    global macro_defining               # If defining macro.
    global macro_buffer                 # Name of macro, array of lines for macro.
    global measure_on

    if not t or len(t) == 0 or not t[0] or t[0].lstrip() == '':
        return
    elif len(t) == 1 or (len(t) == 2 and t[1] == ''):
        command = t[0].lstrip()
        t_args = None
    else:
        command = t[0].lstrip()
        t_args = t[1:]
        if t_args and len(t_args) >= 0:
            t_args[0] = t_args[0].lstrip()
        # fi
    # fi

    if cstop_processing:
        # Read until cstart found (or end of file)
        if command in commands:
            if commands[command] == do_page:        # Do to save the pages (for --pages).
                do_page(t_args, line)
            # fi
            if commands[command] == do_measure:     # Do because of goto's and --measures.
                do_measure(t_args, line)
            # fi
            if commands[command] == do_cstart:
                do_cstart(t_args, line)
            # fi
            if commands[command] == do_cstopnow:
                do_cstopnow(t_args, line)
            # fi
        # fi
        return                          # Done with current cstop processing.
    # fi

    if macro_defining is not None:
        if command in commands:
            if commands[command] == do_endm:
                do_endm(t_args, line)
                return
            # fi
            if commands[command] == do_cstopnow:
                do_cstopnow(t_args, line)
                return
            # fi
        # fi
        macro_define(command, t_args, line)
        return
    # fi

    # Doing if section or else section.
    if iftest[ifdepth] == -1 or iftest[ifdepth] == 1:
        # Try to process command.
        if command is None:             # Ignore nothing given.
            return
        # fi
        if command in macro_buffer.keys():
            replace_macro(command, t_args, line)
            return                      # Henceforth get lines from macro_buffer.
        # fi
        if command[0] == '%':
            command = '%%'
        # fi
        if command in commands:
            try:
                r = commands[command]
            except:
                print_error("not found processing routine for command {}", command)
                print("    ", sys.exc_info()[0], sys.exc_info, file=sys.stderr, flush=True)
            # fi
            r(t_args, line)
            return
        # fi
        if measure_on in goto_table:
            print_error("Notes after a goto are not allowed. measure='{}'".format(measure_on), line)
            return
        # fi
        process_notes(line)
    else:                               # Here if false for "if" -- special else, or in else, or both.
        if t[0] in commands:
            if commands[t[0]] == do_cstopnow:
                do_cstopnow(t_args, line)
            elif commands[t[0]] == do_if:
                do_if(t_args, line)
            elif commands[t[0]] == do_else:
                do_else(t_args, line)
            elif commands[t[0]] == do_endif:
                do_endif(t_args, line)
            # fi
        # fi
        return
    # fi
    return
# End of process_line

# ----------------------------------------------------------------------------
def parse_args():
    global args
    global pages_to_do
    global measures_to_do
    global voices_to_do

    def offset_value(v):
        if len(v) > 0:
            if v[0] == '=':
                v = v[1:]
            # fi
        # fi
        return v
    # End of offset_value

    for indx in range(len(sys.argv) - 1):
        if '--offset' in sys.argv[indx]:
            sys.argv[indx + 1] = '={0}'.format(sys.argv[indx + 1])
        # fi
    # rof
    parser = argparse.ArgumentParser(
        description=__doc__,
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog='this is the epilog')
    parser.add_argument('--vertical', '--vertica', '--vertic', '--verti', '--vert',
                        '--ver', '--ve', '--v', '-v',
                        action='store_true',
                        help = 'Vertical musicomp format output.')
    parser.add_argument('--horizontal', '--horizonta', '--horizont', '--horizon',
                        '--horizo', '--horiz', '--hori', '--hor', '--ho', '--h',
                        action='store_true',
                        help = 'Horizontal musicomp format output.')
    parser.add_argument('--midi1csv', '--midi1cs', '--midi1c', '--midi1', '--midi',
                        '--mid', '--mi', '--m', '--csv', '--cs', '--c', '-c', '-m', '-1',
                        action='store_true',
                        help = 'Output MIDI 1.0 music format output.')
    parser.add_argument('--abc', '-abc',
                        action='store_const', const=1, default=0,
                        help = 'ABC music format output - default.')
    parser.add_argument('--fluidsynth', '--fluidsynt', '--fluidsyn', '--fluidsy', '--fluids',
                        '--fluid', '--flui', '--flu', '--fl', '--f', '--fs',
                        '-fluidsynth', '-fluidsynt', '-fluidsyn', '-fluidsy', '-fluids',
                        '-fluid', '-flui', '-flu', '-fl', '-f', '-fs',
                        action='store_true',
                        help = 'Output fluidsynth music format output.')
    parser.add_argument('--nogoto', '--nogot', '--nogo', '--nog',
                        '-nogoto', '-nogot', '-nogo', '-nog',
                        action='store_true',
                        help = 'Do not parse goto commands, ignore them.')
    parser.add_argument('--noxpose', '--noxpos', '--noxpo', '--noxp', '--nox',
                        '-noxpose', '-noxpos', '-noxpo', '-noxp', '-nox',
                        action='store_true',
                        help = 'Do not parse xpose commands, ignore them.')
    parser.add_argument('--offset', default=0, action = 'store', type=offset_value,
                        help = 'Offset for midi instruments +1, -1, -12 -- because they CAN differ for playing.')
    parser.add_argument('--shift', type=float, default=0.0,
                        help = 'Shift all measures before printing (0.5 = 1/2 note to left/earlier measure).')
    parser.add_argument('--pages', '--page', '-pages', '-page',
                        default='', action = 'store',
                        help = 'Only parse page(s) specified. "1,2,5" or "1,2,5-8,114".')
    parser.add_argument('--measures', '--measure', '--measur', '--measu', '--meas', '--mea', '--me',
                        '-measures', '-measure', '-measur', '-measu', '-meas', '-mea', '-me',
                        default='', action = 'store',
                        help = 'Only parse measure(s) specified. "1,2,5" or "1,2,5-8,114a,115".')
    parser.add_argument('--voices', '--voice', '--voic', '--voi', '--vo',
                        '-voices', '-voice', '-voic', '-voi', '-vo',
                        default='', action = 'store',
                        help = 'Only print voice(s) specified. (parsing done) "1,2,5" or "1,2,5-8,15".')
    parser.add_argument('--wrongties', '--wrongtie', '--wrongti', '--wrongt', '--wrong', '--wron', '--wro', '--wr',
                        '-wrongties', '-wrongtie', '-wrongti', '-wrongt', '-wrong', '-wron', '-wro', '-wr',
                        default='', action = 'store_true',
                        help = 'When reading, ties for --vertical are on the latter note, move to front.')
    parser.add_argument('--nolegato', '--no-legato', action='store_true',
                        help = 'Do not do legatos.')
    parser.add_argument('rest', nargs='*',
                        help='Optional command to execute')
    args = parser.parse_args()

    if args.offset is not None:
        args.offset = int(args.offset)
    # fi

    if args.pages is not None and args.pages != '':
        # global pages_to_do
        n = re.sub(r'\s*,\s*', ',', args.pages)
        n = re.sub(r'\s*,\s*', ',', n)
        pages_to_do = arglist(n, 'parsing --pages', True)
    # fi

    if args.measures is not None and args.measures != '':
        n = re.sub(r'\s*,\s*', ',', args.measures)
        n = re.sub(r'\s*,\s*', ',', n)
        measures_to_do = arglist(n, 'parsing --measures', True)
    # fi

    if args.voices is not None and args.voices != '':
        n = re.sub(r'\s*,\s*', ',', args.voices)
        n = re.sub(r'\s*,\s*', ',', n)
        voices_to_do = arglist(n, 'parsing --voices', True)
    # fi

    if args.rest is not None:
        for indx in range(len(args.rest)):
            if args.rest[indx][0] == '=':
                nextargv = args.rest[indx]
                if len(nextargv) > 0:
                    nextargv = nextargv[1:]
                # fi
                args.rest[indx] = nextargv
            # fi
        # rof
    # fi
    if args.vertical:
        if args.horizontal or args.abc == 1 or args.midi1csv or args.fluidsynth:
            print_error_no_line("Only may have one of --vertical, --horizontal, --abc, --midi1" or --fluidsynth)
            sys.exit(1)
        # fi
    elif args.horizontal:
        if args.abc == 1 or args.midi1csv or args.fluidsynth:
            print_error_no_line("Only may have one of --vertical, --horizontal, --abc, --midi1 or --fluidsynth")
            sys.exit(1)
        # fi
    elif args.midi1csv:
        if args.abc == 1 or args.fluidsynth:
            print_error_no_line("Only may have one of --vertical, --horizontal, --abc, --midi1 or --fluidsynth")
            sys.exit(1)
        # fi
    elif args.fluidsynth:
        if args.abc == 1:
            print_error_no_line("Only may have one of --vertical, --horizontal, --abc, --midi1 or --fluidsynth")
            sys.exit(1)
        # fi
#    else args.abc == 1:
#        print_error_no_line("Only may have one of --vertical, --horizontal, --abc, --midi1 or --fluidsynth")
#        sys.exit(1)
    # fi
    return
# End of parse_args

# ----------------------------------------------------------------------------
# Main program follows.
def main():
    global header
    global measure_meter
    global measure_meter_value
    global args
    global file_name
    global output_name
    global meter
    global voices
    global measure_on
    global key_default
    global key_voice
    global commentonline
    global precomment
    global linecount
    global do_csv_read

    parse_args()
    if args.vertical or args.horizontal:
        header = ( "meter   4/4\n" )
        key_default = "c"                   # Default to key of c.
                                            # At the end of header, print out the key - then follows notes.
        measure_meter = { '': '4/4'}        # Each measure change can have a different meter.
        measure_meter_value = 1             # Computed value for measure.
        meter = '4/4'
    elif args.midi1csv or args.fluidsynth:
        header = []
        key_default = 0                     # Default to key of C.
        measure_meter = { '': '4/4'}        # Each measure change can have a different meter.
        measure_meter_value = 1             # Computed value for measure.
        meter = '4/4'
    else:           # ABC
        header = (  "X:1\n" +               # Song number 1 in the output file.
                    "M:none\n" )            # No meter supposedly means don't check.
        key_default = "C"                   # Default to key of C.
                                            # At the end of header, print out the key - then follows notes.
        measure_meter = { '': 'none'}       # Each measure change can have a different meter.
        measure_meter_value = 1             # Computed value for measure.
        meter = 'none'
    # fi
    for v in range(1, MAXVOICES+1):
        key_voice[''][v] = key_default
    # rof

    new_voice_initialize(voices, measure_on)    # Set a bunch of things for voice=1 so acc_m, etc. are set.

    output_name = sys.stdout
    if args.rest:
        if len(args.rest) >= 1:             # Input.
            file_name = open(args.rest[0], 'r')
        # fi
        if len(args.rest) >= 2:             # Output.
            output_name = open(args.rest[1], 'w')
        # fi
        if len(args.rest) > 2:              # Too many.
            print_error_no_line("Too many arguments, input, output only.  {}".format(args.rest))
            sys.exit(1)
        # fi
    # fi

    precomment = ''
    while True:
        line, commentonline = get_line()
        # fi
        if line:
            if do_csv_read:
                read_csv_file(line)
                continue
            # fi
            if (linecount == 1 and args.fluidsynth):
                if line[:17] == '0, 0, Header, 1, ':
                    do_csv_read = True
                    continue
                # fi
            # fi
            # Split line on spaces, then process line.
            num_putd = 0
            while True:
                if macro_defining is None:
                    if line and line[0] == '=':
                        line = process_putd(line)
                        if len(line) > 0 and line[0] == '=':
                            num_putd += 1
                            if num_putd > 100:
                                print_error("Over 100 putd's done on line", line)
                                break
                            # fi
                            continue
                        # fi
                    # fi
                # fi
                line = re.sub(r'   *', r' ', line)                      # multiple spaces to single.
                t0 = re.sub(r'(^ *[^ ]*).*$', r'\1', line, count=1)
                t1 = re.sub(r'^ *[^ ]*', '', line, count=1)
                t_tmp = t0.lstrip()                                     # For command lookup.
                t = [ t0, t1 ]                                          # Note: a leading space.
                if t_tmp and t_tmp == '.':
                    # If command == '.' toss '.'
                    if len(t) == 2 and t[1]:
                        line = t[1]
                    else:
                        t = None
                        line = None
                        break
                    # fi
                    continue
                # fi
                break
            # elihw

            if t_tmp and t_tmp[0]:
                # If command == '*' ignore.
                if t_tmp[0] != '*' and line[0] != '*' and t_tmp[0] != '#' and line[0] != '#':
                    process_line(t, line)
                    precomment = ''
                else:
                    precomment = precomment + line + "\n"
                # fi
            # fi
        # fi
    # elihw
    return
# End of main

# ----------------------------------------------------------------------------
if __name__ == '__main__':
    calculate.cexp_parser()                                     # initialize parser
    main()
# fi
# ----------------------------------------------------------------------------
exit(errors_happened)
# ----------------------------------------------------------------------------
# End of file musicomp2abc
# ----------------------------------------------------------------------------

# Header:
# * X:          Reference number (think which track on CD, etc.).       First
# * T: Title of tune             (can have multiple)
#   C: Composer of song
#   M: meter    6/8              default common or "M: C"
#   L: 1/4                       length of default note (quarter)
#   K: key      C or D or ...                                           Last
#
#   Notes: follow Header
#       C, D, E, F, |G,A,B,C| D E F G|A B c d|e f g a|b c' d' e'|f' g' a' b'|]
#
#       ~A3 B3|gfe fdB|AFA B2c|dfe dcB|
#
#   Uppercase denote bottom octave (C = middle C on treble stave).
#   Comma after the letter means down an octave.
#   Apostrophe after the letter means up an octave. Multiple ' go up, as ,'s go down.
#   Lowercase letters are next octave above uppercase. four c's: "C, C c c' "
#   |  Vertical line means end of measure/bar -- || gives two lines.
#   ]  means thick bar.  [|  and |] thick/thin and thin/thick.
#   |: start of repeat. :| is end of repeat. Stop one and start another is :||: or "::".
#   Alternate repeats "[1", "[2". If by bar line, can omit the [. "|1" means "|[1". (no spaces)
#   To have notes with "beam"(lines together above/below) eliminate the "space".
#
#   Number after note changes duration. Number times default. B2=B twice as long therefore 1/4 because 1/2.
#   / means shorten, default is 2 or "/2".
#   > after a note, multiplying by 3/2 and removing from 2nd note. I.e. c8>c8 -> c8.c16 (dot means 1/16 extra)
#   < after a note, multiplying by 1/2 and adding rest on 2nd note. I.e. c8<c8 -> c16c8. means 1/16th extra
#
#   ~ is ornament -- roll or turn as in Irish music.
#   Default note lengths for common types of tunes: jig 1/8, reel 1/8, Schottische 1/8,
#       Waltz 1/4, Polka 1/8, Bourree 1/8
#   Time signagures typical: jig 6/8, reel 4/4, waltz 3/4.
#   L: can be used in the middle to change default note length.
#   Rests are lowercase z. Length follows.
#   ^C = C sharp. _B = B flat. ^^ = double sharp. The equals (=) naturalizes it.
#   G major scale: GABcde^fg            for K:C
#   G minor scale: GA_Bcd_efg           for K:C
#   K: automatically adds sharps or flats.      example K:G or K:Gmaj ... and K:Gm or K:Gmin
#   Also K:Bb and K:C#   (B flat and C sharp).
#   Other Modal keys exist: Lydian, Ionian, Mixolydian, Dorian, Aeolian, Phrygian, Locrian,
#       HP (bagpipe - no key signature), Hp (F#,C#,G natural) on printed.
#   K: can go in the middle of a song.   K:A =C -- A major, C natural -- F#,G#.
#   R: = rythm. ... R:reel, R:jig, R:schottische
#   Q: tempo    Example: Q: 120  # of default note length.  Q:1/8 = 120.
#   Can change in the middle of a line like (KRQ):
#       GABcdefg | [M:6/8 K:Gm] gfe dcB | AGB FED |
#   Optional:
#   C: composer
#   S: source of tune.
#   O: geographical origin
#   N: textual notes about the tune. (anything you want, multiple of them, etc.)
#   Z: identity of transcriber. # Z:Marshall Midden 2021-01-04
#   W: for song words           w:  also -- difficult syntax. :)
#   B: for book
#   A: geographical area
#   D: Discography -- D:New Victory Band, One More Dance And Then
#   F: File name (http://www.lesession.co.uk/woodenflute.abc)
#   G: Group -- used for indexing tunes in software.   G: Flute
#   H: history
#   I: Information -- used by some software packages.
#   P: Yuck.  Parts.
#
#   grace notes {GAGDG}G2 -- they can have no time values.
#   - minus sign between two notes of equal pitch "ties". () slurs or played legato.
#       |DEF-|FGA| and |DEF-FGA|
#       (DEF|GAB)
#   Triplets -- no spaces within:
#       Duplet:     (2GA                2 notes in the time of 3
#       Triplet:    (3GAB               3 notes in the time of 2
#       Quadruplet: (4GABA              4 notes in the time of 3
#       ...       : (5GABcd             5 notes in the time of n
#       ...       : (6GABcdc            6 notes in the time of 2
#       ...       : (7GABcdcB           7 notes in the time of n
#       ...       : (8GABcdcBA          8 notes in the time of 3
#       ...       : (9GABcdcBAG         9 notes in the time of n
#       n is 3 in compound time signatures (3/4, 3/8, 9/8 etc), and 2 in simple time signatures (C, 4/4, 2/4 etc.)
#       More complicated forms possible. (Yuck!)
#   [GB][Ac] [B2d2] | [Bd][Ac] [G2B2]   - multiple notes on a stem (chord/unisons)
#   Guitar chords:  "Dm7"               -- note accidental type/bass
#       note:       A to G
#       accidental: # or b
#       type:       m, min, maj, sus, dim, +, 7, 9, 11,#5, etc.
#       / bass:     Bass note
#   Fiddle bowing marks:  u=up-bow, v=down-bow.     v_Au=Bv^c   NOTE: flat A, natural B, sharp c.
#   Staccato, place dot before the note.            .G.A._B.c .d2.e.d.^c
#       H Fermata, L Accent, or emphasis, M Lower mordent (sometimes called mordent),
#       O Coda, P Upper mordent (sometimes called Pralltriller), S Segno, T Trill
#   or can enclose within exclamation marks (!):
#       !+!             Pizzicato for violins, rasp for brass
#       !0! to !5!      Fingerings
#       !D.C.!          Da capo
#       !D.S.!          Da segno
#       !accent!        Accent mark over the note
#       !breath!        Breath mark
#       !coda!          Coda mark
#       !crescendo(!    Start of a crescendo mark
#       !crescendo)!    End of a crescendo mark - this is placed AFTER the last note affected
#       !diminuendo(!   Start of a diminuendo mark
#       !diminuendo)!   End of a diminuendo mark - this is placed AFTER the last note affected
#       !downbow!       Down bow mark
#       !emphasis!      The same as !accent!
#       !fermata!       Fermata, or hold
#       !f!, !ff!, !fff! etc.   Dynamic markings - the more f -s, the louder
#       !fine!          Fine
#       !invertedfermata!   Inverted fermata / hold marking
#       !longphrase!    Vertical line on the upper part of the staff, extending 3/4 of the way down
#       !lowermordent!  Lower mordent, a.k.a. mordent
#       !mediumphrase!  Vertical line on the upper part of the staff, extending down to the centre line
#       !mf!            Dynamic marking for mezzoforte ('half-loud')
#       !mordent!       Lower mordent, a.k.a. mordent
#       !open!          Open string, or, harmonic
#       !p!, !pp!, !ppp!    Dynamic markings - the more p -s, the quieter
#       !pralltriller!  Upper mordent
#       !repeatbar!     Repeat whole of previous bar
#       !repeatbar2!    Repeat whole of previous two bars
#       !roll!          Roll mark
#       !segno!         Segno
#       !shortphrase!   Vertical line on the upper part of the staff
#       !snap!          Snap-pizzicato mark
#       !tenuto!        tenuto (hold note for full duration)
#       !thumb!         Cello thumb symbol
#       !trill!         Trill
#       !turn!          Turn
#       !upbow!         Up bow mark
#       !uppermordent!  Upper mordent, a.k.a. pralltriller
#       !wedge!         Wedge mark
#   As with the single letter symbols, the mark is placed before the note (or first note of a group) affected.
#       !trill!G4
#   V: voice number     V:1     V:20
#       M:6/8
#       L:1/8
#       K:G
#       V:1
#       B3 A3 | G6 | B3 A3 | G6 ||
#       V:2
#       BdB AcA | GAG D3 | BdB AcA | GAG D6 ||
#       V:3
#       D3 D3 | D6 | D3 D3 | D6 ||
#   or:
#       M:6/8
#       L:1/8
#       K:G
#       [V:1] B3 A3 | G6 | B3 A3 | G6 ||
#       [V:2] BdB AcA | GAG D3 | BdB AcA | GAG D3 ||
#       [V:3] D3 D3 | D6 | D3 D3 | D6 ||
#   Notes played at same time, but not a chord (two voices): AB BAG & D6 |
#       The & has the two same length.
#       x draws spaces (not rests).        GAB BAG & x3 G2x
#       Normally use [] for chords.
#   ==============================================================================
#   General MIDI 1
#        24 channels/voices     Alternatively 16 melodic and 8 percussive - respond to note velocity.
#       channel 10 is percussion.
#       multiple notes on each channel (polyphony)
#       128 instruments sounds or "program" number  - program change message.
#        47 percussion sounds
#       Channel messages/controller-number: 1,7,10,11,64,100,101,121,123
#   General MIDI 2
#        32 channels
#       2 percussion channels 10/11
#     16384 variation banks - each has 128 melodic sounds. Up to individual how to use.
#         9 Drum kits
#   ------------------------------------------------------------------------------
# select chan sfont bank prog
#   000-000 Stereo Grand
#   000-001 Bright Grand
#   000-002 Electric Grand
#   000-003 Honky-Tonk
#   000-004 Tine Electric Piano
#   000-005 FM Electric Piano
#   000-006 Harpsichord
#   000-007 Clavinet
#   000-008 Celeste
#   000-009 Glockenspiel
#   000-010 Music Box
#   000-011 Vibraphone
#   000-012 Marimba
#   000-013 Xylophone
#   000-014 Tubular Bells
#   000-015 Dulcimer
#   000-016 Tonewheel Organ
#   000-017 Percussive Organ
#   000-018 Rock Organ
#   000-019 Pipe Organ
#   000-020 Reed Organ
#   000-021 Accordian
#   000-022 Harmonica
#   000-023 Bandoneon
#   000-024 Nylon Guitar
#   000-025 Steel Guitar
#   000-026 Jazz Guitar
#   000-027 Clean Guitar
#   000-028 Muted Guitar
#   000-029 Overdrive Guitar
#   000-030 Distortion Guitar
#   000-031 Guitar Harmonics
#   000-032 Acoustic Bass
#   000-033 Finger Bass
#   000-034 Pick Bass
#   000-035 Fretless Bass
#   000-036 Slap Bass 1
#   000-037 Slap Bass 2
#   000-038 Synth Bass 1
#   000-039 Synth Bass 2
#   000-040 Violin
#   000-041 Viola
#   000-042 Cello
#   000-043 Double Bass
#   000-044 Stereo Strings Trem
#   000-045 Pizzicato Strings
#   000-046 Orchestral Harp
#   000-047 Timpani
#   000-048 Stereo Strings Fast
#   000-049 Stereo Strings Slow
#   000-050 Synth Strings 1
#   000-051 Synth Strings 2
#   000-052 Concert Choir
#   000-053 Voice Oohs
#   000-054 Synth Voice
#   000-055 Orchestra Hit
#   000-056 Trumpet
#   000-057 Trombone
#   000-058 Tuba
#   000-059 Muted Trumpet
#   000-060 French Horns
#   000-061 Brass Section
#   000-062 Synth Brass 1
#   000-063 Synth Brass 2
#   000-064 Soprano Sax
#   000-065 Alto Sax
#   000-066 Tenor Sax
#   000-067 Baritone Sax
#   000-068 Oboe
#   000-069 English Horn
#   000-070 Bassoon
#   000-071 Clarinet
#   000-072 Piccolo
#   000-073 Flute
#   000-074 Recorder
#   000-075 Pan Flute
#   000-076 Bottle Blow
#   000-077 Shakuhachi
#   000-078 Irish Tin Whistle
#   000-079 Ocarina
#   000-080 Square Lead
#   000-081 Saw Lead
#   000-082 Synth Calliope
#   000-083 Chiffer Lead
#   000-084 Charang
#   000-085 Solo Vox
#   000-086 5th Saw Wave
#   000-087 Bass & Lead
#   000-088 Fantasia
#   000-089 Warm Pad
#   000-090 Polysynth
#   000-091 Space Voice
#   000-092 Bowed Glass
#   000-093 Metal Pad
#   000-094 Halo Pad
#   000-095 Sweep Pad
#   000-096 Ice Rain
#   000-097 Soundtrack
#   000-098 Crystal
#   000-099 Atmosphere
#   000-100 Brightness
#   000-101 Goblin
#   000-102 Echo Drops
#   000-103 Star Theme
#   000-104 Sitar
#   000-105 Banjo
#   000-106 Shamisen
#   000-107 Koto
#   000-108 Kalimba
#   000-109 Bagpipes
#   000-110 Fiddle
#   000-111 Shenai
#   000-112 Tinker Bell
#   000-113 Agogo
#   000-114 Steel Drums
#   000-115 Wood Block
#   000-116 Taiko Drum
#   000-117 Melodic Tom
#   000-118 Synth Drum
#   000-119 Reverse Cymbal
#   000-120 Fret Noise
#   000-121 Breath Noise
#   000-122 Seashore
#   000-123 Birds
#   000-124 Telephone 1
#   000-125 Helicopter
#   000-126 Applause
#   000-127 Gun Shot
#   001-038 Synth Bass 101
#   001-044 Mono Strings Trem
#   001-048 Mono Strings Fast
#   001-049 Mono Strings Slow
#   001-052 Concert Choir Mono
#   001-056 Trumpet 2
#   001-057 Trombone 2
#   001-059 Muted Trumpet 2
#   001-060 Solo French Horn
#   001-061 Brass Section Mono
#   001-080 Square Wave
#   001-081 Saw Wave
#   001-098 Synth Mallet
#   001-120 Cut Noise
#   001-121 Fl. Key Click
#   001-122 Rain
#   001-123 Dog
#   001-124 Telephone 2
#   001-125 Car-Engine
#   001-126 Laughing
#   001-127 Machine Gun
#   002-102 Echo Pan
#   002-120 String Slap
#   002-122 Thunder
#   002-123 Horse Gallop
#   002-124 Door Creaking
#   002-125 Car-Stop
#   002-126 Scream
#   002-127 Lasergun
#   003-122 Howling Winds
#   003-123 Bird 2
#   003-124 Door
#   003-125 Car-Pass
#   003-126 Punch
#   003-127 Explosion
#   004-122 Stream
#   004-123 Scratch
#   004-125 Car-Crash
#   004-126 Heart Beat
#   005-122 Bubbles
#   005-124 Windchime
#   005-125 Siren
#   005-126 Footsteps
#   006-125 Train
#   007-125 Jet Plane
#   008-004 Chorused Tine EP
#   008-005 Chorused FM EP
#   008-006 Coupled Harpsichord
#   008-014 Church Bells
#   008-016 Detuned Tnwl. Organ
#   008-017 Detuned Perc. Organ
#   008-019 Pipe Organ 2
#   008-021 Italian Accordian
#   008-024 Ukulele
#   008-025 12-String Guitar
#   008-026 Hawaiian Guitar
#   008-027 Chorused Clean Gt.
#   008-028 Funk Guitar
#   008-030 Feedback Guitar
#   008-031 Guitar Feedback
#   008-038 Synth Bass 3
#   008-039 Synth Bass 4
#   008-048 Orchestra Pad
#   008-050 Synth Strings 3
#   008-061 Brass Section 2
#   008-062 Synth Brass 3
#   008-063 Synth Brass 4
#   008-080 Sine Wave
#   008-081 Doctor Solo
#   008-107 Taisho Koto
#   008-115 Castanets
#   008-116 Concert Bass Drum
#   008-117 Melodic Tom 2
#   008-118 808 Tom
#   008-125 Starship
#   009-014 Carillon
#   009-125 Burst Noise
#   011-000 Piano & Str.-Fade
#   011-001 Piano & Str.-Sus
#   011-004 Tine & FM EPs
#   011-005 Piano & FM EP
#   011-008 Tinkling Bells
#   011-014 Bell Tower
#   011-038 Techno Bass
#   011-039 Pulse Bass
#   011-049 Stereo Strings Velo
#   011-050 Synth Strings 4
#   011-051 Synth Strings 5
#   011-061 Brass Section 3
#   011-078 Whistlin'
#   011-081 Sawtooth Stab
#   011-087 Doctor's Solo
#   011-088 Harpsi Pad
#   011-089 Solar Wind
#   011-096 Mystery Pad
#   011-098 Synth Chime
#   011-100 Bright Saw Stack
#   011-119 Cymbal Crash
#   011-121 Filter Snap
#   011-127 Interference
#   012-000 Bell Piano
#   012-004 Bell Tine EP
#   012-010 Christmas Bells
#   012-027 Clean Guitar 2
#   012-038 Mean Saw Bass
#   012-048 Full Orchestra
#   012-049 Mono Strings Velo
#   012-080 Square Lead 2
#   012-081 Saw Lead 2
#   012-088 Fantasia 2
#   012-089 Solar Wind 2
#   012-119 Tambourine
#   012-122 White Noise Wave
#   012-127 Shooting Star
#   013-048 Woodwind Choir
#   013-080 Square Lead 3
#   013-081 Saw Lead 3
#   013-088 Night Vision
#   016-025 Mandolin
#   120-000 Standard Drums
#   120-001 Standard 2 Drums
#   120-008 Room Drums
#   120-016 Power Drums
#   120-024 Electronic Drums
#   120-025 808/909 Drums
#   120-026 Dance Drums
#   120-032 Jazz Drums
#   120-040 Brush Drums
#   120-048 Orchestral Perc.
#   120-056 SFX Kit
#   128-000 Standard
#   128-001 Standard 2
#   128-008 Room
#   128-016 Power
#   128-024 Electronic
#   128-025 808/909
#   128-026 Dance
#   128-032 Jazz
#   128-040 Brush
#   128-048 Orchestral
#   128-056 SFX
#   ------------------------------------------------------------------------------
#   Put in a V: section.
#   %%MIDI program 1 % Acoustic Grand Piano
#   Piano
#       0 Acoustic Grand Piano
#       1 Bright Acoustic Piano
#       2 Electric Grand Piano
#       3 Honky-tonk Piano
#       4 Electric Piano 1
#       5 Electric Piano 2
#       6 Harpsichord
#       7 Clavi
#   Chromatic Percussion
#       8 Celesta
#       9 Glockenspiel
#       10 Music Box
#       11 Vibraphone
#       12 Marimba
#       13 Xylophone
#       14 Tubular Bells
#       15 Dulcimer
#   Organ
#       16 Drawbar Organ
#       17 Percussive Organ
#       18 Rock Organ
#       19 Church Organ
#       20 Reed Organ
#       21 Accordion
#       22 Harmonica
#       23 Tango Accordion
#   Guitar
#       24 Acoustic Guitar (nylon)
#       25 Acoustic Guitar (steel)
#       26 Electric Guitar (jazz)
#       27 Electric Guitar (clean)
#       28 Electric Guitar (muted)
#       29 Overdriven Guitar
#       30 Distortion Guitar
#       31 Guitar Harmonics
#   Bass
#       32 Acoustic Bass
#       33 Electric Bass (finger)
#       34 Electric Bass (pick)
#       35 Fretless Bass
#       36 Slap Bass 1
#       37 Slap Bass 2
#       38 Synth Bass 1
#       39 Synth Bass 2
#   Strings
#       40 Violin
#       41 Viola
#       42 Cello
#       43 Contrabass
#       44 Tremolo Strings
#       44 Pizzicato Strings
#       46 Orchestral Harp
#       47 Timpani
#   Ensemble
#       48 String Ensemble 1
#       49 String Ensemble 2
#       50 Synth Strings 1
#       51 Synth Strings 2
#       52 Choir Aahs
#       53 Voice Oohs
#       54 Synth Voice
#       55 Orchestra Hit
#   Brass
#       56 Trumpet
#       57 Trombone
#       58 Tuba
#       59 Muted Trumpet
#       60 French Horn
#       61 Brass Section
#       62 Synth Brass 1
#       63 Synth Brass 2
#   Reed
#       64 Soprano Sax
#       65 Alto Sax
#       66 Tenor Sax
#       67 Baritone Sax
#       68 Oboe
#       69 English Horn
#       70 Bassoon
#       71 Clarinet
#   Pipe
#       72 Piccolo
#       73 Flute
#       74 Recorder
#       75 Pan Flute
#       76 Blown bottle
#       77 Shakuhachi
#       78 Whistle
#       79 Ocarina
#   Synth Lead
#       80 Lead 1 (square)
#       81 Lead 2 (sawtooth)
#       82 Lead 3 (calliope)
#       83 Lead 4 (chiff)
#       84 Lead 5 (charang)
#       85 Lead 6 (voice)
#       86 Lead 7 (fifths)
#       87 Lead 8 (bass + lead)
#   Synth Pad
#       88 Pad 1 (new age)
#       89 Pad 2 (warm)
#       90 Pad 3 (polysynth)
#       91 Pad 4 (choir)
#       92 Pad 5 (bowed)
#       93 Pad 6 (metallic)
#       94 Pad 7 (halo)
#       95 Pad 8 (sweep)
#   Synth Effects
#       96 FX 1 (rain)
#       97 FX 2 (soundtrack)
#       98 FX 3 (crystal)
#       99 FX 4 (atmosphere)
#       100 FX 5 (brightness)
#       101 FX 6 (goblins)
#       102 FX 7 (echoes)
#       103 FX 8 (sci-fi)
#   Ethnic
#       104 Sitar
#       105 Banjo
#       106 Shamisen
#       107 Koto
#       108 Kalimba
#       109 Bag pipe
#       110 Fiddle
#       111 Shanai
#   Percussive
#       112 Tinkle Bell
#       113 Agogo
#       114 Steel Drums
#       115 Woodblock
#       116 Taiko Drum
#       117 Melodic Tom
#       118 Synth Drum
#       119 Reverse Cymbal
#   Sound effects
#       120 Guitar Fret Noise
#       121 Breath Noise
#       122 Seashore
#       123 Bird Tweet
#       124 Telephone Ring
#       125 Helicopter
#       126 Applause
#       127 Gunshot
# ----------------------------------------------------------------------------
# timidity      000_Acoustic_Grand_Piano.pat
# timidity      001_Acoustic_Brite_Piano.pat
# timidity      002_Electric_Grand_Piano.pat
# timidity      004_Electric_Piano_1_Rhodes.pat
# timidity      005_Electric_Piano_2_Chorused_Yamaha_DX.pat
# timidity      006_Harpsichord.pat
# timidity      007_Clavinet.pat
# timidity      008_Celesta.pat
# timidity      009_Glockenspiel.pat
# timidity      013_Xylophone.pat
# timidity      014_Tubular_Bells.pat
# timidity      015_Dulcimer.pat
# timidity      016_Hammond_Organ.pat
# timidity      019_Church_Organ.pat
# timidity      021_Accordion.pat
# timidity      023_Tango_Accordion.pat
# timidity      024_Nylon_Guitar.pat
# timidity      025_Steel_Guitar.pat
# timidity      026_Jazz_Guitar.pat
# timidity      027_Clean_Electric_Guitar.pat
# timidity      028_Muted_Electric_Guitar.pat
# timidity      029_Overdriven_Guitar.pat
# timidity      030_Distortion_Guitar.pat
# timidity      032_Acoustic_Bass.pat
# timidity      033_Finger_Bass.pat
# timidity      034_Pick_Bass.pat
# timidity      035_Fretless_Bass.pat
# timidity      036_Slap_Bass_1.pat
# timidity      037_Slap_Bass_2.pat
# timidity      038_Synth_Bass_1.pat
# timidity      040_Violin.pat
# timidity      042_Cello.pat
# timidity      044_Tremolo_Strings.pat
# timidity      045_Pizzicato_Strings.pat
# timidity      046_Harp.pat
# timidity      047_Timpani.pat
# timidity      048_String_Ensemble_1_Marcato.pat
# timidity      053_Voice_Oohs.pat
# timidity      056_Trumpet.pat
# timidity      057_Trombone.pat
# timidity      058_Tuba.pat
# timidity      059_Muted_Trumpet.pat
# timidity      060_French_Horn.pat
# timidity      061_Brass_Section.pat
# timidity      064_Soprano_Sax.pat
# timidity      065_Alto_Sax.pat
# timidity      066_Tenor_Sax.pat
# timidity      067_Baritone_Sax.pat
# timidity      068_Oboe.pat
# timidity      069_English_Horn.pat
# timidity      070_Bassoon.pat
# timidity      071_Clarinet.pat
# timidity      072_Piccolo.pat
# timidity      073_Flute.pat
# timidity      074_Recorder.pat
# timidity      075_Pan_Flute.pat
# timidity      076_Bottle_Blow.pat
# timidity      079_Ocarina.pat
# timidity      080_Square_Wave.pat
# timidity      084_Charang.pat
# timidity      088_New_Age.pat
# timidity      094_Halo_Pad.pat
# timidity      095_Sweep_Pad.pat
# timidity      098_Crystal.pat
# timidity      101_Goblins--Unicorn.pat
# timidity      102_Echo_Voice.pat
# timidity      104_Sitar.pat
# timidity      114_Steel_Drums.pat
# timidity      115_Wood_Block.pat
# timidity      120_Guitar_Fret_Noise.pat
# timidity      122_Seashore.pat
# timidity      125_Helicopter.pat
# ----------------------------------------------------------------------------
# CC values have a range from 0-127, from minimum to maximum value. However, some parameters are (on/off), where 0 to 63 = Off, 64 to 127 = On.
# Most Common Parameters:
#     1 = Modulation wheel
#     2 = Breath Control
#     7 = Volume
#     10 = Pan
#     11 = Expression
#     64 = Sustain Pedal (on/off)
#     65 = Portamento (on/off)
#     71 = Resonance (filter)
#     74 = Frequency Cutoff (filter)
#
# NOTE: There is no standard CC value for Vibrato Amount or Vibrato Speed. Sometimes you can assign them (and other CC mappings) yourself in the software instrument you use.
# Complete List:
#     0 Bank Select (MSB)
#     1 Modulation Wheel
# x   2 Breath controller
# x   3 = Undefined
# x   4 Foot Pedal (MSB)
#     5 Portamento Time (MSB)
#     6 Data Entry (MSB)
#     7 Volume (MSB)
# x   8 Balance (MSB
#     9 = Undefined
#     10 Pan position (MSB)
#     11 Expression (MSB)
# x   12 Effect Control 1 (MSB)
# x   13 Effect Control 2 (MSB)
# x   14 = Undefined
# x   15 = Undefined
# x   16-19 = General Purpose
# x   20-31 = Undefined
# x   32-63 = Controller 0-31
#     64 Hold Pedal (on/off)
#     65 Portamento (on/off)
#     66 Sostenuto Pedal (on/off)
#     67 Soft Pedal (on/off)
#     68 Legato Pedal (on/off)
# x   69 Hold 2 Pedal (on/off)
# x   70 Sound Variation
# x   71 Resonance (Timbre)
# x   72 Sound Release Time
# x   73 Sound Attack Time
# x   74 Frequency Cutoff (Brightness)
# x   75 Sound Control 6
# x   76 Sound Control 7
# x   77 Sound Control 8
# x   78 Sound Control 9
# x   79 Sound Control 10
# x   80 Decay or General Purpose Button 1 (on/off) Roland Tone level 1
# x   81 Hi Pass Filter Frequency or General Purpose Button 2 (on/off) Roland Tone level 2
# x   82 General Purpose Button 3 (on/off) Roland Tone level 3
# x   83 General Purpose Button 4 (on/off) Roland Tone level 4
#     84 Portamento Amount
# x   85-90 = Undefined
#     91 Reverb Level
# x   92 Tremolo Level
#     93 Chorus Level
# x   94 Detune Level
# x   95 Phaser Level
# x   96 Data Button increment
# x   97 Data Button decrement
#     98 Non-registered Parameter (LSB)
#     99 Non-registered Parameter (MSB)
#     100 Registered Parameter (LSB)
#     101 Registered Parameter (MSB)
# x   102-119 = Undefined
#     120 All Sound Off
#     121 All Controllers Off
# x   122 Local Keyboard (on/off)
#     123 All Notes Off
#     124 Omni Mode Off
#     125 Omni Mode On
#     126 Mono Operation
#     127 Poly Mode
# ----------------------------------------------------------------------------
