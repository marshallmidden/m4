#!/usr/bin/python3 -B
# vim: tabstop=8 expandtab shiftwidth=4 softtabstop=4
#-----------------------------------------------------------------------------
# ./musicomp --midi1csv song song.csv
# ./musicomp song song.abc
# ./musicomp --vertical song song.v     # Either v or h (or mixed) input.
# ./musicomp --horizontal song song.h   # Either v or h (or mixed) input.
#-----------------------------------------------------------------------------
# TODO:

# 1) tempo changes - midi does not work right. Probably cannot have in songs without voice 1?
#    Some error about order. 
#       cd ../songs
#       make -j 1

# 2) GOTO - move variables to global, and when processing change measure, etc. and
#    exiting printing routine, do the right thing(s).
#    Need pointer to goto table indexed by measure.
#    Processed at end of a measure, and counter. Says 'Limited to 8' (we'll do dynamic).
#    "x" means continue to next measure.
#    Parsing - when finished, see that all measures exist in goto arguments, and thus must
#    have line number and "line" of the goto for error printing.
#       When a goto is executed more than n times, it wraps around, and begins
#    executing the 1st branch address again.

# 3) Instrument numbers +/- by a given value. (fluidsynth verses timidity)

# 4) Select clef=treble or clef=bass by notes min and max notes on staff(s).
#       # NOTDONEYET - add ' clef=bass'  (after the number)
#       # clef can occur each measure (abc, horizontal, vertical format).
#-----------------------------------------------------------------------------
# Commands not done.
#   print_error("NOTDONEYET - do_goto", line)           Complicated, but should do.
#
#   print_error("NOTDONEYET - do_putd", line)           Not likely to do. (Not used anywhere that I see.)
#   print_error("NOTDONEYET - process_putd", line)      Not likely to do. (Not used anywhere that I see.)
#-----------------------------------------------------------------------------
# NOTDONEYET - Note processing:
#   print_error("NOTDONEYET - doing gsw_operand type of note", line)    - Not related to MIDI.
#=============================================================================
# Additional note processing:
# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
# vol(xxx) before a note sets volume for that note only.
# vol(sfp) before a note sets volume to f for that note only, and following p.
#   vol(p) 3c4, 3d4, vol(sfp) 3e4, 3f4, 3g4
#   (p,p,f,p,p)
# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
# cresc(xxx,yyy) xxx = ending volume. yyy = time (0.75 = three quarter notes).
# dimin(xxx,yyy) xxx = ending volume. yyy = time (0.75 = three quarter notes).
#   Like vol(), but does a volume change from present to xxx over time yyy.
# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
# Macro substitution during note processing.
# A line that looks like notes may use the macro whenever a complete note or
# vol(), cresc(),dimin() may appear. Example follows:
#   macro   abc,A,B,C
#      A4, B4
#      A8, C8
#   endm
#   measure 1
#   voice 2
#   0e4, 0g4
#   vol(ff) abc(1c,1e,1g) abc(2e,2c,2g) 3g4, vol(sf) 3a4
#
# The whole line is processed, left to right -- with the new lines from the
# macro inserted into place. NOTE: The "vol(ff)" refers to the next note in the 
# line, but there is none, so it is tossed away. *NOTE*
#
# The first abc macro is done, then the second, then the two trailing notes.
# Correctly formatted line would have put the vol(ff) before the 3g4 (which
# would affect that note and subsequent for voice 1, but not the 2nd voice 3a4.
# vol(sf) affects the 3a4 and puts volume back to what it was before the "sf".
#
# This shows that no deliminators are used in substitution of arguments (all
# macros), and that intermixing of vertical 'v#:' format and horizontal format
# is allowed. Convert all to one type or the other via command line arguments:
# --horizontal or --vertical. (And it deletes macros too..., which may be useful
# when trying to figure out what a macro really did.)
#
#
# The above would then look like either:
#   measure 1
#   voice   2    0,0
#   v1: 0e4, 1c4, 1c8, 2e4, 2e8, 3g4
#   v2: 0g4, 1e4, 1g8, 2c4, 2g8, vol(sf) 3a4
# or:
#   voice   2    0,0
#      0e  4,  0g  4
#      1c  4,  1e  4
#      1c  8,  1g  8
#      2e  4,  2c  4
#      2e  8,  2g  8
#      3g  4,vol(sf) 3a  4
#
# If the second abc macro had been after 3g4, then there would be no second
# note for either 3g4 line (but comma would put in a r4 -- but the 3a4 would
# have been for voice 1 and without a second note for second voice, error!
#
#   vol(ff) abc(1c,1e,1g) 3g4, abc(2e,2c,2g) vol(sf) 3a4
#
# ./musicomp2abc --vert tv
#   ERROR - Not enough arguments on note line - want 2, have ['vol(sf)3a4']
#   Line 8 - vol(sf)3a4
#
# This shows that if not a command, spaces are eliminated for note processing.
# By the way, the arguments on the voice line for for instruments, 0=default.
#-----------------------------------------------------------------------------
# xpose command is done for --vertical, --horizontal, and --midi1csv, but NOT abc format.
# ABC format thus will "print" right, but not "play" (abc2midi) right.
#       NOTDONEYET - so ABC format can print. NOTDONEYET - abc #
#-----------------------------------------------------------------------------
# instrument 1,2 flute            $$ voice, name or number.
#                                     v-- MIDI control number.
# intensity  1,2 84               $$  7 volume
# pan        1,2 8                $$ 10 pan
# reverb     1,2 52               $$ 91 Reverb level
#-----------------------------------------------------------------------------
#  10   Pan position   64 is center, 0 is hard left, and 127 is hard right.
#  Number: 10 (coarse) 42 (fine)
# Where within the stereo field the device's sound will be placed (assuming that it
# has stereo audio outputs). If a MultiTimbral device, then each Part usually has
# its own pan position. This is generally when Pan becomes useful, because then you
# can use Pan, Volume, and Balance controllers to internally mix all of the Parts to
# the device's stereo outputs. Pan should effect all notes on the channel, including
# notes that were triggered prior to pan message being received, and are still sustaining.
# 14-bit coarse/fine resolution. 16,384 possible positions, 0x0000 to 0x3FFF where 0x2000
# is center position, 0x0000 is hard left, and 0x3FFF is hard right. Some devices only
# respond to coarse adjust (128 positions) where 64 is center, 0 is hard left, and 127 is hard right.
# Note: Most all devices ignore the Fine adjust (#42) for Pan, and just implement Coarse
# adjust (#10) because 14-bit resolution isn't needed for this.
# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
# Expression, number 11 (course)
# Percentage of all playing instruments volume. 100% = all up.
# This is a percentage of Volume (ie, as set by Volume Controller). In other words,
# Expression divides the current volume into 16,384 steps (or 128 if 8-bit instead
# of 14-bit resolution is used). Volume Controller is used to set the overall volume
# of the entire musical part (on a given channel), whereas Expression is used for
# doing crescendos and decrescendos. By having both a master Volume and sub-Volume
# (ie, Expression), it makes possible to do crescendos and decrescendos without
# having to do algebraic calculations to maintain the relative balance between
# instruments. When Expression is at 100% (ie, the maximum of 0x3FFF), then the
# volume represents the true setting of Volume Controller. Lower values of
# Expression begin to subtract from the volume. When Expression is 0% (ie, 0x0000),
# then volume is off. When Expression is 50% (ie, 0x1FFF), then volume is cut in half.
# 
# Here's how Expression is typically used. Let's assume only the coarse adjust is
# used (ie, #11) and therefore only 128 steps are possible. Set the Expression for
# every MIDI channel to one initial value, for example 100. This gives you some
# leeway to increase the expression percentage (ie, up to 127 which is 100%) or
# decrease it. Now, set the channel (ie, instrument) "mix" using Volume Controllers.
# Maybe you'll want the drums louder than the piano, so the former has a Volume
# Controller value of 110 whereas the latter has a value of 90, for example. Now if,
# at some point, you want to drop the volumes of both instruments to half of their
# current Main Volumes, then send Expression values of 64 (ie, 64 represents a 50%
# volume percentage since 64 is half of 128 steps). This would result in the drums
# now having an effective volume of 55 and piano having an effective volume of 45.
# If you wanted to drop the volumes to 25% of their current Main Volumes, then send
# Expression values of 32. This would result in the drums now having an effective
# volume of approximately 27 and piano having an effective volume of approximately
# 22. And yet, you haven't had to change their Volume settings, and therefore still
# maintain that relative mix between two instruments. So think of Volume Controllers
# as being the individual faders upon a mixing console. You set up the instrumental
# balance (ie, mix) using these values. Then you use Expression Controllers as
# "group faders", whereby you can increase or decrease the volumes of one or more
# tracks without upsetting the relative balance between them. 
# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
# Can use legato for slur between notes -- i.e. no attack.
# Legato Pedal, Number: 68
# When on, this causes a legato effect between notes, which is usually achieved by
# skipping the attack portion of the VCA's envelope. Use of this controller allows
# a keyboard player to better simulate the phrasing of wind and brass players, who
# often play several notes with a single tonguing, or simulate guitar pull-offs and
# hammer-ons (ie, where secondary notes are not picked). If a MultiTimbral device,
# then each Part usually has its own Legato Pedal setting.
# Value Range: 0 (to 63) is off. 127 (to 64) is on. 
# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
#  91   Reverb Level - Affects: this is usually the reverb or delay level.
#       If a MultiTimbral device, then each Part usually has its own effects level.
# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
# Tremulo Level, Number: 92
# The tremulo amount (ie, level) for the device. If a MultiTimbral device, then each
# Part Parts usually has its own tremulo level.
# Value Range: 0 to 127, with 0 being no tremulo applied at all. 
#-----------------------------------------------------------------------------
# Note: New addition: second arguments on "voice" command is MIDI instruments.
# Suggest using instrument command instead.
#   %%MIDI program 6 % Harpsichord
#   %%MIDI program 57 % Trombone
#   %%MIDI program 56 % Trumpet
#   %%MIDI program 40 % Violin
#       voice   4       57,56,40,6
#-----------------------------------------------------------------------------
# clef  bass,treble,treble,treble
# clef  G clef = treble clef. 2nd line to the bottom is G pitch above middle C. 3C=1 line below printed.
# clef  C clef = Alto and Tenor clefs. The B points to the middle 3C line.  (viola)
# clef  F clef = Bass clef. The line between the two dots (?:) is F below middle 3C. 3c=1 line above printed.
# clef  Octave clef. Has a number under the G clef. 8=1 octave, 15=2 octaves higher.
#-----------------------------------------------------------------------------
# flats -> key:     B,E,A,D,G,C,F -- always this order. 2nd to last is Key-flat.
# sharps -> key:    F,C,G,D,A,E,B -- always this order. 2nd to last key Key-sharp.
#             vv - is key to use.
# 7 sharps is C# major or A# minor. f+,c+,g+,d+,a+,e+,b+
# 6 sharps is F# major or D# minor. f+,c+,g+,d+,a+,e+
# 5 sharps is B major or G# minor.  f+,c+,g+,d+,a+
# 4 sharps is E major or C# minor.  f+,c+,g+,d+
# 3 sharps is A major or F# minor.  f+,c+,g+
# 2 sharps is D major or B minor.   f+,c+
# 1 sharp  is G major or E minor.   f+
# None     is C major or A minor.
# 1 flat   is F major or D minor.   b-
# 2 flats  is B- major or G minor.  b-,e-
# 3 flats  is E- major or C minor.  b-,e-,a-
# 4 flats  is A- major or F minor.  b-,e-,a-,d-
# 5 flats  is D- major or B- minor. b-,e-,a-,d-,g-
# 6 flats  is G- major or E- minor. b-,e-,a-,d-,g-,c-
# 7 flats  is C- major or A- minor. b-,e-,a-,d-,g-,c-,f-
#-----------------------------------------------------------------------------
# For volume levels= { 0: 'ppp', 1: 'pp', 2: 'p', 3: 'mp', 4: 'mf', 5: 'f', 6: 'ff', 7: 'fff' }
# can use the numbers or names as above. NOTE: lower than 4 is difficult to hear.
#-----------------------------------------------------------------------------
# ABC header:
#     X: 1
#     ...
#     T: title
#     ...
#     K: C
# Empty lines separate tunes, headers (X: ... K:), and free text
# Line-breaks (new-lines, line feeds, carriage returns, end-of-lines) aids readability and breaks long lines.
#   Music code: end of lines means end of typeset sheet music score (lines). Use backslash to for continuation.
#       It continues through information fields, comments, and stylesheet directives.
# Information fields continue with +: at start of next line.
# ..............................................................................
#         V:1
#         a b cd
#     is the same as:
#         [V:1] a b cd
#     Can use [M:9/8]
# K: Key                K:G, K:Dm, K:AMix
# L: Unit Note Length   L:1/4, L:1/8
# M: Meter              M:3/4, M:4/4        Note present means free - no checking.
# Q: Tempo              Q:1/4=120
# T: Title              T:Name Of Song, whatever
# V: Voice              V:4 clef=bass               <----
# W: words              W: lyrics printed after the end of the tune
# w: words              w: lyrics printed aligned with the notes of tune
# ..............................................................................
# clef's can be on V: and K: lines
#       treble  Treble          <- normal treble clef.
#       bass    Bass            <- normal bass clef.
#       bass3   Baritone
#       tenor   Tenor           <- middle c on line above alto staff.
#       alto    Alto            <- middle c on middle staff line. (normal)
#       alto2   Mezzosoprano
#       alto1   Soprano
#       perc
#       none
#-----------------------------------------------------------------------------
# Pass 1
# Need the order of the measures.
# In a measure, want everything for that measure -- so that goto it works.
# Start with measure -1, and the default setup?
# Key, volume, note length, tempo
# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
#   Rests are lowercase z. Length follows.
#   Uppercase denote bottom octave (C = middle C on treble stave).
#   Comma after the letter means down an octave.
#   Apostrophe after the letter means up an octave. Multiple ' go up, as ,'s go down.
#   Lowercase letters are next octave above uppercase. four c's: "C, C c c' "
#   ^C = C sharp. _B = B flat. ^^ = double sharp. The equals (=) naturalizes it.
# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
#   Number after note changes duration. Number times default. B2=B twice as long therefore 1/4 because 1/2.
#   / means shorten, default is 2 or "/2".
#   > after a note, multiplying by 3/2 and removing from 2nd note. I.e. c8>c8 -> c8.c16 (dot means 1/16 extra)
#   < after a note, multiplying by 1/2 and adding rest on 2nd note. I.e. c8<c8 -> c16c8. means 1/16th extra
# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
#   print("   C,,     C,   c     c'   c''   z")
#             ++      +    -    --    n     r
#   print("   ^^C,,   ^C,  _c   __c'  =c''  z")
# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
# Have to think about the time ... if using simple ... then make "L: 1/64", and do multiples via:
#   2 = 32, 3 = 32d, 4 = 16, 6 = 16d, 8 = 8, 12 = 8d, 16 = 4, 24 = 4d, 32 = 2, 48 = 2d, 64 = 1, 96 = 1d, 128=2
# Trills, grace notes, staccato, and triplets, and ... *hmmm*
# staccato = .              (3.a.b.c = triplet staccato         (before note
# T = trill
# H = fermata
# . = staccato mark
# The order of abc constructs for a note is:
# <grace notes>, <chord symbols>, <annotations>/<decorations> (e.g. Irish roll, staccato marker or up/downbow),
#    ... <accidentals>, <note>, <octave>, <note length>, i.e. ~^c'3 or even "Gm7"v.=G,2.
#                                                           irish roll, c (down one, up one),
# syntax (p:q:r which means 'put p notes into the time of q for the next r notes'. If q is not given,
# it defaults as above. If r is not given, it defaults to p.
# For example, (3 is equivalent to (3:: or (3:2 , which in turn are equivalent to (3:2:3, whereas (3::2 is
# equivalent to (3:2:2.
# This can be useful to include notes of different lengths within a tuplet, for example (3:2:2 G4c2 or
# (3:2:4 G2A2Bc. It also describes more precisely how the simple syntax works in cases like (3 D2E2F2 or even
# (3 D3EF2. The number written over the tuplet is p.
# Spaces that appear between the tuplet specifier and the following notes are to be ignored.

# tie is minus (-) between two notes.   i.e. C-C3/2
# NOTE: 3 times normal note length divided by 2.  Or C-.C2
# Each tie symbol, -, should come immediately after a note group but may be followed by a space,
# i.e. =G,2- . Open and close chord delimiters, [ and ], should enclose entire note sequences (except for
# chord symbols), e.g.

# NOTE: spaces between notes means to not connect the notes when printed.
# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
#-----------------------------------------------------------------------------
import argparse
import os
import re
import readline
import shlex
import sys
import random

from fractions import Fraction

#-----------------------------------------------------------------------------
import math
# Log base 2
def Log2(x):
    x = float(x)
    if x == 0:
        return 0
    # fi
    return (math.log10(x) / math.log10(2))
#   End of Log2

#-----------------------------------------------------------------------------
import calculate
#-----------------------------------------------------------------------------
#++ import inspect
#++ print(inspect.currentframe().f_code.co_name, '#0', file=sys.stderr)
#-----------------------------------------------------------------------------
MAXVOICES = 64
NUMBER_BARS_PER_STAFF = 4
# NUMBER_BARS_PER_STAFF = 1
MIDICLICKSPERQUARTER = 480.0

# For setperm and randp commands.
global array_of_random_numbers
array_of_random_numbers = []

# When getting note, various things found:
global sequence_note
sequence_note = 2
global trill_note
trill_note = 1
global normal_note
normal_note = 0
global freqency_note
freqency_note = -1
global gsw_operand
gsw_operand = -2

global allkeys
allkeys = [ 'c','d','e','f','g','a','b',
            'cn','dn','en','fn','gn','an','bn',
            'c-','d-','e-','f-','g-','a-','b-',
            'c--','d--','e--','f--','g--','a--','b--',
            'c+','d+','e+','f+','g+','a+','b+',
            'c++','d++','e++','f++','g++','a++','b++' ]
global accidentals
accidentals = { '':'', 'n':'=', '-':'_', '+':'^', '--':'__', '++':'^^' }

global legal_notes
legal_notes =   {
       '1/64': 0.015625,
      '3/128': 0.0234375,
       '1/32': 0.03125,
       '3/64': 0.046875,
      '7/128': 0.0546875,
       '1/16': 0.0625,
       '3/32': 0.09375,
       '7/64': 0.109375,
     '15/128': 0.1171875,
        '1/8': 0.125,
       '3/16': 0.1875,
       '7/32': 0.21875,
      '15/64': 0.234375,
     '31/128': 0.2421875,
        '1/4': 0.25,
        '3/8': 0.375,
       '7/16': 0.4375,
      '15/32': 0.46875,
      '31/64': 0.484375,
     '63/128': 0.4921875,
        '1/2': 0.5,
        '3/4': 0.75,
        '7/8': 0.875,
      '15/16': 0.9375,
      '31/32': 0.96875,
      '63/64': 0.984375,
    '127/128': 0.9921875,
          '1': 1.0,
        '3/2': 1.5,
        '7/4': 1.75,
       '15/8': 1.875,
      '31/16': 1.9375,
      '63/32': 1.96875,
     '127/64': 1.984375,
    '255/128': 1.9921875,
          '2': 2.0,
          '3': 3.0,
        '7/2': 3.5,
       '15/4': 3.75,
       '31/8': 3.875,
      '63/16': 3.9375,
     '127/32': 3.96875,
     '255/64': 3.984375,
    '511/128': 3.9921875,
       }

legal_mc_notes = {
        0.015625 : '64',
       0.0234375 : '64d',
         0.03125 : '32',
        0.046875 : '32d',
          0.0625 : '16',
         0.09375 : '16d',
           0.125 : '8',
          0.1875 : '8d',
            0.25 : '4',
           0.375 : '4d',
             0.5 : '2',
            0.75 : '2d',
             1.0 : '1',
             1.5 : '1d',
}

global legal_floating
legal_floating = dict((y,x) for x,y in legal_notes.items())
global legal_floating_times
legal_floating_times = sorted(legal_notes.values())

global DECORATIONS
DECORATIONS = '+'
#-- DECORATIONS = '!'

global vlprint
vlprint = { 15: 'ppp',
            31: 'pp',
            47: 'p',                # 61 = p    for 0..127      (2+1)*16-1
            63: 'mp',
            79: 'mf',
            95: 'f',                # 98 = f    for 0..127      (5+1)*16-1
            111: 'ff',
            127: 'fff',             #                           (7+1)*16-1
          }
global S_vlprint                    # First is this note volume, 2nd is following note volumes.
S_vlprint = { 
              'fp':[95,47],         # f for one note, then p.
              'sfp':[95,47],         # f for one note, then p.
              'sffp':[111,47],         # ff for one note, then p.
              'sfff':[127,-1],
              'sfffp':[127,47],
              'sff':[111,-1],
              'sf':[95,-1],
              'sfz':[95,-1],        # 95, then regain volume back to what it was - i.e. vol(95).
              'fz':[95,-1],         # f, then back to what it was.
              'smf':[79,-1],
              'smfz':[79,-1],
              'smp':[63,-1],
              'smpz':[63,-1],
              'sp':[47,-1],
              'spz':[47,-1],
              'spf':[47,95],
              'spp':[31,-1],
              'sppz':[31,-1],
              'sppf':[31,95],
              'sppp':[15,-1],
              'spppz':[15,-1],
              'spppf':[15,95],
            }
# ------------------------------------------------------------------------------
global instruments
instruments = {
    'Acoustic Grand Piano'.lower() : 1,
    'Bright Acoustic Piano'.lower() : 2,
    'Electric Grand Piano'.lower() : 3,
    'Honky-tonk Piano'.lower() : 4,
    'Electric Piano 1'.lower() : 5,
    'Electric Piano 2'.lower() : 6,
    'Harpsichord'.lower() : 7,
    'Clavi'.lower() : 8,
    'Celesta'.lower() : 9,
    'Glockenspiel'.lower() : 10,
    'Music Box'.lower() : 11,
    'Vibraphone'.lower() : 12,
    'Marimba'.lower() : 13,
    'Xylophone'.lower() : 14,
    'Tubular Bells'.lower() : 15,
    'Dulcimer'.lower() : 16,
    'Drawbar Organ'.lower() : 17,
    'Percussive Organ'.lower() : 18,
    'Rock Organ'.lower() : 19,
    'Church Organ'.lower() : 20,
    'Reed Organ'.lower() : 21,
    'Accordion'.lower() : 22,
    'Harmonica'.lower() : 23,
    'Tango Accordion'.lower() : 24,
    'Acoustic Guitar (nylon)'.lower() : 25,
    'Acoustic Guitar (steel)'.lower() : 26,
    'Electric Guitar (jazz)'.lower() : 27,
    'Electric Guitar (clean)'.lower() : 28,
    'Electric Guitar (muted)'.lower() : 29,
    'Overdriven Guitar'.lower() : 30,
    'Distortion Guitar'.lower() : 31,
    'Guitar Harmonics'.lower() : 32,
    'Acoustic Bass'.lower() : 33,
    'Electric Bass (finger)'.lower() : 34,
    'Electric Bass (pick)'.lower() : 35,
    'Fretless Bass'.lower() : 36,
    'Slap Bass 1'.lower() : 37,
    'Slap Bass 2'.lower() : 38,
    'Synth Bass 1'.lower() : 39,
    'Synth Bass 2'.lower() : 40,
    'Violin'.lower() : 41,
    'Viola'.lower() : 42,
    'Cello'.lower() : 43,
    'Contrabass'.lower() : 44,
    'Tremolo Strings'.lower() : 45,
    'Pizzicato Strings'.lower() : 46,
    'Orchestral Harp'.lower() : 47,
    'Timpani'.lower() : 48,
    'String Ensemble 1'.lower() : 49,
    'String Ensemble 2'.lower() : 50,
    'Synth Strings 1'.lower() : 51,
    'Synth Strings 2'.lower() : 52,
    'Choir Aahs'.lower() : 53,
    'Voice Oohs'.lower() : 54,
    'Synth Voice'.lower() : 55,
    'Orchestra Hit'.lower() : 56,
    'Trumpet'.lower() : 57,
    'Trombone'.lower() : 58,
    'Tuba'.lower() : 59,
    'Muted Trumpet'.lower() : 60,
    'French Horn'.lower() : 61,
    'Brass Section'.lower() : 62,
    'Synth Brass 1'.lower() : 63,
    'Synth Brass 2'.lower() : 64,
    'Soprano Sax'.lower() : 65,
    'Alto Sax'.lower() : 66,
    'Tenor Sax'.lower() : 67,
    'Baritone Sax'.lower() : 68,
    'Oboe'.lower() : 69,
    'English Horn'.lower() : 70,
    'Bassoon'.lower() : 71,
    'Clarinet'.lower() : 72,
    'Piccolo'.lower() : 73,
    'Flute'.lower() : 74,
    'Recorder'.lower() : 75,
    'Pan Flute'.lower() : 76,
    'Blown bottle'.lower() : 77,
    'Shakuhachi'.lower() : 78,
    'Whistle'.lower() : 79,
    'Ocarina'.lower() : 80,
    'Lead 1 (square)'.lower() : 81,
    'Lead 2 (sawtooth)'.lower() : 82,
    'Lead 3 (calliope)'.lower() : 83,
    'Lead 4 (chiff)'.lower() : 84,
    'Lead 5 (charang)'.lower() : 85,
    'Lead 6 (voice)'.lower() : 86,
    'Lead 7 (fifths)'.lower() : 87,
    'Lead 8 (bass + lead)'.lower() : 88,
    'Pad 1 (new age)'.lower() : 89,
    'Pad 2 (warm)'.lower() : 90,
    'Pad 3 (polysynth)'.lower() : 91,
    'Pad 4 (choir)'.lower() : 92,
    'Pad 5 (bowed)'.lower() : 93,
    'Pad 6 (metallic)'.lower() : 94,
    'Pad 7 (halo)'.lower() : 95,
    'Pad 8 (sweep)'.lower() : 96,
    'FX 1 (rain)'.lower() : 97,
    'FX 2 (soundtrack)'.lower() : 98,
    'FX 3 (crystal)'.lower() : 99,
    'FX 4 (atmosphere)'.lower() : 100,
    'FX 5 (brightness)'.lower() : 101,
    'FX 6 (goblins)'.lower() : 102,
    'FX 7 (echoes)'.lower() : 103,
    'FX 8 (sci-fi)'.lower() : 104,
    'Sitar'.lower() : 105,
    'Banjo'.lower() : 106,
    'Shamisen'.lower() : 107,
    'Koto'.lower() : 108,
    'Kalimba'.lower() : 109,
    'Bag pipe'.lower() : 110,
    'Fiddle'.lower() : 111,
    'Shanai'.lower() : 112,
    'Tinkle Bell'.lower() : 113,
    'Agogo'.lower() : 114,
    'Steel Drums'.lower() : 115,
    'Woodblock'.lower() : 116,
    'Taiko Drum'.lower() : 117,
    'Melodic Tom'.lower() : 118,
    'Synth Drum'.lower() : 119,
    'Reverse Cymbal'.lower() : 120,
    'Guitar Fret Noise'.lower() : 121,
    'Breath Noise'.lower() : 122,
    'Seashore'.lower() : 123,
    'Bird Tweet'.lower() : 124,
    'Telephone Ring'.lower() : 125,
    'Helicopter'.lower() : 126,
    'Applause'.lower() : 127,
    'Gunshot'.lower() : 128,
}

global extrainfo
extrainfo = {
    #                           91   10    7
    #  control_c            Reverb, Pan, Volume
      74: ["flute",             52,   8,  84],
      72: ["clarinet",          57,  16,  78],
      69: ["oboe",              55,  16,  84],
      61: ["french horn",       62,  32,  74],
      49: ["string ensemble",   60,  48, 127],
      41: ["violin",            60,  48, 119],
  '41-1': ["violin1",           60,  16, 127],
  '41-2': ["violin2",           60,  44, 119],
      42: ["viola",             60,  64,  95],
      43: ["cello",             60,  80,  87],
      71: ["bassoon",           57,  96,  79],
      45: ["tremola strings",   72, 112,  72],
      46: ["pizzicato strings", 72, 112,  72],
      44: ["contrabass",        72, 120,  72],
       0: ["default",            0,  64,  100],
}

# Flute
# 2, 0, Program_c, 0, 73
# 2, 0, Control_c, 0, 7, 84
# 2, 0, Control_c, 0, 10, 37
# 2, 0, Control_c, 0, 91, 52
# ------------------------------------------------------------------------------
# Oboe
# 3, 0, Program_c, 1, 68
# 3, 0, Control_c, 1, 7, 84
# 3, 0, Control_c, 1, 10, 64
# 3, 0, Control_c, 1, 91, 55
# ------------------------------------------------------------------------------
# Clarinetti
# 4, 0, Program_c, 2, 71
# 4, 0, Control_c, 2, 7, 78
# 4, 0, Control_c, 2, 10, 60
# 4, 0, Control_c, 2, 91, 57
# ------------------------------------------------------------------------------
# Bassoon
# 5, 0, Program_c, 3, 70
# 5, 0, Control_c, 3, 7, 79
# 5, 0, Control_c, 3, 10, 89
# 5, 0, Control_c, 3, 91, 57
# ------------------------------------------------------------------------------
# French horn
# 6, 0, Program_c, 4, 60
# 6, 0, Control_c, 4, 7, 74
# 6, 0, Control_c, 4, 10, 46
# 6, 0, Control_c, 4, 91, 62
# ------------------------------------------------------------------------------
# Violin
# 7, 0, Program_c, 5, 48
# 7, 0, Control_c, 5, 7, 127
# 7, 0, Control_c, 5, 10, 16
# 7, 0, Control_c, 5, 91, 60
# ------------------------------------------------------------------------------
# Violin
# 8, 0, Program_c, 6, 48
# 8, 0, Control_c, 6, 7, 119
# 8, 0, Control_c, 6, 10, 44
# 8, 0, Control_c, 6, 91, 60
# 
# 8, 28928, Program_c, 6, 45
# 8, 28928, Control_c, 6, 7, 119
# 8, 28928, Control_c, 6, 10, 44
# 8, 28928, Control_c, 6, 91, 59
# 
# 8, 33152, Program_c, 6, 48
# 8, 33152, Control_c, 6, 7, 119
# 8, 33152, Control_c, 6, 10, 44
# 8, 33152, Control_c, 6, 91, 59
# ------------------------------------------------------------------------------
# Viola
# 9, 0, Program_c, 7, 48
# 9, 0, Control_c, 7, 7, 95
# 9, 0, Control_c, 7, 10, 64
# 9, 0, Control_c, 7, 91, 60
# 
# 9, 28928, Program_c, 7, 45
# 9, 28928, Control_c, 7, 7, 95
# 9, 28928, Control_c, 7, 10, 64
# 9, 28928, Control_c, 7, 91, 59
# 
# 9, 34048, Program_c, 7, 48
# 9, 34048, Control_c, 7, 7, 95
# 9, 34048, Control_c, 7, 10, 64
# 9, 34048, Control_c, 7, 91, 59
# ------------------------------------------------------------------------------
# Cello
# 10, 0, Program_c, 8, 48
# 10, 0, Control_c, 8, 7, 87
# 10, 0, Control_c, 8, 10, 94
# 10, 0, Control_c, 8, 91, 60
# 
# 10, 28928, Program_c, 8, 45
# 10, 28928, Control_c, 8, 7, 87
# 10, 28928, Control_c, 8, 10, 94
# 10, 28928, Control_c, 8, 91, 59
# 
# 10, 33664, Program_c, 8, 48
# 10, 33664, Control_c, 8, 7, 87
# 10, 33664, Control_c, 8, 10, 94
# 10, 33664, Control_c, 8, 91, 59
# ------------------------------------------------------------------------------
# Contra-Bass
# 11, 0, Program_c, 10, 48
# 11, 0, Control_c, 10, 7, 72
# 11, 0, Control_c, 10, 10, 102
# 11, 0, Control_c, 10, 91, 72
# 
# 11, 28928, Program_c, 10, 45
# 11, 28928, Control_c, 10, 7, 72
# 11, 28928, Control_c, 10, 10, 102
# 11, 28928, Control_c, 10, 91, 59
#-----------------------------------------------------------------------------
#-----------------------------------------------------------------------------
global args
global errors_happened
errors_happened = 0                 # system exit, 0 = okay, 1 = errors happened

global linecount
linecount = 0

global putds                        # "micro" and it's replacement/substitution.
putds    = { }                      # dictionary of from:to

global gotos                        # gotos and it's arguments.
gotos = []

global meas                         # measure names.
meas = []
global measure_on                   # The measure/unit are we are working on.
measure_on = ''                     # Default to none. This means we are in the header section.
global bars                         # number of bars per staff
bars = NUMBER_BARS_PER_STAFF        # for abc notation, put new line in output, which ends staff.

global voices                       # number of voices
voices = 1
global cis                          # if cis active, non-zero.
cis = 0

global vl                           # volume levels
vl = { }                            # vl[voice][m] = volumelevel
vl[1] = { }                         # vl[voice][m] = volumelevel
vl[1][''] = 127                     # vl[voice][m] = volumelevel
global running_vl                   # volume levels changing thru measures. (set vl to running_vl at measure.)
running_vl = { }                    # running_vl[voice][m] = volumelevel
running_vl[1] = { }                 # running_vl[voice][m] = volumelevel
running_vl[1][''] = 127             # running_vl[voice][m] = volumelevel

global xpose
xpose = {}
global xpose_new_key                # lowercase normal musicomp usage.
xpose_new_key = {}

global clef
clef = { }                          # no clef specified [measure][voice].
clef[''] = { }
global vinstrument
vinstrument = { }                   # no instruments specified [measure][voice].
global reverb
reverb = { }                        # Reverb value for voice.
global pan
pan = { }                           # Pan (balance 0=left, 126=right, 64=center) for voice.
global intensity
intensity = { }                     # Instrument intensity (volume).
#...
vinstrument[''] = {}                # blank measure.
reverb[''] = {}
pan[''] = {}
intensity[''] = {}

global cresc_volume
cresc_volume = [ ]
global cresc_time
cresc_time = []
global cresc_direction
cresc_direction = []
for i in range(1, MAXVOICES+1):     # This is used as [1] .. [MAXVOICES]
    vinstrument[''][i] = 0          # No instrument. (measure, voice)
    reverb[''][i] = 0
    pan[''][i] = 64
    intensity[''][i] = 100
    clef[''][i] = {}
    clef[''][i] = 'treble'          # No clef.       (voice, measure)
    xpose[i] = 0
    xpose_new_key[i] = 'c'          # No new key.   Text!
    cresc_volume.append(0)
    cresc_time.append(0)
    cresc_direction.append(True)
# rof
global inst
inst = { }                          # track using instrument by instrument.
global oct                          # default octave
oct = { 1 : 0 }
global acc_v_init                   # Last accidental on a note in measure.
global acc_v_init_v_or_h            # Last accidental on a note in measure.
acc_v_init = { 'C':'', 'D':'', 'E':'', 'F':'', 'G':'', 'A':'', 'B':''}
acc_v_init_v_or_h = { 'c':'', 'd':'', 'e':'', 'f':'', 'g':'', 'a':'', 'b':''}
acc_m = { '': {''}}                 # voice: {notes:'+'/-/n}    For this measure, index is voice.
                                    # acc_v_init or acc_v_init_v_or_h: note (a-g): last accidental in # measure.
global acc_m_xpose
acc_m_xpose = { '': {''}}           # After xpose, the new key ... voice: {notes:'+'/-/n}

global time                         # set default note length (time)
time = { 1 : 0 }
global mlth                         # measure length dictionary
mlth = { 1 : { measure_on: 0} }     # nothing in measure working on -- voice 1.
global tlth                         # #or 60ths/voice
tlth = { 1 : 0 }                    # 60ths of a second in a voice -- nothing in measure working on.
global bufs                         # bufs[voice][measure] = text line.
#                                   # ABC format, or musicomp format separated by commas.
bufs = { 1 : {} }
global bufs_length                  # bufs_length[voice][measure][#] ... number= 0..#commas-1 above.
bufs_length = { 1 : {} }
global bufs_accidental              # bufs_length[voice][measure][#] ... number= 0..#commas-1 above.
bufs_accidentals = { 1: {} }
global bufs_tie_next
bufs_tie_next = { 1: '' }
global bufs_vol
bufs_vol = { 1: {} }

global lstac
global lgrace
global lpause
lstac = lgrace = lpause = 4         # starting staccato, grace note, lpause as 4/60th of a second

global iftest                       # check if after if or else.
iftest = { 0:-1 }                   # -1 = processing in if, 0 = skip till else,
#                                   # 1 processing in else, 2 = skip till endif,
#                                   # 3 = skip both if and else.
global ifdepth                      # level of if/else/endif
ifdepth = 0
global cstop_processing
cstop_processing = False            # True if after a cstop.

global macro_internal               # Next internal macro.
macro_internal = 0                  # Number for internal macros (note processing internal macros).
global macro_defining               # If defining macro.
macro_defining = None
global macro_buffer                 # Name of macro, array of lines for macro.
macro_buffer = { '':''}
global macro_arguments              # Name of macro, array of arguments for macro.
macro_arguments = { '':''}

global macro_executing_depth        # If processing macro ... reading from macro buffer.
macro_executing_depth = []          # The macro name currently working on is the last name in the array.
global macro_executing_args         # Depth, array of arguments given to macro.
macro_executing_args = { 0:[] }
global macro_line                   # Depth, line in macro array.
macro_line = { 0:0 }                # Depth, macro name

global header                       # Header to print at top of file.

global meter
global measure_meter

global key_default
key_default = None                  # First key applies globally, if not voice number arguments.
global key_voice                    # Running key by measure then voice.
key_voice = { '': {} }

# This should really be 'where it occurs'.
global tempo_speed_default          # beats per minute
tempo_speed_default = 150.0
global default_note_length          # length of a beat (note)
default_note_length = { '': 1.0 / 4.0 } # before a measure.
global tempo_speed_now              # beats per minute for each measure.
tempo_speed_now = { '': tempo_speed_default }
global tempo_now_note_length          # length of a beat (note)
tempo_now_note_length = { '': 1.0 / 4.0 } # before a measure.

global file_name                    # None = use tty.
global output_name                  # File to print to (default is sys.stdout).
#-----------------------------------------------------------------------------
def print_error(strg, line):
    global linecount
    global errors_happened

    errors_happened = 1             # When exiting, do 1 instead of 0

    print("ERROR -", strg, file=sys.stderr)
    print("  Line {} - {}".format(linecount, line), file=sys.stderr)
    return
# End of print_error

#-----------------------------------------------------------------------------
def print_warning(strg, line):
    global linecount

    print("WARNING -", strg, file=sys.stderr)
    print("  Line {} - {}".format(linecount, line), file=sys.stderr)
    return
# End of print_warning

#-----------------------------------------------------------------------------
# Returns: lengthl - value given, like 4 for quarter note.
#          lengthf - value in floating, 0.25 for a quarter note.
#          ifokay  - True if everything is okay.
def get_time_stak(timeofnote, line):
    global default_note_length          # length of a beat (note)
    global legal_floating_times
    global measure_on
    global args

    if timeofnote <= 0.0:
        print_error("timeofnote '{}' negative or zero -- cannot play a note backwards.".format(timeofnote), line)
        return timeofnote, 0, -1    # False
    # fi
    lengthl = []
    lengthf = []
    t = timeofnote
    for i in reversed(range(len(legal_floating_times))):
        f = legal_floating_times[i]
        while True:
            if f > t:
                break
            # fi
            if args.horizontal or args.vertical:
                v = f
                v = 1.0 / v
                if f in legal_mc_notes:
                    vv = legal_mc_notes[f]
                else:
                    vv = str(Fraction(v).limit_denominator(256))
                    if '/' in vv:
                        vv = '(' + str(f) + ')'
                    # fi
                # fi
                v = vv
            elif args.midi1csv:
                v = round((f * 4.0) * MIDICLICKSPERQUARTER)
            else:       # ABC
                v = f / default_note_length[measure_on]
                v = str(Fraction(v).limit_denominator(256))
                if v[0:2] == '1/':
                    v = v[1:]
                # fi
            # fi
            lengthl.append(v)
            lengthf.append(f)
            t = t - f
            if t <= 0:                  # This isn't needed, but makes me more comfortable.
                break
            # fi
        # elihw
    # rof
    if t > 0:
        print_warning("timeofnote={} -> {} has left-over of t={}".format(timeofnote,lengthl,t), line)
        return lengthl, lengthf, 1      # Problems
    # fi
    if not lengthl or len(lengthl) == 0:
        print_error("timeofnote '{}' not able to return a usable fraction - min of 1/64".format(timeofnote), line)
        return timeofnote, 0, -1    # False
    # fi
    return lengthl, lengthf, 0      # True
# End of get_time_stak

#-----------------------------------------------------------------------------
def default_note_text_fraction(m):
    global default_note_length
    global legal_notes

    l = str(Fraction(default_note_length[m]).limit_denominator(256))
    if l not in legal_notes:
        print_warning("#1 Time fraction '{}' is not a printable note. ({})".format(default_note_length[m],l), line)
    # fi
    return(l)
# End of default_note_text_fraction

#-----------------------------------------------------------------------------
def new_voice_initialize(voice, m):
    global vl                           # volume levels
    global vinstrument
    global reverb
    global pan
    global intensity
    global oct                          # default octave
    global time                         # set default note length (time)
    global mlth                         # measure length dictionary
    global tlth                         # #or 60ths/voice
    global bufs
    global bufs_length
    global bufs_accidentals
    global bufs_tie_next
    global bufs_vol
    global acc_m
    global acc_m_xpose
    global acc_v_init                   # Last accidental on a note in measure.
    global acc_v_init_v_or_h            # Last accidental on a note in measure.
    global args
    global running_vl                   # volume levels changing thru measures.
    global key_default
    global key_voice
    global clef

    if voice not in vl:
        vl[voice] = { }                 # Dictionary
        running_vl[voice] = { }
    if voice not in oct:
        oct[voice] = 0                  # last octave starts at zero
    if voice not in time:
        time[voice] = 0                 # last time starts at zero
    if voice not in mlth:
        mlth[voice] = {}
    if voice not in tlth:
        tlth[voice] = 0                 # #or 60ths/voice
    if voice not in bufs:
        bufs[voice] = {}
        bufs_length[voice] = {}
        bufs_accidentals[voice] = {}
        bufs_tie_next[voice] = ''
        bufs_vol[voice] = {}
    # fi

    if m not in vl[voice]:
        vl[voice][m] = 127              # start volume out at maximum
        running_vl[voice][m] = 127

    if m not in vinstrument:
        vinstrument[m] = {}
        reverb[m] = {}
        pan[m] = {}
        intensity[m] = {}
    # fi
    if voice not in vinstrument[m]:
        vinstrument[m][voice] = 0
        reverb[m][voice] = 0
        pan[m][voice] = 64
        intensity[m][voice] = 100

    if m not in key_voice:
        key_voice[m] = {}
    # fi
    if voice not in key_voice[m]:
        key_voice[m][voice] = key_default
    # fi

    if m not in mlth[voice]:
        mlth[voice][m] = 0              # measure length dictionary
    # fi
    if voice not in acc_m:
        if args.horizontal or args.vertical:
            acc_m[voice] =  {k: v for k, v in acc_v_init_v_or_h.items()}
            acc_m_xpose[voice] =  {k: v for k, v in acc_v_init_v_or_h.items()}
        elif args.midi1csv:
            acc_m[voice] =  {k: v for k, v in acc_v_init_v_or_h.items()}
            acc_m_xpose[voice] =  {k: v for k, v in acc_v_init_v_or_h.items()}
        else:           # ABC
            acc_m[voice] =  {k: v for k, v in acc_v_init.items()}
            acc_m_xpose[voice] =  {k: v for k, v in acc_v_init.items()}
        # fi
    # fi

    for j in vl:
        if m not in clef:
            clef[m] = {}
        # fi
        if m not in clef or j not in clef[m]:
            for k in reversed(range(0, len(meas)-1)):
                mmm = meas[k]
                if mmm in clef and j in clef[mmm]:
                    nc = clef[mmm][j]
                    break
                # fi
            # rof
        else:
            nc = clef[m][j]
        # fi
        clef[m][j] = nc
    # rof
    return
# End of new_voice_initialize

#-----------------------------------------------------------------------------
# Get volume levels at measures -- the volume(s) commands work at that point..
def get_volume_level(m, voice):
    global vl                           # volume levels
    global vlprint
    global args
    global DECORATIONS

    new_voice_initialize(voice, m)
    j = vl[voice][m]                    # volume level for this voice/measure
    if args.horizontal or args.vertical:
        return j
    # fi
    if args.midi1csv:
        return j
    # fi
    j = int(j / 16)
    j = (j * 16) + 15                   # convert so can do index on vlprint.
    return (DECORATIONS + vlprint[j] + DECORATIONS)
# End of get_volume_level

#-----------------------------------------------------------------------------
def rests_in_empty_measure_voices(m, voice):
    global vl                               # volume levels
    global meas
    global mlth
    global bufs
    global bufs_length
    global bufs_accidentals
    global bufs_tie_next
    global bufs_vol
    global args
    global running_vl

    if m in bufs[voice]:                    # Already present, then of right length.
        return
    # fi
    # No text for this voice, create rests to fill it out.
    l = 0
    for i in range(1, len(vl)+1):
        if m in mlth[i]:
            l = max(mlth[i][m], l)
        # fi
    # rof
    if m in mlth[voice]:
        l = l - mlth[voice][m]              # All measure lengths with voices are the same.
    # fi
    if m not in bufs[voice]:
        bufs_vol[voice][m] = []
        if args.horizontal or args.vertical or args.midi1csv:
            bufs[voice][m] = []
            bufs_length[voice][m] = []
            bufs_accidentals[voice][m] = []
            bufs_tie_next[voice] = ''
        else:       # ABC
            bufs[voice][m] = ''
        # fi
    # fi
    if voice in running_vl and m in running_vl[voice]:
        tt = running_vl[voice][m]
    else:
        tt = 127                            # Probably a rest, put as full volume.
    # fi
    bufs_vol[voice][m].append( tt )
    # Put out rests.
    if l <= 0:                              # if nothing to do.
        return
    # fi
    txt = ''
    if args.horizontal or args.vertical or args.midi1csv:
        pass
    else:       # ABC
        lengthl, lengthf, ifokay = get_time_stak(l, 'pass2')
        for i in range(len(lengthl)):
            txt = txt + ' z' + lengthl[i]       # entry in array
        # rof
        if txt == '':
            print_error('% no music for voice {} in measure {}'.format(voice,m), 'pass2')
            return
        # fi
    # fi

    bufs_tie_next[voice] = ''
    if args.horizontal or args.vertical:
        bufs[voice][m].append('r')
        bufs_length[voice][m].append(l)
        bufs_accidentals[voice][m].append('')
    elif args.midi1csv:
        bufs[voice][m].append(0)
        bufs_length[voice][m].append(l)
        bufs_accidentals[voice][m].append('')
    else:       # ABC
        bufs[voice][m] = bufs[voice][m] + txt   # Append the sleeps.
    # fi
    return
# End of rests_in_empty_measure_voices

#-----------------------------------------------------------------------------
def print_measure_abc(m, voice, l_meter, l_tempo, l_dl, l_clef, l_instrument, l_vl, l_txt, l_ky):
    global bufs
    #-- global vl
    global measure_meter
    global clef
    global meas
    global vinstrument
    global reverb
    global pan
    global intensity
    global key_voice                        # Running key by voice.
    global tempo_speed_now

    if voice not in bufs:
        return "ERROR - bufs voice dictionary is hosed.", '', '', '', '', ''
    # fi
    pr = l_txt
    # if first measure, and doing voice, output V:# line.
    if m == meas[0] or (m in clef and voice in clef[m] and l_clef != clef[m][voice]):
        if pr != '':
            pr = pr + '\n'
        # fi
        #-- pr = pr + "V:{}".format(len(vl) - voice + 1)
        pr = pr + "V:{}".format(voice)
        if m in clef and voice in clef[m]:
            if clef[m][voice] != l_clef:
                l_clef = clef[m][voice]
                pr = pr + ' clef={}'.format(l_clef)
            # fi
        # fi
        pr = pr + '\n'
    # fi
    if voice not in vinstrument[m]:
        vinstrument[m][voice] = 0
        reverb[m][voice] = 0
        pan[m][voice] = 64
        intensity[m][voice] = 100
    # fi

    if len(vinstrument[m]) >= voice and vinstrument[m][voice] != 0:
        if l_instrument != vinstrument[m][voice]:
            l_instrument = vinstrument[m][voice]
            if pr != '' and pr[-1] != '\n':
                pr = pr + '\n'
            # fi
            pr = pr + "%%MIDI program {}\n".format(l_instrument)
        # fi
    # fi

    # if default note length != last one
    if l_dl != default_note_text_fraction(m):
        l_dl = default_note_text_fraction(m)
        if l_dl == '1':
            p_dl = '1/1'
        else:
            p_dl = l_dl
        # fi
        pr = pr + "[L:{}]".format(l_dl)
    # fi

    if l_tempo != tempo_speed_now[m]:
        l_tempo = tempo_speed_now[m]
        pr = pr + "[Q:{}={}]".format(l_dl, l_tempo)
    # fi

    vvv = voice
    if vvv in key_voice[m]:
        if l_ky != key_voice[m][vvv]:
            ky = key_voice[m][vvv]
            pr = pr + "[K:{}]".format(ky)
            l_ky = ky
        # fi
    # fi
    #-- # fi
    # if meter != last one
    if l_meter != measure_meter[m]:
        l_meter = measure_meter[m]
        pr = pr + "[M:{}]".format(l_meter)
    # fi
    j = get_volume_level(m, voice)
    v_vl = j

    if v_vl != l_vl:
        pr = pr + v_vl
        l_vl = v_vl
    # fi
    pr = pr + bufs[voice][m] + ' |'
    return pr, l_meter, l_tempo, l_dl, l_clef, l_instrument, l_vl, l_ky
# End of print_measure_abc

#-----------------------------------------------------------------------------
def print_out_abc():
    global vl                               # volume levels
    global meas                             # measures
    global bars                             # number of bars per staff
    global output_name
    global key_default

    #-- for voice in reversed(range(1,len(vl)+1)):
    for voice in range(1,len(vl)+1):
        print("% --- voice", voice, ' ---', file=output_name)
        l_meter = l_dl = l_clef = l_instrument = l_vl = ''
        l_ky = key_default
        l_tempo = ''
        print_line = ''
        for i in range(0, len(meas)):
            m = meas[i]
            if (i % bars) == 0:                # Zero-th one is ''.
                if print_line != '':
                    print_line = print_line + '\n'
                # fi
                print(print_line + "% measure {}".format(m), file=output_name)
                print_line = ''
            # fi
            print_line, l_meter, l_tempo, l_dl, l_clef, l_instrument, l_vl, l_ky = print_measure_abc(m, voice,
                        l_meter, l_tempo, l_dl, l_clef, l_instrument, l_vl, print_line, l_ky)
        # rof
        if print_line != '':
            print_line = print_line + ']'
            print(print_line, file=output_name)
        # fi
    # fi
    return
# End of print_out_abc

#-----------------------------------------------------------------------------
# input:
#   m               The measure.
#   l_meter         Last meter.
#   l_clef          Last clef for voices.
#   l_instrument    Last Instrument for voices.
#   l_vl            Last volume array for voices.
#   l_txt           (print_line entry)
#   l_ky            Last key for this voice.
#   l_tempo         Last tempo
#   l_t_n_l         Last tempo note length.
# returns:
#   print_line
#   l_meter
#   l_dl
#   l_clef
#   l_instrument
#   l_vl
#   l_ky
#   l_tempo
#   l_t_n_l

#   measure xyz
#   meter   x/y
#   clef    abc,def,ghi,jkl,mno,pqr
#   volume  4,5,6,7,6,5
#   tempo   100,4
#   voice   6   30,40,50,60,70,80           $$ needed if volume changes.
#   v1: 3c4, ...
#   vX: 3e4, ...

def print_measure_vh_header(m, l_meter, l_clef, l_instrument, l_vl, l_txt, l_ky, l_tempo, l_t_n_l):
    global vl
    global measure_meter
    global clef
    global vinstrument
    global key_voice
    global tempo_speed_now
    global tempo_now_note_length

    pr = n_meter = n_clef = n_instrument = n_vl = ''

    pr = pr + "measure {}\n".format(m)

    n_meter = measure_meter[m]
    if l_meter != n_meter:
        pr = pr + 'meter   {}\n'.format(n_meter)
    # fi

    n_clef = ''
    for voice in range(1,len(vl)+1):
        if m in clef and voice in clef[m]:
            t = str(clef[m][voice])
            if n_clef == '':
                n_clef = t
            else:
                n_clef = n_clef + ',' + t
            # fi
        # fi
    # rof
    if l_clef != n_clef:
        pr = pr + 'clef    {}\n'.format(n_clef)
    # fi

    pv = False

    for voice in range(1,len(vl)+1):
        new_voice_initialize(voice, m)
        t = str(get_volume_level(m, voice))
        if n_vl == '':
            n_vl = t
        else:
            n_vl = n_vl + ',' + t
        # fi
    # rof
    if l_vl != n_vl:
        pr = pr + 'volumes {}\n'.format(n_vl)
        pv = True
    # fi

    for voice in range(1,len(vl)+1):
        if voice in vinstrument[m]:
            t = vinstrument[m][voice]
            if n_instrument == '':
                n_instrument = str(t)
            else:
                n_instrument = n_instrument + ',' + str(t)
            # fi
        # fi
    # rof

    if l_instrument != n_instrument or pv:
        if n_instrument != '':
            pr = pr + 'voice   {}    {}\n'.format(len(vl), n_instrument)
        else:
            pr = pr + 'voice   {}\n'.format(len(vl))
        # fi
    # fi

    for voice in range(1,len(vl)+1):
        if voice in key_voice[m]:
            if l_ky[voice] != key_voice[m][voice]:
                l_ky[voice] = key_voice[m][voice]
                pr = pr + "key     {}  {}\n".format(voice,l_ky[voice])
            # fi
        # fi
    # rof

    if l_tempo != tempo_speed_now[m] or l_t_n_l != tempo_now_note_length[m]:
        l_tempo = tempo_speed_now[m]
        l_t_n_l = tempo_now_note_length[m]
        l = str(Fraction(1.0 / l_t_n_l).limit_denominator(256))
        pr = pr + "tempo   {},{}\n".format(l_tempo, l)
    # fi
        
    pr = l_txt + pr
    return pr, n_meter, n_clef, n_instrument, n_vl, l_ky, l_tempo, l_t_n_l
# End of print_measure_vh_header

#-----------------------------------------------------------------------------
def print_out_notes_v_or_h(m, print_line):
    global args
    global vl
    global bufs
    global bufs_length
    global bufs_vol
    global bufs_accidentals

    if args.vertical:
        txt = ''
        for voice in range(1,len(vl)+1):
            if len(bufs[voice][m]) == 0:
                continue
            # fi
            txt = txt + "v{}: ".format(voice)
            for i in range(0,len(bufs[voice][m])):
                if i != 0:
                    txt = txt + ', '
                # fi
                l =  bufs_length[voice][m][i]
                if l in legal_mc_notes:
                    lth = legal_mc_notes[l]
                else:
                    lth = str(Fraction(l).limit_denominator(256))
                    if '/' in lth:
                        lth = '(' + str(l) + ')'
                    # fi
                # fi
                txt = txt + bufs[voice][m][i] + lth + bufs_accidentals[voice][m][i]
            # rof
            txt = txt + '\n'
        # rof
        print_line = print_line + txt
        return print_line
    # fi
    # else - horizontal

    ml = mlth[1][m]
    for i in range(1, len(vl)+1):
        if m in mlth[i]:
            if mlth[i][m] != ml:
                print("voice#{} measure#{} not same length({}) as 1st({})".format(i,m,mlth[i][m],ml), file=sys.stderr)
            # fi
            ml = max(mlth[i][m], ml)
        else:
            print("voice#{} not in measure#{}".format(i,m), file=sys.stderr)
        # fi
    # rof
    workingtime = [ 0 ]                         # Zero is ignored.
    working= [ 0 ]
    for voice in range(1,len(vl)+1):
        working.append(0)
        workingtime.append(0)
    # rof

    now = 0
    txt = ' '
    while now < ml:
        for voice in range(1,len(vl)+1):
            if txt != ' ':
                txt = txt + ','
            # fi
            i = workingtime[voice]
            if i <= now:
                j = working[voice]
                l =  bufs_length[voice][m][j]

                if l in legal_mc_notes:
                    lth = "{:>3s}".format(legal_mc_notes[l] + bufs_accidentals[voice][m][j])
                else:
                    lth = str(Fraction(l).limit_denominator(256))
                    if '/' in lth:
                        lth = '(' + str(l) + ')'
                    # fi
                    lth = lth + bufs_accidentals[voice][m][j]
                # fi
                txt = txt + "{:>4s}".format(bufs[voice][m][j]) + lth
                workingtime[voice] = workingtime[voice] + l
                working[voice] = working[voice] + 1
            else:
                txt = txt + '    ' + '   '
            # fi
        # rof
        print_line = print_line + txt + '\n'
        txt = ' '
        nextmin = 999999
        for voice in range(1,len(vl)+1):
            if workingtime[voice] < nextmin:
                nextmin = workingtime[voice]
            # fi
        # rof
        now = nextmin
    # elihw
    return print_line
#   End of print_out_notes_v_or_h

#-----------------------------------------------------------------------------
# Vertical and horizontal have:
#   A header (meter, key, title, etc.)
#   voice   #
#...
#   measure xyz
#   meter   x/y
#   clef    abc,def,ghi,jkl,mno,pqr
#   #-- volume  4,5,6,7,6,5
#   tempo   100,4
#   voice   6   30,40,50,60,70,80           $$ needed if volume changes.
#   v1: 3c4, ...
#   vX: ...
#
def print_out_v_or_h():
    global vl                               # volume levels
    global meas                             # measures
    global args
    global output_name
    global key_default
    global tempo_speed_default
    global default_note_length

    print("voice   {}".format(len(vl)), file=output_name)

    l_meter = ''
    l_clef = l_instrument = l_vl = []
    l_ky = [ '' ]
    for voice in range(1,len(vl)+1):
        l_ky.append(key_default)
    # fi
    l_tempo = tempo_speed_default
    l_t_n_l = default_note_length['']
    print_line = ''

    for i in range(0, len(meas)):
        m = meas[i]
        if args.horizontal and m == meas[0]:
            print_line = print_line + "*   1"
            for j in range(2,len(vl)+1):
                print_line = print_line + "   ,{:>4s}".format(str(j))
            # rof
            print_line = print_line + "\n"
        # fi
        print_line, l_meter, l_clef, l_instrument, l_vl, l_ky, l_tempo, l_t_n_l = print_measure_vh_header(m,
                    l_meter, l_clef, l_instrument, l_vl, print_line, l_ky, l_tempo, l_t_n_l)
        # Print out notes for measure.
        print_line = print_out_notes_v_or_h(m, print_line)
    # rof
    if print_line != '':
        print(print_line, end='', file=output_name)
    # fi
    return
# End of print_out_v_or_h

#-----------------------------------------------------------------------------
def print_out_midi1csv_start(voiceprint):
    global output_name
    print('{}, 0, Start_track'.format(voiceprint), file=output_name)
#   End of print_out_midi1csv_start

#-----------------------------------------------------------------------------
def print_out_midi1csv_tempo(voiceprint, t, l, time_of_tempo):
    global output_name

    X = int(round((60.0 * 1000000.0) / ((4.0 * l)) / t))
    print("{}, {}, Tempo, {}".format(voiceprint, time_of_tempo, X), file=output_name)
# End of print_out_midi1csv_tempo

#-----------------------------------------------------------------------------
def print_header():
    global header
    global tempo_speed_default
    global default_note_length          # length of a beat (note)
    global args
    global vl
    global bars
    global output_name
    global key_voice
    global key_default
    global measure_meter
    global mlth

    if args.vertical or args.horizontal:
        l = str(Fraction(1.0 / default_note_length['']).limit_denominator(256))
        header = header + "bars    {}\n".format(bars)
        header = header + "tempo   {},{}\n".format(tempo_speed_default, l)
        header = header + "key     {}".format(key_default)       # no \n, added when printed.
        for ve in range(1,len(vl) + 1):
            if ve in key_voice[''] and key_voice[''][ve] != key_default:
                header = header + "\nkey     {}  {}".format(ve,key_voice[''][ve]) # No terminating \n.
            # fi
        # rof
    elif args.midi1csv:
# 0, 0, Header, 1, 7, 480               # 480 = midi ticks per quarter note.
        print("0, 0, Header, 1, {}, {}".format(len(vl)+1, int(round(MIDICLICKSPERQUARTER))), file=output_name)
# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
# First track does all tempo's, time and key signatures, and titles.
        print_out_midi1csv_start(1)
# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
# 1, 0, Title_t, "promenade"
        for t in header:
            print('1, 0, Title_t, "{}"'.format(t), file=output_name)
        # rof
# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
        # Initial information (first zero, add 1), and time of 0 = use default tempo/time.
        print_out_midi1csv_tempo(1, tempo_speed_default, default_note_length[''], 0)
# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
# 1, 0, Key_signature, -2, "major"
        print('1, 0, Key_signature, {}, "major"'.format(key_default), file=output_name)
# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
        maxtimelth = 0
        voice = 1
        for i in tlth:
            if maxtimelth < tlth[i]:
                maxtimelth = tlth[i]
                voice = i
            # fi
        # rof
# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
# 1, 0, Time_signature, 4, 2, 48, 8
# 2, 0, Time_signature, 5, 2, 30, 8
# 2, 2400, Time_signature, 6, 2, 72, 8
#           FF 58 04 nn dd cc bb Time Signature
#       The time signature is expressed as four numbers. nn and dd represent the
#       numerator and denominator of the time signature as it would be notated.
#       The denominator is a negative power of two: 2 represents a quarter-note,
#       3 represents an eighth-note, etc.
#       The cc parameter expresses the number of MIDI clocks in a metronome click.
#       The bb parameter expresses the number of notated 32nd-notes in what MIDI
#       thinks of as a quarter-note (24 MIDI Clocks). This was added because there
#       are already multiple programs which allow the user to specify that what
#       MIDI thinks of as a quarter-note (24 clocks) is to be notated as, or
#       related to in terms of, something else. Therefore, the complete event for
#       6/8 time, where the metronome clicks every three eighth-notes, but there
#       are 24 clocks per quarter-note, 72 to the bar, would be (in hex):
#           FF 58 04 06 03 24 08
#    4/(2^2)   72
# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
        # length of each measure. Index via [voice][measure].
        lthworkingmeasure = 0
        lastmeter = ''
        for m in mlth[voice]:
            if lastmeter != measure_meter[m]:
                lastmeter = measure_meter[m]
                l = lastmeter.split('/', 1)
                numerator = l[0]
                denominator = Log2(l[1])
                if denominator.is_integer():
                    denominator = int(denominator)
                else:
                    denominator = l[1]
                    print("meter denominator is not a power of two, leave as {}".format(denominator), file=output_name)
                # fi
                print("1, {}, Time_signature, {}, {}, 48, 8".format(
                        int(round(lthworkingmeasure)),
                        numerator, denominator), file=output_name)
            # fi
            lthworkingmeasure = lthworkingmeasure + mlth[voice][m]
        # rof
# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
# Need to have the lth of each measure - to put tempo in right place.
# NOTDONEYET - multiple tempos in song.
# NOTDONEYET -- X = int(round((60.0 * 1000000.0) / ((4.0 * default_note_length[''])) / tempo_speed_default))
# NOTDONEYET -- print("x, y, Tempo, {}".format(X), file=output_name)
# NOTDONEYET -- tempo associated within measure/bar.
# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
        print("1, {}, End_track".format(maxtimelth + 26), file=output_name)
        return
    else:                               # ABC format
        # Must be a fraction.
        fdnl = default_note_text_fraction('')
        if fdnl == '1':
            fdnl = '1/1'
        # fi
        header = header + "L:{}\n".format(fdnl)
        header = header + "Q:{}={}\n".format(fdnl, tempo_speed_default)
        header = header + "K:{}".format(key_default)       # no \n, added when printed.
    # fi
    print(header, file=output_name)
    return
# End of print_header

#-----------------------------------------------------------------------------
# returns lastmeter printed (which this routine may do).
def print_out_midi1csv_ts(last_bar_meter,voiceon,m_number, lthworkingmeasure):
    global output_name
    global meas
    global measure_meter

    m = meas[m_number]
    if last_bar_meter != measure_meter[m]:
        last_bar_meter = measure_meter[m]
        l = last_bar_meter.split('/', 1)
        numerator = l[0]
        denominator = Log2(l[1])
        if denominator.is_integer():
            denominator = int(denominator)
        else:
            denominator = l[1]
            print("meter denominator is not a power of two, leave as {}".format(denominator), file=output_name)
        # fi
        print("{}, {}, Time_signature, {}, {}, 48, 8".format(
                voiceon+1,
                int(round(lthworkingmeasure)),
                numerator, denominator), file=output_name)
    # fi
    return last_bar_meter
# End of print_measure_midi1csv_ts

#-----------------------------------------------------------------------------
# input   last_instrument_on voice, voiceon, m_number,channel,chan
# returns channel (which may be updated).
#         chan (which may be updated).
#         last_instrument_on printed (which this routine may do).
def print_out_midi1csv_instrument(last_instrument_on,voiceon,m_number,channel,chan, lthworkingmeasure):
    global vinstrument
    global reverb
    global pan
    global intensity
    global meas
    global inst
    global extrainfo
    global output_name
    global mlth

    if m_number >= len(meas):
        return channel, chan, last_instrument_on
    # fi
    m = meas[m_number]
    if voiceon not in vinstrument[m]:
        vinstrument[m][voiceon] = 0
        reverb[m][voiceon] = 0
        pan[m][voiceon] = 64
        intensity[m][voiceon] = 100
    # fi
    if len(vinstrument[m]) >= voiceon and vinstrument[m][voiceon] != 0:
        if last_instrument_on != vinstrument[m][voiceon]:
            last_instrument_on = vinstrument[m][voiceon]
            if last_instrument_on in inst:
                chan = inst[last_instrument_on]
            else:
                chan = channel
                inst[last_instrument_on] = chan
                channel = channel + 1
                if channel == 9:
                    channel = 10
                # fi
            # fi
            q = mlth[voiceon][m]
            print('{}, {}, Program_c, {}, {}'.format( voiceon+1, lthworkingmeasure, chan, last_instrument_on), file=output_name)
# 73: ["flute",             52, 37, 84],
            if last_instrument_on in extrainfo:
                print('{}, {}, Text_t, "{}"'.format(voiceon+1, lthworkingmeasure, extrainfo[last_instrument_on][0]), file=output_name)

                # 121   All Controllers Off
                print('{}, {}, Control_c, {}, {}, {}'.format( voiceon+1, lthworkingmeasure, chan, 121, 0), file=output_name)
                #  64   Hold Pedal Off
                print('{}, {}, Control_c, {}, {}, {}'.format( voiceon+1, lthworkingmeasure, chan, 64, 0), file=output_name)
                #   7   Volume
                print('{}, {}, Control_c, {}, {}, {}'.format( voiceon+1, lthworkingmeasure, chan, 7,
                                                        intensity[m][voiceon]), file=output_name)
                #  10   Pan position   64 is center, 0 is hard left, and 127 is hard right.
                print('{}, {}, Control_c, {}, {}, {}'.format( voiceon+1, lthworkingmeasure, chan, 10,
                                                        pan[m][voiceon]), file=output_name)
                #  91   Reverb Level
                print('{}, {}, Control_c, {}, {}, {}'.format( voiceon+1, lthworkingmeasure, chan, 91,
                                                        reverb[m][voiceon]), file=output_name)
            # fi
        # fi
    # fi
    return channel, chan, last_instrument_on
# End of print_out_midi1csv_instrument

#-----------------------------------------------------------------------------
def do_possible_midi_tie(voice, m_number, i, l, lastmeter, channel, chan, l_instrument, lthworkingmeasures):
    #-- global output_name
    global bufs_accidentals
    global bufs
    global bufs_accidentals
    global bufs_length
    global meas
    global mlth

    flag = False                                # if need do time signature and instrument.
    m = meas[m_number]
    n = bufs[voice][m][i]                       # Note value being tied forward to...
    while True:
        p = i+1                                 # Check next note for tied to this one.
        acc_s = bufs_accidentals[voice][m]
        # tie to next note in this measure
        if p < len(acc_s):                      # If more notes in this measure
            a = acc_s[p]
            # if note is not the same.
            if n != bufs[voice][m][p] or a != 't':
                return l, m_number, lastmeter, channel, chan, l_instrument
            # fi
            if flag:
                #-- lastmeter = print_out_midi1csv_ts(lastmeter,voice, m_number,lthworkingmeasures+l)
                lastmeter = print_out_midi1csv_ts(lastmeter,voice, m_number,lthworkingmeasures)
                channel, chan, l_instrument = print_out_midi1csv_instrument(l_instrument,voice,m_number,channel,chan,lthworkingmeasures)
                flag = False
            # fi
            tmp = bufs_length[voice][m][p]
            l = l + tmp
            bufs_length[voice][m][p] = -tmp     # Mark this length is done.
            i = p
            continue
        # fi
        # Tie to next note in next measure?
        i = -1                                  # To first of next measure.
        m_number = m_number + 1
        if m_number >= len(meas):
            return l, m_number, lastmeter, channel, chan, l_instrument
        # fi
        lthworkingmeasures = lthworkingmeasures + mlth[voice][m]
        #-- print('{}, {}, Text_t, " measure {}"'.format(voice+1, lthworkingmeasures-1, meas[m_number]), file=output_name)
        m = meas[m_number]
        flag = True                             # Need do time signature and instrument if use this.
    # elihw
#   End of do_possible_midi_tie

#-----------------------------------------------------------------------------
def print_out_midi1csv_notes():
    global vl                                   # volume levels
    global meas                                 # measures
    global inst
    global output_name
    global key_voice
    global key_default
    global tempo_speed_default
    global default_note_length                  # length of a beat (note)
    global tempo_speed_now                      # beats per minute for each measure.
    global tempo_now_note_length                # length of a beat (note)
    global bufs_accidentals
    global bufs
    global bufs_vol
    global mlth

    channel = 0                                 # next midi instrument channel to use
    chan = 0                                    # the midi channel using now (allows for repeated use).

    for voice in range(1,len(vl) + 1):
        if voice not in bufs:
            print("ERROR - bufs voice dictionary is hosed (m={}, voice={}, lthworkingmeasures={})".format(m,voice,lthworkingmeasures), file=sys.stderr)
            sys.exit(1)
        # fi
        lthworkingmeasures = 0
        lastmeter = ''
        l_instrument = '0'
        m_number = 0
        print_out_midi1csv_start(voice+1)
        print('{}, 0, Text_t, " voice {}"'.format(voice+1, voice), file=output_name)
        lt = tempo_speed_default
        ll = default_note_length['']
        print_out_midi1csv_tempo(voice+1, lt, ll, 0)
        lastmeter = print_out_midi1csv_ts(lastmeter,voice,m_number,lthworkingmeasures)
        channel, chan, l_instrument = print_out_midi1csv_instrument(l_instrument,voice,m_number,channel,chan,lthworkingmeasures)

        if '' in key_voice:
            if voice in key_voice['']:
                if key_default != key_voice[''][voice]:
                    ky = key_voice[''][voice]
                else:
                    ky = key_default
                # fi
                print('{}, 0, Key_signature, {}, "major"'.format(voice+1, ky), file=output_name)
            else:
                ky = key_default
            # fi
        else:
            ky = key_default
        # fi

        #-- print('{}, {}, Text_t, " measure {}"'.format(voice+1, lthworkingmeasures, meas[m_number]), file=output_name)
        while m_number < len(meas):             # while there are measures left to do
            t_num = m_number
            m = meas[m_number]
            # v_vl = running_vl[voice][m]         # volume level for this voice/measure
            if voice in vl and m in vl[voice]:
                v_vl = vl[voice][m]             # volume level for this voice/measure
            else:
                v_vl = 127                      # Probably a rest, put as full volume.
            # fi
            lth = lthworkingmeasures            # start of measure notes.
            i = 0

            if  m in key_voice and voice in key_voice[m]:
                n_key_voice = key_voice[m][voice] # volume level for this voice/measure
            else:
                n_key_voice = ky
            # fi
            if ky != n_key_voice:
                ky = n_key_voice
                print('{}, {}, Key_signature, {}, "major"'.format(voice+1,lth,ky), file=output_name)
            # fi

            if lt != tempo_speed_now[m] or ll != tempo_now_note_length[m]:
                lt = tempo_speed_now[m]
                ll = tempo_now_note_length[m]
                print_out_midi1csv_tempo(voice+1, lt, ll, lth)
            # fi

            if len(bufs[voice][m]) == 0:        # If nothing in measure, go to next measure.
                m_number = m_number + 1
                continue
            # fi
            while i < len(bufs[voice][m]):      # while there are notes in measure
                l = bufs_length[voice][m][i]    # length of current note.
                if l < 0:
                    lth = lth - l
                    i = i + 1
                    continue                    # previous note was tied to this.
                # fi
                n = bufs[voice][m][i]           # note number
                if n != '0' and n != 0:         # Only for note that plays (not rest).
                    v_vl = bufs_vol[voice][m][i]
                    print("{}, {}, Note_on_c, {}, {}, {}".format(voice+1, lth, chan, n, v_vl), file=output_name)
                # fi
                tmp,m_number,lastmeter, channel, chan, l_instrument = do_possible_midi_tie(voice, m_number, i, l,lastmeter, channel, chan, l_instrument, lthworkingmeasures)
                if n != '0' and n != 0:
                    acc_s = bufs_accidentals[voice][m][i]
                    if acc_s == 'ts' or acc_s == 's':
                        tmp = int(round(tmp / 2.0))
                    # fi
                    print("{}, {}, Note_off_c, {}, {}, {}".format(voice+1, (lth + tmp - 1), chan, n, 0), file=output_name)
                # fi
                lth = lth + l
                i = i + 1
            # rof
            while t_num < m_number:
                lthworkingmeasures = lthworkingmeasures + mlth[voice][m]
                channel, chan, l_instrument = print_out_midi1csv_instrument(l_instrument,voice,m_number,channel,chan,lthworkingmeasures)
                t_num = t_num + 1
                if t_num < len(meas):
                    m = meas[t_num]
                # fi
            # elihw
        # rof   m in meas
        print("{}, {}, End_track".format(voice+1, lthworkingmeasures + 26), file=output_name)
    # rof   voice in range
    return
#   End of print_out_midi1csv_notes

#-----------------------------------------------------------------------------
def do_pass2():
    global meas                             # measures
    global args
    global bufs_tie_next
    global vl
    global output_name
    global ifdepth
    global macro_defining
    global macro_executing_depth
    global errors_happened

    if ifdepth > 0:
        print("Error inside an if block (depth={}) when end of file or cstop* reached".format(ifdepth),file=sys.stderr)
    # fi
    if macro_defining is not None:
        print("Error inside defining macro {}, no endm reached.".format(macro_defining),file=sys.stderr)
    # fi
    if len(macro_executing_depth) > 0:
        print("Error processing macro depth is {}.".format(macro_executing_depth),file=sys.stderr)
    # fi

    print_header()

    # Fix other voices before continuing to process.
    fill_voice_mlth("do_pass2")             # Need to make measure for other voices up to here "mlth".

    # First get the empty measures to have rests of appropriate length.
    # All measures have all voices with same length -- even if some are rests.
    for i in range(0, len(meas)):
        m = meas[i]
        for voice in range(1, len(vl) +1):
            rests_in_empty_measure_voices(m, voice)
            bufs_tie_next[voice] = ''
        # rof
    # rof

    if args.vertical or args.horizontal:
        print_out_v_or_h()
    elif args.midi1csv:
        print_out_midi1csv_notes()
    else:       # ABC
        print_out_abc()
    # fi

    # End of song processing.
    if args.vertical or args.horizontal:
        print("cstop*", file=output_name)
    elif args.midi1csv:
        print("0, 0, End_of_file", file=output_name)
    # else:     # ABC
    # fi
    sys.exit(errors_happened)
# End of do_pass2

#-----------------------------------------------------------------------------
# Get a line. Put it in "line" and return it.
def get_line():
    global linecount
    global args
    global file_name
    global macro_executing_depth
    global macro_executing_args
    global macro_line
    global macro_buffer                 # Name of macro, array of lines for macro.
    global macro_arguments              # Name of macro, array of arguments for macro.
    global errors_happened

    if macro_executing_depth != []:
        l = len(macro_executing_depth)
        the_macro = macro_executing_depth[-1]
        macrodepth = len(macro_executing_depth)
        linenumber = macro_line[macrodepth]
        lines = macro_buffer[the_macro]
        if linenumber >= len(lines):
            p = macro_executing_depth.pop()
            del macro_line[l]
            del macro_executing_args[l]
            return ''
        # fi
        line = macro_buffer[the_macro][linenumber]
        def_args = macro_arguments[the_macro]
        rep_args = macro_executing_args[l]
        for j in range(0, len(def_args)):
            line = line.replace(def_args[j], rep_args[j])
        # rof
        macro_line[macrodepth] = linenumber + 1
        line = line.replace("\t", ' ')              # tabs to spaces
        return line
    # fi

    while True:
        try:
            if args.rest and len(args.rest) >= 1:
                line = file_name.readline()
            else:
                if sys.stdin.isatty():
                    if sys.platform == 'darwin':
                        input('input> ')
                        line = readline.get_line_buffer()
                    else:
                        line = input('input> ')
                    # fi
                else:
                    line = sys.stdin.readline()
                # fi
            # fi
            if line is None or line == '':
                sys.exit(errors_happened)
            # fi
            linecount = linecount + 1
            if line:
                # delete anything from $$ onwards.
                line = re.sub('[$][$].*$', '', line)
                # ignore leading and trailing spaces.
                line = line.replace("\t", ' ')      # tabs to spaces
                line = line.strip()
                # Convert ' followed by something as a "shift".  '; = :   'a = A
                return line
            # fi
        except EOFError:
            pass            # print("Read gave EOF", file=sys.stderr)
        except SystemExit:
            pass            # print("Read gave system exit", file=sys.stderr)
        except KeyboardInterrupt:
            print("Read got keyboard interrupt", file=sys.stderr)
        except:
            print("Read got a processing error", file=sys.stderr)
            print("    ", sys.exc_info()[0], sys.exc_info, file=sys.stderr)
        # yrt
        break
    # elihw
    do_pass2()
    sys.exit(errors_happened)
# End of get_line

#-----------------------------------------------------------------------------
def split_line(line):
    t = None
    if line:
        # Split line on spaces, then process line.
        while True:
            t = line.split(' ', 1)
            if t and t[0] and len(t) == 2 and t[1]:
                t[1] = t[1].strip()
            # fi
            if t and t[0] == '.':
                # If command == '.' toss '.'
                if len(t) == 2 and t[1]:
                    line = t[1]
                else:
                    t = None
                    line = None
                    break
                # fi
                continue
            # fi
            break
        # elihw
    # fi
    return(t, line)
# End of split_line

#-----------------------------------------------------------------------------
def get_list_sep_rem(string):
    strg = sep = rem = ''
    for i in range(0, len(string)):
        c = string[i]                       # Character in string
        if c.isalpha():                     # [a-zA-Z]
            if i != 0 and strg.replace('.','',1).isdigit():    # number followed by letter, stop.
                sep = None
                rem = string[i:]            # the rest of the string, including this character.
                break
            # fi
            strg = strg + c
        elif c.isdigit() or c == '.':       # current is a digit, see if rest are.
            if strg or strg == '':
                strg = strg + c
                continue
            elif strg.isdigit():             # number followed by number, good.
                strg = strg + c
                continue
            elif strg.replace('.','',1).isdigit() and c.isdigit():   # floating number followed by number, good.
                strg = strg + c
                continue
            else:
                print_error("Two periods in a number not allowed", string)
                return None, None, None
            # fi
        else:
            sep = c
            rem = string[i+1:]              # the rest of the string, including this character.
            break
        # fi
    # rof
    return(strg, sep, rem)
# End of get_list_sep_rem

#-----------------------------------------------------------------------------
# Calculate values here.
# Returns:
#   value   -- So far computed value
#   type_error -- type of error

def is_float(strg):
    tree = calculate.parse(strg)            # parse the string

    if tree is not None and len(tree) == 2:
        if tree[0] is not None and tree[0].startswith('ERROR'):
            sexpr = tree[0]
            return strg, sexpr
        # fi
        if tree[1] == '.':
            return strg, "bad input to calculator"
        # fi
        try:
            sexpr = float(tree[1])
            return sexpr, None
        except:
            return strg, "bad input to calculator"
    # fi
    return None, None
# End of is_float

#-----------------------------------------------------------------------------
def put_on_bufs(onvoice, p_meas, prenote, abc_note, timeofnote, append_tie, onetimevolume, postnote):
    global tlth
    global mlth
    global bufs
    global bufs_length
    global bufs_accidentals
    global bufs_tie_next
    global running_vl
    global DECORATIONS
    global args
    global bufs_vol
    global cresc_direction
    global cresc_time
    global cresc_volume
    global vlprint

    if type(abc_note) is int:
        abc_note = str(abc_note)
    # fi
    tlth[onvoice] = tlth[onvoice] + timeofnote
    if p_meas not in mlth[onvoice]:
        mlth[onvoice][p_meas] = 0
    # fi
    mlth[onvoice][p_meas] = mlth[onvoice][p_meas] + timeofnote

    if onvoice not in bufs:
        bufs[onvoice] = {}
        bufs_length[onvoice] = {}
        bufs_accidentals[onvoice] = {}
        bufs_tie_next[onvoice] = ''
        bufs_vol[onvoice] = {}
    # fi
    if onetimevolume is None:
        if onvoice in running_vl and p_meas in running_vl[onvoice]:
            onetimevolume = running_vl[onvoice][p_meas]
        else:
            onetimevolume = 127                 # Probably a rest, put as full volume.
        # fi
    # fi
    if p_meas not in bufs[onvoice]:
        bufs_vol[onvoice][p_meas] = [ onetimevolume ]
        if args.horizontal or args.vertical:
            bufs[onvoice][p_meas] = [prenote + abc_note]
            bufs_length[onvoice][p_meas] = [timeofnote]
            bufs_accidentals[onvoice][p_meas] = [append_tie]
        elif args.midi1csv:
            bufs[onvoice][p_meas] = [abc_note]
            bufs_length[onvoice][p_meas] = [timeofnote]
            bufs_accidentals[onvoice][p_meas] = [append_tie]
        else:           # ABC
            bufs[onvoice][p_meas] = prenote + abc_note + postnote
        # fi
    else:
        bufs_vol[onvoice][p_meas].append( onetimevolume )
        if args.vertical or args.horizontal:
            bufs[onvoice][p_meas].append(prenote + abc_note)
            bufs_length[onvoice][p_meas].append(timeofnote)
            bufs_accidentals[onvoice][p_meas].append(append_tie)
        elif args.midi1csv:
            bufs[onvoice][p_meas].append(abc_note)
            bufs_length[onvoice][p_meas].append(timeofnote)
            bufs_accidentals[onvoice][p_meas].append(append_tie)
        else:           # ABC
            bufs[onvoice][p_meas] = bufs[onvoice][p_meas] + ' ' + prenote + abc_note + postnote
        # fi
    # fi

    # If crescendo happening, do it.
    if cresc_time[onvoice] == 0:
        return
    # fi

    if cresc_time[onvoice] <= timeofnote:

        running_vl[onvoice][p_meas] = cresc_volume[onvoice]
        cresc_time[onvoice] = 0
        if args.vertical or args.horizontal or args.midi1csv:
            pass
        else:
            j = int(cresc_volume[onvoice] / 16)
            j = (j * 16) + 15                   # convert so can do index on vlprint.
            if cresc_direction[onvoice]:
                k = 'crescendo)'
            else:
                k = 'diminuendo)'
            # fi
            bufs[onvoice][p_meas] = bufs[onvoice][p_meas] + \
                                    DECORATIONS + vlprint[j] + DECORATIONS + \
                                    DECORATIONS + k + DECORATIONS
        # fi
        return
    # fi

    dt = cresc_time[onvoice] + 0.0
    v =  cresc_volume[onvoice] - running_vl[onvoice][p_meas] + 0.0
    x1 = v / dt                         # total  1920/48 = 4
    x2 = x1 * timeofnote                # x2 = x1 * timeofnote

    cresc_time[onvoice] = cresc_time[onvoice] - timeofnote
    running_vl[onvoice][p_meas] = running_vl[onvoice][p_meas] + int(x2)

    return
# End of put_on_bufs

#-----------------------------------------------------------------------------
def instak(onvoice, p_meas, prenote, thenote, timeofnote, append_tie, line, onenotevolume, postnote):
    global args

    if args.midi1csv:
        put_on_bufs(onvoice, p_meas, prenote, thenote,
                    int(round(timeofnote * MIDICLICKSPERQUARTER * 4)), append_tie, onenotevolume, postnote)
        return
    # fi

    lengthl, lengthf, ifokay = get_time_stak(timeofnote, line)
    if ifokay == -1:                    # if time is error
        return
    # fi

    j = 1
    q = 0
    if args.horizontal or args.vertical:
        if ifokay == 1:                 # Did not fit properly.
            q = timeofnote
            put_on_bufs(onvoice, p_meas, prenote, thenote, q, append_tie, onenotevolume, postnote)
            return
        # fi
    # fi

    for l in lengthl:
        if args.horizontal:
            # Length done elsewise, and accidentals elsewise too.
            q = lengthf[j-1]
            put_on_bufs(onvoice, p_meas, prenote, thenote, q, append_tie, onenotevolume, postnote)
            append_tie = 't'
            j = j + 1
        elif args.vertical:
            q = lengthf[j-1]
            # tie goes on one before
            if j == len(lengthl):           # last one gets passed in append_tie note.
                put_on_bufs(onvoice, p_meas, prenote, thenote, q, append_tie, onenotevolume, postnote)
            elif j < len(lengthl):
                put_on_bufs(onvoice, p_meas, prenote, thenote, q, 't', onenotevolume, postnote)
            # fi
            j = j + 1
        else:           # ABC
            if j != len(lengthl) and thenote != 'z':
                abc_note = thenote + l + '-'
            else:
                abc_note = thenote + l + append_tie
            # fi
            q = lengthf[j-1]
            put_on_bufs(onvoice, p_meas, prenote, abc_note, q, append_tie, onenotevolume, postnote)
            j = j + 1
        # fi
        prenote = ''
    # rof
    return
# End of instak

#-----------------------------------------------------------------------------
# Make all voices match with rests, etc. The ones we have are now to be processed.
# Need to make measure for all known voices up to here "mlth". (Add rests.)
def fill_voice_mlth(line):
    global vl
    global mlth
    global tlth
    global args
    global meas

    maxvoice = len(vl) + 1
    for p_meas in meas:
        m = 0
        for i in range(1, maxvoice):
            if p_meas not in mlth[i]:
                mlth[i][p_meas] = 0
            # fi
            m = max(mlth[i][p_meas], m)
        # rof
        # Put out rests for smaller in measure.
        for i in range(1, maxvoice):
            l = m - mlth[i][p_meas]     # time short
            if l > 0 :                      # if short, need a rest.
                if args.horizontal or args.vertical:
                    instak(i, p_meas, '', 'r', l , '', line, None, '')
                elif args.midi1csv:
                    instak(i, p_meas, '', 0, l / (MIDICLICKSPERQUARTER * 4) , '', line, None, '')
                else:           # ABC
                    instak(i, p_meas, '', 'z', l , '', line, None, '')
                # fi
            # fi
        # rof
    # rof
    # Set total for voice to max of all.
    t = 0
    for i in range(1, maxvoice):
        t = max(tlth[i], t)
    # rof
    for i in range(1, maxvoice):
        tlth[i] = t                     # Total for all voices is now max of all.
    # rof
    return
# End of fill_voice_mlth

#-----------------------------------------------------------------------------
# Separate arguments for argument.
def arglist(wline, line):
    newline = []
    # break into arguments.
    newstr = ''
    np = 0                              # ()
    nb = 0                              # []
    nc = 0                              # {}
    for c in wline:
        if c == ',' and np == 0 and nb == 0 and nc == 0:    # we want to split on commas
            newline.append(newstr)
            newstr = ''
        elif c == ' ' or c == "\t":
            pass
        else:
            newstr = newstr + c
            if c == '(':
                np = np + 1
            elif c == ')':
                if np == 0:
                    print_error("too many right parenthesis", line)
                    return ''
                # fi
                np = np - 1
            elif c == '[':
                nb = nb + 1
            elif c == ']':
                if nb == 0:
                    print_error("too many right brackets", line)
                    return ''
                # fi
                nb = nb - 1
            elif c == '{':
                nc = nc + 1
            elif c == '}':
                if nc == 0:
                    print_error("too many right curly braces", line)
                    return ''
                # fi
                nc = nc - 1
            # fi
        # fi
    # rof
    if np != 0:
        print_error("too many left (by {}) parenthesis".format(np), line)
        return ''
    # fi
    if nb != 0:
        print_error("too many left (by {}) brackets".format(nb), line)
        return ''
    # fi
    if nc != 0:
        print_error("too many left (by {}) curly braces".format(nc), line)
        return ''
    # fi
    newline.append(newstr)
    return newline
# End of arglist

#-----------------------------------------------------------------------------
# change -- rename existing command or copy.
#         change  measure to unit   $$ or:
#         change  command measure to unit

def do_change(t_args, line):
    global macro_buffer
    global commands

    if t_args is None or len(t_args) == 0:
        print_error("change does not have three or four arguments.", line)
        return
    # fi
    t_args = t_args[0].split(' ')
    if t_args is None or len(t_args) < 3 or len(t_args) > 4:
        print_error("change -- there is not three or four arguments.", line)
        return
    # fi
    if len(t_args) == 4:
        if t_args[0] != 'command' or t_args[2] != 'to':
            print_error("change -- command is not first argument of four and to is not third.", line)
            return
        # fi
        t_args = t_args[1:]
    elif len(t_args) == 3:
        if t_args[1] != 'to':
            print_error("change -- to is not second argument.", line)
            return
        # fi
    # fi
    old = t_args[0]
    new = t_args[2]
    # make sure new name does not exist already. -- error
    if new in commands:
        if commands[new] == commands[old]:
            return
        # fi
        print_error("copy new name already exists as different command.", line)
    elif new in macro_buffer:
        print_error("change new name already exists as macro.", line)
        return
    if old not in commands:
        print_error("change old name does not exist.", line)
        return
    # fi
    commands[new] = commands[old]
    del commands[old]
    return
# End of do_change

#-----------------------------------------------------------------------------
# copy -- make another name for existing name/copy, replace existing with warning.
#         copy    measure to unit   $$ or:
#         copy    command measure to unit
def do_copy(t_args, line):
    global macro_buffer
    global commands

    if t_args is None or len(t_args) == 0:
        print_error("copy does not have three or four arguments.", line)
        return
    # fi
    t_args = t_args[0].split(' ')
    if t_args is None or len(t_args) < 3 or len(t_args) > 4:
        print_error("copy - there is not three or four arguments.", line)
        return
    # fi
    if len(t_args) == 4:
        if t_args[0] != 'command' or t_args[2] != 'to':
            print_error("copy - command is not first argument of four and to is not third.", line)
            return
        # fi
        t_args = t_args[1:]
    elif len(t_args) == 3:
        if t_args[1] != 'to':
            print_error("copy - to is not second argument.", line)
            return
        # fi
    # fi
    old = t_args[0]
    new = t_args[2]
    # make sure new name does not exist already. -- error
    if new in commands:
        if commands[new] == commands[old]:
            return
        # fi
        print_error("copy new name already exists as different command.", line)
    elif new in macro_buffer:
        print_error("copy new name already exists as macro.", line)
        return
    if old not in commands:
        print_error("copy old name does not exist.", line)
        return
    # fi
    commands[new] = commands[old]
    return
# End of do_copy

#-----------------------------------------------------------------------------
#   title promenade     $$ Gives a title to the song, multiple allowed.
def do_title(t_args, line):
    global header
    global args

    if t_args is None or len(t_args) == 0:
        #-- print_warning("Title does not have any text.", line)
        if args.vertical or args.horizontal:
            header = header + "title   \n"
        elif args.midi1csv:
            pass
        else:           # ABC
            header = header + "T:\n"
        # fi
        return
    # fi
    # T: Title of tune        (can have multiple)
    t = line.split(' ', 1)
    if not t or len(t) < 2:
        t = [ ' ', ' ' ]
    # fi
    if args.vertical or args.horizontal:
        header = header + "title   {}\n".format(t[1])
    elif args.midi1csv:
        header.append(t[1])
    else:           # ABC
        header = header + "T:{}\n".format(t[1])
    # fi
    return
# End of do_title

#-----------------------------------------------------------------------------
#   tempo  150,4        $$ Number of notes of given length in a minute.
#   tempo  30           $$ Number of frames (1/57.1429 seconds) per whole note.
def do_tempo(t_args, line):
    global tempo_speed_default          # beats per minute
    global default_note_length          # length of a beat (note)
    global tempo_speed_now
    global tempo_now_note_length
    global measure_on
    global mlth
    global vl

    if t_args is None or len(t_args) == 0:
        print_error("tempo does not have one or two arguments.", line)
        return
    # fi
    t_args = t_args[0].split(',')
    if t_args is None or len(t_args) == 0 or len(t_args) > 2:
        print_error("tempo - there is not one or two arguments.", line)
        return
    # fi

    fill_voice_mlth(line)                   # Need to make measure for other voices up to here "mlth".

    for ve in range(1, len(vl)+1):
        if mlth[ve][measure_on] != 0:
            print_error("do_tempo in the middle of a measure not allowed", line)
            return
        # fi
    # rof

    #   f1 is value   -- So far computed value
    #   type_error -- type of error
    f1, type_error = is_float(t_args[0])
    if type_error is not None:
        print_error("tempo does not have first argument as a floating number. {}".format(type_error), line)
        return
    # fi
    if f1 is None:
        print_error("tempo does not have first argument as a floating number.", line)
        return
    # fi
    if len(t_args) == 1:
        x = int(round(f1 / 60.0))
        if measure_on == '':
            tempo_speed_default = x
        # fi
        default_note_length[measure_on] = 1.0               # whole note
        tempo_speed_now[measure_on] = x
        tempo_now_note_length[measure_on] = 1.0
        return
    # fi
    f2, type_error = is_float(t_args[1])
    if type_error is not None:
        return
    # fi
    if f2 is None:
        print_error("tempo does not have second argument as a floating number.", line)
        return
    # fi
    if measure_on == '':
        tempo_speed_default = int(round(f1))
    # fi
    default_note_length[measure_on] = (1.0 / f2)
    tempo_speed_now[measure_on] = int(round(f1))
    tempo_now_note_length[measure_on] = (1.0 / f2)
    return
# End of do_tempo

#-----------------------------------------------------------------------------
def do_cstopnow(t_args, line):
    global errors_happened

    do_pass2()
    sys.exit(errors_happened)
# End of do_cstopnow

#-----------------------------------------------------------------------------
#   cstart              restart compiling.      (like #if 0 ... #endif // 0)
def do_cstart(t_args, line):
    global cstop_processing

    if not cstop_processing:
        print_error("Not in cstop processing and got a cstart", line)
    # fi
    cstop_processing = False
    return
# End of do_cstart

#-----------------------------------------------------------------------------
#   cstop               stop till cstart or cstop* found.
def do_cstop(t_args, line):
    global commands
    global cstop_processing

    cstop_processing = True
    return
# End of do_cstop

#-----------------------------------------------------------------------------
def do_endm(t_args, line):
    global macro_defining

    if macro_defining is None:
        print_error("endm command while not defining a macro", line)
        return
    # fi
    macro_defining = None
    return
# End of do_endm

#-----------------------------------------------------------------------------
def replace_macro(command, t_args, line):
    global macro_arguments              # Name of macro, array of arguments for macro.
    global macro_executing_depth        # If processing macro ... reading from macro buffer.
    global macro_executing_args         # Depth, array of arguments given to macro.
    global macro_line                   # Depth, line in macro array.

    if t_args is None or len(t_args) == 0:
        if macro_arguments[command] != []:
            print_error("macro command does not have any arguments, but needs {}.".format(macro_arguments[command]), line)
            return
        # fi
        wargs = None
    else:
        wargs = arglist(t_args[0], line)
        if len(wargs) != len(macro_arguments[command]):
            print_error("macro command has {} arguments, but needs {}.".format(wargs,macro_arguments[command]), line)
            return
        # fi
    # fi
    macro_executing_depth.append(command)
    macrodepth = len(macro_executing_depth)
    macro_executing_args[macrodepth] = wargs
    macro_line[macrodepth] = 0             # First line in buffer.
# End of replace_macro

#-----------------------------------------------------------------------------
#   macro name,arg1,arg2,...,argn
#     body of macro
#   endm
#         Changes arg1 to passed in usage.
#   name  first,second arg,something    # example 3 arguments - spaces allowed.
#
# Macros must not be existing commands -- replace existing macro with warning.
def do_macro(t_args, line):
    global commands
    global macro_defining               # If defining macro.
    global macro_buffer                 # Name of macro, array of lines for macro.
    global macro_arguments              # Name of macro, array of arguments for macro.

    if t_args is None or len(t_args) == 0:
        print_error("macro command does not have any arguments.", line)
        return
    # fi

    wargs = arglist(t_args[0], line)
    if not wargs or len(wargs) < 1:
        print_error("no macro name.", line)
        return
    # fi

    name = wargs[0]
    args = wargs[1:]
    if name in commands:
        print_error("macro ({}) would replace existing command".format(name), line)
        return
    # fi
    if name in macro_buffer:
        print_warning("macro ({}) will replace existing macro".format(name), line)
    # fi

    macro_buffer[name] = []             # No lines in bujffer.
    macro_arguments[name] = args
    macro_defining = name
    return
# End of do_macro

#-----------------------------------------------------------------------------
def macro_define(command, t_args, line):
    global macro_defining               # If defining macro.
    global macro_buffer                 # Name of macro, array of lines for macro.

    if t_args and len(t_args) > 0:
        macro_buffer[macro_defining].append(command + ' ' + ' '.join(t_args))
    else:
        macro_buffer[macro_defining].append(command)
    # fi
    return
# End of macro_define

#-----------------------------------------------------------------------------
# putd ... if already existing, replace with warning.
#     putd   /cmajor/c,e,g/
#     =cmajor,b           # c,e,g,b       Note: do multiple putd's on this line.
def do_putd(t_args, line):
    print_error("NOTDONEYET - do_putd", line)
    return
# End of do_putd

#-----------------------------------------------------------------------------
def process_putd(line):
    print_error("NOTDONEYET - process_putd", line)
    return ''                           # Ignore putd for now.
# End of process_putd

#-----------------------------------------------------------------------------
def do_endif(t_args, line):
    global ifdepth

    if ifdepth == 0:
        print_error("endif command while not in an if command", line)
        return
    # fi
    # if iftest[ifdepth] == -1:           # already processing, handle as normal if.
    # if iftest[ifdepth] == 0:            # skipping if, want to do else.
    # if iftest[ifdepth] == 1:            # processing in else, want to do as normal if.
    # if iftest[ifdepth] == 2:            # skipping in else, ignore if and else processing, want endif.
    # if iftest[ifdepth] == 3:            # skip both if and else, want endif
    ifdepth = ifdepth - 1
    return
# End of do_endif

#-----------------------------------------------------------------------------
def do_else(t_args, line):
    global ifdepth
    global iftest

    if ifdepth == 0 or iftest[ifdepth] == 1 or iftest[ifdepth] == 2:
        print_error("else command while not in an if command", line)
        return
    # fi

    if iftest[ifdepth] == -1:           # already processing, handle as normal if.
        iftest[ifdepth] = 2             # Switch to skipping else.
        return
    # fi
    if iftest[ifdepth] == 0:            # skipping if, want to do else.
        iftest[ifdepth] = 1             # Switch to processing else.
        return
    # fi
    # if iftest[ifdepth] == 3:            # skip both if and else, want endif
    # NOTE: do not test for if/else/endif ... second else.
    return
# End of do_else

#-----------------------------------------------------------------------------
#   if/else/endif
def do_if(t_args, line):
    global iftest                       # check if after if or else.
    global ifdepth                      # level of if/else/endif

    if t_args is None or len(t_args) == 0:
        print_error("if command does not have exactly one argument.", line)
        return
    # fi
    # if iftest[ifdepth] == -1:           # already processing, handle as normal if.
    # if iftest[ifdepth] == 0:            # skipping if, want to do else.
    # if iftest[ifdepth] == 1:            # processing in else, want to do as normal if.
    # if iftest[ifdepth] == 2:            # skipping in else, ignore if and else processing, want endif.
    # if iftest[ifdepth] == 3:            # skip both if and else, want endif
    if iftest[ifdepth] == -1 or iftest[ifdepth] == 1:   # process this if normally.
        wargs = arglist(t_args[0], line)
        if not wargs or len(wargs) < 1:
            print_error("no if argument.", line)
            return
        # fi
        value, type_error = is_float(wargs[0])
        if type_error is not None:
            print_error("if unable to determine if value ({}).".format(wargs[0]), line)
            return
        # fi
        value =  -1 if value < 0 or value > 0 else 0   # 0 is false, otherwise everything is true.
    else:
        value = 3                           # Skip both if and else.
    # fi
    ifdepth = ifdepth + 1
    iftest[ifdepth] =  value
    return
# End of do_if

#-----------------------------------------------------------------------------
def do_marker(t_args, line):
    global args

    fill_voice_mlth(line)                   # Need to make measure for other voices up to here "mlth".

    if t_args is None or len(t_args) == 0:
        value = '0'
    else:
        value, type_error = is_float(t_args[0])
        if type_error is not None:
            print_warning("marker unable to compute value({}) - using text string.".format(t_args[0]), line)
            value = str(t_args[0])
        else:
            value = str(int(round(value)))      # Stupid python language upgrade incompatibility.
        # fi
    # fi

    if args.rest and len(args.rest) >= 2:
        outf = sys.stdout
    else:
        outf = sys.stderr
    # fi
    if args.rest and len(args.rest) >= 1:
        # Can get input from terminal.
        if sys.stdin.isatty():
            if sys.platform == 'darwin':
                input('marker ' + value + ' > ')
                line = readline.get_line_buffer()
            else:
                line = input('marker ' + value + ' > ')
            # fi
        else:
            print('marker ' + value + ' > ', file=outf)
            line = sys.stdin.readline()
        # fi
    # fi
    return
# End of do_marker

#-----------------------------------------------------------------------------
# Not likely to ever do.
#   debug               ignore
def do_debug(t_args, line):
    print_error("debug command makes no sense for python or MIDI.", line)
    return
# End of do_debug

#-----------------------------------------------------------------------------
#   randp   m1          Assigned unduplicated random numbers from last setperm.
def do_randp(t_args, line):
    global array_of_random_numbers

    if t_args is None or len(t_args) == 0:
        print_error("randp command does not have exactly one argument.", line)
        return
    # fi
    wargs = arglist(t_args[0], line)
    if not wargs or len(wargs) < 1:
        print_error("no randp argument.", line)
        return
    # fi
    if len(array_of_random_numbers) <= 0:
        # print_error("randp needs a setperm before it runs.".format(wargs[0],value), line)
        ran = 0
    else:
        ran = array_of_random_numbers.pop()
    # fi
    computeit = wargs[0] + '=' + str(ran)       # Do the assignment.
    value, type_error = is_float(computeit)
    if type_error is not None:
        print_error("randp unable to assign value({}) to first argument({}).".format(wargs[0],value), line)
        return
    # fi
    return
# End of do_randp

#-----------------------------------------------------------------------------
#   setperm 44          Semi random numbers between 1 and 44, without duplication.
def do_setperm(t_args, line):
    global array_of_random_numbers

    if t_args is None or len(t_args) != 1 or t_args[0] == '':
        print_error("setperm command does not have any arguments.", line)
        return
    # fi
    wargs = arglist(t_args[0], line)
    if not wargs or len(wargs) != 1:
        print_error("Need exactly one setperm argument", line)
        return
    # fi

    value, type_error = is_float(wargs[0])     # From 1 to value.
    if type_error is not None or value < 1:
        print_error("setperm unable to compute reasonable value({}) for number of unique random numbers.".format(wargs[0]), line)
        return
    # fi
    value = int(round(value))                   # So, python2 and python3 do round differently. *SCREAM*
    array_of_random_numbers = random.sample(range(1, value+1), value)
    return
# End of do_setperm

#-----------------------------------------------------------------------------
#   randu   m1,10       $$ random number between 1 and 10.
def do_randu(t_args, line):
    if t_args is None or len(t_args) <= 0 or t_args[0] == '':
        print_error("randu command does not have any arguments.", line)
        return
    # fi
    wargs = arglist(t_args[0], line)
    if not wargs or len(wargs) < 1:
        print_error("no randu arguments", line)
        return
    # fi

    value, type_error = is_float(wargs[1])     # From 1 to value.
    if type_error is not None or value < 1:
        print_error("randu unable to compute reasonable value({}) to store in ({}).".format(wargs[1],wargs[0]), line)
        return
    # fi
    ran = random.randint(1, int(round(value)))  # Random value.
    computeit = wargs[0] + '=' + str(ran)       # Do the assignment.
    value, type_error = is_float(computeit)
    if type_error is not None:
        print_error("randu unable to assign value({}) to first argument({}).".format(wargs[0],value), line)
        return
    # fi
    return
# End of do_randu

#-----------------------------------------------------------------------------
# Not likely to ever do.
#   percus              does things with slide projector.
def do_percus(t_args, line):
    print_error("percus command makes no sense for python or MIDI.", line)
    return
# End of do_percus

#-----------------------------------------------------------------------------
# Not likely to ever do. Would do it differently for MIDI.
#   delay 15            delay in 1/60ths of a second. Like a fermate.  15=1/4th of a second
def do_delay(t_args, line):
    global voices                       # number of voices
    global cis                          # if cis active, non-zero.
    global tempo_speed_default
    global default_note_length
    global measure_on
    global tempo_speed_now
    global tempo_now_note_length

    fill_voice_mlth(line)               # Need to make measure for other voices up to here "mlth".

    if t_args is None or len(t_args) <= 0 or t_args[0] == '':
        print_error("delay command does not have any arguments.", line)
        return
    # fi
    wargs = arglist(t_args[0], line)
    if not wargs or len(wargs) < 1:
        print_error("no delay arguments", line)
        return
    # fi
    value, type_error = is_float(wargs[0])
    if type_error is not None:
        print_error("delay unable to compute value({}).".format(wargs[0]), line)
        return
    # fi

    # Convert value/60.0 to note_beats/minute (tempo).
    # tempo_speed_default = 120.0                 # beats per minute.
    # default_note_length[measure_on]     # length of a beat (note)
    # (tempo beats/minute) * (1/60.0 minutes/sec)
    #  (tempo/60.0  beats/sec) * (1/default_note_length[measure_on] = ?_note/beats)
    #  (tempo/(60.0*default_note_length[measure_on]) ?_note/sec)  * seconds
    if measure_on == '':
        rvalue = value * tempo_speed_default / (60.0*default_note_length[measure_on])
    else:
        rvalue = value * tempo_speed_now[measure_on] / (60.0*tempo_now_note_length[measure_on])
    # fi

    loopstart = 1 if cis == 0 else cis
    r = 'r({}/60.0)'.format(rvalue)
    #-- r = 'r4'
    for onvoice in range(loopstart+1, voices + 1):
        r = r + ',r({}/60.0)'.format(rvalue)
        #-- r = r + ',r4'
    # rof
    process_notes([r], r)
    return
# End of do_delay

#-----------------------------------------------------------------------------
# Not likely to ever do.
#   slide  from,to,length     Glissando - only can be used after voice 1 or cis n command.
def do_slide(t_args, line):
    print_error("slide command makes no sense for python or MIDI.", line)
    return
# End of do_slide

#-----------------------------------------------------------------------------
# Not likely to do. I think this is xpose?
#   pitch -2            sets semitones lower
def do_pitch(t_args, line):
    print_error("NOTDONEYET - do_pitch", line)
    return
# End of do_pitch

#-----------------------------------------------------------------------------
# Not likely to do. No idea what this does.
#   temper a            sets just intonation in the key.
def do_temper(t_args, line):
    print_error("NOTDONEYET - do_temper", line)
    return
# End of do_temper

#-----------------------------------------------------------------------------
# Not likely to ever do. Use key command.
#   sharp   f
def do_sharp(t_args, line):
    print_error("NOTDONEYET - do_sharp", line)
    return
# End of do_sharp

#-----------------------------------------------------------------------------
# Not likely to ever do. Use key command.
#   flat    b,e         flat/sharp are cumulative -- double flats, etc.
def do_flat(t_args, line):
    print_error("NOTDONEYET - do_flat", line)
    return
# End of do_flat

#-----------------------------------------------------------------------------
# Not likely to ever do. Use key command.
#   natural c           undo any flat/sharp.
def do_natural(t_args, line):
    print_error("NOTDONEYET - do_natural", line)
    return
# End of do_natural

#-----------------------------------------------------------------------------
#   goto    6.5,x,8,2,... $$ repeat and/or skip.  "x" = continue, forwards, backwards, max 8 args.
#                       counter is number of times reached.
def do_goto(t_args, line):
    print_error("NOTDONEYET - do_goto", line)
    return
# End of do_goto

#-----------------------------------------------------------------------------
def to_abc_note(note_number):
    if note_number <= 0 or note_number == '0':
        return 'z'
    # fi
    o = int(note_number / 12)                           # get octave
    n = note_number - (o * 12)                          # note is remainder
    octaves = { 0:',,,', 1:',,', 2:',', 3:'', 4:'', 5:"'", 6:"''", 7:"'''", 8:"'''" }
    notes = { 0:'a', 1:'^a', 2:'b', 3:'c', 4:'^c', 5:'d', 6:'^d', 7:'e', 8:'f', 9:'^f', 10:'g', 11:'^g' }
    n = notes[n]
    if o <= 3:                                          # uppercase letter
        n = n.upper()
    else:                                               # lowercase letter
        n = n.lower()
    # fi
    o = octaves[o]
    thenote = n + o
    return thenote
# End of to_abc_note

#-----------------------------------------------------------------------------
#   decode  m1,3c+      $$ note number for 3c+ into m1
def do_decode(t_args, line):
    global args

    if t_args is None or len(t_args) <= 0 or t_args[0] == '':
        print_error("decode command does not have any arguments.", line)
        return
    # fi
    wargs = arglist(t_args[0], line)
    if not wargs or len(wargs) < 1:
        print_error("no decode arguments", line)
        return
    # fi
    # onvoice = ? ... make it 1.
    # Save what type of processing we are doing.
    saveargsh = args.horizontal
    saveargsv = args.vertical
    saveargsm = args.midi1csv
    saveargabc = args.abc
    # Set to midi format -- so we have a value.
    args.horizontal = False
    args.vertical = False
    args.midi1csv = True
    args.abc = False

    therest, thenote, typenote = getnote(wargs[1], 1, line)
    
    # Restore type of processing we are doing.
    args.horizontal = saveargsh
    args.vertical = saveargsv
    args.midi1csv = saveargsm
    args.abc = saveargabc

    if therest is None:
        print_warning("decode note had error with note {}".format(wargs[1]), line)
        return
    # fi
    #-- if therest != '':
    #--     print_warning("decode note has extra characters '{}' after note".format(therest), line)
    #--     return
    #-- # fi
    if thenote <= 12+12-3:
        computeit = wargs[0] + '=' + '0'                       # rest = 0
    else:
        computeit = wargs[0] + '=' + str(thenote) + '+3-12-12'  # Convert from midi note to musicomp value.
    # fi
    value, type_error = is_float(computeit)
    if type_error is not None:
        print_error("decode note unable to assign value({}) to first argument({}).".format(wargs[0],thenote), line)
        return
    # fi
    return
# End of do_decode

#-----------------------------------------------------------------------------
def do_clef(t_args, line):
    global clef
    global measure_on

    if t_args is None or len(t_args) <= 0 or t_args[0] == '':
        print_error("clef does not have an argument", line)
        return
    # fi

    wargs = arglist(t_args[0], line)
    if not wargs or len(wargs) < 1:
        print_error("no clef selection arguments", line)
        return
    # fi
    for i in range(1, len(wargs)+1):
        clef[measure_on][i] = wargs[i-1].strip()   # No checking.
    # rof
    return
# End of do_clef

#-----------------------------------------------------------------------------
def do_bars(t_args, line):
    global bars

    if t_args is None or len(t_args) <= 0 or t_args[0] == '':
        print_error("bars does not have an expression to process", line)
        return
    # fi

    m = t_args[0]

    f, type_error = is_float(m)
    if type_error is not None:
        return
    # fi
    if f is None:
        print_error("bars argument as a calculation did not return a value", line)
        return
    # fi
    bars = int(round(f))
    # fi
    return
# End of do_bars

#-----------------------------------------------------------------------------
def do_meter(t_args, line):
    global meter
    global measure_meter
    global measure_on
    global args

    if t_args is None or len(t_args) <= 0 or t_args[0] == '':
        print_error("meter does not have an expression to process", line)
        return
    # fi

    m = t_args[0]

    f, type_error = is_float(m)
    if type_error is not None:
        return
    # fi
    if f is None:
        print_error("meter argument as a calculation did not return a value", line)
        return
    # fi
    meter = m
    measure_meter[measure_on] = m                       # Save text for meter.
    # fi
    return
# End of do_meter

#-----------------------------------------------------------------------------
#   calc m1=10          variables m1 to m9.  m(m2)=m9/5   # floating point.
#               Note: special variables stac, grace, frames, pause
def do_calc(t_args, line):
    if t_args is None or len(t_args) <= 0:
        print_error("calc does not have an expression to process", line)
        return
    # fi
    f, type_error = is_float(t_args[0])
    if type_error is not None:
        return
    # fi
    if f is None:
        print_error("calculate did not return a value", line)
        return
    # fi
    return
# End of do_calc

#-----------------------------------------------------------------------------
# 7 sharps is C# major or A# minor. f+,c+,g+,d+,a+,e+,b+
# 6 sharps is F# major or D# minor. f+,c+,g+,d+,a+,e+
# 5 sharps is B major or G# minor.  f+,c+,g+,d+,a+
# 4 sharps is E major or C# minor.  f+,c+,g+,d+
# 3 sharps is A major or F# minor.  f+,c+,g+
# 2 sharps is D major or B minor.   f+,c+
# 1 sharp  is G major or E minor.   f+
# None     is C major or A minor.
# 1 flat   is F major or D minor.   b-
# 2 flats  is B- major or G minor.  b-,e-
# 3 flats  is E- major or C minor.  b-,e-,a-
# 4 flats  is A- major or F minor.  b-,e-,a-,d-
# 5 flats  is D- major or B- minor. b-,e-,a-,d-,g-
# 6 flats  is G- major or E- minor. b-,e-,a-,d-,g-,c-
# 7 flats  is C- major or A- minor. b-,e-,a-,d-,g-,c-,f-

# Following does not do multiple sharps or flats, but that is crazy anyway. Neither naturals.
global key_sig
key_sig = { 'c+':7, 'f+':6, 'b':5, 'e':4, 'a':3, 'd':2, 'g':1, 'c':0,
            'f':-1, 'b-':-2, 'e-':-3, 'a-':-4, 'd-':-5, 'g-':-6, 'c-':-7 }

global key_sig_int
key_sig_int = {}
for i in key_sig:
    key_sig_int[key_sig[i]] = i
# rof

global key_convert
key_convert = {
    'c+':  {     # f+,c+,g+,d+,a+,e+,b+
        '0c-':None,  '0c':'0c+', '0cn':'0cn', '0c+':'0c+',   '0d-':'0d-', '0d':'0d+', '0dn':'0dn', '0d+':'0d+',
        '0e-':'0e-', '0e':'0e+', '0en':'0en', '0e+':'0f',    '0f-':'0e',  '0f':'0f+', '0fn':'0fn', '0f+':'0f+',
        '0g-':'0g-', '0g':'0g+', '0gn':'0gn', '0g+':'0g+',   '0a-':'0a-', '0a':'0a+', '0an':'0an', '0a+':'0a+',
        '0b-':'0b-', '0b':'0b+', '0bn':'0bn', '0b+':'1c',
        '1c-':'0b',  '1c':'1c+', '1cn':'1cn', '1c+':'1c+',   '1d-':'1d-', '1d':'1d+', '1dn':'1dn', '1d+':'1d+',
        '1e-':'1e-', '1e':'1e+', '1en':'1en', '1e+':'1f',    '1f-':'1e',  '1f':'1f+', '1fn':'1fn', '1f+':'1f+',
        '1g-':'1g-', '1g':'1g+', '1gn':'1gn', '1g+':'1g+',   '1a-':'1a-', '1a':'1a+', '1an':'1an', '1a+':'1a+',
        '1b-':'1b-', '1b':'1b+', '1bn':'1bn', '1b+':'2c',
        '2c-':'1b',  '2c':'2c+', '2cn':'2cn', '2c+':'2c+',   '2d-':'2d-', '2d':'2d+', '2dn':'2dn', '2d+':'2d+',
        '2e-':'2e-', '2e':'2e+', '2en':'2en', '2e+':'2f',    '2f-':'2e',  '2f':'2f+', '2fn':'2fn', '2f+':'2f+',
        '2g-':'2g-', '2g':'2g+', '2gn':'2gn', '2g+':'2g+',   '2a-':'2a-', '2a':'2a+', '2an':'2an', '2a+':'2a+',
        '2b-':'2b-', '2b':'2b+', '2bn':'2bn', '2b+':'3c',
        '3c-':'2b',  '3c':'3c+', '3cn':'3cn', '3c+':'3c+',   '3d-':'3d-', '3d':'3d+', '3dn':'3dn', '3d+':'3d+',
        '3e-':'3e-', '3e':'3e+', '3en':'3en', '3e+':'3f',    '3f-':'3e',  '3f':'3f+', '3fn':'3fn', '3f+':'3f+',
        '3g-':'3g-', '3g':'3g+', '3gn':'3gn', '3g+':'3g+',   '3a-':'3a-', '3a':'3a+', '3an':'3an', '3a+':'3a+',
        '3b-':'3b-', '3b':'3b+', '3bn':'3bn', '3b+':'4c',
        '4c-':'3b',  '4c':'4c+', '4cn':'4cn', '4c+':'4c+',   '4d-':'4d-', '4d':'4d+', '4dn':'4dn', '4d+':'4d+',
        '4e-':'4e-', '4e':'4e+', '4en':'4en', '4e+':'4f',    '4f-':'4e',  '4f':'4f+', '4fn':'4fn', '4f+':'4f+',
        '4g-':'4g-', '4g':'4g+', '4gn':'4gn', '4g+':'4g+',   '4a-':'4a-', '4a':'4a+', '4an':'4an', '4a+':'4a+',
        '4b-':'4b-', '4b':'4b+', '4bn':'4bn', '4b+':'5c',
        '5c-':'4b',  '5c':'5c+', '5cn':'5cn', '5c+':'5c+',   '5d-':'5d-', '5d':'5d+', '5dn':'5dn', '5d+':'5d+',
        '5e-':'5e-', '5e':'5e+', '5en':'5en', '5e+':'5f',    '5f-':'5e',  '5f':'5f+', '5fn':'5fn', '5f+':'5f+',
        '5g-':'5g-', '5g':'5g+', '5gn':'5gn', '5g+':'5g+',   '5a-':'5a-', '5a':'5a+', '5an':'5an', '5a+':'5a+',
        '5b-':'5b-', '5b':'5b+', '5bn':'5bn', '5b+':'6c',
        '6c-':'5b',  '6c':'6c+', '6cn':'6cn', '6c+':'6c+',   '6d-':'6d-', '6d':'6d+', '6dn':'6dn', '6d+':'6d+',
        '6e-':'6e-', '6e':'6e+', '6en':'6en', '6e+':'6f',    '6f-':'6e',  '6f':'6f+', '6fn':'6fn', '6f+':'6f+',
        '6g-':'6g-', '6g':'6g+', '6gn':'6gn', '6g+':'6g+',   '6a-':'6a-', '6a':'6a+', '6an':'6an', '6a+':'6a+',
        '6b-':'6b-', '6b':'6b+', '6bn':'6bn', '6b+':'7c',
        '7c-':'6b',  '7c':'7c+', '7cn':'7cn', '7c+':'7c+',   '7d-':'7d-', '7d':'7d+', '7dn':'7dn', '7d+':'7d+',
        '7e-':'7e-', '7e':'7e+', '7en':'7en', '7e+':'7f',    '7f-':'7e',  '7f':'7f+', '7fn':'7fn', '7f+':'7f+',
        '7g-':'7g-', '7g':'7g+', '7gn':'7gn', '7g+':'7g+',   '7a-':'7a-', '7a':'7a+', '7an':'7an', '7a+':'7a+',
        '7b-':'7b-', '7b':'7b+', '7bn':'7bn', '7b+':'8c',
        '8c-':'7b',  '8c':'8c+', '8cn':'8cn', '8c+':'8c+',   '8d-':'8d-', '8d':'8d+', '8dn':'8dn', '8d+':'8d+',
        '8e-':'8e-', '8e':'8e+', '8en':'8en', '8e+':'8f',    '8f-':'8e',  '8f':'8f+', '8fn':'8fn', '8f+':'8f+',
        '8g-':'8g-', '8g':'8g+', '8gn':'8gn', '8g+':'8g+',   '8a-':'8a-', '8a':'8a+', '8an':'8an', '8a+':'8a+',
        '8b-':'8b-', '8b':'8b+', '8bn':'8bn', '8b+':None,
    },
    'f+':  {     # f+,c+,g+,d+,a+,e+
        '0c-':None,  '0c':'0c+', '0cn':'0cn', '0c+':'0c+',   '0d-':'0d-', '0d':'0d+', '0dn':'0dn', '0d+':'0d+',
        '0e-':'0e-', '0e':'0e+', '0en':'0en', '0e+':'0f',    '0f-':'0e',  '0f':'0f+', '0fn':'0fn', '0f+':'0f+',
        '0g-':'0g-', '0g':'0g+', '0gn':'0gn', '0g+':'0g+',   '0a-':'0a-', '0a':'0a+', '0an':'0an', '0a+':'0a+',
        '0b-':'0b-', '0b':'0b', '0bn':'0b', '0b+':'1c',
        '1c-':'0b',  '1c':'1c+', '1cn':'1cn', '1c+':'1c+',   '1d-':'1d-', '1d':'1d+', '1dn':'1dn', '1d+':'1d+',
        '1e-':'1e-', '1e':'1e+', '1en':'1en', '1e+':'1f',    '1f-':'1e',  '1f':'1f+', '1fn':'1fn', '1f+':'1f+',
        '1g-':'1g-', '1g':'1g+', '1gn':'1gn', '1g+':'1g+',   '1a-':'1a-', '1a':'1a+', '1an':'1an', '1a+':'1a+',
        '1b-':'1b-', '1b':'1b', '1bn':'1b', '1b+':'2c',
        '2c-':'1b',  '2c':'2c+', '2cn':'2cn', '2c+':'2c+',   '2d-':'2d-', '2d':'2d+', '2dn':'2dn', '2d+':'2d+',
        '2e-':'2e-', '2e':'2e+', '2en':'2en', '2e+':'2f',    '2f-':'2e',  '2f':'2f+', '2fn':'2fn', '2f+':'2f+',
        '2g-':'2g-', '2g':'2g+', '2gn':'2gn', '2g+':'2g+',   '2a-':'2a-', '2a':'2a+', '2an':'2an', '2a+':'2a+',
        '2b-':'2b-', '2b':'2b', '2bn':'2b', '2b+':'3c',
        '3c-':'2b',  '3c':'3c+', '3cn':'3cn', '3c+':'3c+',   '3d-':'3d-', '3d':'3d+', '3dn':'3dn', '3d+':'3d+',
        '3e-':'3e-', '3e':'3e+', '3en':'3en', '3e+':'3f',    '3f-':'3e',  '3f':'3f+', '3fn':'3fn', '3f+':'3f+',
        '3g-':'3g-', '3g':'3g+', '3gn':'3gn', '3g+':'3g+',   '3a-':'3a-', '3a':'3a+', '3an':'3an', '3a+':'3a+',
        '3b-':'3b-', '3b':'3b', '3bn':'3b', '3b+':'4c',
        '4c-':'3b',  '4c':'4c+', '4cn':'4cn', '4c+':'4c+',   '4d-':'4d-', '4d':'4d+', '4dn':'4dn', '4d+':'4d+',
        '4e-':'4e-', '4e':'4e+', '4en':'4en', '4e+':'4f',    '4f-':'4e',  '4f':'4f+', '4fn':'4fn', '4f+':'4f+',
        '4g-':'4g-', '4g':'4g+', '4gn':'4gn', '4g+':'4g+',   '4a-':'4a-', '4a':'4a+', '4an':'4an', '4a+':'4a+',
        '4b-':'4b-', '4b':'4b', '4bn':'4b', '4b+':'5c',
        '5c-':'4b',  '5c':'5c+', '5cn':'5cn', '5c+':'5c+',   '5d-':'5d-', '5d':'5d+', '5dn':'5dn', '5d+':'5d+',
        '5e-':'5e-', '5e':'5e+', '5en':'5en', '5e+':'5f',    '5f-':'5e',  '5f':'5f+', '5fn':'5fn', '5f+':'5f+',
        '5g-':'5g-', '5g':'5g+', '5gn':'5gn', '5g+':'5g+',   '5a-':'5a-', '5a':'5a+', '5an':'5an', '5a+':'5a+',
        '5b-':'5b-', '5b':'5b', '5bn':'5b', '5b+':'6c',
        '6c-':'5b',  '6c':'6c+', '6cn':'6cn', '6c+':'6c+',   '6d-':'6d-', '6d':'6d+', '6dn':'6dn', '6d+':'6d+',
        '6e-':'6e-', '6e':'6e+', '6en':'6en', '6e+':'6f',    '6f-':'6e',  '6f':'6f+', '6fn':'6fn', '6f+':'6f+',
        '6g-':'6g-', '6g':'6g+', '6gn':'6gn', '6g+':'6g+',   '6a-':'6a-', '6a':'6a+', '6an':'6an', '6a+':'6a+',
        '6b-':'6b-', '6b':'6b', '6bn':'6b', '6b+':'7c',
        '7c-':'6b',  '7c':'7c+', '7cn':'7cn', '7c+':'7c+',   '7d-':'7d-', '7d':'7d+', '7dn':'7dn', '7d+':'7d+',
        '7e-':'7e-', '7e':'7e+', '7en':'7en', '7e+':'7f',    '7f-':'7e',  '7f':'7f+', '7fn':'7fn', '7f+':'7f+',
        '7g-':'7g-', '7g':'7g+', '7gn':'7gn', '7g+':'7g+',   '7a-':'7a-', '7a':'7a+', '7an':'7an', '7a+':'7a+',
        '7b-':'7b-', '7b':'7b', '7bn':'7b', '7b+':'8c',
        '8c-':'7b',  '8c':'8c+', '8cn':'8cn', '8c+':'8c+',   '8d-':'8d-', '8d':'8d+', '8dn':'8dn', '8d+':'8d+',
        '8e-':'8e-', '8e':'8e+', '8en':'8en', '8e+':'8f',    '8f-':'8e',  '8f':'8f+', '8fn':'8fn', '8f+':'8f+',
        '8g-':'8g-', '8g':'8g+', '8gn':'8gn', '8g+':'8g+',   '8a-':'8a-', '8a':'8a+', '8an':'8an', '8a+':'8a+',
        '8b-':'8b-', '8b':'8b', '8bn':'8b', '8b+':None,
    },
    'b':  {     # f+,c+,g+,d+,a+
        '0c-':None,  '0c':'0c+', '0cn':'0cn', '0c+':'0c+',   '0d-':'0d-', '0d':'0d+', '0dn':'0dn', '0d+':'0d+',
        '0e-':'0e-', '0e':'0e', '0en':'0e', '0e+':'0f',    '0f-':'0e',  '0f':'0f+', '0fn':'0fn', '0f+':'0f+',
        '0g-':'0g-', '0g':'0g+', '0gn':'0gn', '0g+':'0g+',   '0a-':'0a-', '0a':'0a+', '0an':'0an', '0a+':'0a+',
        '0b-':'0b-', '0b':'0b', '0bn':'0b', '0b+':'1c',
        '1c-':'0b',  '1c':'1c+', '1cn':'1cn', '1c+':'1c+',   '1d-':'1d-', '1d':'1d+', '1dn':'1dn', '1d+':'1d+',
        '1e-':'1e-', '1e':'1e', '1en':'1e', '1e+':'1f',    '1f-':'1e',  '1f':'1f+', '1fn':'1fn', '1f+':'1f+',
        '1g-':'1g-', '1g':'1g+', '1gn':'1gn', '1g+':'1g+',   '1a-':'1a-', '1a':'1a+', '1an':'1an', '1a+':'1a+',
        '1b-':'1b-', '1b':'1b', '1bn':'1b', '1b+':'2c',
        '2c-':'1b',  '2c':'2c+', '2cn':'2cn', '2c+':'2c+',   '2d-':'2d-', '2d':'2d+', '2dn':'2dn', '2d+':'2d+',
        '2e-':'2e-', '2e':'2e', '2en':'2e', '2e+':'2f',    '2f-':'2e',  '2f':'2f+', '2fn':'2fn', '2f+':'2f+',
        '2g-':'2g-', '2g':'2g+', '2gn':'2gn', '2g+':'2g+',   '2a-':'2a-', '2a':'2a+', '2an':'2an', '2a+':'2a+',
        '2b-':'2b-', '2b':'2b', '2bn':'2b', '2b+':'3c',
        '3c-':'2b',  '3c':'3c+', '3cn':'3cn', '3c+':'3c+',   '3d-':'3d-', '3d':'3d+', '3dn':'3dn', '3d+':'3d+',
        '3e-':'3e-', '3e':'3e', '3en':'3e', '3e+':'3f',    '3f-':'3e',  '3f':'3f+', '3fn':'3fn', '3f+':'3f+',
        '3g-':'3g-', '3g':'3g+', '3gn':'3gn', '3g+':'3g+',   '3a-':'3a-', '3a':'3a+', '3an':'3an', '3a+':'3a+',
        '3b-':'3b-', '3b':'3b', '3bn':'3b', '3b+':'4c',
        '4c-':'3b',  '4c':'4c+', '4cn':'4cn', '4c+':'4c+',   '4d-':'4d-', '4d':'4d+', '4dn':'4dn', '4d+':'4d+',
        '4e-':'4e-', '4e':'4e', '4en':'4e', '4e+':'4f',    '4f-':'4e',  '4f':'4f+', '4fn':'4fn', '4f+':'4f+',
        '4g-':'4g-', '4g':'4g+', '4gn':'4gn', '4g+':'4g+',   '4a-':'4a-', '4a':'4a+', '4an':'4an', '4a+':'4a+',
        '4b-':'4b-', '4b':'4b', '4bn':'4b', '4b+':'5c',
        '5c-':'4b',  '5c':'5c+', '5cn':'5cn', '5c+':'5c+',   '5d-':'5d-', '5d':'5d+', '5dn':'5dn', '5d+':'5d+',
        '5e-':'5e-', '5e':'5e', '5en':'5e', '5e+':'5f',    '5f-':'5e',  '5f':'5f+', '5fn':'5fn', '5f+':'5f+',
        '5g-':'5g-', '5g':'5g+', '5gn':'5gn', '5g+':'5g+',   '5a-':'5a-', '5a':'5a+', '5an':'5an', '5a+':'5a+',
        '5b-':'5b-', '5b':'5b', '5bn':'5b', '5b+':'6c',
        '6c-':'5b',  '6c':'6c+', '6cn':'6cn', '6c+':'6c+',   '6d-':'6d-', '6d':'6d+', '6dn':'6dn', '6d+':'6d+',
        '6e-':'6e-', '6e':'6e', '6en':'6e', '6e+':'6f',    '6f-':'6e',  '6f':'6f+', '6fn':'6fn', '6f+':'6f+',
        '6g-':'6g-', '6g':'6g+', '6gn':'6gn', '6g+':'6g+',   '6a-':'6a-', '6a':'6a+', '6an':'6an', '6a+':'6a+',
        '6b-':'6b-', '6b':'6b', '6bn':'6b', '6b+':'7c',
        '7c-':'6b',  '7c':'7c+', '7cn':'7cn', '7c+':'7c+',   '7d-':'7d-', '7d':'7d+', '7dn':'7dn', '7d+':'7d+',
        '7e-':'7e-', '7e':'7e', '7en':'7e', '7e+':'7f',    '7f-':'7e',  '7f':'7f+', '7fn':'7fn', '7f+':'7f+',
        '7g-':'7g-', '7g':'7g+', '7gn':'7gn', '7g+':'7g+',   '7a-':'7a-', '7a':'7a+', '7an':'7an', '7a+':'7a+',
        '7b-':'7b-', '7b':'7b', '7bn':'7b', '7b+':'8c',
        '8c-':'7b',  '8c':'8c+', '8cn':'8cn', '8c+':'8c+',   '8d-':'8d-', '8d':'8d+', '8dn':'8dn', '8d+':'8d+',
        '8e-':'8e-', '8e':'8e', '8en':'8e', '8e+':'8f',    '8f-':'8e',  '8f':'8f+', '8fn':'8fn', '8f+':'8f+',
        '8g-':'8g-', '8g':'8g+', '8gn':'8gn', '8g+':'8g+',   '8a-':'8a-', '8a':'8a+', '8an':'8an', '8a+':'8a+',
        '8b-':'8b-', '8b':'8b', '8bn':'8b', '8b+':None,
    },
    'e':  {     # f+,c+,g+,d+
        '0c-':None,  '0c':'0c+', '0cn':'0cn', '0c+':'0c+',   '0d-':'0d-', '0d':'0d+', '0dn':'0dn', '0d+':'0d+',
        '0e-':'0e-', '0e':'0e', '0en':'0e', '0e+':'0f',    '0f-':'0e',  '0f':'0f+', '0fn':'0fn', '0f+':'0f+',
        '0g-':'0g-', '0g':'0g+', '0gn':'0gn', '0g+':'0g+',   '0a-':'0a-', '0a':'0a', '0an':'0a', '0a+':'0a+',
        '0b-':'0b-', '0b':'0b', '0bn':'0b', '0b+':'1c',
        '1c-':'0b',  '1c':'1c+', '1cn':'1cn', '1c+':'1c+',   '1d-':'1d-', '1d':'1d+', '1dn':'1dn', '1d+':'1d+',
        '1e-':'1e-', '1e':'1e', '1en':'1e', '1e+':'1f',    '1f-':'1e',  '1f':'1f+', '1fn':'1fn', '1f+':'1f+',
        '1g-':'1g-', '1g':'1g+', '1gn':'1gn', '1g+':'1g+',   '1a-':'1a-', '1a':'1a', '1an':'1a', '1a+':'1a+',
        '1b-':'1b-', '1b':'1b', '1bn':'1b', '1b+':'2c',
        '2c-':'1b',  '2c':'2c+', '2cn':'2cn', '2c+':'2c+',   '2d-':'2d-', '2d':'2d+', '2dn':'2dn', '2d+':'2d+',
        '2e-':'2e-', '2e':'2e', '2en':'2e', '2e+':'2f',    '2f-':'2e',  '2f':'2f+', '2fn':'2fn', '2f+':'2f+',
        '2g-':'2g-', '2g':'2g+', '2gn':'2gn', '2g+':'2g+',   '2a-':'2a-', '2a':'2a', '2an':'2a', '2a+':'2a+',
        '2b-':'2b-', '2b':'2b', '2bn':'2b', '2b+':'3c',
        '3c-':'2b',  '3c':'3c+', '3cn':'3cn', '3c+':'3c+',   '3d-':'3d-', '3d':'3d+', '3dn':'3dn', '3d+':'3d+',
        '3e-':'3e-', '3e':'3e', '3en':'3e', '3e+':'3f',    '3f-':'3e',  '3f':'3f+', '3fn':'3fn', '3f+':'3f+',
        '3g-':'3g-', '3g':'3g+', '3gn':'3gn', '3g+':'3g+',   '3a-':'3a-', '3a':'3a', '3an':'3a', '3a+':'3a+',
        '3b-':'3b-', '3b':'3b', '3bn':'3b', '3b+':'4c',
        '4c-':'3b',  '4c':'4c+', '4cn':'4cn', '4c+':'4c+',   '4d-':'4d-', '4d':'4d+', '4dn':'4dn', '4d+':'4d+',
        '4e-':'4e-', '4e':'4e', '4en':'4e', '4e+':'4f',    '4f-':'4e',  '4f':'4f+', '4fn':'4fn', '4f+':'4f+',
        '4g-':'4g-', '4g':'4g+', '4gn':'4gn', '4g+':'4g+',   '4a-':'4a-', '4a':'4a', '4an':'4a', '4a+':'4a+',
        '4b-':'4b-', '4b':'4b', '4bn':'4b', '4b+':'5c',
        '5c-':'4b',  '5c':'5c+', '5cn':'5cn', '5c+':'5c+',   '5d-':'5d-', '5d':'5d+', '5dn':'5dn', '5d+':'5d+',
        '5e-':'5e-', '5e':'5e', '5en':'5e', '5e+':'5f',    '5f-':'5e',  '5f':'5f+', '5fn':'5fn', '5f+':'5f+',
        '5g-':'5g-', '5g':'5g+', '5gn':'5gn', '5g+':'5g+',   '5a-':'5a-', '5a':'5a', '5an':'5a', '5a+':'5a+',
        '5b-':'5b-', '5b':'5b', '5bn':'5b', '5b+':'6c',
        '6c-':'5b',  '6c':'6c+', '6cn':'6cn', '6c+':'6c+',   '6d-':'6d-', '6d':'6d+', '6dn':'6dn', '6d+':'6d+',
        '6e-':'6e-', '6e':'6e', '6en':'6e', '6e+':'6f',    '6f-':'6e',  '6f':'6f+', '6fn':'6fn', '6f+':'6f+',
        '6g-':'6g-', '6g':'6g+', '6gn':'6gn', '6g+':'6g+',   '6a-':'6a-', '6a':'6a', '6an':'6a', '6a+':'6a+',
        '6b-':'6b-', '6b':'6b', '6bn':'6b', '6b+':'7c',
        '7c-':'6b',  '7c':'7c+', '7cn':'7cn', '7c+':'7c+',   '7d-':'7d-', '7d':'7d+', '7dn':'7dn', '7d+':'7d+',
        '7e-':'7e-', '7e':'7e', '7en':'7e', '7e+':'7f',    '7f-':'7e',  '7f':'7f+', '7fn':'7fn', '7f+':'7f+',
        '7g-':'7g-', '7g':'7g+', '7gn':'7gn', '7g+':'7g+',   '7a-':'7a-', '7a':'7a', '7an':'7a', '7a+':'7a+',
        '7b-':'7b-', '7b':'7b', '7bn':'7b', '7b+':'8c',
        '8c-':'7b',  '8c':'8c+', '8cn':'8cn', '8c+':'8c+',   '8d-':'8d-', '8d':'8d+', '8dn':'8dn', '8d+':'8d+',
        '8e-':'8e-', '8e':'8e', '8en':'8e', '8e+':'8f',    '8f-':'8e',  '8f':'8f+', '8fn':'8fn', '8f+':'8f+',
        '8g-':'8g-', '8g':'8g+', '8gn':'8gn', '8g+':'8g+',   '8a-':'8a-', '8a':'8a', '8an':'8a', '8a+':'8a+',
        '8b-':'8b-', '8b':'8b', '8bn':'8b', '8b+':None,
    },
    'a':  {     # f+,c+,g+
        '0c-':None,  '0c':'0c+', '0cn':'0cn', '0c+':'0c+',   '0d-':'0d-', '0d':'0d', '0dn':'0d', '0d+':'0d+',
        '0e-':'0e-', '0e':'0e', '0en':'0e', '0e+':'0f',    '0f-':'0e',  '0f':'0f+', '0fn':'0fn', '0f+':'0f+',
        '0g-':'0g-', '0g':'0g+', '0gn':'0gn', '0g+':'0g+',   '0a-':'0a-', '0a':'0a', '0an':'0a', '0a+':'0a+',
        '0b-':'0b-', '0b':'0b', '0bn':'0b', '0b+':'1c',
        '1c-':'0b',  '1c':'1c+', '1cn':'1cn', '1c+':'1c+',   '1d-':'1d-', '1d':'1d', '1dn':'1d', '1d+':'1d+',
        '1e-':'1e-', '1e':'1e', '1en':'1e', '1e+':'1f',    '1f-':'1e',  '1f':'1f+', '1fn':'1fn', '1f+':'1f+',
        '1g-':'1g-', '1g':'1g+', '1gn':'1gn', '1g+':'1g+',   '1a-':'1a-', '1a':'1a', '1an':'1a', '1a+':'1a+',
        '1b-':'1b-', '1b':'1b', '1bn':'1b', '1b+':'2c',
        '2c-':'1b',  '2c':'2c+', '2cn':'2cn', '2c+':'2c+',   '2d-':'2d-', '2d':'2d', '2dn':'2d', '2d+':'2d+',
        '2e-':'2e-', '2e':'2e', '2en':'2e', '2e+':'2f',    '2f-':'2e',  '2f':'2f+', '2fn':'2fn', '2f+':'2f+',
        '2g-':'2g-', '2g':'2g+', '2gn':'2gn', '2g+':'2g+',   '2a-':'2a-', '2a':'2a', '2an':'2a', '2a+':'2a+',
        '2b-':'2b-', '2b':'2b', '2bn':'2b', '2b+':'3c',
        '3c-':'2b',  '3c':'3c+', '3cn':'3cn', '3c+':'3c+',   '3d-':'3d-', '3d':'3d', '3dn':'3d', '3d+':'3d+',
        '3e-':'3e-', '3e':'3e', '3en':'3e', '3e+':'3f',    '3f-':'3e',  '3f':'3f+', '3fn':'3fn', '3f+':'3f+',
        '3g-':'3g-', '3g':'3g+', '3gn':'3gn', '3g+':'3g+',   '3a-':'3a-', '3a':'3a', '3an':'3a', '3a+':'3a+',
        '3b-':'3b-', '3b':'3b', '3bn':'3b', '3b+':'4c',
        '4c-':'3b',  '4c':'4c+', '4cn':'4cn', '4c+':'4c+',   '4d-':'4d-', '4d':'4d', '4dn':'4d', '4d+':'4d+',
        '4e-':'4e-', '4e':'4e', '4en':'4e', '4e+':'4f',    '4f-':'4e',  '4f':'4f+', '4fn':'4fn', '4f+':'4f+',
        '4g-':'4g-', '4g':'4g+', '4gn':'4gn', '4g+':'4g+',   '4a-':'4a-', '4a':'4a', '4an':'4a', '4a+':'4a+',
        '4b-':'4b-', '4b':'4b', '4bn':'4b', '4b+':'5c',
        '5c-':'4b',  '5c':'5c+', '5cn':'5cn', '5c+':'5c+',   '5d-':'5d-', '5d':'5d', '5dn':'5d', '5d+':'5d+',
        '5e-':'5e-', '5e':'5e', '5en':'5e', '5e+':'5f',    '5f-':'5e',  '5f':'5f+', '5fn':'5fn', '5f+':'5f+',
        '5g-':'5g-', '5g':'5g+', '5gn':'5gn', '5g+':'5g+',   '5a-':'5a-', '5a':'5a', '5an':'5a', '5a+':'5a+',
        '5b-':'5b-', '5b':'5b', '5bn':'5b', '5b+':'6c',
        '6c-':'5b',  '6c':'6c+', '6cn':'6cn', '6c+':'6c+',   '6d-':'6d-', '6d':'6d', '6dn':'6d', '6d+':'6d+',
        '6e-':'6e-', '6e':'6e', '6en':'6e', '6e+':'6f',    '6f-':'6e',  '6f':'6f+', '6fn':'6fn', '6f+':'6f+',
        '6g-':'6g-', '6g':'6g+', '6gn':'6gn', '6g+':'6g+',   '6a-':'6a-', '6a':'6a', '6an':'6a', '6a+':'6a+',
        '6b-':'6b-', '6b':'6b', '6bn':'6b', '6b+':'7c',
        '7c-':'6b',  '7c':'7c+', '7cn':'7cn', '7c+':'7c+',   '7d-':'7d-', '7d':'7d', '7dn':'7d', '7d+':'7d+',
        '7e-':'7e-', '7e':'7e', '7en':'7e', '7e+':'7f',    '7f-':'7e',  '7f':'7f+', '7fn':'7fn', '7f+':'7f+',
        '7g-':'7g-', '7g':'7g+', '7gn':'7gn', '7g+':'7g+',   '7a-':'7a-', '7a':'7a', '7an':'7a', '7a+':'7a+',
        '7b-':'7b-', '7b':'7b', '7bn':'7b', '7b+':'8c',
        '8c-':'7b',  '8c':'8c+', '8cn':'8cn', '8c+':'8c+',   '8d-':'8d-', '8d':'8d', '8dn':'8d', '8d+':'8d+',
        '8e-':'8e-', '8e':'8e', '8en':'8e', '8e+':'8f',    '8f-':'8e',  '8f':'8f+', '8fn':'8fn', '8f+':'8f+',
        '8g-':'8g-', '8g':'8g+', '8gn':'8gn', '8g+':'8g+',   '8a-':'8a-', '8a':'8a', '8an':'8a', '8a+':'8a+',
        '8b-':'8b-', '8b':'8b', '8bn':'8b', '8b+':None,
    },
    'd':  {     # f+,c+
        '0c-':None,  '0c':'0c+', '0cn':'0cn', '0c+':'0c+',   '0d-':'0d-', '0d':'0d', '0dn':'0d', '0d+':'0d+',
        '0e-':'0e-', '0e':'0e', '0en':'0e', '0e+':'0f',    '0f-':'0e',  '0f':'0f+', '0fn':'0fn', '0f+':'0f+',
        '0g-':'0g-', '0g':'0g', '0gn':'0g', '0g+':'0g+',   '0a-':'0a-', '0a':'0a', '0an':'0a', '0a+':'0a+',
        '0b-':'0b-', '0b':'0b', '0bn':'0b', '0b+':'1c',
        '1c-':'0b',  '1c':'1c+', '1cn':'1cn', '1c+':'1c+',   '1d-':'1d-', '1d':'1d', '1dn':'1d', '1d+':'1d+',
        '1e-':'1e-', '1e':'1e', '1en':'1e', '1e+':'1f',    '1f-':'1e',  '1f':'1f+', '1fn':'1fn', '1f+':'1f+',
        '1g-':'1g-', '1g':'1g', '1gn':'1g', '1g+':'1g+',   '1a-':'1a-', '1a':'1a', '1an':'1a', '1a+':'1a+',
        '1b-':'1b-', '1b':'1b', '1bn':'1b', '1b+':'2c',
        '2c-':'1b',  '2c':'2c+', '2cn':'2cn', '2c+':'2c+',   '2d-':'2d-', '2d':'2d', '2dn':'2d', '2d+':'2d+',
        '2e-':'2e-', '2e':'2e', '2en':'2e', '2e+':'2f',    '2f-':'2e',  '2f':'2f+', '2fn':'2fn', '2f+':'2f+',
        '2g-':'2g-', '2g':'2g', '2gn':'2g', '2g+':'2g+',   '2a-':'2a-', '2a':'2a', '2an':'2a', '2a+':'2a+',
        '2b-':'2b-', '2b':'2b', '2bn':'2b', '2b+':'3c',
        '3c-':'2b',  '3c':'3c+', '3cn':'3cn', '3c+':'3c+',   '3d-':'3d-', '3d':'3d', '3dn':'3d', '3d+':'3d+',
        '3e-':'3e-', '3e':'3e', '3en':'3e', '3e+':'3f',    '3f-':'3e',  '3f':'3f+', '3fn':'3fn', '3f+':'3f+',
        '3g-':'3g-', '3g':'3g', '3gn':'3g', '3g+':'3g+',   '3a-':'3a-', '3a':'3a', '3an':'3a', '3a+':'3a+',
        '3b-':'3b-', '3b':'3b', '3bn':'3b', '3b+':'4c',
        '4c-':'3b',  '4c':'4c+', '4cn':'4cn', '4c+':'4c+',   '4d-':'4d-', '4d':'4d', '4dn':'4d', '4d+':'4d+',
        '4e-':'4e-', '4e':'4e', '4en':'4e', '4e+':'4f',    '4f-':'4e',  '4f':'4f+', '4fn':'4fn', '4f+':'4f+',
        '4g-':'4g-', '4g':'4g', '4gn':'4g', '4g+':'4g+',   '4a-':'4a-', '4a':'4a', '4an':'4a', '4a+':'4a+',
        '4b-':'4b-', '4b':'4b', '4bn':'4b', '4b+':'5c',
        '5c-':'4b',  '5c':'5c+', '5cn':'5cn', '5c+':'5c+',   '5d-':'5d-', '5d':'5d', '5dn':'5d', '5d+':'5d+',
        '5e-':'5e-', '5e':'5e', '5en':'5e', '5e+':'5f',    '5f-':'5e',  '5f':'5f+', '5fn':'5fn', '5f+':'5f+',
        '5g-':'5g-', '5g':'5g', '5gn':'5g', '5g+':'5g+',   '5a-':'5a-', '5a':'5a', '5an':'5a', '5a+':'5a+',
        '5b-':'5b-', '5b':'5b', '5bn':'5b', '5b+':'6c',
        '6c-':'5b',  '6c':'6c+', '6cn':'6cn', '6c+':'6c+',   '6d-':'6d-', '6d':'6d', '6dn':'6d', '6d+':'6d+',
        '6e-':'6e-', '6e':'6e', '6en':'6e', '6e+':'6f',    '6f-':'6e',  '6f':'6f+', '6fn':'6fn', '6f+':'6f+',
        '6g-':'6g-', '6g':'6g', '6gn':'6g', '6g+':'6g+',   '6a-':'6a-', '6a':'6a', '6an':'6a', '6a+':'6a+',
        '6b-':'6b-', '6b':'6b', '6bn':'6b', '6b+':'7c',
        '7c-':'6b',  '7c':'7c+', '7cn':'7cn', '7c+':'7c+',   '7d-':'7d-', '7d':'7d', '7dn':'7d', '7d+':'7d+',
        '7e-':'7e-', '7e':'7e', '7en':'7e', '7e+':'7f',    '7f-':'7e',  '7f':'7f+', '7fn':'7fn', '7f+':'7f+',
        '7g-':'7g-', '7g':'7g', '7gn':'7g', '7g+':'7g+',   '7a-':'7a-', '7a':'7a', '7an':'7a', '7a+':'7a+',
        '7b-':'7b-', '7b':'7b', '7bn':'7b', '7b+':'8c',
        '8c-':'7b',  '8c':'8c+', '8cn':'8cn', '8c+':'8c+',   '8d-':'8d-', '8d':'8d', '8dn':'8d', '8d+':'8d+',
        '8e-':'8e-', '8e':'8e', '8en':'8e', '8e+':'8f',    '8f-':'8e',  '8f':'8f+', '8fn':'8fn', '8f+':'8f+',
        '8g-':'8g-', '8g':'8g', '8gn':'8g', '8g+':'8g+',   '8a-':'8a-', '8a':'8a', '8an':'8a', '8a+':'8a+',
        '8b-':'8b-', '8b':'8b', '8bn':'8b', '8b+':None,
    },
    'g':  {     # f+
        '0c-':None,  '0c':'0c', '0cn':'0c', '0c+':'0c+',   '0d-':'0d-', '0d':'0d', '0dn':'0d', '0d+':'0d+',
        '0e-':'0e-', '0e':'0e', '0en':'0e', '0e+':'0f',    '0f-':'0e',  '0f':'0f+', '0fn':'0fn', '0f+':'0f+',
        '0g-':'0g-', '0g':'0g', '0gn':'0g', '0g+':'0g+',   '0a-':'0a-', '0a':'0a', '0an':'0a', '0a+':'0a+',
        '0b-':'0b-', '0b':'0b', '0bn':'0b', '0b+':'1c',
        '1c-':'0b',  '1c':'1c', '1cn':'1c', '1c+':'1c+',   '1d-':'1d-', '1d':'1d', '1dn':'1d', '1d+':'1d+',
        '1e-':'1e-', '1e':'1e', '1en':'1e', '1e+':'1f',    '1f-':'1e',  '1f':'1f+', '1fn':'1fn', '1f+':'1f+',
        '1g-':'1g-', '1g':'1g', '1gn':'1g', '1g+':'1g+',   '1a-':'1a-', '1a':'1a', '1an':'1a', '1a+':'1a+',
        '1b-':'1b-', '1b':'1b', '1bn':'1b', '1b+':'2c',
        '2c-':'1b',  '2c':'2c', '2cn':'2c', '2c+':'2c+',   '2d-':'2d-', '2d':'2d', '2dn':'2d', '2d+':'2d+',
        '2e-':'2e-', '2e':'2e', '2en':'2e', '2e+':'2f',    '2f-':'2e',  '2f':'2f+', '2fn':'2fn', '2f+':'2f+',
        '2g-':'2g-', '2g':'2g', '2gn':'2g', '2g+':'2g+',   '2a-':'2a-', '2a':'2a', '2an':'2a', '2a+':'2a+',
        '2b-':'2b-', '2b':'2b', '2bn':'2b', '2b+':'3c',
        '3c-':'2b',  '3c':'3c', '3cn':'3c', '3c+':'3c+',   '3d-':'3d-', '3d':'3d', '3dn':'3d', '3d+':'3d+',
        '3e-':'3e-', '3e':'3e', '3en':'3e', '3e+':'3f',    '3f-':'3e',  '3f':'3f+', '3fn':'3fn', '3f+':'3f+',
        '3g-':'3g-', '3g':'3g', '3gn':'3g', '3g+':'3g+',   '3a-':'3a-', '3a':'3a', '3an':'3a', '3a+':'3a+',
        '3b-':'3b-', '3b':'3b', '3bn':'3b', '3b+':'4c',
        '4c-':'3b',  '4c':'4c', '4cn':'4c', '4c+':'4c+',   '4d-':'4d-', '4d':'4d', '4dn':'4d', '4d+':'4d+',
        '4e-':'4e-', '4e':'4e', '4en':'4e', '4e+':'4f',    '4f-':'4e',  '4f':'4f+', '4fn':'4fn', '4f+':'4f+',
        '4g-':'4g-', '4g':'4g', '4gn':'4g', '4g+':'4g+',   '4a-':'4a-', '4a':'4a', '4an':'4a', '4a+':'4a+',
        '4b-':'4b-', '4b':'4b', '4bn':'4b', '4b+':'5c',
        '5c-':'4b',  '5c':'5c', '5cn':'5c', '5c+':'5c+',   '5d-':'5d-', '5d':'5d', '5dn':'5d', '5d+':'5d+',
        '5e-':'5e-', '5e':'5e', '5en':'5e', '5e+':'5f',    '5f-':'5e',  '5f':'5f+', '5fn':'5fn', '5f+':'5f+',
        '5g-':'5g-', '5g':'5g', '5gn':'5g', '5g+':'5g+',   '5a-':'5a-', '5a':'5a', '5an':'5a', '5a+':'5a+',
        '5b-':'5b-', '5b':'5b', '5bn':'5b', '5b+':'6c',
        '6c-':'5b',  '6c':'6c', '6cn':'6c', '6c+':'6c+',   '6d-':'6d-', '6d':'6d', '6dn':'6d', '6d+':'6d+',
        '6e-':'6e-', '6e':'6e', '6en':'6e', '6e+':'6f',    '6f-':'6e',  '6f':'6f+', '6fn':'6fn', '6f+':'6f+',
        '6g-':'6g-', '6g':'6g', '6gn':'6g', '6g+':'6g+',   '6a-':'6a-', '6a':'6a', '6an':'6a', '6a+':'6a+',
        '6b-':'6b-', '6b':'6b', '6bn':'6b', '6b+':'7c',
        '7c-':'6b',  '7c':'7c', '7cn':'7c', '7c+':'7c+',   '7d-':'7d-', '7d':'7d', '7dn':'7d', '7d+':'7d+',
        '7e-':'7e-', '7e':'7e', '7en':'7e', '7e+':'7f',    '7f-':'7e',  '7f':'7f+', '7fn':'7fn', '7f+':'7f+',
        '7g-':'7g-', '7g':'7g', '7gn':'7g', '7g+':'7g+',   '7a-':'7a-', '7a':'7a', '7an':'7a', '7a+':'7a+',
        '7b-':'7b-', '7b':'7b', '7bn':'7b', '7b+':'8c',
        '8c-':'7b',  '8c':'8c', '8cn':'8c', '8c+':'8c+',   '8d-':'8d-', '8d':'8d', '8dn':'8d', '8d+':'8d+',
        '8e-':'8e-', '8e':'8e', '8en':'8e', '8e+':'8f',    '8f-':'8e',  '8f':'8f+', '8fn':'8fn', '8f+':'8f+',
        '8g-':'8g-', '8g':'8g', '8gn':'8g', '8g+':'8g+',   '8a-':'8a-', '8a':'8a', '8an':'8a', '8a+':'8a+',
        '8b-':'8b-', '8b':'8b', '8bn':'8b', '8b+':None,
    },
    'c':  {     # No sharps or flats.
        '0c-':None,  '0c':'0c', '0cn':'0c', '0c+':'0c+',   '0d-':'0d-', '0d':'0d', '0dn':'0d', '0d+':'0d+',
        '0e-':'0e-', '0e':'0e', '0en':'0e', '0e+':'0f',    '0f-':'0e',  '0f':'0f', '0fn':'0f', '0f+':'0f+',
        '0g-':'0g-', '0g':'0g', '0gn':'0g', '0g+':'0g+',   '0a-':'0a-', '0a':'0a', '0an':'0a', '0a+':'0a+',
        '0b-':'0b-', '0b':'0b', '0bn':'0b', '0b+':'1c',
        '1c-':'0b',  '1c':'1c', '1cn':'1c', '1c+':'1c+',   '1d-':'1d-', '1d':'1d', '1dn':'1d', '1d+':'1d+',
        '1e-':'1e-', '1e':'1e', '1en':'1e', '1e+':'1f',    '1f-':'1e',  '1f':'1f', '1fn':'1f', '1f+':'1f+',
        '1g-':'1g-', '1g':'1g', '1gn':'1g', '1g+':'1g+',   '1a-':'1a-', '1a':'1a', '1an':'1a', '1a+':'1a+',
        '1b-':'1b-', '1b':'1b', '1bn':'1b', '1b+':'2c',
        '2c-':'1b',  '2c':'2c', '2cn':'2c', '2c+':'2c+',   '2d-':'2d-', '2d':'2d', '2dn':'2d', '2d+':'2d+',
        '2e-':'2e-', '2e':'2e', '2en':'2e', '2e+':'2f',    '2f-':'2e',  '2f':'2f', '2fn':'2f', '2f+':'2f+',
        '2g-':'2g-', '2g':'2g', '2gn':'2g', '2g+':'2g+',   '2a-':'2a-', '2a':'2a', '2an':'2a', '2a+':'2a+',
        '2b-':'2b-', '2b':'2b', '2bn':'2b', '2b+':'3c',
        '3c-':'2b',  '3c':'3c', '3cn':'3c', '3c+':'3c+',   '3d-':'3d-', '3d':'3d', '3dn':'3d', '3d+':'3d+',
        '3e-':'3e-', '3e':'3e', '3en':'3e', '3e+':'3f',    '3f-':'3e',  '3f':'3f', '3fn':'3f', '3f+':'3f+',
        '3g-':'3g-', '3g':'3g', '3gn':'3g', '3g+':'3g+',   '3a-':'3a-', '3a':'3a', '3an':'3a', '3a+':'3a+',
        '3b-':'3b-', '3b':'3b', '3bn':'3b', '3b+':'4c',
        '4c-':'3b',  '4c':'4c', '4cn':'4c', '4c+':'4c+',   '4d-':'4d-', '4d':'4d', '4dn':'4d', '4d+':'4d+',
        '4e-':'4e-', '4e':'4e', '4en':'4e', '4e+':'4f',    '4f-':'4e',  '4f':'4f', '4fn':'4f', '4f+':'4f+',
        '4g-':'4g-', '4g':'4g', '4gn':'4g', '4g+':'4g+',   '4a-':'4a-', '4a':'4a', '4an':'4a', '4a+':'4a+',
        '4b-':'4b-', '4b':'4b', '4bn':'4b', '4b+':'5c',
        '5c-':'4b',  '5c':'5c', '5cn':'5c', '5c+':'5c+',   '5d-':'5d-', '5d':'5d', '5dn':'5d', '5d+':'5d+',
        '5e-':'5e-', '5e':'5e', '5en':'5e', '5e+':'5f',    '5f-':'5e',  '5f':'5f', '5fn':'5f', '5f+':'5f+',
        '5g-':'5g-', '5g':'5g', '5gn':'5g', '5g+':'5g+',   '5a-':'5a-', '5a':'5a', '5an':'5a', '5a+':'5a+',
        '5b-':'5b-', '5b':'5b', '5bn':'5b', '5b+':'6c',
        '6c-':'5b',  '6c':'6c', '6cn':'6c', '6c+':'6c+',   '6d-':'6d-', '6d':'6d', '6dn':'6d', '6d+':'6d+',
        '6e-':'6e-', '6e':'6e', '6en':'6e', '6e+':'6f',    '6f-':'6e',  '6f':'6f', '6fn':'6f', '6f+':'6f+',
        '6g-':'6g-', '6g':'6g', '6gn':'6g', '6g+':'6g+',   '6a-':'6a-', '6a':'6a', '6an':'6a', '6a+':'6a+',
        '6b-':'6b-', '6b':'6b', '6bn':'6b', '6b+':'7c',
        '7c-':'6b',  '7c':'7c', '7cn':'7c', '7c+':'7c+',   '7d-':'7d-', '7d':'7d', '7dn':'7d', '7d+':'7d+',
        '7e-':'7e-', '7e':'7e', '7en':'7e', '7e+':'7f',    '7f-':'7e',  '7f':'7f', '7fn':'7f', '7f+':'7f+',
        '7g-':'7g-', '7g':'7g', '7gn':'7g', '7g+':'7g+',   '7a-':'7a-', '7a':'7a', '7an':'7a', '7a+':'7a+',
        '7b-':'7b-', '7b':'7b', '7bn':'7b', '7b+':'8c',
        '8c-':'7b',  '8c':'8c', '8cn':'8c', '8c+':'8c+',   '8d-':'8d-', '8d':'8d', '8dn':'8d', '8d+':'8d+',
        '8e-':'8e-', '8e':'8e', '8en':'8e', '8e+':'8f',    '8f-':'8e',  '8f':'8f', '8fn':'8f', '8f+':'8f+',
        '8g-':'8g-', '8g':'8g', '8gn':'8g', '8g+':'8g+',   '8a-':'8a-', '8a':'8a', '8an':'8a', '8a+':'8a+',
        '8b-':'8b-', '8b':'8b', '8bn':'8b', '8b+':None,
    },
    'f':  {     # b-
        '0c-':None,  '0c':'0c', '0cn':'0c', '0c+':'0c+',   '0d-':'0d-', '0d':'0d', '0dn':'0d', '0d+':'0d+',
        '0e-':'0e-', '0e':'0e', '0en':'0e', '0e+':'0f',    '0f-':'0e',  '0f':'0f', '0fn':'0f', '0f+':'0f+',
        '0g-':'0g-', '0g':'0g', '0gn':'0g', '0g+':'0g+',   '0a-':'0a-', '0a':'0a', '0an':'0a', '0a+':'0a+',
        '0b-':'0b-', '0b':'0b-', '0bn':'0bn', '0b+':'1c',
        '1c-':'0b',  '1c':'1c', '1cn':'1c', '1c+':'1c+',   '1d-':'1d-', '1d':'1d', '1dn':'1d', '1d+':'1d+',
        '1e-':'1e-', '1e':'1e', '1en':'1e', '1e+':'1f',    '1f-':'1e',  '1f':'1f', '1fn':'1f', '1f+':'1f+',
        '1g-':'1g-', '1g':'1g', '1gn':'1g', '1g+':'1g+',   '1a-':'1a-', '1a':'1a', '1an':'1a', '1a+':'1a+',
        '1b-':'1b-', '1b':'1b-', '1bn':'1bn', '1b+':'2c',
        '2c-':'1b',  '2c':'2c', '2cn':'2c', '2c+':'2c+',   '2d-':'2d-', '2d':'2d', '2dn':'2d', '2d+':'2d+',
        '2e-':'2e-', '2e':'2e', '2en':'2e', '2e+':'2f',    '2f-':'2e',  '2f':'2f', '2fn':'2f', '2f+':'2f+',
        '2g-':'2g-', '2g':'2g', '2gn':'2g', '2g+':'2g+',   '2a-':'2a-', '2a':'2a', '2an':'2a', '2a+':'2a+',
        '2b-':'2b-', '2b':'2b-', '2bn':'2bn', '2b+':'3c',
        '3c-':'2b',  '3c':'3c', '3cn':'3c', '3c+':'3c+',   '3d-':'3d-', '3d':'3d', '3dn':'3d', '3d+':'3d+',
        '3e-':'3e-', '3e':'3e', '3en':'3e', '3e+':'3f',    '3f-':'3e',  '3f':'3f', '3fn':'3f', '3f+':'3f+',
        '3g-':'3g-', '3g':'3g', '3gn':'3g', '3g+':'3g+',   '3a-':'3a-', '3a':'3a', '3an':'3a', '3a+':'3a+',
        '3b-':'3b-', '3b':'3b-', '3bn':'3bn', '3b+':'4c',
        '4c-':'3b',  '4c':'4c', '4cn':'4c', '4c+':'4c+',   '4d-':'4d-', '4d':'4d', '4dn':'4d', '4d+':'4d+',
        '4e-':'4e-', '4e':'4e', '4en':'4e', '4e+':'4f',    '4f-':'4e',  '4f':'4f', '4fn':'4f', '4f+':'4f+',
        '4g-':'4g-', '4g':'4g', '4gn':'4g', '4g+':'4g+',   '4a-':'4a-', '4a':'4a', '4an':'4a', '4a+':'4a+',
        '4b-':'4b-', '4b':'4b-', '4bn':'4bn', '4b+':'5c',
        '5c-':'4b',  '5c':'5c', '5cn':'5c', '5c+':'5c+',   '5d-':'5d-', '5d':'5d', '5dn':'5d', '5d+':'5d+',
        '5e-':'5e-', '5e':'5e', '5en':'5e', '5e+':'5f',    '5f-':'5e',  '5f':'5f', '5fn':'5f', '5f+':'5f+',
        '5g-':'5g-', '5g':'5g', '5gn':'5g', '5g+':'5g+',   '5a-':'5a-', '5a':'5a', '5an':'5a', '5a+':'5a+',
        '5b-':'5b-', '5b':'5b-', '5bn':'5bn', '5b+':'6c',
        '6c-':'5b',  '6c':'6c', '6cn':'6c', '6c+':'6c+',   '6d-':'6d-', '6d':'6d', '6dn':'6d', '6d+':'6d+',
        '6e-':'6e-', '6e':'6e', '6en':'6e', '6e+':'6f',    '6f-':'6e',  '6f':'6f', '6fn':'6f', '6f+':'6f+',
        '6g-':'6g-', '6g':'6g', '6gn':'6g', '6g+':'6g+',   '6a-':'6a-', '6a':'6a', '6an':'6a', '6a+':'6a+',
        '6b-':'6b-', '6b':'6b-', '6bn':'6bn', '6b+':'7c',
        '7c-':'6b',  '7c':'7c', '7cn':'7c', '7c+':'7c+',   '7d-':'7d-', '7d':'7d', '7dn':'7d', '7d+':'7d+',
        '7e-':'7e-', '7e':'7e', '7en':'7e', '7e+':'7f',    '7f-':'7e',  '7f':'7f', '7fn':'7f', '7f+':'7f+',
        '7g-':'7g-', '7g':'7g', '7gn':'7g', '7g+':'7g+',   '7a-':'7a-', '7a':'7a', '7an':'7a', '7a+':'7a+',
        '7b-':'7b-', '7b':'7b-', '7bn':'7bn', '7b+':'8c',
        '8c-':'7b',  '8c':'8c', '8cn':'8c', '8c+':'8c+',   '8d-':'8d-', '8d':'8d', '8dn':'8d', '8d+':'8d+',
        '8e-':'8e-', '8e':'8e', '8en':'8e', '8e+':'8f',    '8f-':'8e',  '8f':'8f', '8fn':'8f', '8f+':'8f+',
        '8g-':'8g-', '8g':'8g', '8gn':'8g', '8g+':'8g+',   '8a-':'8a-', '8a':'8a', '8an':'8a', '8a+':'8a+',
        '8b-':'8b-', '8b':'8b-', '8bn':'8bn', '8b+':None,
    },
    'b-':  {     # b-,e-
        '0c-':None,  '0c':'0c', '0cn':'0c', '0c+':'0c+',   '0d-':'0d-', '0d':'0d', '0dn':'0d', '0d+':'0d+',
        '0e-':'0e-', '0e':'0e-', '0en':'0en', '0e+':'0f',    '0f-':'0e',  '0f':'0f', '0fn':'0f', '0f+':'0f+',
        '0g-':'0g-', '0g':'0g', '0gn':'0g', '0g+':'0g+',   '0a-':'0a-', '0a':'0a', '0an':'0a', '0a+':'0a+',
        '0b-':'0b-', '0b':'0b-', '0bn':'0bn', '0b+':'1c',
        '1c-':'0b',  '1c':'1c', '1cn':'1c', '1c+':'1c+',   '1d-':'1d-', '1d':'1d', '1dn':'1d', '1d+':'1d+',
        '1e-':'1e-', '1e':'1e-', '1en':'1en', '1e+':'1f',    '1f-':'1e',  '1f':'1f', '1fn':'1f', '1f+':'1f+',
        '1g-':'1g-', '1g':'1g', '1gn':'1g', '1g+':'1g+',   '1a-':'1a-', '1a':'1a', '1an':'1a', '1a+':'1a+',
        '1b-':'1b-', '1b':'1b-', '1bn':'1bn', '1b+':'2c',
        '2c-':'1b',  '2c':'2c', '2cn':'2c', '2c+':'2c+',   '2d-':'2d-', '2d':'2d', '2dn':'2d', '2d+':'2d+',
        '2e-':'2e-', '2e':'2e-', '2en':'2en', '2e+':'2f',    '2f-':'2e',  '2f':'2f', '2fn':'2f', '2f+':'2f+',
        '2g-':'2g-', '2g':'2g', '2gn':'2g', '2g+':'2g+',   '2a-':'2a-', '2a':'2a', '2an':'2a', '2a+':'2a+',
        '2b-':'2b-', '2b':'2b-', '2bn':'2bn', '2b+':'3c',
        '3c-':'2b',  '3c':'3c', '3cn':'3c', '3c+':'3c+',   '3d-':'3d-', '3d':'3d', '3dn':'3d', '3d+':'3d+',
        '3e-':'3e-', '3e':'3e-', '3en':'3en', '3e+':'3f',    '3f-':'3e',  '3f':'3f', '3fn':'3f', '3f+':'3f+',
        '3g-':'3g-', '3g':'3g', '3gn':'3g', '3g+':'3g+',   '3a-':'3a-', '3a':'3a', '3an':'3a', '3a+':'3a+',
        '3b-':'3b-', '3b':'3b-', '3bn':'3bn', '3b+':'4c',
        '4c-':'3b',  '4c':'4c', '4cn':'4c', '4c+':'4c+',   '4d-':'4d-', '4d':'4d', '4dn':'4d', '4d+':'4d+',
        '4e-':'4e-', '4e':'4e-', '4en':'4en', '4e+':'4f',    '4f-':'4e',  '4f':'4f', '4fn':'4f', '4f+':'4f+',
        '4g-':'4g-', '4g':'4g', '4gn':'4g', '4g+':'4g+',   '4a-':'4a-', '4a':'4a', '4an':'4a', '4a+':'4a+',
        '4b-':'4b-', '4b':'4b-', '4bn':'4bn', '4b+':'5c',
        '5c-':'4b',  '5c':'5c', '5cn':'5c', '5c+':'5c+',   '5d-':'5d-', '5d':'5d', '5dn':'5d', '5d+':'5d+',
        '5e-':'5e-', '5e':'5e-', '5en':'5en', '5e+':'5f',    '5f-':'5e',  '5f':'5f', '5fn':'5f', '5f+':'5f+',
        '5g-':'5g-', '5g':'5g', '5gn':'5g', '5g+':'5g+',   '5a-':'5a-', '5a':'5a', '5an':'5a', '5a+':'5a+',
        '5b-':'5b-', '5b':'5b-', '5bn':'5bn', '5b+':'6c',
        '6c-':'5b',  '6c':'6c', '6cn':'6c', '6c+':'6c+',   '6d-':'6d-', '6d':'6d', '6dn':'6d', '6d+':'6d+',
        '6e-':'6e-', '6e':'6e-', '6en':'6en', '6e+':'6f',    '6f-':'6e',  '6f':'6f', '6fn':'6f', '6f+':'6f+',
        '6g-':'6g-', '6g':'6g', '6gn':'6g', '6g+':'6g+',   '6a-':'6a-', '6a':'6a', '6an':'6a', '6a+':'6a+',
        '6b-':'6b-', '6b':'6b-', '6bn':'6bn', '6b+':'7c',
        '7c-':'6b',  '7c':'7c', '7cn':'7c', '7c+':'7c+',   '7d-':'7d-', '7d':'7d', '7dn':'7d', '7d+':'7d+',
        '7e-':'7e-', '7e':'7e-', '7en':'7en', '7e+':'7f',    '7f-':'7e',  '7f':'7f', '7fn':'7f', '7f+':'7f+',
        '7g-':'7g-', '7g':'7g', '7gn':'7g', '7g+':'7g+',   '7a-':'7a-', '7a':'7a', '7an':'7a', '7a+':'7a+',
        '7b-':'7b-', '7b':'7b-', '7bn':'7bn', '7b+':'8c',
        '8c-':'7b',  '8c':'8c', '8cn':'8c', '8c+':'8c+',   '8d-':'8d-', '8d':'8d', '8dn':'8d', '8d+':'8d+',
        '8e-':'8e-', '8e':'8e-', '8en':'8en', '8e+':'8f',    '8f-':'8e',  '8f':'8f', '8fn':'8f', '8f+':'8f+',
        '8g-':'8g-', '8g':'8g', '8gn':'8g', '8g+':'8g+',   '8a-':'8a-', '8a':'8a', '8an':'8a', '8a+':'8a+',
        '8b-':'8b-', '8b':'8b-', '8bn':'8bn', '8b+':None,
    },
    'e-':  {     # b-,e-,a-
        '0c-':None,  '0c':'0c', '0cn':'0c', '0c+':'0c+',   '0d-':'0d-', '0d':'0d', '0dn':'0d', '0d+':'0d+',
        '0e-':'0e-', '0e':'0e-', '0en':'0en', '0e+':'0f',    '0f-':'0e',  '0f':'0f', '0fn':'0f', '0f+':'0f+',
        '0g-':'0g-', '0g':'0g', '0gn':'0g', '0g+':'0g+',   '0a-':'0a-', '0a':'0a-', '0an':'0an', '0a+':'0a+',
        '0b-':'0b-', '0b':'0b-', '0bn':'0bn', '0b+':'1c',
        '1c-':'0b',  '1c':'1c', '1cn':'1c', '1c+':'1c+',   '1d-':'1d-', '1d':'1d', '1dn':'1d', '1d+':'1d+',
        '1e-':'1e-', '1e':'1e-', '1en':'1en', '1e+':'1f',    '1f-':'1e',  '1f':'1f', '1fn':'1f', '1f+':'1f+',
        '1g-':'1g-', '1g':'1g', '1gn':'1g', '1g+':'1g+',   '1a-':'1a-', '1a':'1a-', '1an':'1an', '1a+':'1a+',
        '1b-':'1b-', '1b':'1b-', '1bn':'1bn', '1b+':'2c',
        '2c-':'1b',  '2c':'2c', '2cn':'2c', '2c+':'2c+',   '2d-':'2d-', '2d':'2d', '2dn':'2d', '2d+':'2d+',
        '2e-':'2e-', '2e':'2e-', '2en':'2en', '2e+':'2f',    '2f-':'2e',  '2f':'2f', '2fn':'2f', '2f+':'2f+',
        '2g-':'2g-', '2g':'2g', '2gn':'2g', '2g+':'2g+',   '2a-':'2a-', '2a':'2a-', '2an':'2an', '2a+':'2a+',
        '2b-':'2b-', '2b':'2b-', '2bn':'2bn', '2b+':'3c',
        '3c-':'2b',  '3c':'3c', '3cn':'3c', '3c+':'3c+',   '3d-':'3d-', '3d':'3d', '3dn':'3d', '3d+':'3d+',
        '3e-':'3e-', '3e':'3e-', '3en':'3en', '3e+':'3f',    '3f-':'3e',  '3f':'3f', '3fn':'3f', '3f+':'3f+',
        '3g-':'3g-', '3g':'3g', '3gn':'3g', '3g+':'3g+',   '3a-':'3a-', '3a':'3a-', '3an':'3an', '3a+':'3a+',
        '3b-':'3b-', '3b':'3b-', '3bn':'3bn', '3b+':'4c',
        '4c-':'3b',  '4c':'4c', '4cn':'4c', '4c+':'4c+',   '4d-':'4d-', '4d':'4d', '4dn':'4d', '4d+':'4d+',
        '4e-':'4e-', '4e':'4e-', '4en':'4en', '4e+':'4f',    '4f-':'4e',  '4f':'4f', '4fn':'4f', '4f+':'4f+',
        '4g-':'4g-', '4g':'4g', '4gn':'4g', '4g+':'4g+',   '4a-':'4a-', '4a':'4a-', '4an':'4an', '4a+':'4a+',
        '4b-':'4b-', '4b':'4b-', '4bn':'4bn', '4b+':'5c',
        '5c-':'4b',  '5c':'5c', '5cn':'5c', '5c+':'5c+',   '5d-':'5d-', '5d':'5d', '5dn':'5d', '5d+':'5d+',
        '5e-':'5e-', '5e':'5e-', '5en':'5en', '5e+':'5f',    '5f-':'5e',  '5f':'5f', '5fn':'5f', '5f+':'5f+',
        '5g-':'5g-', '5g':'5g', '5gn':'5g', '5g+':'5g+',   '5a-':'5a-', '5a':'5a-', '5an':'5an', '5a+':'5a+',
        '5b-':'5b-', '5b':'5b-', '5bn':'5bn', '5b+':'6c',
        '6c-':'5b',  '6c':'6c', '6cn':'6c', '6c+':'6c+',   '6d-':'6d-', '6d':'6d', '6dn':'6d', '6d+':'6d+',
        '6e-':'6e-', '6e':'6e-', '6en':'6en', '6e+':'6f',    '6f-':'6e',  '6f':'6f', '6fn':'6f', '6f+':'6f+',
        '6g-':'6g-', '6g':'6g', '6gn':'6g', '6g+':'6g+',   '6a-':'6a-', '6a':'6a-', '6an':'6an', '6a+':'6a+',
        '6b-':'6b-', '6b':'6b-', '6bn':'6bn', '6b+':'7c',
        '7c-':'6b',  '7c':'7c', '7cn':'7c', '7c+':'7c+',   '7d-':'7d-', '7d':'7d', '7dn':'7d', '7d+':'7d+',
        '7e-':'7e-', '7e':'7e-', '7en':'7en', '7e+':'7f',    '7f-':'7e',  '7f':'7f', '7fn':'7f', '7f+':'7f+',
        '7g-':'7g-', '7g':'7g', '7gn':'7g', '7g+':'7g+',   '7a-':'7a-', '7a':'7a-', '7an':'7an', '7a+':'7a+',
        '7b-':'7b-', '7b':'7b-', '7bn':'7bn', '7b+':'8c',
        '8c-':'7b',  '8c':'8c', '8cn':'8c', '8c+':'8c+',   '8d-':'8d-', '8d':'8d', '8dn':'8d', '8d+':'8d+',
        '8e-':'8e-', '8e':'8e-', '8en':'8en', '8e+':'8f',    '8f-':'8e',  '8f':'8f', '8fn':'8f', '8f+':'8f+',
        '8g-':'8g-', '8g':'8g', '8gn':'8g', '8g+':'8g+',   '8a-':'8a-', '8a':'8a-', '8an':'8an', '8a+':'8a+',
        '8b-':'8b-', '8b':'8b-', '8bn':'8bn', '8b+':None,
    },
    'a-':  {     # b-,e-,a-,d-
        '0c-':None,  '0c':'0c', '0cn':'0c', '0c+':'0c+',   '0d-':'0d-', '0d':'0d-', '0dn':'0dn', '0d+':'0d+',
        '0e-':'0e-', '0e':'0e-', '0en':'0en', '0e+':'0f',    '0f-':'0e',  '0f':'0f', '0fn':'0f', '0f+':'0f+',
        '0g-':'0g-', '0g':'0g', '0gn':'0g', '0g+':'0g+',   '0a-':'0a-', '0a':'0a-', '0an':'0an', '0a+':'0a+',
        '0b-':'0b-', '0b':'0b-', '0bn':'0bn', '0b+':'1c',
        '1c-':'0b',  '1c':'1c', '1cn':'1c', '1c+':'1c+',   '1d-':'1d-', '1d':'1d-', '1dn':'1dn', '1d+':'1d+',
        '1e-':'1e-', '1e':'1e-', '1en':'1en', '1e+':'1f',    '1f-':'1e',  '1f':'1f', '1fn':'1f', '1f+':'1f+',
        '1g-':'1g-', '1g':'1g', '1gn':'1g', '1g+':'1g+',   '1a-':'1a-', '1a':'1a-', '1an':'1an', '1a+':'1a+',
        '1b-':'1b-', '1b':'1b-', '1bn':'1bn', '1b+':'2c',
        '2c-':'1b',  '2c':'2c', '2cn':'2c', '2c+':'2c+',   '2d-':'2d-', '2d':'2d-', '2dn':'2dn', '2d+':'2d+',
        '2e-':'2e-', '2e':'2e-', '2en':'2en', '2e+':'2f',    '2f-':'2e',  '2f':'2f', '2fn':'2f', '2f+':'2f+',
        '2g-':'2g-', '2g':'2g', '2gn':'2g', '2g+':'2g+',   '2a-':'2a-', '2a':'2a-', '2an':'2an', '2a+':'2a+',
        '2b-':'2b-', '2b':'2b-', '2bn':'2bn', '2b+':'3c',
        '3c-':'2b',  '3c':'3c', '3cn':'3c', '3c+':'3c+',   '3d-':'3d-', '3d':'3d-', '3dn':'3dn', '3d+':'3d+',
        '3e-':'3e-', '3e':'3e-', '3en':'3en', '3e+':'3f',    '3f-':'3e',  '3f':'3f', '3fn':'3f', '3f+':'3f+',
        '3g-':'3g-', '3g':'3g', '3gn':'3g', '3g+':'3g+',   '3a-':'3a-', '3a':'3a-', '3an':'3an', '3a+':'3a+',
        '3b-':'3b-', '3b':'3b-', '3bn':'3bn', '3b+':'4c',
        '4c-':'3b',  '4c':'4c', '4cn':'4c', '4c+':'4c+',   '4d-':'4d-', '4d':'4d-', '4dn':'4dn', '4d+':'4d+',
        '4e-':'4e-', '4e':'4e-', '4en':'4en', '4e+':'4f',    '4f-':'4e',  '4f':'4f', '4fn':'4f', '4f+':'4f+',
        '4g-':'4g-', '4g':'4g', '4gn':'4g', '4g+':'4g+',   '4a-':'4a-', '4a':'4a-', '4an':'4an', '4a+':'4a+',
        '4b-':'4b-', '4b':'4b-', '4bn':'4bn', '4b+':'5c',
        '5c-':'4b',  '5c':'5c', '5cn':'5c', '5c+':'5c+',   '5d-':'5d-', '5d':'5d-', '5dn':'5dn', '5d+':'5d+',
        '5e-':'5e-', '5e':'5e-', '5en':'5en', '5e+':'5f',    '5f-':'5e',  '5f':'5f', '5fn':'5f', '5f+':'5f+',
        '5g-':'5g-', '5g':'5g', '5gn':'5g', '5g+':'5g+',   '5a-':'5a-', '5a':'5a-', '5an':'5an', '5a+':'5a+',
        '5b-':'5b-', '5b':'5b-', '5bn':'5bn', '5b+':'6c',
        '6c-':'5b',  '6c':'6c', '6cn':'6c', '6c+':'6c+',   '6d-':'6d-', '6d':'6d-', '6dn':'6dn', '6d+':'6d+',
        '6e-':'6e-', '6e':'6e-', '6en':'6en', '6e+':'6f',    '6f-':'6e',  '6f':'6f', '6fn':'6f', '6f+':'6f+',
        '6g-':'6g-', '6g':'6g', '6gn':'6g', '6g+':'6g+',   '6a-':'6a-', '6a':'6a-', '6an':'6an', '6a+':'6a+',
        '6b-':'6b-', '6b':'6b-', '6bn':'6bn', '6b+':'7c',
        '7c-':'6b',  '7c':'7c', '7cn':'7c', '7c+':'7c+',   '7d-':'7d-', '7d':'7d-', '7dn':'7dn', '7d+':'7d+',
        '7e-':'7e-', '7e':'7e-', '7en':'7en', '7e+':'7f',    '7f-':'7e',  '7f':'7f', '7fn':'7f', '7f+':'7f+',
        '7g-':'7g-', '7g':'7g', '7gn':'7g', '7g+':'7g+',   '7a-':'7a-', '7a':'7a-', '7an':'7an', '7a+':'7a+',
        '7b-':'7b-', '7b':'7b-', '7bn':'7bn', '7b+':'8c',
        '8c-':'7b',  '8c':'8c', '8cn':'8c', '8c+':'8c+',   '8d-':'8d-', '8d':'8d-', '8dn':'8dn', '8d+':'8d+',
        '8e-':'8e-', '8e':'8e-', '8en':'8en', '8e+':'8f',    '8f-':'8e',  '8f':'8f', '8fn':'8f', '8f+':'8f+',
        '8g-':'8g-', '8g':'8g', '8gn':'8g', '8g+':'8g+',   '8a-':'8a-', '8a':'8a-', '8an':'8an', '8a+':'8a+',
        '8b-':'8b-', '8b':'8b-', '8bn':'8bn', '8b+':None,
    },
    'd-':  {     # b-,e-,a-,d-,g-
        '0c-':None,  '0c':'0c', '0cn':'0c', '0c+':'0c+',   '0d-':'0d-', '0d':'0d-', '0dn':'0dn', '0d+':'0d+',
        '0e-':'0e-', '0e':'0e-', '0en':'0en', '0e+':'0f',    '0f-':'0e',  '0f':'0f', '0fn':'0f', '0f+':'0f+',
        '0g-':'0g-', '0g':'0g-', '0gn':'0gn', '0g+':'0g+',   '0a-':'0a-', '0a':'0a-', '0an':'0an', '0a+':'0a+',
        '0b-':'0b-', '0b':'0b-', '0bn':'0bn', '0b+':'1c',
        '1c-':'0b',  '1c':'1c', '1cn':'1c', '1c+':'1c+',   '1d-':'1d-', '1d':'1d-', '1dn':'1dn', '1d+':'1d+',
        '1e-':'1e-', '1e':'1e-', '1en':'1en', '1e+':'1f',    '1f-':'1e',  '1f':'1f', '1fn':'1f', '1f+':'1f+',
        '1g-':'1g-', '1g':'1g-', '1gn':'1gn', '1g+':'1g+',   '1a-':'1a-', '1a':'1a-', '1an':'1an', '1a+':'1a+',
        '1b-':'1b-', '1b':'1b-', '1bn':'1bn', '1b+':'2c',
        '2c-':'1b',  '2c':'2c', '2cn':'2c', '2c+':'2c+',   '2d-':'2d-', '2d':'2d-', '2dn':'2dn', '2d+':'2d+',
        '2e-':'2e-', '2e':'2e-', '2en':'2en', '2e+':'2f',    '2f-':'2e',  '2f':'2f', '2fn':'2f', '2f+':'2f+',
        '2g-':'2g-', '2g':'2g-', '2gn':'2gn', '2g+':'2g+',   '2a-':'2a-', '2a':'2a-', '2an':'2an', '2a+':'2a+',
        '2b-':'2b-', '2b':'2b-', '2bn':'2bn', '2b+':'3c',
        '3c-':'2b',  '3c':'3c', '3cn':'3c', '3c+':'3c+',   '3d-':'3d-', '3d':'3d-', '3dn':'3dn', '3d+':'3d+',
        '3e-':'3e-', '3e':'3e-', '3en':'3en', '3e+':'3f',    '3f-':'3e',  '3f':'3f', '3fn':'3f', '3f+':'3f+',
        '3g-':'3g-', '3g':'3g-', '3gn':'3gn', '3g+':'3g+',   '3a-':'3a-', '3a':'3a-', '3an':'3an', '3a+':'3a+',
        '3b-':'3b-', '3b':'3b-', '3bn':'3bn', '3b+':'4c',
        '4c-':'3b',  '4c':'4c', '4cn':'4c', '4c+':'4c+',   '4d-':'4d-', '4d':'4d-', '4dn':'4dn', '4d+':'4d+',
        '4e-':'4e-', '4e':'4e-', '4en':'4en', '4e+':'4f',    '4f-':'4e',  '4f':'4f', '4fn':'4f', '4f+':'4f+',
        '4g-':'4g-', '4g':'4g-', '4gn':'4gn', '4g+':'4g+',   '4a-':'4a-', '4a':'4a-', '4an':'4an', '4a+':'4a+',
        '4b-':'4b-', '4b':'4b-', '4bn':'4bn', '4b+':'5c',
        '5c-':'4b',  '5c':'5c', '5cn':'5c', '5c+':'5c+',   '5d-':'5d-', '5d':'5d-', '5dn':'5dn', '5d+':'5d+',
        '5e-':'5e-', '5e':'5e-', '5en':'5en', '5e+':'5f',    '5f-':'5e',  '5f':'5f', '5fn':'5f', '5f+':'5f+',
        '5g-':'5g-', '5g':'5g-', '5gn':'5gn', '5g+':'5g+',   '5a-':'5a-', '5a':'5a-', '5an':'5an', '5a+':'5a+',
        '5b-':'5b-', '5b':'5b-', '5bn':'5bn', '5b+':'6c',
        '6c-':'5b',  '6c':'6c', '6cn':'6c', '6c+':'6c+',   '6d-':'6d-', '6d':'6d-', '6dn':'6dn', '6d+':'6d+',
        '6e-':'6e-', '6e':'6e-', '6en':'6en', '6e+':'6f',    '6f-':'6e',  '6f':'6f', '6fn':'6f', '6f+':'6f+',
        '6g-':'6g-', '6g':'6g-', '6gn':'6gn', '6g+':'6g+',   '6a-':'6a-', '6a':'6a-', '6an':'6an', '6a+':'6a+',
        '6b-':'6b-', '6b':'6b-', '6bn':'6bn', '6b+':'7c',
        '7c-':'6b',  '7c':'7c', '7cn':'7c', '7c+':'7c+',   '7d-':'7d-', '7d':'7d-', '7dn':'7dn', '7d+':'7d+',
        '7e-':'7e-', '7e':'7e-', '7en':'7en', '7e+':'7f',    '7f-':'7e',  '7f':'7f', '7fn':'7f', '7f+':'7f+',
        '7g-':'7g-', '7g':'7g-', '7gn':'7gn', '7g+':'7g+',   '7a-':'7a-', '7a':'7a-', '7an':'7an', '7a+':'7a+',
        '7b-':'7b-', '7b':'7b-', '7bn':'7bn', '7b+':'8c',
        '8c-':'7b',  '8c':'8c', '8cn':'8c', '8c+':'8c+',   '8d-':'8d-', '8d':'8d-', '8dn':'8dn', '8d+':'8d+',
        '8e-':'8e-', '8e':'8e-', '8en':'8en', '8e+':'8f',    '8f-':'8e',  '8f':'8f', '8fn':'8f', '8f+':'8f+',
        '8g-':'8g-', '8g':'8g-', '8gn':'8gn', '8g+':'8g+',   '8a-':'8a-', '8a':'8a-', '8an':'8an', '8a+':'8a+',
        '8b-':'8b-', '8b':'8b-', '8bn':'8bn', '8b+':None,
    },
    'g-':  {     # b-,e-,a-,d-,g-,c-
        '0c-':None,  '0c':'0c-', '0cn':'0cn', '0c+':'0c+',   '0d-':'0d-', '0d':'0d-', '0dn':'0dn', '0d+':'0d+',
        '0e-':'0e-', '0e':'0e-', '0en':'0en', '0e+':'0f',    '0f-':'0e',  '0f':'0f', '0fn':'0f', '0f+':'0f+',
        '0g-':'0g-', '0g':'0g-', '0gn':'0gn', '0g+':'0g+',   '0a-':'0a-', '0a':'0a-', '0an':'0an', '0a+':'0a+',
        '0b-':'0b-', '0b':'0b-', '0bn':'0bn', '0b+':'1c',
        '1c-':'0b',  '1c':'1c-', '1cn':'1cn', '1c+':'1c+',   '1d-':'1d-', '1d':'1d-', '1dn':'1dn', '1d+':'1d+',
        '1e-':'1e-', '1e':'1e-', '1en':'1en', '1e+':'1f',    '1f-':'1e',  '1f':'1f', '1fn':'1f', '1f+':'1f+',
        '1g-':'1g-', '1g':'1g-', '1gn':'1gn', '1g+':'1g+',   '1a-':'1a-', '1a':'1a-', '1an':'1an', '1a+':'1a+',
        '1b-':'1b-', '1b':'1b-', '1bn':'1bn', '1b+':'2c',
        '2c-':'1b',  '2c':'2c-', '2cn':'2cn', '2c+':'2c+',   '2d-':'2d-', '2d':'2d-', '2dn':'2dn', '2d+':'2d+',
        '2e-':'2e-', '2e':'2e-', '2en':'2en', '2e+':'2f',    '2f-':'2e',  '2f':'2f', '2fn':'2f', '2f+':'2f+',
        '2g-':'2g-', '2g':'2g-', '2gn':'2gn', '2g+':'2g+',   '2a-':'2a-', '2a':'2a-', '2an':'2an', '2a+':'2a+',
        '2b-':'2b-', '2b':'2b-', '2bn':'2bn', '2b+':'3c',
        '3c-':'2b',  '3c':'3c-', '3cn':'3cn', '3c+':'3c+',   '3d-':'3d-', '3d':'3d-', '3dn':'3dn', '3d+':'3d+',
        '3e-':'3e-', '3e':'3e-', '3en':'3en', '3e+':'3f',    '3f-':'3e',  '3f':'3f', '3fn':'3f', '3f+':'3f+',
        '3g-':'3g-', '3g':'3g-', '3gn':'3gn', '3g+':'3g+',   '3a-':'3a-', '3a':'3a-', '3an':'3an', '3a+':'3a+',
        '3b-':'3b-', '3b':'3b-', '3bn':'3bn', '3b+':'4c',
        '4c-':'3b',  '4c':'4c-', '4cn':'4cn', '4c+':'4c+',   '4d-':'4d-', '4d':'4d-', '4dn':'4dn', '4d+':'4d+',
        '4e-':'4e-', '4e':'4e-', '4en':'4en', '4e+':'4f',    '4f-':'4e',  '4f':'4f', '4fn':'4f', '4f+':'4f+',
        '4g-':'4g-', '4g':'4g-', '4gn':'4gn', '4g+':'4g+',   '4a-':'4a-', '4a':'4a-', '4an':'4an', '4a+':'4a+',
        '4b-':'4b-', '4b':'4b-', '4bn':'4bn', '4b+':'5c',
        '5c-':'4b',  '5c':'5c-', '5cn':'5cn', '5c+':'5c+',   '5d-':'5d-', '5d':'5d-', '5dn':'5dn', '5d+':'5d+',
        '5e-':'5e-', '5e':'5e-', '5en':'5en', '5e+':'5f',    '5f-':'5e',  '5f':'5f', '5fn':'5f', '5f+':'5f+',
        '5g-':'5g-', '5g':'5g-', '5gn':'5gn', '5g+':'5g+',   '5a-':'5a-', '5a':'5a-', '5an':'5an', '5a+':'5a+',
        '5b-':'5b-', '5b':'5b-', '5bn':'5bn', '5b+':'6c',
        '6c-':'5b',  '6c':'6c-', '6cn':'6cn', '6c+':'6c+',   '6d-':'6d-', '6d':'6d-', '6dn':'6dn', '6d+':'6d+',
        '6e-':'6e-', '6e':'6e-', '6en':'6en', '6e+':'6f',    '6f-':'6e',  '6f':'6f', '6fn':'6f', '6f+':'6f+',
        '6g-':'6g-', '6g':'6g-', '6gn':'6gn', '6g+':'6g+',   '6a-':'6a-', '6a':'6a-', '6an':'6an', '6a+':'6a+',
        '6b-':'6b-', '6b':'6b-', '6bn':'6bn', '6b+':'7c',
        '7c-':'6b',  '7c':'7c-', '7cn':'7cn', '7c+':'7c+',   '7d-':'7d-', '7d':'7d-', '7dn':'7dn', '7d+':'7d+',
        '7e-':'7e-', '7e':'7e-', '7en':'7en', '7e+':'7f',    '7f-':'7e',  '7f':'7f', '7fn':'7f', '7f+':'7f+',
        '7g-':'7g-', '7g':'7g-', '7gn':'7gn', '7g+':'7g+',   '7a-':'7a-', '7a':'7a-', '7an':'7an', '7a+':'7a+',
        '7b-':'7b-', '7b':'7b-', '7bn':'7bn', '7b+':'8c',
        '8c-':'7b',  '8c':'8c-', '8cn':'8cn', '8c+':'8c+',   '8d-':'8d-', '8d':'8d-', '8dn':'8dn', '8d+':'8d+',
        '8e-':'8e-', '8e':'8e-', '8en':'8en', '8e+':'8f',    '8f-':'8e',  '8f':'8f', '8fn':'8f', '8f+':'8f+',
        '8g-':'8g-', '8g':'8g-', '8gn':'8gn', '8g+':'8g+',   '8a-':'8a-', '8a':'8a-', '8an':'8an', '8a+':'8a+',
        '8b-':'8b-', '8b':'8b-', '8bn':'8bn', '8b+':None,
    },
    'c-':  {     # b-,e-,a-,d-,g-,c-,f-
        '0c-':None,  '0c':'0c-', '0cn':'0cn', '0c+':'0c+',   '0d-':'0d-', '0d':'0d-', '0dn':'0dn', '0d+':'0d+',
        '0e-':'0e-', '0e':'0e-', '0en':'0en', '0e+':'0f',    '0f-':'0e',  '0f':'0f-', '0fn':'0fn', '0f+':'0f+',
        '0g-':'0g-', '0g':'0g-', '0gn':'0gn', '0g+':'0g+',   '0a-':'0a-', '0a':'0a-', '0an':'0an', '0a+':'0a+',
        '0b-':'0b-', '0b':'0b-', '0bn':'0bn', '0b+':'1c',
        '1c-':'0b',  '1c':'1c-', '1cn':'1cn', '1c+':'1c+',   '1d-':'1d-', '1d':'1d-', '1dn':'1dn', '1d+':'1d+',
        '1e-':'1e-', '1e':'1e-', '1en':'1en', '1e+':'1f',    '1f-':'1e',  '1f':'1f-', '1fn':'1fn', '1f+':'1f+',
        '1g-':'1g-', '1g':'1g-', '1gn':'1gn', '1g+':'1g+',   '1a-':'1a-', '1a':'1a-', '1an':'1an', '1a+':'1a+',
        '1b-':'1b-', '1b':'1b-', '1bn':'1bn', '1b+':'2c',
        '2c-':'1b',  '2c':'2c-', '2cn':'2cn', '2c+':'2c+',   '2d-':'2d-', '2d':'2d-', '2dn':'2dn', '2d+':'2d+',
        '2e-':'2e-', '2e':'2e-', '2en':'2en', '2e+':'2f',    '2f-':'2e',  '2f':'2f-', '2fn':'2fn', '2f+':'2f+',
        '2g-':'2g-', '2g':'2g-', '2gn':'2gn', '2g+':'2g+',   '2a-':'2a-', '2a':'2a-', '2an':'2an', '2a+':'2a+',
        '2b-':'2b-', '2b':'2b-', '2bn':'2bn', '2b+':'3c',
        '3c-':'2b',  '3c':'3c-', '3cn':'3cn', '3c+':'3c+',   '3d-':'3d-', '3d':'3d-', '3dn':'3dn', '3d+':'3d+',
        '3e-':'3e-', '3e':'3e-', '3en':'3en', '3e+':'3f',    '3f-':'3e',  '3f':'3f-', '3fn':'3fn', '3f+':'3f+',
        '3g-':'3g-', '3g':'3g-', '3gn':'3gn', '3g+':'3g+',   '3a-':'3a-', '3a':'3a-', '3an':'3an', '3a+':'3a+',
        '3b-':'3b-', '3b':'3b-', '3bn':'3bn', '3b+':'4c',
        '4c-':'3b',  '4c':'4c-', '4cn':'4cn', '4c+':'4c+',   '4d-':'4d-', '4d':'4d-', '4dn':'4dn', '4d+':'4d+',
        '4e-':'4e-', '4e':'4e-', '4en':'4en', '4e+':'4f',    '4f-':'4e',  '4f':'4f-', '4fn':'4fn', '4f+':'4f+',
        '4g-':'4g-', '4g':'4g-', '4gn':'4gn', '4g+':'4g+',   '4a-':'4a-', '4a':'4a-', '4an':'4an', '4a+':'4a+',
        '4b-':'4b-', '4b':'4b-', '4bn':'4bn', '4b+':'5c',
        '5c-':'4b',  '5c':'5c-', '5cn':'5cn', '5c+':'5c+',   '5d-':'5d-', '5d':'5d-', '5dn':'5dn', '5d+':'5d+',
        '5e-':'5e-', '5e':'5e-', '5en':'5en', '5e+':'5f',    '5f-':'5e',  '5f':'5f-', '5fn':'5fn', '5f+':'5f+',
        '5g-':'5g-', '5g':'5g-', '5gn':'5gn', '5g+':'5g+',   '5a-':'5a-', '5a':'5a-', '5an':'5an', '5a+':'5a+',
        '5b-':'5b-', '5b':'5b-', '5bn':'5bn', '5b+':'6c',
        '6c-':'5b',  '6c':'6c-', '6cn':'6cn', '6c+':'6c+',   '6d-':'6d-', '6d':'6d-', '6dn':'6dn', '6d+':'6d+',
        '6e-':'6e-', '6e':'6e-', '6en':'6en', '6e+':'6f',    '6f-':'6e',  '6f':'6f-', '6fn':'6fn', '6f+':'6f+',
        '6g-':'6g-', '6g':'6g-', '6gn':'6gn', '6g+':'6g+',   '6a-':'6a-', '6a':'6a-', '6an':'6an', '6a+':'6a+',
        '6b-':'6b-', '6b':'6b-', '6bn':'6bn', '6b+':'7c',
        '7c-':'6b',  '7c':'7c-', '7cn':'7cn', '7c+':'7c+',   '7d-':'7d-', '7d':'7d-', '7dn':'7dn', '7d+':'7d+',
        '7e-':'7e-', '7e':'7e-', '7en':'7en', '7e+':'7f',    '7f-':'7e',  '7f':'7f-', '7fn':'7fn', '7f+':'7f+',
        '7g-':'7g-', '7g':'7g-', '7gn':'7gn', '7g+':'7g+',   '7a-':'7a-', '7a':'7a-', '7an':'7an', '7a+':'7a+',
        '7b-':'7b-', '7b':'7b-', '7bn':'7bn', '7b+':'8c',
        '8c-':'7b',  '8c':'8c-', '8cn':'8cn', '8c+':'8c+',   '8d-':'8d-', '8d':'8d-', '8dn':'8dn', '8d+':'8d+',
        '8e-':'8e-', '8e':'8e-', '8en':'8en', '8e+':'8f',    '8f-':'8e',  '8f':'8f-', '8fn':'8fn', '8f+':'8f+',
        '8g-':'8g-', '8g':'8g-', '8gn':'8gn', '8g+':'8g+',   '8a-':'8a-', '8a':'8a-', '8an':'8an', '8a+':'8a+',
        '8b-':'8b-', '8b':'8b-', '8bn':'8bn', '8b+':None,
    },
}
#   key   a             key of a major.
def do_key(t_args, line):
    global args
    global measure_on
    global key_sig
    global key_default
    global key_voice
    global mlth
    global vl

    if t_args is None or len(t_args) != 1:
        print_error("key command does not have arguments", line)
        return
    # fi
    vargs = t_args[0].split()
    if len(vargs) <= 0 or len(vargs) > 2:
        print_error("key command does not have correct number of arguments", line)
        return
    # fi

    k = vargs[0] if len(vargs) < 2 else vargs[1]
    k = k.lower()                           # Technically should not have to do this.
    if k not in key_sig:
        print_error("key '{}' not recognized.".format(k), line)
        return
    # fi
    if args.vertical or args.horizontal:
        kl = k                              # printing and used are the same.
    elif args.midi1csv:
        kl = k
        k = key_sig[k]                      # Key number extracted.
    else:                   # ABC
        kl = k
        k = k.upper()
        k = k.replace('-', 'b')             # Does multiple flats
        k = k.replace('+', '#')             # Does multiple sharps.
        k = k.replace('n', '=')             # Does multiple naturals.
    # fi
    # k = value to store in key_voice, key_default, etc. -- used for printing, etc.
    # kl = printable version of input.

    fill_voice_mlth(line)                   # Need to make measure for other voices up to here "mlth".

    for ve in range(1, len(vl)+1):
        if mlth[ve][measure_on] != 0:
            print_error("do_key in the middle of a measure not allowed", line)
            return
        # fi
    # rof

    if len(vargs) == 1:                     # One argument, all voices change.
        if measure_on == '':
            key_default = k                 # Used in xpose, and when printing midicsv output.
        # fi
        for ve in range(1, MAXVOICES+1):
            key_voice[measure_on][ve] = k   # Running key by voice.
        # rof
        return
    # fi                # multiple arguments, voices first.

    jkl = "".join(vargs[0])
    wargs = arglist(jkl, line)
    if not wargs or len(wargs) < 1:
        print_error("no voice arguments on key line", line)
        return
    # fi
    for w in wargs:
        f1, type_error = is_float(w)
        if type_error is not None:
            return
        # fi
        if f1 is None:
            print_error("voice {} is not a number.".format(w), line)
            return
        # fi
        f1 = int(round(f1))
        key_voice[measure_on][f1] = k       # key by measure and voice.
    # rof
    return
# End of do_key

#-----------------------------------------------------------------------------
#   cis   2             $$ only voice 2 follows. sets volume too.
def do_cis(t_args, line):
    global voices               # number of voices
    global cis                  # cis ...
    global vinstrument
    global reverb
    global pan
    global intensity
    global measure_on
    global instruments

    if t_args is None or len(t_args) != 1:
        print_error("cis does not have one or two arguments.", line)
        return
    # fi

    vargs = t_args[0].split()

    f1, type_error = is_float(vargs[0])
    if type_error is not None:
        return
    # fi
    if f1 is None:
        print_error("cis does not have first argument as a number.", line)
        return
    # fi
    f1 = int(round(f1))
    if f1 < 1  or f1 > MAXVOICES:       # If out of range.
        print_error("number of cis must between 1 and {} inclusive. Not ({})".format(MAXVOICES, f1), line)
        return
    # fi

    voices = f1                         # Max voices.
    cis = f1                            # Doing just one voice from now on.

    for i in range(1, cis + 1):
        new_voice_initialize(i, measure_on)
    # rof

    # If there is a second argument, choose instrument for the voice.
    if len(vargs) > 1:
        i = str(vargs[1]).lower()
        if i in instruments:
            vinstrument[measure_on][cis] = instruments[i]
            reverb[measure_on][cis] = 0
            pan[measure_on][cis] = 64
            intensity[measure_on][cis] = 100
        else:
            f1, type_error = is_float(i)
            if type_error is not None:
                return
            # fi
            if f1 is None:
                print_error("cis does not have instrument argument as a number.", line)
                return
            # fi
            f1 = int(round(f1))
            if f1 not in instruments.values():
                print_error("instrument value {} not in instrument table.".format(f1), line)
                return
            # fi
            vinstrument[measure_on][cis] = f1
            reverb[measure_on][cis] = 0
            pan[measure_on][cis] = 64
            intensity[measure_on][cis] = 100
        # fi
    # fi
    fill_voice_mlth(line)               # Need to make measure for all voices up to here "mlth".
    return
# End of do_cis

#-----------------------------------------------------------------------------
#   volume  4,7,5                       $$ for 3 voices; mf and fff, and a touch louder.
#       The volume is a number between 0 and 7.
#       Caution: you should use only volumes 5 through 7
def do_volume_both(t_args, line, command_name):
    global vl                           # volume levels
    global measure_on
    global vlprint
    global args
    global cresc_direction
    global cresc_time
    global cresc_volume
    global running_vl

    if t_args is None or len(t_args) == 0:
        print_error(command_name + " needs at least one argument", line)
        return
    # fi
    wline = t_args[0]
    # Get rid of all white spoce.
    wline = ''.join(wline.split())
    wargs = arglist(wline, line)

    if len(wargs) == 0 or len(wargs) > MAXVOICES:
        print_error(command_name + " needs from one to {} arguments".format(MAXVOICES), line)
        return
    # fi

    for i in range(1, len(wargs)+1):
        v, type_error = is_float(wargs[i - 1])
        if type_error is not None:
            for j in vlprint:
                if wargs[i - 1] == vlprint[j]:
                    v = j
                    type_error = None
                    break
                # fi
            # rof
            if type_error is not None:
                print_error(command_name + " did not get have a number or volume name. {}".format(type_error), line)
                return
            # fi
            # Fall through, because we found it via letters.
        # fi
        if v is None:
            print_error(command_name + " does not have argument as a number.", line)
            return
        # fi
        v = int(round(v))
        if v < 0:                       # If error or bad value
            print_error(command_name + " for voice {} not good {}, making it zero.".format(i,v), line)
            v = 0
        # fi
        if command_name == 'volumes':
            if v > 127:                 # If error or bad value
                print_error(command_name + " {} for voice {} not good, making it 127.".format(v,i), line)
                v = 127
            # fi
        elif command_name == 'volume' and v > 7:    # If error or bad value
            print_error(command_name + " {} for voice {} not good, making it 7 (127 for midi).".format(v,i), line)
            v = 127
        else:
            v = int((v * 16) + 15)      # Convert to 0 to 127.
        # fi
        if not i in vl:
            new_voice_initialize(i, measure_on)
        # fi
        vl[i][measure_on] = v           # Change volume for voice.
        running_vl[i][measure_on] = v   # Force running change - also stop crescendo.
        cresc_volume[i] = 0
        cresc_time[i] = 0
        cresc_direction[i] = True
    # rof
    fill_voice_mlth(line)               # Need to make measure for other voices up to here "mlth".
    return
# End of do_volume_both

#-----------------------------------------------------------------------------
def do_volume(t_args, line):
    do_volume_both(t_args, line, "volume")
    return
# End of do_volume

#-----------------------------------------------------------------------------
# This allows numbers 1 to 128.
def do_volumes(t_args, line):
    do_volume_both(t_args, line, "volumes")
    return
# End of do_volumes

#-----------------------------------------------------------------------------
def do_set_voices(f1, line):
    global voices                       # number of voices
    global measure_on

    for i in range(1, f1+1):
        new_voice_initialize(i, measure_on)
    # rof
    voices = f1                         # Max voices.
    return
# End of do_set_voices

#-----------------------------------------------------------------------------
#   voice 4                             $$ number of voices from now onwards.   sets volume too. Default 4?
#   voice 4   50,60,70,80               $$ Set the instruments %%MIDI program 50 ...
def do_voice(t_args, line):
    global cis                          # non-zero if doing one voice only.
    global vinstrument
    global reverb
    global pan
    global intensity
    global measure_on
    global instruments

    if t_args is None or len(t_args) != 1:
        print_error("voice does not have one argument.", line)
        return
    # fi

    vargs = t_args[0].split()
    f1, type_error = is_float(vargs[0])
    if type_error is not None:
        return
    # fi
    if f1 is None:
        print_error("voice does not have first argument as a number.", line)
        return
    # fi
    f1 = int(round(f1))
    if f1 < 1  or f1 > MAXVOICES:       # If out of range.
        print_error("number of voices must between 1 and {} inclusive. Not ({})".format(MAXVOICES, f1), line)
        return
    # fi

    do_set_voices(f1, line)

    fill_voice_mlth(line)               # Need to make measure for other voices up to here "mlth".

    # If there are more arguments, choose instruments for the voices.
    if len(vargs) > 1:
        jkl = "".join(vargs[1:])
        wargs = arglist(jkl, line)
        if not wargs or len(wargs) < 1:
            print_error("no instrument selection arguments on voice line", line)
            return
        # fi
        if len(wargs) > f1:
            print_error("number instruments ({}) greater than voices ({})".format(len(wargs),f1),line)
        # fi
        for i in range(0, len(wargs)):
            j = str(wargs[i])    # No checking.
            j = str(j).lower()
            if j in instruments:
                vinstrument[measure_on][i+1] = instruments[j]
                reverb[measure_on][i+1] = 0
                pan[measure_on][i+1] = 64
                intensity[measure_on][i+1] = 100
            else:
                f1, type_error = is_float(j)
                if type_error is not None:
                    return
                # fi
                if f1 is None:
                    print_error("voice does not have instrument argument {} as a number.".format(j), line)
                    return
                # fi
                f1 = int(round(f1))
                if f1 != 0 and f1 not in instruments.values():
                    print_error("instrument value {} not in instrument table.".format(f1), line)
                    return
                # fi
                vinstrument[measure_on][i+1] = str(f1)
                reverb[measure_on][i+1] = 0
                pan[measure_on][i+1] = 64
                intensity[measure_on][i+1] = 100
            # fi
        # rof
    # fi

    cis = 0                             # No longer doing just one voice.
    return
# End of do_voice

#-----------------------------------------------------------------------------
#   measure 6.5         $$ need not be integers
def do_measure(t_args, line):
    global measure_on
    global meas
    global vl
    global running_vl
    global default_note_length
    global vinstrument
    global reverb
    global pan
    global intensity
    global acc_m                            # Last accidental on a note in measure.
    global acc_m_xpose
    global acc_v_init                       # Last accidental on a note in measure.
    global acc_v_init_v_or_h                # Last accidental on a note in measure.
    global meter
    global measure_meter
    global clef
    global mlth                             # measure length dictionary
    global args
    global key_voice
    global tempo_now_note_length
    global tempo_speed_now

    fill_voice_mlth(line)                   # Need to make measure for other voices up to here "mlth".

    if t_args is None or len(t_args) != 1:
        print_error("Measure missing argument.", line)
        return
    # fi
    if t_args[0] in meas:
        print_error("Measure already exists.", line)
        return
    # fi

    # Last note length ... continue to this measure, until it changes.
    last_m = measure_on
    measure_on = str(t_args[0])
    meas.append(measure_on)
    for i in range(1, len(vl)+1):
        if measure_on not in vinstrument:
            vinstrument[measure_on] = {}
            reverb[measure_on] = {}
            pan[measure_on] = {}
            intensity[measure_on] = {}
            key_voice[measure_on] = {}
        # fi
        if i not in vl:
            vl[i] = {}
            running_vl[i] = {}
        # fi
        for j in vl:
            if measure_on not in clef:
                clef[measure_on] = {}
            # fi
            if j not in clef[measure_on]:
                clef[measure_on][j] = {}
            # fi
            if last_m not in clef or j not in clef[last_m]:
                for k in reversed(range(0, len(meas)-1)):
                    mmm = meas[k]
                    if mmm in clef and j in clef[mmm]:
                        nc = clef[mmm][j]
                        break
                    # fi
                # rof
            else:
                nc = clef[last_m][j]
            # fi
            clef[measure_on][j] = nc
        # rof
        new_voice_initialize(i, measure_on)
        mlth[i][measure_on] = 0
        # last instrument continues - might change shortly.
        vinstrument[measure_on][i] = vinstrument[last_m][i]
        pan[measure_on][i] = pan[last_m][i]
        reverb[measure_on][i] = reverb[last_m][i]
        intensity[measure_on][i] = intensity[last_m][i]
        key_voice[measure_on][i] = key_voice[last_m][i]
        # Carry forward.
        vl[i][measure_on] = vl[i][last_m]
        running_vl[i][measure_on] = running_vl[i][last_m]
        # Initialize the accidental for each note in measure.
        if args.horizontal or args.vertical:
            acc_m[i] =  {k: v for k, v in acc_v_init_v_or_h.items()}
            acc_m_xpose[i] =  {k: v for k, v in acc_v_init_v_or_h.items()}
        elif args.midi1csv:
            acc_m[i] =  {k: v for k, v in acc_v_init_v_or_h.items()}
            acc_m_xpose[i] =  {k: v for k, v in acc_v_init_v_or_h.items()}
        else:           # ABC
            acc_m[i] =  {k: v for k, v in acc_v_init.items()}
            acc_m_xpose[i] =  {k: v for k, v in acc_v_init.items()}
        # fi
    # rof
    # default note length continues with current - might change shortly.
    default_note_length[measure_on] = default_note_length[last_m]
    tempo_speed_now[measure_on] = tempo_speed_now[last_m]
    tempo_now_note_length[measure_on] = tempo_now_note_length[last_m]
    measure_meter[measure_on] = meter       # Each measure change can have a different meter.
    return
# End of do_measure

#-----------------------------------------------------------------------------
#   instrument 1,2 flute                $$ voices for an instrument.
def do_instrument(t_args, line):
    global vinstrument
    global reverb
    global pan
    global intensity
    global measure_on
    global instruments
    global extrainfo

    if t_args is None or len(t_args) != 1:
        print_error("instrument does not have arguments.", line)
        return
    # fi

    vargs = t_args[0].split()
    INST = " ".join(vargs[1:]).lower()
    if INST in instruments:
        INST = str(instruments[INST])           # Convert to number.
    else:
        f1, type_error = is_float(INST)
        if type_error is not None:
            return
        # fi
        if f1 is None:
            print_error("voice does not have instrument argument {} as a number.".format(INST), line)
            return
        # fi
        f1 = int(round(f1))
        if f1 not in instruments.values():
            print_error("instrument value {} not in instrument table.".format(f1), line)
            return
        # fi
        INST = str(f1)
    # fi

    jkl = "".join(vargs[0])
    wargs = arglist(jkl, line)
    if not wargs or len(wargs) < 1:
        print_error("no voice arguments on instrument line", line)
        return
    # fi
    for w in wargs:
        f1, type_error = is_float(w)
        if type_error is not None:
            return
        # fi
        if f1 is None:
            print_error("voice {} is not a number.".format(w), line)
            return
        # fi
        f1 = int(round(f1))
        if INST not in extrainfo:
            extrainfo[INST] = []
            j = None
            for k in instruments:
                if str(instruments[k]) == INST:
                    j = k
                    break
                # fi
            # rof
            if j is None:
                print_error("instrument not in dictionary instruments {}".format(INST), line)
                return
            # fi
            extrainfo[INST].append(j)       # The instrument number
            extrainfo[INST].append(0)       # The reverb setting.
            extrainfo[INST].append(64)      # The pan setting (left/right % for stereo).
            extrainfo[INST].append(100)     # The intensity (volume, kind of) setting.
        # fi
        vinstrument[measure_on][f1] = INST
        reverb[measure_on][f1] = extrainfo[INST][1]
        intensity[measure_on][f1] = extrainfo[INST][3]
        pan[measure_on][f1] = extrainfo[INST][2]
    # rof

    return
# End of do_instrument

#-----------------------------------------------------------------------------
def do_reverb(t_args, line):
    global reverb
    global extrainfo
    global measure_on
    global vinstrument

    if t_args is None or len(t_args) != 1:
        print_error("reverb does not have arguments.", line)
        return
    # fi

    vargs = t_args[0].split()
    if len(vargs) <= 0 or len(vargs) > 2:
        print_error("reverb does not have correct number of arguments.", line)
        return
    # fi
    if len(vargs) == 1:
        r = 0
    else:
        r = vargs[1]
        f1, type_error = is_float(r)
        if type_error is not None:
            return
        # fi
        if f1 is None:
            print_error("voice does not have reverb argument {} as a number.".format(r), line)
            return
        # fi
        r = int(round(f1))
    # fi
    if r < 0 or r > 127:
        print_error("reverb value {} not in range 0to 127.".format(r), line)
        return
    # fi

    jkl = "".join(vargs[0])
    wargs = arglist(jkl, line)
    if not wargs or len(wargs) < 1:
        print_error("no voice arguments on reverb line", line)
        return
    # fi
    for w in wargs:
        f1, type_error = is_float(w)
        if type_error is not None:
            return
        # fi
        if f1 is None:
            print_error("voice {} is not a number.".format(w), line)
            return
        # fi
        f1 = int(round(f1))

        INST = vinstrument[measure_on][f1]
        extrainfo[INST][1] = r
        reverb[measure_on][f1] = r
    # rof
    return
# End of do_reverb

#-----------------------------------------------------------------------------
def do_intensity(t_args, line):
    global intensity
    global extrainfo
    global measure_on
    global vinstrument

    if t_args is None or len(t_args) != 1:
        print_error("intensity does not have arguments.", line)
        return
    # fi

    vargs = t_args[0].split()
    if len(vargs) <= 0 or len(vargs) > 2:
        print_error("intensity does not have correct number of arguments.", line)
        return
    # fi
    if len(vargs) == 1:
        intens = 0
    else:
        intens = vargs[1]
        f1, type_error = is_float(intens)
        if type_error is not None:
            return
        # fi
        if f1 is None:
            print_error("voice does not have intensity argument {} as a number.".format(intens), line)
            return
        # fi
        intens = int(round(f1))
    # fi
    if intens < 0 or intens > 127:
        print_error("intensity value {} not in range 0 to 127".format(intens), line)
        return
    # fi

    jkl = "".join(vargs[0])
    wargs = arglist(jkl, line)
    if not wargs or len(wargs) < 1:
        print_error("no voice arguments on intensity line", line)
        return
    # fi
    for w in wargs:
        f1, type_error = is_float(w)
        if type_error is not None:
            return
        # fi
        if f1 is None:
            print_error("voice {} is not a number.".format(w), line)
            return
        # fi
        f1 = int(round(f1))

        INST = vinstrument[measure_on][f1]
        extrainfo[INST][1] = intens
        intensity[measure_on][f1] = intens
    # rof
    return
# End of do_intensity

#-----------------------------------------------------------------------------
def do_pan(t_args, line):
    global pan
    global extrainfo
    global measure_on
    global vinstrument

    if t_args is None or len(t_args) != 1:
        print_error("pan does not have arguments.", line)
        return
    # fi

    vargs = t_args[0].split()
    if len(vargs) <= 0 or len(vargs) > 2:
        print_error("pan does not have correct number of arguments.", line)
        return
    # fi
    if len(vargs) == 1:
        p = 0
    else:
        p = vargs[1]
        f1, type_error = is_float(p)
        if type_error is not None:
            return
        # fi
        if f1 is None:
            print_error("voice does not have pan argument {} as a number.".format(p), line)
            return
        # fi
        p = int(round(f1))
        if p < 0 or p > 127:
            print_error("pan value {} not in range 0 to 127.".format(p), line)
            return
        # fi
    # fi
    jkl = "".join(vargs[0])
    wargs = arglist(jkl, line)
    if not wargs or len(wargs) < 1:
        print_error("no voice arguments on pan line", line)
        return
    # fi
    for w in wargs:
        f1, type_error = is_float(w)
        if type_error is not None:
            return
        # fi
        if f1 is None:
            print_error("voice {} is not a number.".format(w), line)
            return
        # fi
        f1 = int(round(f1))

        INST = vinstrument[measure_on][f1]
        extrainfo[INST][1] = p
        pan[measure_on][f1] = p
    # rof
    return
# End of do_pan

#-----------------------------------------------------------------------------
def do_xpose(t_args, line):
    global xpose
    global xpose_new_key
    global measure_on
    global key_sig
    global key_sig_int
    global key_default
    global key_voice

    if t_args is None or len(t_args) != 1:
        print_error("xpose does not have arguments.", line)
        return
    # fi

    vargs = t_args[0].split()
    if len(vargs) <= 0 or len(vargs) > 3:
        print_error("xpose does not have correct number of arguments.", line)
        return
    # fi
    if len(vargs) == 1:
        x = 0
    else:
        x = vargs[1]
        f1, type_error = is_float(x)
        if type_error is not None:
            return
        # fi
        if f1 is None:
            print_error("voice does not have xpose argument {} as a number.".format(x), line)
            return
        # fi
        x = int(round(f1))
    # fi
    if x < -12 or x > 12:
        print_error("xpose value {} not in range -12 to 12.".format(x), line)
        return
    # fi
    if len(vargs) <= 2:
        k = kl = key_default
        if args.midi1csv:
            # Convert kl from integer to lowercase normal musicomp usage.
            kl = key_sig_int[kl]
        # fi
    else:
        k = kl = vargs[2]
        if kl not in key_sig:
            print_error("no key {} in key_sig({})".format(kl,keysig), line)
            return
        # fi
        if args.midi1csv:
            # Convert kl from normal musicomp to midi1csv format (integer).
            k = key_sig[kl]
        # fi
    # fi
    # k is used for key_voice
    # kl is used in getnote via xpose_new_key (musicomp text)

    jkl = "".join(vargs[0])
    wargs = arglist(jkl, line)
    if not wargs or len(wargs) < 1:
        print_error("no voice arguments on xpose line", line)
        return
    # fi
    for w in wargs:
        f1, type_error = is_float(w)
        if type_error is not None:
            return
        # fi
        if f1 is None:
            print_error("voice {} is not a number.".format(w), line)
            return
        # fi
        xpose_new_key[f1] = kl
        f1 = int(round(f1))
        xpose[f1] = x
# NOTDONEYET - keys   This doesn't make sense? Why set key_voice?  2021-06-18_21-33-56
        key_voice[measure_on][f1] = k
    # rof
    return
# End of do_xpose

#-----------------------------------------------------------------------------
# dictionary commandname : routine. execute via(?): globals()['do_cstopnow'](t_args, line)
global commands
commands = {
             'bars'    : do_bars,
             'calc'    : do_calc,
             'change'  : do_change,
             'cis'     : do_cis,
             'clef'    : do_clef,
             'copy'    : do_copy,
             'cstart'  : do_cstart,
             'cstop'   : do_cstop,
             'cstop*'  : do_cstopnow,
             'debug'   : do_debug,
             'decode'  : do_decode,
             'delay'   : do_delay,
             'else'    : do_else,
             'end'     : do_cstopnow,
             'endif'   : do_endif,
             'endm'    : do_endm,
             'flat'    : do_flat,
             'goto'    : do_goto,
             'if'      : do_if,
             'key'     : do_key,
             'macro'   : do_macro,
             'marker'  : do_marker,
             'measure' : do_measure,
             'unit'    : do_measure,
             'meter'   : do_meter,
             'natural' : do_natural,
             'percus'  : do_percus,
             'pitch'   : do_pitch,
             'putd'    : do_putd,
             'randu'   : do_randu,
             'randp'   : do_randp,
             'setperm' : do_setperm,
             'sharp'   : do_sharp,
             'slide'   : do_slide,
             'start'   : do_cstart,
             'stop'    : do_cstop,
             'stop*'   : do_cstopnow,
             'tempo'   : do_tempo,
             'temper'  : do_temper,
             'title'   : do_title,
             'voice'   : do_voice,
             'volume'  : do_volume,
             'volumes' : do_volumes,
             'reverb'  : do_reverb,
             'pan'     : do_pan,
             'intensity' : do_intensity,
             'instrument' : do_instrument,
             'xpose'   : do_xpose,
             # '.' -- handled specially.
           }

#-----------------------------------------------------------------------------
# For plato calc command processing :)
# w=1,h=2,q=4,e=8,th=+0k        # for plato calc command
# s=(1),d=(1),b=(1),t=(1)       # for plato calc command
# m1, m2, m3, m4, m5, m6, m7, m8, m9
# freq(A) = 968000/A
# nearest(A)      = int(round(ln(A/27.5)*12/0.693147))
# framlth = 60*(20/21)          # frames per second
# tempo(a,b)      = 60*framlth*b*[1./a]
# min2(a,b)       = (a+b-abs(a-b))/2      $$ by Dan Sleator
# min4(l,a,b,d)   = min2(min2(l,a),min2(b,d))
# max2(a,b)       = (a+b+abs(a-b))/2      $$ note, no < or > ops
# max4(l,a,b,d)   = max2(max2(l,a),max2(b,d))
#-----------------------------------------------------------------------------
# Notes and comma for separating voices.
# Length of note in 1/60ths of a second.   r[1]    = 1/57.1429 frames per second
# Length of notes as floating number.      (0.25)  = 1/4 = quarter note.
# variable: pause = break between two identical notes, or "broken notes".
# Note: variables in () and [].
#-----------------------------------------------------------------------------
# rests
# Notes: 3c4,4c4,r2     $$ 3 voices, last is a rest.
#        3a8,,4c8       $$ voice 2 is still playing
# ONALM
# O = octave. default to most recently used for this voice. from 1 to 8.  Middle C = octave 3.
# N = note itself a through g. Probably allow upper or lower case. :) "r" = rest.
# A = Default to normal key value. accidental -> +, -, ++, --, n. Do not carry to next note. (n=natural)
# L = Default to most recently used for this voice. note length. Like 16 for sixteenth note. Can do 16th.
#       w, h, q -> whole, half, quarter.
#       3(4) -> 3 notes in the time of a quarter note. (triplets)
#       (.25) -> 1/4 note.
#       [12] -> number of output frames ... 1/57.1429 of a second.
#   Example:    4b-3(4)         $$ beginning of a triplet
# M = modifier. Normal note. Any combination: d = dotted, s=staccato, b = broken by pause from next, t = tie.
#   3a16t           $$ lengthens previous by 1/16th ... must be same note.

# Special note forms (replace O and N):  (13) - note number. [440] = frequency in Hz. {317} GSW - ignore.
#     t(3a,3g,7)4  = ON,ON,number,LM   - example, 7 notes, quarter note length.
#        NOTE: in 60ths of a second, be careful using it.
#     s4(4a,b,a,g) = sLM(ONA,ONA,...)  - play all notes as grace notes, length of staccato, LM=length
#               last note lasts until LM (quarter note in example) is reached.
#-----------------------------------------------------------------------------
# For octave 3c = 60.
note_in_octave_value = {
   'c-':59,
   'c':60, 'cn':60,
   'c+':61, 'd-':61,
   'd':62, 'dn':62,
   'd+':63, 'e-':63,
   'e':64, 'en':64, 'f-':64,
   'e+':65, 'f':65, 'fn':65,
   'f+':66, 'g-':66,
   'g':67, 'gn':67,
   'g+':68, 'a-':68,
   'a':69, 'an':69,
   'a+':70, 'b-':70,
   'b':71, 'bn':71,
   'b+':72
}

global note_to_midi_value
note_to_midi_value = { }
global midi_value_to_note_flat
midi_value_to_note_flat = { }
global midi_value_to_note_sharp
midi_value_to_note_sharp = { }

for o in range(0,9):        # 0 thru 8
    for n in note_in_octave_value:
        x = str(o) + n
        v = (note_in_octave_value[n] - (60-24)) + 12*o      # 60-36=24 = '0c'
        note_to_midi_value[x] = v
        if len(n) == 2:     # accidental
            if n[1] == '+':
                midi_value_to_note_sharp[v] = x
            # fi
            if n[1] == '-':
                midi_value_to_note_flat[v] = x
            # fi
        else:
            midi_value_to_note_sharp[v] = x
            midi_value_to_note_flat[v] = x
        # fi
    # rof
# rof

#-----------------------------------------------------------------------------
# return:
#       therest (for time)
#       thenote         Convert to abc format for note, octave.
#       typenote:       -2 gsw oprnd, -1 freq, 0 note, 1 trill, 2 sequence

def getnote(note_to_decode, voice, line):
    global sequence_note
    global trill_note
    global normal_note
    global freqency_note
    global gsw_operand
    global oct                                  # default octave
    global accidentals
    global allkeys
    global acc_m                                # Last accidental on a note in measure.
    global acc_m_xpose
    global measure_on
    global args
    global note_to_midi_value
    global midi_value_to_note_flat
    global midi_value_to_note_sharp
    global key_sig
    global key_sig_int
    global key_convert
    global key_default
    global key_voice
    global xpose
    global xpose_new_key

    temp3 = 0                                   # character pointer
    if note_to_decode == '0':
        return '', 0, normal_note
    # fi
    if not note_to_decode or note_to_decode == '':
        return '', '', normal_note
    # fi
    if note_to_decode[0] == '{' or note_to_decode[0] == '[' or note_to_decode[0] == '(':
        if note_to_decode[0] == '{':            # gsw oprnd     { }
            typenote = gsw_operand              # set gsw-opnd flag
        elif note_to_decode[0] == '[':          # frequency     [ ]
            typenote = freqency_note            # set freq flag
        else:
            typenote = normal_note              # return normal note
        # fi
        work3 = 1
        #  must balance parens since note is followed by time
        #  [440]4
        # balance parens
        for temp2 in range(temp3 + 1, len(note_to_decode)):
            work4 = note_to_decode[temp2]
            if work4 == '(' or work4 == '[':
                work3 = work3 + 1               # count ('s
            elif work4 == ')' or work4 == ']':
                work3 = work3 - 1               # subtract  )'s
                if work3 < 1:
                    temp3 = temp2 + 1           # temp2 has last matched )
                    therest = note_to_decode[temp3:]
                    note_to_decode = note_to_decode[0:temp3]
                    thenote, type_error = is_float(note_to_decode)
                    if type_error is not None:
                        return therest, thenote, type_error
                    # fi
                    if thenote is None:
                        print_error("Note is not legal '{}', computation failed".format(note_to_decode), line)
                        return therest, thenote, type_error
                    # fi
                    thenote = int(round(thenote))
                    if typenote == freqency_note:  # if freq calculate it
                        #-- thenote = freq(thenote)
                        thenote = 968000/thenote    # NOT handled anywhere.
                    elif typenote == normal_note:
                        if thenote != 0:
                            thenote = thenote + xpose[voice]
                        # fi
                    # fi
                    # get ready for time computation
                    return therest, thenote, typenote
                # fi
            # fi
        # rof
        print_error("Note is not legal '{}', unbalanced parenthesis".format(note_to_decode), line)
        return '', None, normal_note
    # fi
    if note_to_decode[0] in [ '0', '1', '2', '3', '4', '5', '6', '7', '8' ]:    # check octave
        oct[voice] = int(note_to_decode[0])                                     # save octave
        temp3 = temp3 + 1
    # fi
    if len(note_to_decode) <= temp3 or note_to_decode[temp3] is None:
        print_error("no note_to_decode '{}' temp3={} len(note_to_decode)={}".format(note_to_decode,temp3, len(note_to_decode)), line)
        return '', None, normal_note
    # fi
    thenote = note_to_decode[temp3]
    if thenote not in [ 'a', 'b', 'c', 'd', 'e', 'f', 'g' ]:      # if not note -- reset, etc.
        if note_to_decode[0] == 's':            # check for sequence
            if note_to_decode[1] == '(':        # if time given
                print_error("sequence does not have a number of notes before parenthesis", line)
                return '', None, None                # ???
            # fi
            #       from, from_character, to, to_character, optionallength
            note_to_decode = note_to_decode[1:]
            sc = note_to_decode.find('(')
            if sc < 0:
                print_error("Sequence is not legal '{}' no parenthesis ".format(note_to_decode), line)
                return '', None, normal_note
            # fi
            number_in_sequence = note_to_decode[0:sc]
            number_in_sequence, type_error = is_float(number_in_sequence)
            if type_error is not None:
                print_error(type_error, line)
                return '', None, None                # ???
            # fi
            if number_in_sequence is None:
                print_error("sequence does not have a number of notes before parenthesis", line)
                return '', None, None                # ???
            # fi
            number_in_sequence = int(round(number_in_sequence))
            #-- time(note_to_decode, voice, line)   # get the time
            therest = note_to_decode[sc:]
            return therest, number_in_sequence, sequence_note
        # fi
        if note_to_decode[0] == 't':          # check for trill
            if note_to_decode[1] != '(':        # check for parenthesis
                print_error("Note is not legal '{}', no parenthesis".format(note_to_decode), line)
                return '', None, normal_note
            # fi
            #-- if typenote == trill_note:
            #--     print_error("Note is not legal '{}' double trill".format(note_to_decode), line)
            #--     return '', None, normal_note
            #-- # fi
            return note_to_decode[2:], 't(', trill_note
        # fi
        if note_to_decode[0] == 'r':          # check for rest
            # Rest follows.
            if args.horizontal or args.vertical:
                thenote = 'r'
            elif args.midi1csv:
                thenote = 0
            else:       # ABC
                thenote = 'z'                   # Convert to abc format rest.
            # fi
            temp3 = temp3 + 1
            # get ready for time computation
            therest = note_to_decode[temp3:]
            return therest, thenote, normal_note
        # fi
        print_error("Note is not legal '{}' unknown".format(note_to_decode), line)
        return '', None, normal_note
    # fi
    temp3 = temp3 + 1
    if len(note_to_decode) <= temp3:
        temp4 = ''
    else:
        temp4 = note_to_decode[temp3]
    # fi
    if temp4 == 'n':                            # natural special
        temp3 = temp3 + 1
        thenote = thenote + temp4                 # construct  dn
        if thenote not in allkeys:
            print_error("Note is not legal '{}' not good decode={}  n".format(note_to_decode,thenote), line)
            return '', None, normal_note
        # fi
        therest = note_to_decode[temp3:]
    elif temp4 == '+' or temp4 == '-':          # check special note
        thenote = thenote + temp4                 # construct  d+ or d-
        temp3 = temp3 + 1
        if len(note_to_decode) <= temp3:
            temp4 = ''
        else:
            temp4 = note_to_decode[temp3]
        # fi
        if temp4 == '+' or temp4 == '-':        # check special note
            thenote = thenote + temp4           # construct  d++ or d--
            temp3 = temp3 + 1
        # fi
        if thenote not in allkeys:
            print_error("Note is not legal '{}' not good decode={} +/-".format(note_to_decode,thenote), line)
            return '', None, normal_note
        # fi
        therest = note_to_decode[temp3:]
    else:
        if thenote not in allkeys:
            print_error("Note is not legal '{}' uh-ish {}".format(note_to_decode,thenote), line)
            return '', None, normal_note
        # fi
    # fi

    #   thenote             Convert to abc format for note, octave.
    n = thenote[0].lower()
    if args.horizontal or args.vertical or args.midi1csv:
        N = n.lower()
    else:               # ABC format
        N = n.upper()
    # fi
    if len(thenote) > 1:
        a = thenote[1:]
        if a not in accidentals:
            print_error("sharp/flat/natural is not legal '{}'".format(a), line)
            return '', None, normal_note
        # fi
        if args.horizontal or args.vertical:
            A = a
        elif args.midi1csv:
            A = a
        else:       # ABC
            A = accidentals[a]
        # fi
    else:
        A = a = ''
    # fi
    octaves = { 0:',,,', 1:',,', 2:',', 3:'', 4:'', 5:"'", 6:"''", 7:"'''", 8:"'''" }
    o = oct[voice]
    if o not in octaves:
        print_error("Note is not legal '{}' oct strange {}".format(note_to_decode,o), line)
        return '', None, normal_note
    # fi
    if a not in accidentals:
        print_error("Note is not legal '{}' accidentals strange {}".format(note_to_decode,a), line)
        return '', None, normal_note
    # fi

    if a == '' and voice in acc_m and N in acc_m[voice] and acc_m[voice][N] != '':
        # Check if default from last potential problem.
        print_warning("previous note '{}' voice {} in measure {} was '{}' and this note is default - FIXING".format(n,voice,measure_on,acc_m[voice][N]),line)
        a = acc_m[voice][N]
        if args.horizontal or args.vertical:
            A = a
        elif args.midi1csv:
            A = a
        else:       # ABC
            A = accidentals[a]          # Convert to abc format.
        # fi
    # if
    acc_m[voice][N] = a                 # Save for next note for voice.
    # . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
    # Have o(ctave),a(ccidental),and n(ote).
    # Convert for key.

    ky = key_voice[measure_on][voice]
    if args.horizontal or args.vertical:
        if ky not in key_sig:
            print_error("key name='{}' not in key_sig.".format(ky), line)
            sys.exit(1)
        # fi
        thenote = "{}".format(o) + n + a
        thenote = thenote.lower()
        if thenote not in key_convert[ky]:
            print_error("thenote='{}' not in key_sig={} dictionary.".format(thenote,key_sig.keys()), line)
            sys.exit(1)
        # fi
        thenote = key_convert[ky][thenote]
        o = thenote[0]
        n = thenote[1].lower()
        if len(thenote) > 2:
            A = a = thenote[2]
        else:
            A = a = ''
        # fi
    elif args.midi1csv:
        if ky not in key_sig_int:
            print_error("key number='{}' not in key_sig_int={}".format(ky,key_sig_int.keys()), line)
            sys.exit(1)
        # fi
        if a != '':
            thenote = "{}".format(o) + n + a
        else:
            thenote = "{}".format(o) + n + a
            ky = key_sig_int[ky]
            if thenote not in key_convert[ky]:
                print_error("thenote={} not in key_convert[{}] dictionary.".format(thenote,ky), line)
                sys.exit(1)
            # fi
            thenote = key_convert[ky][thenote]
        # fi
        o = thenote[0]
        n = thenote[1].lower()
        if len(thenote) > 2:
            A = a = thenote[2]
        else:
            A = a = ''
        # fi
    else:           # ABC
        # ky = ky.lower()
        # ky = ky.replace('b', '-')           # Does multiple flats
        # ky = ky.replace('#', '+')           # Does multiple sharps.
        # ky = ky.replace('=', 'n')           # Does multiple naturals.
        # if ky not in key_sig:
        #     print_error("key name='{}' not in key_sig.".format(ky.lower()), line)
        #     sys.exit(1)
        # # fi
        # Do not convert it in ABC format.
        pass
    # fi
    # . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
    # Have translated key of o(ctave),a(ccidental),and n(ote). -- Original for ABC.

    # 1) xpose added to the note.
    # 2) xpose_new_key converted back to o/n/a

    if (args.midi1csv or args.horizontal or args.vertical) and xpose[voice] != 0:      # So can print.
        jkl = str(o) + str(n) + a
        if jkl not in note_to_midi_value:
            print_error("note {} for xpose is not in note_to_midi_value".format(jkl), line)
            return '', None, normal_note
        # fi
        lkj = note_to_midi_value[jkl] + xpose[voice]
        if key_sig[xpose_new_key[voice]] <= 0:
            lkj = midi_value_to_note_flat[lkj]
        else:
            lkj = midi_value_to_note_sharp[lkj]
        # fi
        # Convert lkj to new_o, new_n, new_a.
        new_o = int(lkj[0])
        new_n = lkj[1].lower()

        if args.horizontal or args.vertical or args.midi1csv:
            new_N = new_n.lower()
        else:               # ABC format
            new_N = new_n.upper()
        # fi

        if len(lkj) > 2:
            new_a = lkj[2]
            new_A = new_a
        else:
            new_a = 'n'
            new_A = 'n'
        # fi

        # If new_a == '', then need check with new_a == n too.
        # IDEA: go through all notes in key, checking for [], and append().
        #   If only one found, check if 'n':
        #       if acc_m_xpose[voice][new_N] == ''
        #           then got the note, without the 'n'.
        #       else:
        #           the note needs the 'n'.
        #       # fi
        #   else: == multiple matches. Put out the accidental.

        k = []
        t = str(new_o) + new_n + new_a
        new_key = xpose_new_key[voice]
        if new_key in key_convert:
            for i in key_convert[new_key.lower()]:
                j = key_convert[new_key.lower()][i]
                if j == t:
                    k.append(i)
                # fi
            # rof
        # fi

        if len(k) == 1:
            j = key_convert[new_key.lower()][t]
            if j == t:          # 3 chars match 3 chars.
                acc_m_xpose[voice][new_N] = new_A
            else:
                if acc_m_xpose[voice][new_N] != '':
                    acc_m_xpose[voice][new_N] = new_A
                # fi
            # fi
        else:
            if acc_m_xpose[voice][new_N] != '':
                acc_m_xpose[voice][new_N] = new_A
            else:
                new_A = new_a = ''
            # fi
        # fi

        # . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
        # Need to know the key, and if various +/- and acc_m_xpose == '', don't need the +/-.
        #   (Reverse of key.)

        # If do not need the n/= for this voice and measure ...
        if acc_m_xpose[voice][new_N] == '':
            if new_a == 'n':
                new_A = ''
                new_a = ''
            else:
                acc_m_xpose[voice][new_N] = new_A
            # fi
        else:
            acc_m_xpose[voice][new_N] = new_A
        # fi
        o = new_o
        n = new_n
        N = new_N
        a = new_a
        A = new_A
    # else:             # ABC format - do nothing.
    #    pass;
    # fi
    # .............................................................................
    # Convert to right format.
    if args.horizontal or args.vertical:
        n = n.lower()
        #-- o = oct[voice]
    elif args.midi1csv:
        n = n.lower()
        #-- o = oct[voice]
    else:                           # ABC
        #-- o = oct[voice]
        if o <= 3:                                      # uppercase letter
            n = n.upper()
        else:                                           # lowercase letter
            n = n.lower()
        # fi
    # fi
    if args.horizontal or args.vertical:
        thenote = "{}".format(o) + n + a
    elif args.midi1csv:
        if a != '':
            thenote = "{}".format(o) + n + a
        else:
            thenote = "{}".format(o) + n + a
        # fi
        k = ky if xpose[voice] == 0 else xpose_new_key[voice]
        if type(k) is str:
            nthenote = key_convert[k.lower()][thenote]
        else:
            nthenote = key_convert[key_sig_int[k]][thenote]
        # fi
        abc = note_to_midi_value[nthenote]
        thenote = abc
    else:           # ABC
        # Do not convert it in ABC format.
        thenote = A + n + octaves[o]
    # fi
# .............................................................................
    therest = note_to_decode[temp3:]
    return therest, thenote, normal_note
# End of getnote

#-----------------------------------------------------------------------------
# compute time
# Returns:
#   timeofnote      computed length in 60ths
#   accidentals     -4 marcato, -2 tied, -1 stac, 0 normal
#   number_dots     Number of "dots".

def get_time(therest, line):
    work4 = 0
    vwork = 0
    if therest and not therest[0].isalpha():    # if not a note or modifier (computable)
        vwork, type_error = is_float(therest)
        # errorrest = everything after value -- if error occurs.
        # vwork = value calculated before error (even if not error).
        # type_error = message of error type.
        if type_error is not None:
            print_error(type_error, line)
            return 0, None, None                # ???
        # fi
        if vwork is None:
            vwork = 0
        # fi
    # fi
    if vwork == 0:
        work = 0                                # No time given
    else:
        if therest[0]  == "[":                  # number of 1/60ths
            work = (1.0/64.0) * vwork           # Number of 64th notes
        elif therest[0]  == "(":                # (.25) = 1/4 note (or like "4")
            work = vwork
        else:
            work = 1.0 / vwork
        # fi
    # fi
    work4 = 0                                   # No incidentals yet.
    bit_from_character = { 's': -1, 't': -2, 'b': -4, 'd': -8 }
    number_dots = 0
    if therest and therest != '':
        for i in reversed(range(0, len(therest))):
            temp4 = therest[i]
            # temp4 = [temp4 == "s"] + 2*[temp4 == "t"] + 4*[temp4 == "b"] + 8*[temp4 == "d"]
            if temp4 not in bit_from_character:
                break
            # fi
            temp4 = bit_from_character[temp4]
            if temp4 < 0 and temp4 > -8:
                work4 = work4 | (-temp4)
            else:
                number_dots = number_dots + 1
            # fi
        # rof
    # fi
    return work, -work4, number_dots
# End of get_time

#-----------------------------------------------------------------------------
def do_tie(onvoice, vnumber, line):
    global measure_on                   # The measure we are on.
    global meas                         # volume levels
    global bufs

    if vnumber is not None:
        return '-'
    # fi
    m = measure_on
    if m not in bufs[onvoice] or bufs[onvoice][m] == '':
        # Do measure before.
        w = len(meas) - 1               # current measure number in array.
        if w == 0:
            print_error("no previous measure to tie note to.", line)
            return ''
        else:
            m = meas[w-1]
        # fi
    # fi
    bufs[onvoice][m] = bufs[onvoice][m] + '-'
    return ''
# End of do_tie

#-----------------------------------------------------------------------------
# therest,new_one_note_volume,newvolume,text_str = get_vol_note(temp1, line)
def get_vol_note(temp1, line):
    global S_vlprint
    global vlprint

    therest = temp1[4:]
    sc = therest.find(')')
    if sc < 0 or sc == 0:
        print_error("A 'vol(' needs a number followed by a ')' -- ')' or number is missing", line)
        return '', None, None, None
    # fi
    f2 = -1                         # No volume setting after the "vol"
    s1 = therest[0:sc]
    therest = therest[sc+1:]
    f1, type_error = is_float(s1)
    if type_error is not None:
        for j in vlprint:
            if s1 == vlprint[j]:
                f1 = j
                type_error = None
                break
            # fi
        # rof
        if type_error is not None:
            for j in S_vlprint:
                if j == s1:
                    f1 = S_vlprint[j][0]
                    f2 = S_vlprint[j][1]
                    if f2 > 127:    # If out of range.
                        print_error("{} volume number must be between 1 and 127 inclusive. Not ({})".format(j,f2), line)
                        return '', None, None, None
                    # fi
                    type_error = None
                    break
                # fi
            # rof
            if type_error is not None:
                print_error("vol(xxx) did not get have a number or volume name. {}".format(type_error), line)
                return '', None, None, None
            # fi
        # fi
    # fi
    if f1 is None:
        print_error("volume is not a number.", line)
        return '', None, None, None
    # fi
    f1 = int(round(f1))
    if f1 < 1  or f1 > 127:       # If out of range.
        print_error("volume number must be between 1 and 127 inclusive. Not ({})".format(f1), line)
        return '', None, None, None
    # fi
    return therest, f1, f2, s1
# End of get_vol_note

#-----------------------------------------------------------------------------
# therest,newvolume,newtime = get_cresc(temp1, line)
def get_cresc(temp1, line):
    therest = temp1[6:]
    sc = therest.find(',')
    if sc < 0 or sc == 0:
        print_error("A 'cresc(' needs a number followed by a ',' -- ',' or number is missing", line)
        return '', None, None
    # fi
    s1 = therest[0:sc]
    s2 = therest[sc+1:]
    sc = s2.find(')')
    if sc < 0 or sc == 0:
        print_error("A 'cresc(' needs a number followed by a ',' and ')' -- ')' or time missing", line)
        return '', None, None
    # fi
    therest = s2[sc+1:]
    s2 = s2[0:sc]
    # . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
    f1, type_error = is_float(s1)
    if type_error is not None:
        for j in vlprint:
            if s1 == vlprint[j]:
                f1 = j
                type_error = None
                break
            # fi
        # rof
        if type_error is not None:
            print_error("cresc(xxx,yyy) did not get have a number or volume name. {}".format(type_error), line)
            return '', None, None
        # fi
    # fi
    if f1 is None:
        print_error("volume is not a number.", line)
        return '', None, None
    # fi
    f1 = int(round(f1))
    if f1 < 1  or f1 > 127:       # If out of range.
        print_error("volume number must be between 1 and 127 inclusive. Not ({})".format(f1), line)
        return '', None, None
    # fi
    # . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
    f2, type_error = is_float(s2)
    if type_error is not None:
        print_error("cresc(xxx,yyy) did not get have a time value - {}".format(type_error), line)
        return '', None, None
    # fi
    if f2 is None:
        print_error("time value is not a number.", line)
        return '', None, None
    # fi
    if f2 <= 0:                     # If out of range.
        print_error("time value must be greater than 0. Not ({})".format(f2), line)
        return '', None, None
    # fi
    # . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
    return therest, f1, f2
# End of get_cresc

#-----------------------------------------------------------------------------
# Parse and process possible notes line.
# All have ,'s as separators.
# old way is: voice1,voice2,voice3,voice4   -- 3c4, 3e4, 3g4, 4c4
# new way: v#:3c4,d,e,f,g,a,b,4c
# Both have measure terminate them.

#-- unit notego
def process_notes(t_args, line):
    global voices                       # number of voices
    global cis                          # if cis active, non-zero.
    global time                         # set default note length (time) dictionary
    global measure_on                   # The measure we are on.
    global sequence_note
    global trill_note
    global freqency_note
    global gsw_operand
    global legal_notes
    global mlth                         # measure length dictionary
    global args
    global bufs_accidentals
    global bufs_tie_next
    global bufs
    global DECORATIONS
    global macro_buffer                 # Name of macro, array of lines for macro.
    global macro_internal               # Next internal macro.
    global cresc_direction
    global cresc_time
    global cresc_volume
    global macro_arguments              # Name of macro, array of arguments for macro.
    global macro_executing_args
    global macro_executing_depth
    global macro_line
    global meas
    global running_vl
    global vlprint

    if not measure_on or measure_on == '':  # no measure yet
        print_error("no measure processed yet - must have one before notes.", line)
        return
    # fi
    # Get rid of all white spoce.
    wline = ''.join(line.split())
    wargs = arglist(wline, line)
    if not wargs or len(wargs) < 1:
        print_error("no arguments on note line", line)
        return
    # fi
#............................................................................
    # Check if 'v#' or 'v(#)'
    vnumber = None
    if wargs[0]:
        if (wargs[0])[0] == 'v' and (wargs[0])[1] != 'o':
            s1 = (wargs[0])[1:]
            sc = s1.find(':')
            if sc < 0:
                print_error("A 'v' needs a number followed by a colon -- colon is missing", line)
                return
            # fi
            if sc == 0:
                print_error("A 'v' needs a number followed by a colon -- number is missing", line)
                return
            # fi
            s1 = s1[0:sc]

            f1, type_error = is_float(s1)
            if type_error is not None:
                return
            # fi
            if f1 is None:
                print_error("voice number is not a number.", line)
                return
            # fi
            f1 = int(round(f1))
            if f1 < 1  or f1 > MAXVOICES:       # If out of range.
                print_error("voice number must be between 1 and {} inclusive. Not ({})".format(MAXVOICES, f1), line)
                return
            # fi
            do_set_voices(f1, line)
            cis = f1
            wargs[0] = (wargs[0])[sc+2:]
            if wargs[0] == '' and len(wargs) > 1:
                print_error("Cannot have a blank argument after v{}".format(cis), line)
                return
            # fi
            vnumber = 0
        # fi
    # fi
#............................................................................
    if cis == 0:                        # if not doing only one voice continuously for a while...
        if len(wargs) > voices:
            print_error("too many arguments ({}), greater than voices (>{})".format(len(wargs), voices), line)
            return
        # fi
        measlth = 0
        for i in range(0, len(wargs)):
            if wargs[i] != '':
                measlth = max(measlth, mlth[i+1][measure_on])
            # fi
        # rof
        for i in range(0, len(wargs)):
            if wargs[i] != '':
                l = measlth - mlth[i+1][measure_on]
                if l > 0:
                    if args.horizontal or args.vertical:
                        instak(i+1, measure_on, '', 'r', l, '', line, None, '')
                    elif args.midi1csv:
                        instak(i+1, measure_on, '', 0, l / (MIDICLICKSPERQUARTER * 4) , '', line, None, '')
                    else:           # ABC
                        instak(i+1, measure_on, '', 'z', l, '', line, None, '')
                    # fi
                # fi
            # fi
        # rof
    # fi
#............................................................................
    # Decode and stack the notes.
    loopstart = 1 if cis == 0 else cis
    for onvoice in range(loopstart, voices + 1):
        while True:
            if cis == 0 and len(wargs) < onvoice:
                print_error("Not enough arguments on note line - want {}, have {}".format(onvoice,wargs), line)
                return
            # fi
            if vnumber is None:
                temp1 = wargs[onvoice - loopstart]          # loopstart fixes "cis" being used.
                rest_wargs_on_line = wargs[onvoice - loopstart +1:]
            else:
                if vnumber >= len(wargs):
                    break
                # fi
                temp1 = wargs[vnumber]
                rest_wargs_on_line = wargs[vnumber +1:]
            # fi
            prenote = ''
            postnote = ''
            onenotevolume = None
            while True:
                for c in macro_buffer:
                    t = temp1[0:len(c) + 1]
                    if c != '' and c + '(' == t:
                        therest = temp1[len(c)+1:]
                        f = therest.find(')')
                        if f < 0:
                            print_error("macro {} does not have a closing parenthesis".format(c), line)
                            return
                        # fi
                        margs = [ therest[0:f] ]
                        temp1 = therest[f+1:]
                        # 1) Create and put in a temporary macro with no arguments for temp1
                        #    (rest of line), if anything in temp1 (not None, nor '').
                        # 2) Put in this macro with arguments.
                        if temp1 is not None and temp1 != '':
                            m_name = 'Internal_Macro_{}'.format(macro_internal)
                            if rest_wargs_on_line == []:
                                macro_buffer[m_name] = [ temp1 ]        # lines in bujffer.
                            else:
                                macro_buffer[m_name] = [ temp1 + "," + ",".join(rest_wargs_on_line) ]
                            # fi
                            # macro_defining = m_name               # No need, we did it.
                            macro_arguments[m_name] = []
                            macro_internal = macro_internal + 1     # Next internal macro.
                            macro_executing_depth.append(m_name)    # Add in the name.
                            macrodepth = len(macro_executing_depth) # one more to do.
                            macro_executing_args[macrodepth] = []   # No arguments
                            macro_line[macrodepth] = 0              # First line in buffer.
                        # fi
                        replace_macro(c, margs, line)
                        return                                      # Go out and read line for macro.
                    # fi
                # rof
                if temp1[0:4] == 'vol(':
                    therest,onenotevolume,f2,f3 = get_vol_note(temp1, line)
                    # onenotevolume for midi1csv format.
                    if onenotevolume is None:
                        return
                    # fi
                    if f2 != -1:
                        running_vl[onvoice][measure_on] = f2
                    # fi
                    if args.vertical or args.horizontal or args.midi1csv:
                        prenote = prenote + 'vol(' + str(f3) + ') '
                        # onenotevole already set for below.
                    else:           # ABC
                        # Cannot do sfp and such. Boo His.
                        #-- prenote = prenote + DECORATIONS + str(f3) + DECORATIONS
                        j = int(onenotevolume / 16)
                        j = (j * 16) + 15
                        prenote = prenote + DECORATIONS + vlprint[j] + DECORATIONS
                        if f2 == -1:
                            j = int(running_vl[onvoice][measure_on] / 16)
                            j = (j * 16) + 15
                            postnote = postnote + DECORATIONS + vlprint[j] + DECORATIONS
                        # fi
                    # fi
                    temp1 = therest
                    continue
                # fi
                if temp1[0:6] == 'cresc(' or temp1[0:6] == 'dimin(':
                    # cresc(ff,5.25)    # volume to go to, 5.25 = time in floating.
                    therest,newvolume,newtime = get_cresc(temp1, line)
                    if newvolume is None:
                        return
                    # fi
                    cresc_volume[onvoice] = newvolume
                    if args.vertical or args.horizontal:
                        prenote = prenote + 'cresc(' + str(newvolume) + ',' + str(newtime) + ') '
                        cresc_time[onvoice] = newtime + 0.0
                    elif args.midi1csv:
                        cresc_time[onvoice] = int(round(newtime * MIDICLICKSPERQUARTER * 4))
                    else:           # ABC
                        if newvolume > running_vl[onvoice][measure_on]:
                            cresc_direction[onvoice] = True
                            prenote = prenote + DECORATIONS + 'crescendo(' + DECORATIONS
                        else:
                            cresc_direction[onvoice] = False
                            prenote = prenote + DECORATIONS + 'diminuendo(' + DECORATIONS
                        # fi
                        cresc_time[onvoice] = newtime + 0.0
                    # fi
                    temp1 = therest
                    continue
                # fi
                break
            # elihw
            therest, thenote, typenote = getnote(temp1, onvoice, line) # get next note
            if thenote is None:
                print_error("no note? therest='{}' thenote='{}' typenote='{}'".format(therest,thenote,typenote), line)
                break
            # fi

            if type(thenote) == str and thenote == '':
                break
            # fi
            if type(thenote) is int and typenote != sequence_note:
                #-- if thenote == 0:                        # return nothing, ignore.
                #--     break
                #-- # fi
                if args.vertical or args.horizontal:
                    thenote = "({})".format(thenote)        # Put back as a number.
                elif args.midi1csv:
                    if thenote < 0:
                        thenote = 0
                    # fi
                else:           # ABC
                    thenote = to_abc_note(thenote)          # Convert number to abc text.
                # fi
            # fi
            if typenote == trill_note:
                therest, thenote, typenote = getnote(therest, onvoice, line)
                if thenote is None or thenote == 0 or thenote == '':
                    print_error("trill is not legal, no first note", line)
                    return
                # fi

                if typenote == gsw_operand:                                 # 2**16 gsw opnd
                    quotes = thenote - (1 << 16)
                else:
                    quotes = thenote
                # fi
                if therest is None or therest == '' or therest[0] != ',':
                    print_error("trill is not legal, no comma after first note", line)
                    return
                # fi
                therest = therest[1:]                                       # comma removed
                therest, thenote, typenote = getnote(therest, onvoice, line)  # get second note
                if thenote is None or thenote == 0 or thenote == '':
                    print_error("trill is not legal, second note missing", line)
                    return
                # fi
                if typenote == gsw_operand:                                 # 2**16 gsw opnd
                    quotes1 = thenote - (1 << 16)
                    print_error("trill is not legal, first note not correct", line)
                    return
                elif typenote == freqency_note or typenote == trill_note or typenote == sequence_note:
                    print_error("trill is not legal, first note not correct", line)
                    return
                # fi
                quotes1 = thenote
                if therest is None or therest == '':
                    print_error("trill is not legal, missing number of notes", line)
                    return
                # fi
                if therest is None or therest == '' or therest[0] != ',':
                    print_error("trill is not legal, no comma after second note", line)
                # fi
                therest = therest[1:]                                       # comma removed
                np = temp1 = 0
                f = therest.find(')')
                if f < 0:
                    print_error("trill is not legal, missing closing parenthesis", line)
                    return
                # fi
                num = therest[0:f]
                if len(therest) <= f:
                    print_error("trill is not legal, missing length after parenthesis", line)
                    return
                # fi
                therest = therest[f+1:]
                np, type_error = is_float(num)
                if np is None or np == 0 or type_error is not None:
                    print_error("trill is not legal, number of notes to play", line)
                    return
                # fi
                timeofnote, r_accidentals, number_dots = get_time(therest, line)
                if r_accidentals is None or r_accidentals < 0 or number_dots is None:
                    print_error("trill is not legal", line)
                    return
                # fi
                if timeofnote == 0:
                    timeofnote = time[onvoice]
                # fi
                if number_dots != 0:
                    p = timeofnote / 2.0
                    for i in range(1,number_dots+1):
                        timeofnote = timeofnote + p
                        p = p / 2.0
                    # rof
                # fi
                time[onvoice] = timeofnote

    #   t(3a,3g,7)4 =>  '(7:4:2 3a3g'

                # vwork = float(timeofnote) / float(np)

                # t(quotes, quotes1, np)lengthl
                if args.horizontal or args.vertical or args.midi1csv:
                    lengthf = [ timeofnote ]
                else:           # ABC
                    lengthl, lengthf, ifokay = get_time_stak(timeofnote, line)
                    if ifokay != 0 or len(lengthl) != 1:         # if time is error
                        print_warning("trill time must be a printable note length, not '{}'".format(lengthl),line)
                        t = 0
                        for l in range(0,len(lengthl)):
                            t = t + lengthf[l]
                        # fi
                        lengthf = [ t ]
                        print_warning("trill time remade '{}'".format(lengthf),line)
                    # fi
                    l = str(Fraction(lengthf[0]).limit_denominator(256))
                    where = l.find('/')
                    lth = '1'
                    if where > 0:                               # / in fraction
                        numerator = l[0:where]
                        if numerator != '1':
                            lth = numerator
                            l = '1' + l[where:]
                        # fi
                    # fi
                    if l not in legal_notes:
                        print_warning("#2 Time fraction '{}' is not a printable note. ({})".format(lengthf[0],l), line)
                    # fi
                    if l == '1':
                        l = '1/1'
                    # fi
                # fi

                if args.horizontal or args.vertical:
                    np = int(round(np))
                    abc_note = "t({},{},{})".format(quotes,quotes1,np)
                    put_on_bufs(onvoice, measure_on, prenote, abc_note, lengthf[0], '', onenotevolume, '')
                    if vnumber is None:
                        break                                       # normal old way.
                    # fi
                    vnumber = vnumber + 1
                    continue
                elif args.midi1csv:
                    lthtrill = int(round((lengthf[0] / int(np)) * MIDICLICKSPERQUARTER * 4.0))
                    for i in range(0, int(np)):
                        if (i % 2) == 0:
                            abc_note = quotes
                        else:
                            abc_note = quotes1
                        # fi
                        put_on_bufs(onvoice, measure_on, prenote, abc_note, lthtrill, '', onenotevolume, '')
                    # rof
                    if vnumber is None:
                        break                                       # normal old way.
                    # fi
                    vnumber = vnumber + 1
                    continue
                else:           # ABC
                    abc_note = "[L:{}]".format(l)
                    abc_note = abc_note + '(' + str(int(np)) + ':' + lth + ':' + str(int(np))
                    for i in range(0, int(np)):
                        if (i % 2) == 0:
                            abc_note = abc_note + quotes
                        else:
                            abc_note = abc_note + quotes1
                        # fi
                    # rof
                    l_dl = default_note_text_fraction(measure_on)
                    if l_dl == '1':
                        l_dl = '1/1'
                    # fi
                    abc_note = abc_note + "[L:{}]".format(l_dl)
                    put_on_bufs(onvoice, measure_on, prenote, abc_note, lengthf[0], '', onenotevolume, postnote)
                    if vnumber is None:
                        break                                       # normal old way.
                    # fi
                    vnumber = vnumber + 1
                    continue
                # fi
            elif typenote == sequence_note:
                number_in_sequence = thenote
                if therest[0] != '(':
                    print_error("sequence is not legal, no parenthesis after number {}".format(number_in_sequence), line)
                    return
                # fi
                therest = therest[1:]                                       # parenthesis removed
                notes = []
                for sn in range(0,number_in_sequence):
                    therest, thenote, typenote = getnote(therest, onvoice, line)
                    if thenote is None or thenote == '':
                        print_error("sequence is not legal, no note", line)
                        return
                    # fi
                    if typenote == gsw_operand:                                 # 2**16 gsw opnd
                        quotes = thenote - (1 << 16)
                    else:
                        quotes = thenote
                    # fi
                    if sn != number_in_sequence - 1:
                        if therest is None or therest == '' or therest[0] != ',':
                            print_error("sequence is not legal, no comma after note", line)
                            return
                        # fi
                    elif therest[0] != ')':
                        print_error("sequence is not legal, no right parenthesis after last note", line)
                        return
                    # fi
                    therest = therest[1:]                                       # parenthesis removed
                    notes.append(quotes)
                # rof
                timeofnote, r_accidentals, number_dots = get_time(therest, line)
                if r_accidentals is None or r_accidentals < 0 or number_dots is None:
                    print_error("sequence is not legal, r_accidentals={} number_dots={}".format(r_accidentals,number_dots), line)
                    return
                # fi
                if timeofnote == 0:
                    timeofnote = time[onvoice]
                # fi
                if number_dots != 0:
                    p = timeofnote / 2.0
                    for i in range(1,number_dots+1):
                        timeofnote = timeofnote + p
                        p = p / 2.0
                    # rof
                # fi
                time[onvoice] = timeofnote

                if args.horizontal or args.vertical:
                    lengthf = [ timeofnote ]
                    abc_note = "s{}({})".format(number_in_sequence, ','.join(notes))
                    put_on_bufs(onvoice, measure_on, prenote, abc_note, lengthf[0], '', onenotevolume, '')
                    if vnumber is None:
                        break                                       # normal old way.
                    # fi
                    vnumber = vnumber + 1
                    continue
                elif args.midi1csv:
                    lengthf = [ timeofnote ]
                    lthseq = int(round((lengthf[0] / number_in_sequence) * MIDICLICKSPERQUARTER * 4.0))
                    for q in notes:
                        put_on_bufs(onvoice, measure_on, prenote, q, lthseq, '', onenotevolume, '')
                    # rof
                    if vnumber is None:
                        break                                       # normal old way.
                    # fi
                    vnumber = vnumber + 1
                    continue
                else:           # ABC
                    if number_in_sequence == 2 or number_in_sequence == 3:
                        dnl = timeofnote / 2
                        l_time = int(round(timeofnote / dnl - 0.5))
                    elif number_in_sequence == 4 or number_in_sequence == 6:
                        dnl = timeofnote / 4
                        l_time = int(round(timeofnote / dnl - 0.5))
                    elif number_in_sequence == 8:
                        dnl = timeofnote / 8
                        l_time = int(round(timeofnote / dnl - 0.5))
                    else:
                        print_error("number in sequence ({}) not 2,3,4,6,8.".format(number_in_sequence),line)
                        return
                    # fi
                    dnl_str = str(Fraction(dnl).limit_denominator(256))

                    lengthl, lengthf, ifokay = get_time_stak(timeofnote, line)
                    if ifokay != 0 or len(lengthl) != 1:         # if time is error
                        print_warning("sequence time must be a printable note length, not '{}'".format(lengthl),line)
                        t = 0
                        for l in range(0,len(lengthl)):
                            t = t + lengthf[l]
                        # fi
                        lengthf = [ t ]
                        print_warning("sequence time remade '{}'".format(lengthf),line)
                    # fi

                    if dnl_str == '1':
                        dnl_str = '1/1'
                    # fi
                    abc_note = "[L:{}]".format(dnl_str)
                    abc_note = abc_note + '(' + str(number_in_sequence) + ':' + str(l_time) + ':' + str(number_in_sequence) + ' '
                    for q in notes:
                        abc_note = abc_note + q
                    # rof
                    l_dl = default_note_text_fraction(measure_on)
                    if l_dl == '1':
                        l_dl = '1/1'
                    # fi
                    abc_note = abc_note + "[L:{}]".format(l_dl)
                    put_on_bufs(onvoice, measure_on, prenote, abc_note, lengthf[0], '', onenotevolume, postnote)
                    if vnumber is None:
                        break                                       # normal old way.
                    # fi
                    vnumber = vnumber + 1
                    continue
                # fi
            # end of sequence processing above.

            #-- elif thenote == 0:                               # if nothing to do
            #--     break
            #-- # fi

            timeofnote, r_accidentals, number_dots = get_time(therest, line)
            if r_accidentals is None or number_dots is None:
                print_error("Error getting time for note", line)
                return
            # fi
            # r_accidentals = -4 marcato, -2 tied, -1 stac, 0 normal
            #    bits are $union$'ed together for multiple modifiers (then negated).
            # number_dots  are how many "d" (dotted) were found.
            if timeofnote is None or timeofnote == 0:
                if number_dots != 0:
                    print_error("cannot have dotted syntax on a default note length.", line)
                    return
                # fi
                timeofnote = time[onvoice]
            # fi
            if number_dots != 0:
                p = timeofnote / 2.0
                for i in range(1,number_dots+1):
                    timeofnote = timeofnote + p
                    p = p / 2.0
                # rof
            # fi
            time[onvoice] = timeofnote

            if typenote == gsw_operand:
                print_error("NOTDONEYET - doing gsw_operand type of note", line)
                return
            # fi

            append_tie = bufs_tie_next[onvoice]
            bufs_tie_next[onvoice] = ''
            # Tied note
            # r_accidentals = -4 marcato, -2 tied, -1 stac, 0 normal
            if r_accidentals < -6 or r_accidentals in (-6, -3, -2):
                if vnumber is not None:         # vertical input format
                    if args.horizontal:                     # horizontal output
                        # put tie on following note.
                        bufs_tie_next[onvoice] = 't'
                    elif args.midi1csv:                     # midi1csv output
                        # put tie on following note.
                        bufs_tie_next[onvoice] = 't'
                    elif args.vertical:                     # vertical output
                        append_tie = 't'
                    else:           # ABC
                        append_tie = do_tie(onvoice, vnumber, line)
                    # fi
                else:                           # horizontal input format
                    if args.vertical:                       # vertical output
                        # put tie on previous note.
                        if measure_on not in bufs[onvoice] or bufs[onvoice][measure_on] == '':
                            # Do measure before.
                            w = len(meas) - 1               # current measure number in array.
                            if w == 0:
                                print_error("no previous measure to tie note to.", line)
                                return ''
                            else:
                                m = meas[w-1]
                            # fi
                        else:
                            m = measure_on
                        # fi
                        i = len(bufs_accidentals[onvoice][m]) - 1
                        bufs_accidentals[onvoice][m][i] = bufs_accidentals[onvoice][m][i] + 't'
                        append_tie = ''                     # Nothing on this note, on previous.
                    elif args.horizontal or args.midi1csv:  # horizontal output
                        append_tie = 't'
                    else:           # ABC
                        append_tie = do_tie(onvoice, vnumber, line)
                    # fi
                # fi
            # fi

            # Staccato
            if r_accidentals < -6 or r_accidentals in (-5, -3, -1):
                if args.horizontal or args.vertical or args.midi1csv:
                    append_tie = append_tie + 's'
                else:           # ABC
                    thenote = '.' + thenote                 # . before the note for staccato
                # fi
            # fi

            instak(onvoice, measure_on, prenote, thenote, timeofnote, append_tie, line, onenotevolume, postnote)
            if vnumber is None:
                break                                       # normal old way.
            else:
                vnumber = vnumber + 1
            # fi
        # elihw
    # rof
    return
# End of process_notes

#=============================================================================
# Parse and process line.
def process_line(t, line):
    global iftest                       # check if after if or else.
    global ifdepth                      # level of if/else/endif
    global commands
    global cstop_processing
    global macro_defining               # If defining macro.
    global macro_buffer                 # Name of macro, array of lines for macro.

    if not t or len(t) == 0:
        return
    elif len(t) == 1:
        command = t[0]
        t_args = None
    else:
        command = t[0]
        t_args = t[1:]
    # fi

    if cstop_processing:
        # Read until cstart found (or end of file)
        if command in commands:
            if commands[command] == do_cstart:
                do_cstart(t_args, line)
            # fi
            if commands[command] == do_cstopnow:
                do_cstopnow(t_args, line)
            # fi
        # fi
        return                          # Done with current cstop processing.
    # fi

    if macro_defining is not None:
        if command in commands:
            if commands[command] == do_endm:
                do_endm(t_args, line)
                return;
            # fi
            if commands[command] == do_cstopnow:
                do_cstopnow(t_args, line)
                return;
            # fi
        # fi
        macro_define(command, t_args, line)
        return
    # fi

    # Doing if section or else section.
    if iftest[ifdepth] == -1 or iftest[ifdepth] == 1:
        # Try to process command.
        if command is None:             # Ignore nothing given.
            return
        # fi
        if command in macro_buffer.keys():
            replace_macro(command, t_args, line)
            return                      # Henceforth get lines from macro_buffer.
        # fi
        if command in commands:
            try:
                r = commands[command]
            except:
                print_error("not found processing routine for command {}", command)
                print("    ", sys.exc_info()[0], sys.exc_info, file=sys.stderr)
            # fi
            r(t_args, line)
            return
        # fi
        process_notes(t,line)
    else:                               # Here if false for "if" -- special else, or in else, or both.
        if t[0] in commands:
            if commands[t[0]] == do_cstopnow:
                do_cstopnow(t_args, line)
            elif commands[t[0]] == do_if:
                do_if(t_args, line)
            elif commands[t[0]] == do_else:
                do_else(t_args, line)
            elif commands[t[0]] == do_endif:
                do_endif(t_args, line)
            # fi
        # fi
        return
    # fi
    return
# End of process_line

#-----------------------------------------------------------------------------
def parse_args():
    global args

    parser = argparse.ArgumentParser(
        description=__doc__,
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog='this is the epilog')
    parser.add_argument('--vertical', '--vertica', '--vertic', '--verti', '--vert',
                        '--ver', '--ve', '--v', '-v',
                        action='store_true',
                        help = 'Vertical musicomp format output.')
    parser.add_argument('--horizontal', '--horizonta', '--horizont', '--horizon',
                        '--horizo', '--horiz', '--hori', '--hor', '--ho', '--h',
                        action='store_true',
                        help = 'Horizontal musicomp format output.')
    parser.add_argument('--midi1csv', '--midi1cs', '--midi1c', '--midi1', '--midi',
                        '--mid', '--mi', '--m', '--csv', '--cs', '--c', '-c', '-m', '-1',
                        action='store_true',
                        help = 'Output MIDI 1.0 music format output - default.')
    parser.add_argument('--abc', '-abc',
                        action='store_const', const=1, default=0,
                        help = 'ABC music format output - default.')
    parser.add_argument('rest', nargs='*',
                        help='Optional command to execute')
    args = parser.parse_args()

    if args.vertical:
        if args.horizontal or args.abc == 1 or args.midi1csv:
            print("Only may have one of --vertical, --horizontal, --abc, or --midi1", file=sys.stderr)
            sys.exit(1)
        # fi
    elif args.horizontal:
        if args.abc == 1 or args.midi1csv:
            print("Only may have one of --vertical, --horizontal, --abc, or --midi1", file=sys.stderr)
            sys.exit(1)
        # fi
    elif args.abc == 1 and args.midi1csv:
        print("Only may have one of --vertical, --horizontal, or --abc", file=sys.stderr)
        sys.exit(1)
    # fi
    return
# End of parse_args

#-----------------------------------------------------------------------------
# Main program follows.
def main():
    global header
    global measure_meter
    global args
    global file_name
    global output_name
    global meter
    global voices
    global measure_on
    global key_default
    global key_voice

    parse_args()
    if args.vertical or args.horizontal:
        header = ( "meter   4/4\n" )
        key_default = "c"                   # Default to key of c.
                                            # At the end of header, print out the key - then follows notes.
        measure_meter = { '': '4/4'}        # Each measure change can have a different meter.
        meter = '4/4'
    elif args.midi1csv:
        header = []
        key_default = 0                     # Default to key of C.
        measure_meter = { '': '4/4'}        # Each measure change can have a different meter.
        meter = '4/4'
    else:           # ABC
        header = (  "X:1\n" +               # Song number 1 in the output file.
                    "M:none\n" )            # No meter supposedly means don't check.
        key_default = "C"                   # Default to key of C.
                                            # At the end of header, print out the key - then follows notes.
        measure_meter = { '': 'none'}       # Each measure change can have a different meter.
        meter = 'none'
    # fi
    for v in range(1, MAXVOICES+1):
        key_voice[''][v] = key_default
    # rof

    new_voice_initialize(voices, measure_on)    # Set a bunch of things for voice=1 so acc_m, etc. are set.

    output_name = sys.stdout
    if args.rest:
        if len(args.rest) >= 1:             # Input.
            file_name = open(args.rest[0], 'r')
        # fi
        if len(args.rest) >= 2:             # Output.
            output_name = open(args.rest[1], 'w')
        # fi
        if len(args.rest) > 2:              # Too many.
            print("Too many arguments, input, output only.  {}".format(args.rest), file=sys.stderr)
            sys.exit(1)
        # fi
    # fi

    while True:
        line = get_line()
        if line:
            # Split line on spaces, then process line.
            while True:
                t = line.split(' ', 1)
                if t and t[0] and len(t) == 2 and t[1]:
                    t[1] = t[1].strip()
                # fi
                if t and t[0] == '.':
                    # If command == '.' toss '.'
                    if len(t) == 2 and t[1]:
                        line = t[1]
                    else:
                        t = None
                        line = None
                        break
                    # fi
                    continue
                # fi

                if line and line[0] == '=':
                    line = process_putd(line)
                    continue
                # fi
                break
            # elihw

            if t and t[0]:
                # If command == '*' ignore.
                if t[0] != '*' and line[0] != '*' and t[0] != '#' and line[0] != '#':
                    process_line(t, line)
                # fi
            # fi
        # fi
    # elihw
    return
# End of main

#-----------------------------------------------------------------------------
if __name__ == '__main__':
    calculate.cexp_parser()                                     # initialize parser
    main()
# fi
#-----------------------------------------------------------------------------
exit(errors_happened)
#-----------------------------------------------------------------------------
# End of file musicomp2abc
#-----------------------------------------------------------------------------

# Header:
# * X:          Reference number (think which track on CD, etc.).       First
# * T: Title of tune             (can have multiple)
#   C: Composer of song
#   M: meter    6/8              default common or "M: C"
#   L: 1/4                       length of default note (quarter)
#   K: key      C or D or ...                                           Last
#
#   Notes: follow Header
#       C, D, E, F, |G,A,B,C| D E F G|A B c d|e f g a|b c' d' e'|f' g' a' b'|]
#
#       ~A3 B3|gfe fdB|AFA B2c|dfe dcB|
#
#   Uppercase denote bottom octave (C = middle C on treble stave).
#   Comma after the letter means down an octave.
#   Apostrophe after the letter means up an octave. Multiple ' go up, as ,'s go down.
#   Lowercase letters are next octave above uppercase. four c's: "C, C c c' "
#   |  Vertical line means end of measure/bar -- || gives two lines.
#   ]  means thick bar.  [|  and |] thick/thin and thin/thick.
#   |: start of repeat. :| is end of repeat. Stop one and start another is :||: or "::".
#   Alternate repeats "[1", "[2". If by bar line, can omit the [. "|1" means "|[1". (no spaces)
#   To have notes with "beam"(lines together above/below) eliminate the "space".
#
#   Number after note changes duration. Number times default. B2=B twice as long therefore 1/4 because 1/2.
#   / means shorten, default is 2 or "/2".
#   > after a note, multiplying by 3/2 and removing from 2nd note. I.e. c8>c8 -> c8.c16 (dot means 1/16 extra)
#   < after a note, multiplying by 1/2 and adding rest on 2nd note. I.e. c8<c8 -> c16c8. means 1/16th extra
#
#   ~ is ornament -- roll or turn as in Irish music.
#   Default note lengths for common types of tunes: jig 1/8, reel 1/8, Schottische 1/8,
#       Waltz 1/4, Polka 1/8, Bourree 1/8
#   Time signagures typical: jig 6/8, reel 4/4, waltz 3/4.
#   L: can be used in the middle to change default note length.
#   Rests are lowercase z. Length follows.
#   ^C = C sharp. _B = B flat. ^^ = double sharp. The equals (=) naturalizes it.
#   G major scale: GABcde^fg            for K:C
#   G minor scale: GA_Bcd_efg           for K:C
#   K: automatically adds sharps or flats.      example K:G or K:Gmaj ... and K:Gm or K:Gmin
#   Also K:Bb and K:C#   (B flat and C sharp).
#   Other Modal keys exist: Lydian, Ionian, Mixolydian, Dorian, Aeolian, Phrygian, Locrian,
#       HP (bagpipe - no key signature), Hp (F#,C#,G natural) on printed.
#   K: can go in the middle of a song.   K:A =C -- A major, C natural -- F#,G#.
#   R: = rythm. ... R:reel, R:jig, R:schottische
#   Q: tempo    Example: Q: 120  # of default note length.  Q:1/8 = 120.
#   Can change in the middle of a line like (KRQ):
#       GABcdefg | [M:6/8 K:Gm] gfe dcB | AGB FED |
#   Optional:
#   C: composer
#   S: source of tune.
#   O: geographical origin
#   N: textual notes about the tune. (anything you want, multiple of them, etc.)
#   Z: identity of transcriber. # Z:Marshall Midden 2021-01-04
#   W: for song words           w:  also -- difficult syntax. :)
#   B: for book
#   A: geographical area
#   D: Discography -- D:New Victory Band, One More Dance And Then
#   F: File name (http://www.lesession.co.uk/woodenflute.abc)
#   G: Group -- used for indexing tunes in software.   G: Flute
#   H: history
#   I: Information -- used by some software packages.
#   P: Yuck.  Parts.
#
#   grace notes {GAGDG}G2 -- they can have no time values.
#   - minus sign between two notes of equal pitch "ties". () slurs or played legato.
#       |DEF-|FGA| and |DEF-FGA|
#       (DEF|GAB)
#   Triplets -- no spaces within:
#       Duplet:     (2GA                2 notes in the time of 3
#       Triplet:    (3GAB               3 notes in the time of 2
#       Quadruplet: (4GABA              4 notes in the time of 3
#       ...       : (5GABcd             5 notes in the time of n
#       ...       : (6GABcdc            6 notes in the time of 2
#       ...       : (7GABcdcB           7 notes in the time of n
#       ...       : (8GABcdcBA          8 notes in the time of 3
#       ...       : (9GABcdcBAG         9 notes in the time of n
#       n is 3 in compound time signatures (3/4, 3/8, 9/8 etc), and 2 in simple time signatures (C, 4/4, 2/4 etc.)
#       More complicated forms possible. (Yuck!)
#   [GB][Ac] [B2d2] | [Bd][Ac] [G2B2]   - multiple notes on a stem (chord/unisons)
#   Guitar chords:  "Dm7"               -- note accidental type/bass
#       note:       A to G
#       accidental: # or b
#       type:       m, min, maj, sus, dim, +, 7, 9, 11,#5, etc.
#       / bass:     Bass note
#   Fiddle bowing marks:  u=up-bow, v=down-bow.     v_Au=Bv^c   NOTE: flat A, natural B, sharp c.
#   Staccato, place dot before the note.            .G.A._B.c .d2.e.d.^c
#       H Fermata, L Accent, or emphasis, M Lower mordent (sometimes called mordent),
#       O Coda, P Upper mordent (sometimes called Pralltriller), S Segno, T Trill
#   or can enclose within exclamation marks (!):
#       !+!             Pizzicato for violins, rasp for brass
#       !0! to !5!      Fingerings
#       !D.C.!          Da capo
#       !D.S.!          Da segno
#       !accent!        Accent mark over the note
#       !breath!        Breath mark
#       !coda!          Coda mark
#       !crescendo(!    Start of a crescendo mark
#       !crescendo)!    End of a crescendo mark - this is placed AFTER the last note affected
#       !diminuendo(!   Start of a diminuendo mark
#       !diminuendo)!   End of a diminuendo mark - this is placed AFTER the last note affected
#       !downbow!       Down bow mark
#       !emphasis!      The same as !accent!
#       !fermata!       Fermata, or hold
#       !f!, !ff!, !fff! etc.   Dynamic markings - the more f -s, the louder
#       !fine!          Fine
#       !invertedfermata!   Inverted fermata / hold marking
#       !longphrase!    Vertical line on the upper part of the staff, extending 3/4 of the way down
#       !lowermordent!  Lower mordent, a.k.a. mordent
#       !mediumphrase!  Vertical line on the upper part of the staff, extending down to the centre line
#       !mf!            Dynamic marking for mezzoforte ('half-loud')
#       !mordent!       Lower mordent, a.k.a. mordent
#       !open!          Open string, or, harmonic
#       !p!, !pp!, !ppp!    Dynamic markings - the more p -s, the quieter
#       !pralltriller!  Upper mordent
#       !repeatbar!     Repeat whole of previous bar
#       !repeatbar2!    Repeat whole of previous two bars
#       !roll!          Roll mark
#       !segno!         Segno
#       !shortphrase!   Vertical line on the upper part of the staff
#       !snap!          Snap-pizzicato mark
#       !tenuto!        tenuto (hold note for full duration)
#       !thumb!         Cello thumb symbol
#       !trill!         Trill
#       !turn!          Turn
#       !upbow!         Up bow mark
#       !uppermordent!  Upper mordent, a.k.a. pralltriller
#       !wedge!         Wedge mark
#   As with the single letter symbols, the mark is placed before the note (or first note of a group) affected.
#       !trill!G4
#   V: voice number     V:1     V:20
#       M:6/8
#       L:1/8
#       K:G
#       V:1
#       B3 A3 | G6 | B3 A3 | G6 ||
#       V:2
#       BdB AcA | GAG D3 | BdB AcA | GAG D6 ||
#       V:3
#       D3 D3 | D6 | D3 D3 | D6 ||
#   or:
#       M:6/8
#       L:1/8
#       K:G
#       [V:1] B3 A3 | G6 | B3 A3 | G6 ||
#       [V:2] BdB AcA | GAG D3 | BdB AcA | GAG D3 ||
#       [V:3] D3 D3 | D6 | D3 D3 | D6 ||
#   Notes played at same time, but not a chord (two voices): AB BAG & D6 |
#       The & has the two same length.
#       x draws spaces (not rests).        GAB BAG & x3 G2x
#       Normally use [] for chords.
#   ==============================================================================
#   General MIDI 1
#        24 channels/voices     Alternatively 16 melodic and 8 percussive - respond to note velocity.
#       channel 10 is percussion.
#       multiple notes on each channel (polyphony)
#       128 instruments sounds or "program" number  - program change message.
#        47 percussion sounds
#       Channel messages/controller-number: 1,7,10,11,64,100,101,121,123
#   General MIDI 2
#        32 channels
#       2 percussion channels 10/11
#     16384 variation banks - each has 128 melodic sounds. Up to individual how to use.
#         9 Drum kits
#   ------------------------------------------------------------------------------
#   Put in a V: section.
#   %%MIDI program 1 % Acoustic Grand Piano
#   Piano
#       1 Acoustic Grand Piano
#       2 Bright Acoustic Piano
#       3 Electric Grand Piano
#       4 Honky-tonk Piano
#       5 Electric Piano 1
#       6 Electric Piano 2
#       7 Harpsichord
#       8 Clavi
#   Chromatic Percussion
#       9 Celesta
#       10 Glockenspiel
#       11 Music Box
#       12 Vibraphone
#       13 Marimba
#       14 Xylophone
#       15 Tubular Bells
#       16 Dulcimer
#   Organ
#       17 Drawbar Organ
#       18 Percussive Organ
#       19 Rock Organ
#       20 Church Organ
#       21 Reed Organ
#       22 Accordion
#       23 Harmonica
#       24 Tango Accordion
#   Guitar
#       25 Acoustic Guitar (nylon)
#       26 Acoustic Guitar (steel)
#       27 Electric Guitar (jazz)
#       28 Electric Guitar (clean)
#       29 Electric Guitar (muted)
#       30 Overdriven Guitar
#       31 Distortion Guitar
#       32 Guitar Harmonics
#   Bass
#       33 Acoustic Bass
#       34 Electric Bass (finger)
#       35 Electric Bass (pick)
#       36 Fretless Bass
#       37 Slap Bass 1
#       38 Slap Bass 2
#       39 Synth Bass 1
#       40 Synth Bass 2
#   Strings
#       41 Violin
#       42 Viola
#       43 Cello
#       44 Contrabass
#       45 Tremolo Strings
#       46 Pizzicato Strings
#       47 Orchestral Harp
#       48 Timpani
#   Ensemble
#       49 String Ensemble 1
#       50 String Ensemble 2
#       51 Synth Strings 1
#       52 Synth Strings 2
#       53 Choir Aahs
#       54 Voice Oohs
#       55 Synth Voice
#       56 Orchestra Hit
#   Brass
#       57 Trumpet
#       58 Trombone
#       59 Tuba
#       60 Muted Trumpet
#       61 French Horn
#       62 Brass Section
#       63 Synth Brass 1
#       64 Synth Brass 2
#   Reed
#       65 Soprano Sax
#       66 Alto Sax
#       67 Tenor Sax
#       68 Baritone Sax
#       69 Oboe
#       70 English Horn
#       71 Bassoon
#       72 Clarinet
#   Pipe
#       73 Piccolo
#       74 Flute
#       75 Recorder
#       76 Pan Flute
#       77 Blown bottle
#       78 Shakuhachi
#       79 Whistle
#       80 Ocarina
#   Synth Lead
#       81 Lead 1 (square)
#       82 Lead 2 (sawtooth)
#       83 Lead 3 (calliope)
#       84 Lead 4 (chiff)
#       85 Lead 5 (charang)
#       86 Lead 6 (voice)
#       87 Lead 7 (fifths)
#       88 Lead 8 (bass + lead)
#   Synth Pad
#       89 Pad 1 (new age)
#       90 Pad 2 (warm)
#       91 Pad 3 (polysynth)
#       92 Pad 4 (choir)
#       93 Pad 5 (bowed)
#       94 Pad 6 (metallic)
#       95 Pad 7 (halo)
#       96 Pad 8 (sweep)
#   Synth Effects
#       97 FX 1 (rain)
#       98 FX 2 (soundtrack)
#       99 FX 3 (crystal)
#       100 FX 4 (atmosphere)
#       101 FX 5 (brightness)
#       102 FX 6 (goblins)
#       103 FX 7 (echoes)
#       104 FX 8 (sci-fi)
#   Ethnic
#       105 Sitar
#       106 Banjo
#       107 Shamisen
#       108 Koto
#       109 Kalimba
#       110 Bag pipe
#       111 Fiddle
#       112 Shanai
#   Percussive
#       113 Tinkle Bell
#       114 Agogo
#       115 Steel Drums
#       116 Woodblock
#       117 Taiko Drum
#       118 Melodic Tom
#       119 Synth Drum
#       120 Reverse Cymbal
#   Sound effects
#       121 Guitar Fret Noise
#       122 Breath Noise
#       123 Seashore
#       124 Bird Tweet
#       125 Telephone Ring
#       126 Helicopter
#       127 Applause
#       128 Gunshot
#-----------------------------------------------------------------------------
# timidity      000_Acoustic_Grand_Piano.pat
# timidity      001_Acoustic_Brite_Piano.pat
# timidity      002_Electric_Grand_Piano.pat
# timidity      004_Electric_Piano_1_Rhodes.pat
# timidity      005_Electric_Piano_2_Chorused_Yamaha_DX.pat
# timidity      006_Harpsichord.pat
# timidity      007_Clavinet.pat
# timidity      008_Celesta.pat
# timidity      009_Glockenspiel.pat
# timidity      013_Xylophone.pat
# timidity      014_Tubular_Bells.pat
# timidity      015_Dulcimer.pat
# timidity      016_Hammond_Organ.pat
# timidity      019_Church_Organ.pat
# timidity      021_Accordion.pat
# timidity      023_Tango_Accordion.pat
# timidity      024_Nylon_Guitar.pat
# timidity      025_Steel_Guitar.pat
# timidity      026_Jazz_Guitar.pat
# timidity      027_Clean_Electric_Guitar.pat
# timidity      028_Muted_Electric_Guitar.pat
# timidity      029_Overdriven_Guitar.pat
# timidity      030_Distortion_Guitar.pat
# timidity      032_Acoustic_Bass.pat
# timidity      033_Finger_Bass.pat
# timidity      034_Pick_Bass.pat
# timidity      035_Fretless_Bass.pat
# timidity      036_Slap_Bass_1.pat
# timidity      037_Slap_Bass_2.pat
# timidity      038_Synth_Bass_1.pat
# timidity      040_Violin.pat
# timidity      042_Cello.pat
# timidity      044_Tremolo_Strings.pat
# timidity      045_Pizzicato_Strings.pat
# timidity      046_Harp.pat
# timidity      047_Timpani.pat
# timidity      048_String_Ensemble_1_Marcato.pat
# timidity      053_Voice_Oohs.pat
# timidity      056_Trumpet.pat
# timidity      057_Trombone.pat
# timidity      058_Tuba.pat
# timidity      059_Muted_Trumpet.pat
# timidity      060_French_Horn.pat
# timidity      061_Brass_Section.pat
# timidity      064_Soprano_Sax.pat
# timidity      065_Alto_Sax.pat
# timidity      066_Tenor_Sax.pat
# timidity      067_Baritone_Sax.pat
# timidity      068_Oboe.pat
# timidity      069_English_Horn.pat
# timidity      070_Bassoon.pat
# timidity      071_Clarinet.pat
# timidity      072_Piccolo.pat
# timidity      073_Flute.pat
# timidity      074_Recorder.pat
# timidity      075_Pan_Flute.pat
# timidity      076_Bottle_Blow.pat
# timidity      079_Ocarina.pat
# timidity      080_Square_Wave.pat
# timidity      084_Charang.pat
# timidity      088_New_Age.pat
# timidity      094_Halo_Pad.pat
# timidity      095_Sweep_Pad.pat
# timidity      098_Crystal.pat
# timidity      101_Goblins--Unicorn.pat
# timidity      102_Echo_Voice.pat
# timidity      104_Sitar.pat
# timidity      114_Steel_Drums.pat
# timidity      115_Wood_Block.pat
# timidity      120_Guitar_Fret_Noise.pat
# timidity      122_Seashore.pat
# timidity      125_Helicopter.pat
#-----------------------------------------------------------------------------
# CC values have a range from 0-127, from minimum to maximum value. However, some parameters are (on/off), where 0 to 63 = Off, 64 to 127 = On.
# Most Common Parameters:
#     1 = Modulation wheel
#     2 = Breath Control
#     7 = Volume
#     10 = Pan
#     11 = Expression
#     64 = Sustain Pedal (on/off)
#     65 = Portamento (on/off)
#     71 = Resonance (filter)
#     74 = Frequency Cutoff (filter)
#
# NOTE: There is no standard CC value for Vibrato Amount or Vibrato Speed. Sometimes you can assign them (and other CC mappings) yourself in the software instrument you use.
# Complete List:
#     0 Bank Select (MSB)
#     1 Modulation Wheel
# x   2 Breath controller
# x   3 = Undefined
# x   4 Foot Pedal (MSB)
#     5 Portamento Time (MSB)
#     6 Data Entry (MSB)
#     7 Volume (MSB)
# x   8 Balance (MSB
#     9 = Undefined
#     10 Pan position (MSB)
#     11 Expression (MSB)
# x   12 Effect Control 1 (MSB)
# x   13 Effect Control 2 (MSB)
# x   14 = Undefined
# x   15 = Undefined
# x   16-19 = General Purpose
# x   20-31 = Undefined
# x   32-63 = Controller 0-31
#     64 Hold Pedal (on/off)
#     65 Portamento (on/off)
#     66 Sostenuto Pedal (on/off)
#     67 Soft Pedal (on/off)
#     68 Legato Pedal (on/off)
# x   69 Hold 2 Pedal (on/off)
# x   70 Sound Variation
# x   71 Resonance (Timbre)
# x   72 Sound Release Time
# x   73 Sound Attack Time
# x   74 Frequency Cutoff (Brightness)
# x   75 Sound Control 6
# x   76 Sound Control 7
# x   77 Sound Control 8
# x   78 Sound Control 9
# x   79 Sound Control 10
# x   80 Decay or General Purpose Button 1 (on/off) Roland Tone level 1
# x   81 Hi Pass Filter Frequency or General Purpose Button 2 (on/off) Roland Tone level 2
# x   82 General Purpose Button 3 (on/off) Roland Tone level 3
# x   83 General Purpose Button 4 (on/off) Roland Tone level 4
#     84 Portamento Amount
# x   85-90 = Undefined
#     91 Reverb Level
# x   92 Tremolo Level
#     93 Chorus Level
# x   94 Detune Level
# x   95 Phaser Level
# x   96 Data Button increment
# x   97 Data Button decrement
#     98 Non-registered Parameter (LSB)
#     99 Non-registered Parameter (MSB)
#     100 Registered Parameter (LSB)
#     101 Registered Parameter (MSB)
# x   102-119 = Undefined
#     120 All Sound Off
#     121 All Controllers Off
# x   122 Local Keyboard (on/off)
#     123 All Notes Off
#     124 Omni Mode Off
#     125 Omni Mode On
#     126 Mono Operation
#     127 Poly Mode
#-----------------------------------------------------------------------------
