part= 1, block=c --------------------------- allocation
     20  *
     21  *allocation of storage and common
     22  *
     23  * storage:
     24  *       512 words for input file buffer
     25  *        (the rest is used in macro expansion)
     26  *
     27  * temporary common:
     28  *       960 words of binary
     29  *       512 words for the 4 note buffers
     30  *       20 words of random junk
     31  *       500 words of goto/measure buffers
     32  *       136 words of command/macro name table
     33  *       2413 words of macro stuff
     34  *       100 words of putd stuff
     35  *       everything else is macro and putd text
     36  *
     37  * normal layout of nc vars:
     38  *       nc1: start of note buffers
     39  *       nc513: start of junk
     40  *       nc533: start of measure buffers
     41  *       nc1033: start of command table
     42  *       nc1169: some piece of the binary, as much as fits
     43  *
     44  * at some times, this is unloaded and -stoload- or -comload-
     45  * on some other segment is done. In that case, return to
     46  * the main loop is through entry point 'reload' rather
     47  * than 'ml' ('ml' assumes the default comload is in
     48  * effect)
part= 1, block=d --------------------------- d- student
     49  define  student
     50          s.stud  = 2
     51          s.his   = s.stud
     52          l.his   = 9     $$ number of "his" variables
     53            array,m(l.his)=v(s.his)
     54          m1      = v(s.his)
     55          m2      = v(s.his+1)
     56          m3      = v(s.his+2)
     57          m4      = v(s.his+3)
     58          m5      = v(s.his+4)
     59          m6      = v(s.his+5)
     60          m7      = v(s.his+6)
     61          m8      = v(s.his+7)
     62          m9      = v(s.his+8)
     63          stac    = n(s.his+l.his)
     64          pause   = n(s.his+l.his+1)
     65          grace   = nc514
     66  *****   ... beware!! is defined below and must match!!!
                 WWW                                            
     67  *    lthwhol must be the same as sths60 in define set music
     68          lthwhol = n(s.his+l.his+2)
     69          frames  = lthwhol
     70  *
     71          l.stud  = l.his+3
     72  *
     73          s=(1),d=(1),b=(1),t=(1)
     74  ** d (dotted) modifier handled specially in unit "time"
     75          w=1,h=2,q=4,e=8,th=+0
     76          freq(.) = 968000/.
                      a           a
     77          nearest(.)      = round[ln(./27.5)*12/0.693147]
                         a                  a                   
     78          x       = n140 $$ =mtemp, used in goto but didnt work
     79          work    = n141, vwork   = v141
     80          work1   = n142, vwork1  = v142
     81          work2   = n143, vwork2  = v143
     82          work3   = n144, vwork3  = v144
     83          work4   = n145
     84          temp    = n146, vtemp   = v146
     85          temp1   = n147, vtemp1  = v147
     86          temp2   = n148
     87          temp3   = n149
     88          temp4   = n150
     89  define  music
part= 1, block=e --------------------------- defines
     90  *
     91  define  music
     92          blklth  = 322   $$ length of a disk block
     93          m29     = o37 7777 7777
     94          m30     = o77 7777 7777
     95          top1    = o4000 0000 0000 0000 0000
     96          rest    = 1     $$ value of rest
     97          gswlth  = 1288  $$ storage for gswaids (JT 9/7/76)
     98  *
     99          linemx  = 165   $$ location to show line number
    100          linemy  = 512-16 $$ y loc of above
    101          kmask   = -o7777
    102          na      = 10
    103          nas     = 11
    104          nb      = 12
    105          nc      = 1
    106          ncs     = 2
    107          nd      = 3
    108          nds     = 4
    109          ne      = 5
    110          nf      = 6
    111          nfs     = 7
    112          ng      = 8
    113          ngs     = 9
    114  *
    115          crystal = 3872000
    116          freq(.) = (crystal/.-2)/4
                      a             a     
    117  *       . = beats/min ; . = 1/note (4=quarter)
                 a               b                     
    118  *
    119  * the parameter below determines the timing. it must
    120  * be changed  if the Plato ouput rate changes. the
    121  * value of "framlth" is the number of plato output
    122  * frames per second.
    123  *
    124  *        framlth=60              $$ frames per second
    125          framlth=60*(20/21)      $$ frames per second
    126          tempo(.,.)      = 60*framlth*.*[1./.]
                       a b                    b     a 
    127          min2(.,.)       = (.+.-abs(.-.))/2      $$ by Dan Sleator
                      a b           a b     a b                           
    128          min4(.,.,.,.)   = min2(min2(.,.),min2(.,.))
                      l a b d                l a       b d  
    129          max2(.,.)       = (.+.+abs(.-.))/2      $$ note, no < or > ops
                      a b           a b     a b                                
    130          max4(.,.,.,.)   = max2(max2(.,.),max2(.,.))
                      l a b d                l a       b d  
    131          count(.)        = [.=0]+10-int[(bitcnt(.$diff$(.-1))-1)/6]
                       a            a                   a       a          
    132          lobit(.)        = bitcnt(. $diff$ (.-1))
                       a                  a         a    
    133          busysys         = (tactive>350)
    134  *
    135  *
    136          mtemp   = n140  $$ my temp!
    137          work    = n141, vwork   = v141
    138          work1   = n142, vwork1  = v142
    139          work2   = n143, vwork2  = v143
    140          work3   = n144, vwork3  = v144
    141          work4   = n145
    142          temp    = n146, vtemp   = v146
    143          temp1   = n147, vtemp1  = v147
    144          temp2   = n148
    145          temp3   = n149
    146          temp4   = n150
    147  *
    148          file    = n1    $$ dataset name
    149          authcde = n2    $$ authoring code
    150          blknum  = n3    $$ block number (=-1 if wasnt in blk)
    151  *
    152          bitmap=nc1              $$ defines free blocks
    153          used(.)=nc(.+1)         $$ non-0 if in use
                      a     a                              
    154          myblox(.)=nc(.+100)     $$ what blocks allocated
                        a     a                                  
    155          filenam(.)=nc(.+200)    $$ file name for song
                         a     a                              
    156          code(.)=nc(.+300)       $$ dedit codeword
                      a     a                             
    157          s.disk=1                $$ start of disk i/o buffer
    158          l.disk=zwpr $$ its length
    159  *
part= 1, block=f --------------------------- define1
    160  *
    161  * common layout below
    162          s.bin   = 1     $$ start of binary in common
    163          s.binsg = 16    $$ start of binary segments in common
    164  *  ncbin is the starting position of the binary in nc vars.
    165          ncbin = 1+512+20+500+137
    166  * note that the numbers above MUST match the values of
    167  * l.buffs, l.junk,  l.meas and l.comnd; if any of those is
    168  * changed, you must also change this define...
    169          l.binsg=1501-ncbin      $$ space left for binary
    170          nambin  = nc1           $$ binary name
    171          title   = nc3           $$ start of title
    172          binsegs = nc(ncbin)     $$ start of actual binary
    173            segment,  buffer = binsegs,7  $$ binary segments
    174          l.bin   = 960           $$ maximum length of a binary
    175          maxbin  = (l.bin-16)*8  $$ max number of bytes
    176  *
    177  *
    178          s.buffs = s.bin+l.bin   $$ start of buffers in common
    179          s.comm = s.buffs        $$ start of default -comload-
    180          ncbuff = 1      $$ nc position into which to comload
    181          blth    = 128   $$ (2**7...)
                                         XXX 
    182          bufs(.,.)       = nc(-blth+(.*blth)+.)
                      a b                    a       b 
    183          buf1(.) = nc(.)
                      a       a 
    184          buf2(.) = nc(blth+.)
                      a            a 
    185          buf3(.) = nc(2*blth+.)
                      a              a 
    186          buf4(.) = nc(3*blth+.)
                      a              a 
    187          l.buffs = 4*blth
    188  *
    189          s.junk  = s.buffs+l.buffs       $$ start of junk
    190          l.junk  = 20                    $$ length of it
    191          ncjunk  = ncbuff+l.buffs        $$ nc pos of junk
    192  *
    193          s.meas  = s.junk+l.junk         $$ start of measures
    194          ncmeas  = ncjunk+l.junk         $$ nc pos of measures
    195          meas(.) = nc(ncmeas-1+.)
                      a                a 
    196          l.meas  = 500   $$ length of measure tables
    197  *       NOTE: goto references are stored here too!
    198  *
    199          s.comnd = s.meas+l.meas
    200          nccomn = ncmeas+l.meas        $$ nc pos of commands
    201          command(.) = nc(nccomn-1+.)    $$ command table
                         a                a                     
    202          setcmd(.,.)     = command(work1-work1+1)-(.$union$(work2-work2+.))
                        a b                     <        < a             <      b  
    203          l.comnd = 137   $$ extra room for macros and -copy-
    204  *
    205          l.comm=l.buffs+l.junk+l.meas+l.comnd   $$ length for default -comload-
    206  *
    207          s.macro = s.comnd+l.comnd
    208          maxmac  = 75    $$ number of macros(max of 87!)
    209          maxmarg = 16    $$ number of arguments per macro
    210          segmentv,macpos=nc1,1,20
    211          segmentv,maclen=nc1,21,20
    212          segmentv,macargs=nc1,41,20
    213          macsub(.,.)     = nc(maxmac+(.-1)*maxmarg+.)    $$ macsub(macnum,argnum)  the dummy arguments
                        a b                   a            b                                                  
    214          l.macro = maxmac+maxmac*maxmarg+maxmarg
    215  *
    216          s.putd  = s.macro+l.macro       $$ putd area
    217          maxputs = 50    $$ max number of putds
    218          putname(.)      = nc(.) $$ arg 1
                         a            a          
    219          putstuf(.)      = nc(maxputs+.) $$ pointer to arg 2
                         a                    a                     
    220          l.putd  = 2*maxputs     $$ putd length
    221  *
    222          s.text  = s.putd+l.putd
    223          text(.) = nc(.) $$ macro and putd text
                      a       a                        
    224          l.text  = lcommon-s.text
    225  *
part= 1, block=g --------------------------- stud. vars
    226  *
    227  * student defines
    228  *       Note: temp-temp4, work-work4 are n141-n150.
    229  *               they are previously defined
    230  *
    231  * n1 reserved.
    232          s.stud  = 2
    233  *
    234          s.his   = s.stud
    235          l.his   = 9     $$ number of "his" variables
    236            array,hisvar(l.his)=v(s.his)
    237          lstac   = n(s.his+l.his)
    238          lpause  = n(s.his+l.his+1)
    239          sths60  = n(s.his+l.his+2)
    240          l.stud  = l.his+3
    241  *
    242          s.line  = s.stud+l.stud $$ where line is put for processing
    243          l(.)    = n(s.line-1+.)
                   a                  a 
    244          line    = l(1)
    245          comfld  = line $mask$ -o7777
    246            segment, char = line,6
    247              nxt3(.) = (char(.) $cls$ 12) $union$ (char(.+1) $cls$ 6) $union$ char(.+2)
                          a          a                          a                          a   
    248          l.line  = 20    $$ max length of a line
    249  *
    250          s.keys  = s.line+l.line
    251          keys(.) = n(s.keys+.)
                      a             a 
    252          setkey(.,.)     = keys(work1-work1+1)-. $union$ (.+(.$cls$6))
                        a b                  <        <a          b  b        
    253          l.keys  = 36    $$ number of keys+even.
    254  *
    255  *
    256          s.vars  = s.keys+l.keys
    257  *
    258          lstname = n(s.vars)     $$ last block name
    259          measlth = n(s.vars+1)
    260            segment,mlth = measlth,15
    261          block   = n(s.vars+2)
    262          linenum = n(s.vars+3)
    263          word    = n(s.vars+4)
    264          blox    = n(s.vars+5)
    265          blox2   = n(s.vars+6)
    266          lthleft = n(s.vars+7)
    267          ncomnd  = n(s.vars+8)
    268          strtstp = n(s.vars+9)
    269          measure = v(s.vars+10)
    270          cis     = n(s.vars+11)
    271          vol     = n(s.vars+12)
    272            segment,vo  = vol,3
    273              vl(.)   = vo(2+.)
                        a           a 
    274              numvoc  = vo(1)
    275          maxtofx    = n(s.vars+13)
    276            segment,maxt = maxtofx,15,s
    277          tofx    = n(s.vars+14)
    278            segment,t = tofx,15,s
    279          segment,oct = n(s.vars+15),7
    280            time(.) = oct(.+4)
                        a        a   
    281          segment,ts = n(s.vars+16),15,s  $$ #or 60ths/voice
    282          mat     = n(s.vars+17)  $$ #measures.
    283          ngoto   = n(s.vars+18)  $$ number of gotos
    284          binpt   = n(s.vars+19)  $$ binary pointer
    285          tbinpt  = n(s.vars+20)  $$ temp. binary pointer
    286          errloc  = n(s.vars+21)
    287          length  = n(s.vars+22)  $$ length of line in characters
    288          pnt     = n(s.vars+23)  $$ pointer used to move through line
    289  *continued in next block
part= 2, block=a --------------------------- stud. vars
    290  *continued from previous block
    291          errlth  = n(s.vars+24)  $$ length of error message
    292          argindx = n(s.vars+25)
    293          onearg  = n(s.vars+26)  $$ is it one arg or not?
    294          onvoice = n(s.vars+27)  $$ voice working on
    295          timey   = v(s.vars+28)  $$ time started
    296          vproc   = v(s.vars+29)  $$ proctim started
    297          xstopx  = n(s.vars+30)  $$ stop command number
    298          xmacrox = n(s.vars+31)
    299          xifx    = n(s.vars+32)
    300          putdnum = n(s.vars+33)  $$ number of putds
    301          textusd = n(s.vars+34)  $$ #word of text used!
    302          iftest  = n(s.vars+35)  $$ are you after if or else
    303          ifdepth = n(s.vars+36)  $$ depth of if nest
    304          titlect = n(s.vars+37)  $$ title pointer
    305          macnum  = n(s.vars+38)  $$ number of macros
    306          binoff  = n(s.vars+39)  $$ binary load offset
    307          Binpt   = binpt + 8*binoff  $$ actual binary pos
    308          Tbinpt  = tbinpt + 8*binoff $$ similar
    309            inbin(.) = buffer[({[Tbinpt+1]=maxbin}2+1)\(tbinpt-tbinpt+1)]-.
                         a                                   /       <          <a
    310  *
    311          limit   = 64
    312  *** if there are this many words left in the binary
    313  *** buffer, it is time to change the loading. Reasoning:
    314  *** each entry in the note buffer can generate at most
    315  *** 8 binary bytes (the 'cis', 4 voices, the 'delay', amount)
    316  *** and there are 64 entries per buffer.
    317          reload = (l.binsg - limit)*8
    318  *** if tbinpt passes this limit, change the loading
    319  *note maxmarg=16
    320          macputs(.)      = n(s.vars+39+.)        $$ temp. buffers for macro arguments(maxmarg long)
                         a                     a                                                           
    321          users(.)=macputs(.)     $$ abuse buffer for queue
                       a          a                               
    322          np      = macputs(13)    $$ number of ('s
    323          quotes  = macputs(14)    $$ ?
    324          quotes1 = macputs(15)
    325  *
    326          errors  = macputs(1)
    327            segment,err = errors,6
    328          l.error = 10    $$ no more than 10 words available
    329          l.vars  = 39+maxmarg
    330  *
part= 2, block=b --------------------------- stud. vars
    331  *
    332          s.args  = s.vars+l.vars
    333          arglis1(.)      = n(.+s.args-1)
                         a           a          
    334            segment,vertical,arglist = arglis1(1),31,30
    335            segment,vertical,lth = arglis1(1),1,30
    336          l.args  = 16
    337  *
    338          s.temps = s.args+l.args
    339          l.temps = 9
    340          erchk   = n(s.temps+l.temps)
    341  *
    342  *** extra stuff that did not fit in student vars:
    343          lthline = nc(ncjunk)    $$ real linelength in words
    344          lgrace  = nc(ncjunk+1)  $$ in student defines also!!
    345          shortst = nc(ncjunk+2)  $$ shortest legal note
    346          debug   = nc(ncjunk+3)  $$ debugging flag
    347  ***
    348  *
part= 2, block=c --------------------------- entry
    349  *
    350  ***   ieu
    351  *
    352  from    temp;musicomp;mcmp;nmusicomp;nmcmp;
    353  if      temp
    354  .       jumpout musicomp
    355  endif
    356  group   temp
    357  if      temp='musician'
    358  .       pause   .75,keys=next,term
    359  endif
    360  calc    erchk-(zlesson/'mcmp')          $$ see who we are
                      <        =                                  
    361          lstname-n1              $$ get songname
                        <                               
    362          blox-blox2-n2           $$ and block map
                     <     <                             
    363  finish  leave                   $$ to clean up dataset
    364  imain   erchk,*,q
    365  jump    ieuer
    366  *
                                                                                                             ieuer
    367  unit    ieuer
    368  back    outless
    369  do      clear
    370  common  8050,no load
    371  storage gswlth          $$ NOTE: must be _ 2*blklth!!
                                                  >           
    372  do      queuer          $$ enter the "compile q"
    373  *
    374  do      initial                 $$ initializations
    375  do      getfile                 $$ attach input file
    376  jump    backfore                $$ go into answer state
    377  *
                                                                                                             outless
    378  unit    outless
    379  do      mustclr
    380  jumpout
    381  *
                                                                                                             mustclr
    382  unit    mustclr $$ clear busy
    383  release records,1,1
    384  release common
    385  *
                                                                                                             gswaidgo
    386  unit    gswaidgo
    387  do      mustclr
    388  jumpout gswaids
    389  jumpout
    390  *
                                                                                                             iferrs
    391  unit    iferrs
    392  iferror truncbin
    393  *
                                                                                                             erase
    394  unit    erase
    395  erase   abort
    396  do      erchk,*,x
    397  *
                                                                                                             *
    398  unit    *
    399  at      164
    400  write   *
    401  *
                                                                                                             getfile
    402  unit    getfile
    403  attach  mcmpdata,-1 $$ attach the dataset
    404  jump    zreturn,x,ioerror('dataset',0)
    405  do      getblock                $$ get the first block
    406  *
                                                                                                             new
    407  unit    new
    408  termop  new
    409  jumpout nmcmp
    410  *
                                                                                                             queuer
    411  unit    queuer                  $$ "compile queue"
    412  reserve common                  $$ try to set the lock
    413  goto    zreturn,q,x             $$ did it!
    414  if      busysys
    415  .       foregnd
    416  else
    417  .       backgnd
    418  endif
    419  calc    temp1-0                 $$ number of others
                      <                                     
    420          temp--1                 $$ station number
                     <                                    
    421  *
    422  *   note that the -loop- below should run as a critical
    423  *   section but does not. this could cause race conditions,
    424  *   so we use the -reserve common- as a lock
    425  *
    426  loop    temp1<usersin-1         $$ find all other users
    427  .       in      temp-temp+1     $$ this guy in?
                             <                          
    428  .       if      zreturn $and$ temp/station      $$ yep
                                           =                   
    429  .       .       calc    users(temp1-temp1+1)-temp
                                            <        <    
    430  .       endif
    431  endloop
    432  loop    temp1>0                 $$ as long as others are in
    433  .       erase   abort
    434  .       at      1010
    435  .       write   Waiting to compile
    436  .
    437  .               Position in queue = <s,temp1> of <s,usersin-1>
                                             (       )    (           )
    438  .       pause   3,keys=funct
    439  .       reserve common          $$ set the lock
    440  outloop zreturn                 $$ success..
    441  .       doto    1,temp2-1,temp1
                                <       
    442  .       in      users(temp2)    $$ this character still in?
    443  .       if      zreturn=0       $$ if not
    444  .       .       deletes users(1);temp1,1,temp2
    445  .       .       calc    temp1-temp1-1
                                      <       
    446  .       endif
    447  .       1
    448  endloop
    449  foregnd
    450  *
part= 2, block=d --------------------------- here
                                                                                                             backfore
    451  unit    backfore        $$ choose backgnd or foregnd
    452  ** ask user if he wants foregnd or backgnd  (JT&M4 6/7/76)
    453  ** default for NEXT             (PK 10/31/76)
    454  back    q
    455  back1   q               $$ disable branching keys
    456  at      1010
    457  write   Press  b for backgnd,  f for foregnd.
    458
    459          Number of users on = <t,tactive,3>.
                                      (           ) 
    460  arrow   1610
    461  long    1
    462  match   temp,f,b
    463  calcc   temp,temp--not(busysys),,
                          <               
    464  do      erase
    465  mode    write
    466  at      101
    467  if      temp=0
    468  .       write   F<t,tactive,3>
                          (           )
    469  .       foregnd
    470  else
    471  .       backgnd
    472  .       write   B<t,tactive,3>
                          (           )
    473  endif
    474  *
    475  *
                                                                                                   here
    476  entry   here
    477  imain   erchk,*,iferrs
    478  do      erchk,x,iferrs  $$ since imain unit not executed yet
    479  mode    rewrite
    480  calc    timey-clock
                      <     
    481          vproc-proctim
                      <       
    482  at      linemx-8*16,linemy
    483  write   Compiling line#      for song <a,lstname>
                                               (         )
    484  mode    rewrite
    485  at      linemx-8*16+41*8,linemy
    486  write   measure# <s,measure>
                          (         )
    487  calc    errloc-512-16*2
                       <        
    488  mode    rewrite
    489  *
    490  *   enter here to reload common in the normal fashion
    491  *
                                                                                                   reload
    492  entry   reload
    493  comload nc(ncbuff),s.comm,l.comm
    494          binsegs,s.binsg+binoff,l.binsg
    495  *
                                                                                                   ml
    496  entry   ml
    497  1loop
    498  0loop
    499  branch  key-stop,x,9done,x
    500  if      tbinpt>reload           $$ binary buffer close to full?
    501  .       goto    remap           $$ yes, change binary mapping
    502  endif
    503  branch  lthleft-1,1nextbk,x
    504  transfr s,word;line;min2(l.line,lthleft)  $$ get next line
    505  at      linemx,linemy
    506  show    linenum+1
    507  calc    work-0  $$ length of line:  decrement lthleft
                     <                                        
    508  branch  (line $mask$ o7777)-1,1found,x
    509  calc    work-1
                     < 
    510  branch  (l(2) $mask$ o7777)-1,1found,x
    511  calc    work-2
                     < 
    512  branch  (l(3) $mask$ o7777)-1,1found,x
    513  find    0,l(4),l.line-3,work,1,o7777
    514  branch  work,1nextbk,x
    515  calc    work-work+3
                     <      
    516  1found
    517  calc    word-word+(work-work+1)
                     <          <       
    518          lthline-work            $$ save line length
                        <                                   
    519          lthleft-lthleft-work
                        <            
    520          linenum-linenum+1
                        <         
    521  branch  char(1)-"*",x,0loop,x  $$ if comment ignore
    522  search  0,1,line,10*work,1,length
    523  branch  length-length-1,0loop,x
                       <                
    524  search  o5353 0000 0000 0000 0000,2,line,length,1,work
    525  0rescan                 $$ here to rescan the line
    526  branch  work,0end,x
    527  if      work<9
    528  .       move    '        ',1,line,work,(9-work)
    529  .       calc    work-9
                             < 
    530  endif
    531  calc    length-work-1
                       <      
    532  calc    char(work)-0
                           < 
    533  doto    1end,length-length,9,-1
                            <           
    534  branch  char(length)-o55,0end,x,0end
    535  calc    char(length)-0
                             < 
    536  1end
    537  0end
    538  branch  line-'        ',x,0loop,x
    539  *
    540  if      char(1)="="
    541  .       do      putdgo
    542  endif
    543  *
    544  find    comfld,command(1),ncomnd,work,1,-o7777 $$ command?
    545  *
    546  * continued --
part= 2, block=e --------------------------- compile
    547  *
    548  calc    work2--1        $$ not a command
                      <                          
    549  if      work>-1
    550  .       calc    work2-command(work+1)$mask$o7777        $$ command code
                              <                                                 
    551  .       branch  work2-xstopx,x,9done,x $$ process stop* always
    552  endif
    553  branch  strtstp,x,2start  $$ check start/stop flag
    554  *
    555  branch  iftest,x,1false  $$ check if/endif flag
    556  *
    557  * process stop/start commands
    558  * and else/endif commands in TRUE contingent
    559  * in this unit without doing the arglist.
    560  branch  work2-xstopx,x,9done,2stop,1loop,x      $$ stop*,stop,start
    561  branch  work2-xifx,x,x,2else,2endif,2indent,x   $$ if,else,endif,indent
    562  *
    563  calc    binpt-tbinpt  $$ save new binary pointer
                      <                                  
    564  *
    565  goto    work,notego,x, $$ if not command/macro then...
    566  calc    pnt-8
                    < 
    567  do      arglist  $$ separate arguments for argument
    568  *
    569  goto    work2,x,tempo,calc,pitch,randu,slide,goto,voice,
    570          vol,cis,percus,temper,change,copy,measure,randp,
    571          setperm,key,sharp,flat,natural,
    572          marker,delay,endm,putd,x,x,x,if,x,x,x,decode,title,
    573          debugit,macro,macrosub  $$ macro always at end, uses ending commands for subsitution
    574  write   error, error, error
    575  pause   keys=all
    576  iferror
    577  zero    nc(n150-'bomboff')
                        <          
    578  *
    579  1nextbk
    580  do      getblock
    581  goto    reload          $$ reload the normal thingies
    582  9done
    583  goto    done
    584  *
    585  2start
    586  branch  work2-xstopx,1loop,9done,2stop,x,1loop  $$ start command
    587  calc    strtstp--1
                        <  
    588  branch  1loop   $$ now start doing something
    589  2stop
    590  calc    strtstp-0
                        < 
    591  branch  1loop   $$ stop compiling lines
    592  *
    593  2else
    594  calc    iftest-not(iftest)
                       <           
    595  branch  1loop
    596  2endif
    597  calc    iftest--1
                       <  
    598  branch  1loop
    599  *
    600  2indent
    601  move    line,9,line,1,length-8
    602  calc    work-length-7
                     <        
    603  branch  0rescan
    604  *
    605  1false
    606  * process stop/if/else/endif commands in FALSE contingent
    607  branch  work2-xstopx,x,9done,2stop,1loop,x
    608  branch  work2-xifx,1loop,3if,x,x,1loop  $$ if,else,endif
    609  branch  ifdepth-1,x,4nest       $$ is it a nested command?
    610  calcs   work2-xifx-2,iftest-not(iftest),-1 $$ else/endif
                                    <                            
    611  branch  1loop
    612  3if
    613  calc    ifdepth-ifdepth+1 $$ depth in if commands
                        <                                 
    614  branch  1loop
    615  *
    616  4nest
    617  branch  work2-xifx-2,1loop,x,1loop      $$ look for endif
    618  calc    ifdepth-ifdepth-1
                        <         
    619  branch  1loop   $$ go back and skip some more commands
    620  *
part= 2, block=f --------------------------- compile 1
    621  *
                                                                                                             notego
    622  unit    notego
    623  calc    pnt-0
                    < 
    624  do      arglist $$ separate arguments for argument
    625  branch  cis>0 $and$ argindx=0 $and$ onearg=1,1doto,x        $$ if in count inhibit mode
    626  branch  numvoc-argindx,1tomany,x
    627  branch  onearg-1,x,1doto
    628  goto    toofew(numvoc+1)
    629  1tomany
    630  goto    toomany(numvoc+1)
    631  *
    632  1doto
    633  calc    work3--1                $$ longest chunk
                      <                                  
    634  doto    8,work4-cis+1,numvoc+1  $$ align notes
                        <                              
    635  if      lth(work4)>0
    636  .       if      work3-ts(work4)
    637  .       .       calc    work3-ts(work4)
                                      <         
    638  .       endif
    639  endif
    640  8
    641  doto    9,work4-cis+1,numvoc+1
                        <              
    642  if      lth(work4)>0
    643  .       if      ts(work4)-work3
    644  .       .       do      instak(work4,1,work3-ts(work4))
    645  .       endif
    646  endif
    647  9
    648  *
    649  * decode and stack the notes
    650  doto    2loop,onvoice-cis,numvoc        $$ loop correct no. times
                              <                                           
    651  branch  (onvoice-cis)-argindx,x,x,2loop $$ allow too few args
    652  calc    temp1-1 $$ set for routine nextarg1
                      <                             
    653  if      onvoice>0
    654  .       calc    temp1-arglist(onvoice)+1        $$ set for nextarg1
                              <                                             
    655  endif
    656  do      note(onvoice+1) $$ get next note
    657  c  work1=computed value
    658  c  work2=  -2 gsw oprnd, -1 freq, 0 note, 1 trill, 2 sequence
    659  branch  work2-1,x,1trill,2seq
    660  branch  work1,x,2loop,x $$ do nothing if 0
    661  do      time    $$ get time
    662  c  work=computed length in 60ths
    663  c  work4=  -4 marcato, -2 tied, -1 stac, 0 normal
    664  c  bits are $union$'ed together for multiple modifiers
    665  if      work-1
    666  .       calc    work-time(onvoice+1)    $$ if not given, use old value
                             <                                                 
    667  endif
    668  calc    time(onvoice+1)-work
                                <    
    669  if      work2           $$ if gsw oprnd, output it
    670  .       calc    work1-work1$union$(1$cls$16)
                              <                      
    671  endif
    672  branch  work4+6,1ts,1tm,1stac,1marc,1ts,1tied,1stac,x
    673  do      instak(onvoice+1,work1,work)    $$ place on stack
    674  branch  2loop
    675  *
    676  1tied
    677  calc    work4-t(onvoice+1)-1    $$ add new length to old
                      <                                          
    678  branch  work4-1,1zappo,x        $$ check for something to tie to
    679  calc    bufs(onvoice+1,work4)-bufs(onvoice+1,work4)+work
                                      <                          
    680  calc    ts(onvoice+1)-ts(onvoice+1)+work
                              <                  
    681          mlth(onvoice+1)-mlth(onvoice+1)+work
                                <                    
    682  branch  2loop
    683  *
    684  1ts
    685  calc    work4-t(onvoice+1)-1    $$ like ties
                      <                              
    686  branch  work4-1,1zappo,x
    687  calc    bufs(onvoice+1,work4)-bufs(onvoice+1,work4)+lstac
                                      <                           
    688  calc    ts(onvoice+1)-ts(onvoice+1)+lstac
                              <                   
    689          mlth(onvoice+1)-mlth(onvoice+1)+lstac
                                <                     
    690  branch  2stac
    691  *
    692  1stac
    693  do      instak(onvoice+1,work1,lstac)
    694  2stac
    695  do      instak(onvoice+1,1,work-lstac)
    696  branch  2loop
    697  *
    698  1tm
    699  calc    work4-t(onvoice+1)-1    $$ like ties
                      <                              
    700  branch  work4-1,1zappo,x
    701  calc    bufs(onvoice+1,work4)-bufs(onvoice+1,work4)+(work-lpause)
                                      <                                   
    702  calc    ts(onvoice+1)-ts(onvoice+1)+(work-lpause)
                              <                           
    703          mlth(onvoice+1)-mlth(onvoice+1)+(work-lpause)
                                <                             
    704  branch  2marc
    705  ****  unit continued in next block  ****
part= 2, block=g --------------------------- compile 2
    706  * continued unit    notego
    707  1marc           $$ broken (=note separated from next)
    708  do      instak(onvoice+1,work1,work-lpause)
    709  2marc
    710  do      instak(onvoice+1,1,lpause)
    711  branch  2loop
    712  c  trills and frills....
    713  c
    714  1trill
    715  do      dotrill                 $$ damn unit length
    716  *
    717  2loop
    718  do      unstak
    719  goto    ml
    720  *
    721  2seq
    722  if      work-1
    723  .       calc    work-time(onvoice+1)    $$ if not given, use old value
                             <                                                 
    724  endif
    725  calc    time(onvoice+1)-work
                                <    
    726  calc    quotes1-work
                        <    
    727  3seq
    728  branch  quotes1-lgrace,2loop,x     $$ check for no time
    729  do      note1                     $$ get a note
    730  if      work2
    731  .       calc    work1-work1$union$(1$cls$16)
                              <                      
    732  endif           $$ gsw operand
    733  if      err(1)=","
    734  .       do      instak(onvoice+1,work1,lgrace)
    735  .       move    errors,2,errors,1,l.error*10-1
    736  .       calc    quotes1-quotes1-lgrace
                                <              
    737  .       branch  3seq
    738  elseif  err(1)=")"
    739  .       do      instak(onvoice+1,work1,quotes1)
    740  .       branch  2loop
    741  endif
    742  *
    743  2errs
    744  pack    errors,errlth, sequence is not legal
    745  goto    error
    746  1zappo
    747  pack    errors,errlth, nothing to tie to
    748  goto    error
    749  c
    750  c
    751  c
    752  c
                                                                                                             time
    753  unit    time    $$ compute time
    754  calc    work4-vwork-0
                      <     < 
    755  if      err(1)>"z"              $$ if not a note or modifier
    756  .       compute vwork,errors,errlth,work4
    757  .       if      formok>-1       $$ if error
    758  .       .       pack    errors,errlth,error <s,formok> in expression
                                                     (        )              
    759  .       .       goto    error
    760  .       endif
    761  endif
    762  if      formok
    763  .       if      bitcnt(vwork)>0
    764  .       .       if      err(1)="["
    765  .       .       .       calc    work-vwork
                                             <     
    766  .       .       else
    767  .       .       .       if      err(1)="("
    768  .       .       .       .       calc    vwork-(1./vwork)
                                                      <          
    769  .       .       .       endif
    770  .       .       .       calc    work-vwork
                                             <     
    771  .       .       .       if      work>shortst
    772  .       .       .       .       do      tiny
    773  .       .       .       endif
    774  .       .       .       calc    work-sths60/work
                                             <           
    775  .       .       endif
    776  .       endif
    777  else
    778  .       calc    work-0
                             < 
    779  endif
    780  if      errlth-1
    781  .       calc    errlth-1
                               < 
    782  endif
    783  calc    work4-0
                      < 
    784          errlth-errlth+1
                       <        
    785  99loop  temp4-err(errlth-errlth-1)
                      <          <         
    786          temp4-[temp4="s"]+2*[temp4="t"]+4*[temp4="b"]+8*[temp4="d"]
                      <                                                     
    787  if      temp4<0 $and$ temp4>-8
    788  .       calc    work4-work4 $union$ (-temp4)
                              <                      
    789  elseif  temp4=-8                $$ dotted?
    790  .       if      work $mask$ 1   $$ if rounding error
    791  .       .       do      tiny2
    792  .       endif
    793  .       calc    work-3*(work $ars$ 1)
                             <                
    794  endif
    795  branch  temp4<0 $and$ errlth>1,99loop,x  $$ get all modifiers
    796          work4--work4
                      <      
    797  *
part= 3, block=a --------------------------- compile 2a
    798  *
                                                                                                             tiny2
    799  unit    tiny2
    800  calc    temp3-errors
                      <      
    801          temp2-errlth            $$ save modifier info
                      <                                       
    802  pack    errors,errlth,note cannot be "dotted" accurately
    803  do      warning
    804  calc    errors-temp3
                       <     
    805          errlth-temp2
                       <     
    806  *
                                                                                                             tiny
    807  unit    tiny
    808  calc    temp3-errors
                      <      
    809          temp2-errlth            $$ save modifier info
                      <                                       
    810  pack    errors,errlth,note is too short
    811  do      warning
    812  calc    errors-temp3
                       <     
    813          errlth-temp2
                       <     
    814  *
                                                                                                             note
    815  unit    note(temp)
    816  do      nextarg1(temp)
    817  calc    work2-0
                      < 
    818  *
                                                                                                   note1
    819  entry   note1
    820  calc    temp3-1 $$ character pointer
                      <                      
    821          work1-0 $$ return error value
                      <                       
    822          work2-0 $$ return normal note
                      <                       
    823  branch  errors='0',1q,x
    824  branch  err(1)-1,1q,x   $$ 0=end of line
    825  branch  err(1)-"(",x,1tab,x     $$ table look up ( )
    826  branch  err(1)-"[",x,1freq,x    $$ frequency     [ ]
    827  branch  err(1)-o76,x,1gsw,x     $$ gsw oprnd     { }
    828  if      err(1)_"0" $and$ err(1)_"8"       $$ check octave
                       >                <                         
    829  .       calc    oct(temp)-err(1)-"0"    $$ save octave
                                  <                            
    830  .               temp3-temp3+1
                              <       
    831  endif
    832  calc    temp2-err(temp3)
                      <          
    833  branch  temp2-("g"+1),x,1rest   $$ note or rest
    834  calc    work-0
                     < 
    835          temp3-temp3+1
                      <       
    836          temp4-err(temp3)
                      <          
    837  branch  temp4="n",2find,x       $$ natural special
    838  branch  temp4="+"$or$temp4="-",x,1find  $$ check special note
    839  calc    work-temp4$cls$48
                     <            
    840          temp3-temp3+1
                      <       
    841          temp4-err(temp3+1)
                      <            
    842  branch  temp4="n",2find,x       $$ natural special
    843  branch  temp4="+"$or$temp4="-",x,3find  $$ check special note
    844  calc    work-temp4$cls$42
                     <            
    845  2find
    846  calc    temp3-temp3+1
                      <       
    847  3find
    848  calc    work-work$union$(temp2$cls$54)  $$ construct  d+
                     <                                           
    849  find    work,keys(1),l.keys-1,work,1,kmask     $$ no keys(0)='even'
    850  branch  work,1err,x
    851  calc    work1-(keys(work+1)$mask$o7700)$ars$6   $$ return table number
                      <                                                        
    852  branch  1calc
    853  1find
    854  calc    work-work$union$(temp2$cls$54)  $$ construct  d+
                     <                                           
    855  find    work,keys(1),l.keys-1,work,1,kmask     $$ no keys(0)='even'
    856  branch  work,1err,x
    857  calc    work1-keys(work+1)$mask$o77     $$ return table number
                      <                                                
    858  *
part= 3, block=b --------------------------- compile 3
    859  *
    860  1calc
    861  calc    work1-oct(temp)*12+work1+2      $$ calculate table #
                      <                                              
    862  *
    863  1time   $$ get ready for time computation
    864  move    errors,temp3,errors,1,10*l.error-temp3
    865  calc    errlth-errlth-temp3+1
                       <              
    866  1q
    867  goto    q
    868  *
    869  1err
    870  pack    errors,errlth, note is not legal
    871  calcs   temp>argindx,pnt-length,arglist(temp)
                                 <                    
    872  goto    error
    873  *
    874  1freq
    875  calc    work2--1        $$ set freq flag
                      <                          
    876  1tab
    877  calc    work3-1
                      < 
    878  c  must balance parens since note is followed by time
    879  c  [440]4
    880  doto    999,temp2-temp3+1,errlth        $$ balance parens
                          <                                       
    881  calc    work4-err(temp2)
                      <          
    882  branch  work4-"(",x,1left,1right,x
    883  branch  work4-"[",999,1left,1right,999
    884  1left
    885  calc    work3-work3+1   $$ count ('s
                      <                      
    886  branch  999
    887  1right
    888  calc    work3-work3-1   $$ subtract  )'s
                      <                          
    889  branch  work3-1,1comp,x
    890  999
    891  branch  1err
    892  1comp
    893  calc    temp3-temp2+1   $$ temp2 has last matched )
                      <                                     
    894          work1-0
                      < 
    895  compute work1,errors,temp2,work1        $$ get quantity
    896  if      formok>-1
    897  .       pack    errors,errlth,error <s,formok> in expression
                                             (        )              
    898  .       goto    error
    899  endif
    900  branch  work2+1,1time,x,1time   $$ if freq calculate it
    901  calc    work1-freq(work1)
                      <           
    902  branch  1time
    903  *
    904  1gsw
    905  branch  err(2)-"[",1err,x,1err
    906  calc    temp3-2
                      < 
    907          work2--2        $$ set gsw-opnd flag
                      <                              
    908  branch  1tab
    909  *
    910  1rest
    911  branch  err(1)-"s",x,1seq,1trill        $$ check for trill pr seqence
    912  calc    work1-1
                      < 
    913          temp3-temp3+1
                      <       
    914  branch  1time
    915  *
    916  1trill
    917  branch  err(1)-"t",1err,x,1err  $$ check for trill
    918  branch  err(2)-"(",1err,x,1err
    919  branch  work2-1,x,1err,x
    920  calc    work2-1 $$ set flag for trill
                      <                       
    921  branch  1q                      $$ leave unit
    922  *
    923  1seq
    924  if      err(2)/"("              $$ if time given
                       =                                 
    925  .       move    errors,2,errors,1,10*l.error-1
    926  .       search  '(',1,errors,l.error*10-1,1,errlth
    927  .       branch  errlth,1err,x
    928  .       calc    errlth-errlth-1 $$ ignore the (
                               <                        
    929  .       do      time            $$ get the time
    930  .       move    errors,errlth+2,errors,1,l.error*10-errlth-1
    931  else
    932  .       calc    work--1         $$ set flag for no time given
                             <                                        
    933  .       move    errors,3,errors,1,l.error*10-2
    934  endif
    935  calc    work2-2                 $$ set flag for sequence
                      <                                          
part= 3, block=c --------------------------- compile 4
                                                                                                             dotrill
    936  unit    dotrill
    937  move    errors,3,errors,1,10*l.error-2
    938  calc    errlth-errlth-2
                       <        
    939  do      note1
    940  branch  work1,x,2errs,x
    941  calc    quotes-work1-(1$cls$16)(work2=-2)       $$ 2**16 gsw opnd
                       <                                                  
    942  branch  err(1)-",",2errs,x,2errs
    943  move    errors,2,errors,1,10*l.error-1
    944  do      note1   $$ get second note
    945  branch  work1,x,2errs,x
    946  calc    quotes1-work1 -(1$cls$16)(work2=-2)     $$ 2**16
                        <                                        
    947  branch  err(1)-",",2errs,x,2errs
    948  move    errors,2,errors,1,10*l.error-1
    949  branch  (errlth-errlth-1)-2,2errs,x
                        <                   
    950  *
    951  calc    np-temp1-0
                   <     < 
    952  doto    1234,work4-1,errlth
                           <        
    953  branch  err(work4)-")",x,12345,x        $$ work4 has last paren
    954  1234
    955  branch  2errs
    956  12345
    957  compute np,errors,work4-1,temp1
    958  if      formok>-1
    959  .       pack    errors,errlth,error <s,formok> in expression
                                             (        )              
    960  .       goto    error
    961  endif
    962  branch  np,x,2errs,x
    963  move    errors,work4+1,errors,1,10*l.error-work4-1
    964  do      time    $$ get overall duration of the note
    965  branch  work4,2errs,x
    966  if      work-1
    967  .       calc    work-time(onvoice+1)
                             <               
    968  endif
    969  calc    time(onvoice+1)-work
                                <    
    970  calc    vwork-work/np
                      <       
    971  doto    5trill,work4-1,np       $$ stack the output
                             <                              
    972  branch  (work4$mask$1)-1,2nd,x
    973  do      instak(onvoice+1,quotes,vwork)
    974  branch  5trill
    975  2nd
    976  do      instak(onvoice+1,quotes1,vwork)
    977  5trill
    978  goto    q
    979  *
    980  2errs
    981  pack    errors,errlth, trill is not legal
    982  goto    error
part= 3, block=d --------------------------- stack 1
    983  *
                                                                                                             instak
    984  unit    instak(temp,temp1,temp2)
    985  branch  temp2-1,1q,x
    986  calc    ts(temp)-ts(temp)+temp2
                         <              
    987          mlth(temp)-mlth(temp)+temp2
                           <                
    988  branch  t(temp)-1,1not,x
    989  calc    temp4-bufs(temp,t(temp))
                      <                  
    990  branch  temp4=temp1 $and$ temp4/1,x,1not
                                        =        
    991  calc    temp4-t(temp)+4
                      <         
    992          bufs(temp,temp4-3)-lpause
                                   <      
    993          bufs(temp,temp4-2)-1
                                   < 
    994          bufs(temp,temp4-5)-bufs(temp,temp4-5)+lpause(bufs(temp,temp4-5)>lpause)
                                   <                                                    
    995  branch  1
    996  1not
    997  calc    temp4-t(temp)+2
                      <         
    998  1
    999  calc    bufs(temp,temp4)-temp1
                                 <     
   1000          bufs(temp,temp4-1)-temp2
                                   <     
   1001          t(temp)-temp4
                        <     
   1002  if      t(temp)>maxt(temp)
   1003  .       calc    maxt(temp)-t(temp)
                                   <       
   1004  .       if      t(temp)>blth
   1005  .       .       goto    toobad
   1006  .       endif
   1007  endif           $$ keeps maximum stack usage
   1008  1q
   1009  *
                                                                                                             emptystk
   1010  unit    emptystk
   1011  do      measchk
   1012  do      fillup          $$ make voices same length
   1013  calc    work-1
                     < 
   1014  do      unstak1
   1015  calc    measlth-0               $$ clear total
                        <                              
   1016  *
                                                                                                             measdone
   1017  unit    measdone
   1018  c  similar to emptystk, but allows tied notes
   1019  c  across measure boundaries
   1020  do      measchk         $$ check this measure
   1021  do      fillup
   1022  do      unstak  $$ make sure all nice and simple
   1023  calc    measlth-0               $$ clear total
                        <                              
   1024  *
                                                                                                             fillup
   1025  unit    fillup
   1026  calc    work1-0
                      < 
   1027  doto    1,work-cis+1,numvoc+1
                       <              
   1028  if      work1-ts(work)
   1029  .       calc    work1-ts(work)
                              <        
   1030  endif
   1031  1
   1032  * now we know which voice was longest
   1033  doto    2,work-cis+1,numvoc+1
                       <              
   1034  if      ts(work)-work1          $$ if voice too short
   1035  .       do      instak(work,1,work1-ts(work))   $$ lengthen it
   1036  endif
   1037
   1038  2
   1039  *
                                                                                                             measchk
   1040  unit    measchk
   1041  calc    work1--1                $$ longest voice so far
                      <                                         
   1042  doto    1test,work-cis+1,numvoc+1
                           <              
   1043  if      work1-mlth(work)
   1044  .       calc    work1-mlth(work)
                              <          
   1045  endif
   1046  1test
   1047  doto    2test,work-cis+1,numvoc+1
                           <              
   1048  branch  mlth(work)/work1,2bad,x
                           =            
   1049  2test
   1050  branch  1exit
   1051  2bad
   1052  pack    errors,errlth,voice <s,work> is too short by <s,work1-mlth(work)> frames
                                     (      )                 (                  )       
   1053  do      warning
   1054  1exit
   1055  *
part= 3, block=e --------------------------- stack 2
   1056  *
                                                                                                             unstak
   1057  unit    unstak
   1058  calc    work-3          $$ leave bottom entry alone
                     <                                      
   1059  *
                                                                                                   unstak1
   1060  entry   unstak1         $$ empty out note buffer
   1061  1more
   1062  calc    temp-999999
                     <      
   1063          temp1-0
                      < 
   1064  doto    1,temp2-cis+1,numvoc+1
                        <              
   1065  if      bufs(temp2,1)-temp      $$ if this is shorter
   1066  .       calc    temp-bufs(temp2,1)      $$ keep the minimum
                             <                                      
   1067  .               temp1-temp2     $$ and whose it is
                              <                            
   1068  endif
   1069  1
   1070  * now we know the shortest first entry and where it is
   1071  branch  t(temp1)-work,1done,x   $$ if done, leave
   1072  *
   1073  calc    temp4-temp+numvoc*(cis=0)-1     $$ find -delay- needed
                      <                                                
   1074  *
   1075  doto    2,temp2-cis+1,numvoc+1  $$ output the data
                        <                                  
   1076  calc    temp3-bufs(temp2,2)     $$ note to be output
                      <                                      
   1077  if      (temp3 $mask$ (1 $cls$ 16))/0
                                            = 
   1078  .       calc    inbin(109)      $$ gsw operand form
   1079  .               inbin((temp3 $ars$ 14) $mask$ o  3)
   1080  .               inbin((temp3 $ars$  7) $mask$ o177)
   1081  .               inbin(temp3 $mask$ o177)
   1082  else
   1083  .       if      temp3<1 $or$ temp3>99   $$ if note # out of range
   1084  .       .       calc    temp3-max2(min2(temp3,99),0)    $$ fix it
                                      <                                   
   1085  .       endif
   1086  .       calc    inbin(temp3)
   1087  endif
   1088  * now shorten each voice
   1089  calc    temp3-bufs(temp2,1)     $$ get time for voice
                      <                                       
   1090  if      temp3=temp              $$ if equal minimum
   1091  .       calc    mtemp-t(temp2)
                              <        
   1092  .       if      mtemp>2
   1093  .       .       block   bufs(temp2,3),bufs(temp2,1),mtemp-2
   1094  .       endif
   1095  .       calc    t(temp2)-mtemp-2        $$ delete entry
                                 <                              
   1096  else
   1097  .       calc    bufs(temp2,1)-bufs(temp2,1)-temp        $$ reduce length
                                      <                                          
   1098  endif
   1099  calc    ts(temp2)-ts(temp2)-temp        $$ reduce total length
                          <                                            
   1100  2
   1101  *
   1102  1delay
   1103  if      temp4>0                 $$ if we need delay
   1104  .       if      temp4>59        $$ if it does not fit
   1105  .       .       calc    inbin(100)
   1106  .       .               inbin(59)
   1107  .       .               temp4-temp4-59
                                      <        
   1108  .       .       branch  1delay  $$ keep going
   1109  .       else
   1110  .       .       calc    inbin(100)
   1111  .       .               inbin(temp4)    $$ output delay byte
   1112  .       endif
   1113  endif
   1114  * done one level, go for more...
   1115  branch  1more
   1116  *
   1117  1done                           $$ all done!
   1118  *
part= 3, block=f --------------------------- initial
   1119  *
                                                                                                             initial
   1120  unit    initial
   1121  stoload                 $$ for safety..
   1122  comload nc1,s.bin,l.bin $$ zero out binary
   1123  zero    nc1,l.bin
   1124  comload nc(ncbuff),s.comm,l.comm
   1125  zero    nc(ncbuff),l.comm       $$ zero some buffers
   1126  calc    work1-0 $$ define setcmd uses work1 and work2 internally
                      <                                                  
   1127          work2--1
                      <  
   1128          shortst-999999          $$ no shortest note defined
                        <                                           
   1129  calc                    $$ ,1)  = new command
   1130          setcmd('tempo   ',1)
   1131          setcmd('calc    ',1)
   1132          setcmd('pitch   ',1)
   1133          setcmd('randu   ',1)
   1134          setcmd('slide   ',1)
   1135          setcmd('goto    ',1)
   1136          setcmd('voice   ',1)
   1137          setcmd('volume  ',1)
   1138          setcmd('cis     ',1)
   1139          setcmd('percus  ',1)
   1140          setcmd('temper  ',1)
   1141          setcmd('change  ',1)
   1142          setcmd('copy    ',1)
   1143          setcmd('measure ',1)
   1144          setcmd('randp   ',1)
   1145          setcmd('setperm ',1)
   1146          setcmd('key     ',1)
   1147          setcmd('sharp   ',1)
   1148          setcmd('flat    ',1)
   1149          setcmd('natural ',1)
   1150          setcmd('marker  ',1)
   1151          setcmd('delay   ',1)
   1152          setcmd('endm    ',1)
   1153          setcmd('putd    ',1)
   1154          setcmd('stop*   ',1)
   1155          setcmd('end     ',0)    $$ same as stop*
   1156          setcmd('cstop*  ',0)    $$ same as stop*
   1157  calc    xstopx-work2    $$ set xstopx
                       <                      
   1158          setcmd('stop    ',1)    $$ stop must follow stop*
   1159          setcmd('cstop   ',0)    $$ same as stop
   1160          setcmd('start   ',1)    $$ start must follow stop
   1161          setcmd('cstart  ',0)    $$ same as start
   1162          setcmd('if      ',1)
   1163  calc    xifx-work2      $$ set xifx
                     <                      
   1164          setcmd('else    ',1)
   1165          setcmd('endif   ',1)
   1166          setcmd('.       ',1)
   1167          setcmd('decode  ',1)
   1168          setcmd('title   ',1)
   1169          setcmd('debug   ',1)            $$ debug compiler
   1170          setcmd('macro   ',1)    $$ must be last command number!
   1171  calc    xmacrox-work2   $$ set xmacrox
                        <                      
   1172  *
   1173  calc    ncomnd-work1    $$ number of commands
                       <                              
   1174  *comload
   1175  *
part= 3, block=g --------------------------- init/stats
   1176  *
                                                                                                   init2
   1177  entry   init2           $$ keeps unit initial small
   1178  do      keys    $$ initialize key table (student vars!)
   1179  zero    hisvar(1),l.his $$ zero out user variables
   1180  calc    strtstp--1      $$ start stop flag
                        <                          
   1181          measure--1      $$ measure number on right now
                        <                                      
   1182          t(1)-t(2)-t(3)-t(4)-0
                     <    <    <    < 
   1183          maxt(1)-maxt(2)-maxt(3)-maxt(4)-0
                        <       <       <       < 
   1184          vl(0)-vl(1)-vl(2)-vl(3)-7       $$ set volumes
                      <     <     <     <                      
   1185          oct(1)-oct(2)-oct(3)-oct(4)-0   $$ set octaves
                       <      <      <      <                  
   1186          time(1)-time(2)-time(3)-time(4)-0       $$ set times
                        <       <       <       <                    
   1187          ts(1)-ts(2)-ts(3)-ts(4)-0
                      <     <     <     < 
   1188          measlth-0                       $$ measure lengths
                        <                                          
   1189          sths60-round(tempo(150,4))      $$ initialize tempo
                       <                                            
   1190          lstac-lgrace-lpause-4   $$ set length of stac etc.
                      <      <      <                              
   1191          iftest--1       $$ if, else or endif
                       <                             
   1192          ifdepth-mat-ngoto-titlect-cis-numvoc-0
                        <   <     <       <   <      < 
   1193          textusd-macnum-putdnum-0
                        <      <       < 
   1194  comload binsegs,s.binsg,l.binsg
   1195  calc    binpt-tbinpt-binoff-0
                      <      <      < 
   1196  calc    inbin(102)
   1197  calc    inbin((vol$cls$8)$mask$o177)
   1198  calc    inbin((vol$cls$15)$mask$o177)
   1199  comload         $$ don't need binary any more
   1200  *
                                                                                                             stats
   1201  unit    stats
   1202  base
   1203  at      222
   1204  write   S T A T I S T I C S
   1205  at      176,456
   1206  write   for song <a,lstname>
                          (         )
   1207  comload nc1,s.bin,l.bin
   1208  at      513
   1209  showa   title,titlect
   1210  comload
   1211  at      913
   1212  write   Total lines      = <t,linenum,4>
                                    (           )
   1213          Highest measure  = <t,measure,4>
                                    (           )
   1214          Binary length    = <t,Binpt,4> bytes
                                    (         )      
   1215                             <t,int((Binpt-1)/8)+1,4> words
                                    (                      )      
   1216
   1217          Number of users  = <t,tactive,4>
                                    (           )
   1218          CPU time used    = <t,vproc,4.2>
                                    (           )
   1219          Elapsed time     = <t,timey,4.2>
                                    (           )
   1220          TIPS             = <t,1000*vproc/timey,4.2>
                                    (                      )
   1221
   1222          Lines/second     = <t,linenum/timey,4.2>
                                    (                   )
   1223          Lines/CPU second = <t,linenum/vproc,4.2>
                                    (                   )
   1224          CPU ms per line  = <t,1000*vproc/linenum,4.1>
                                    (                        )
   1225
   1226          Note buffer usage:
   1227
   1228          Buffer          Max. used
   1229             1              <t,maxt(1),4>
                                   (           )
   1230             2              <t,maxt(2),4>
                                   (           )
   1231             3              <t,maxt(3),4>
                                   (           )
   1232             4              <t,maxt(4),4>
                                   (           )
   1233  at      3104
   1234  write   Press NEXT to store or hear the song, SHIFT-LAB to edit it
   1235  pause   keys=next,term,lab1
   1236  jump    (key=next),prestonw,toedit
   1237  *
part= 4, block=a --------------------------- getblock
   1238  *
                                                                                                             getblock
   1239  unit    getblock                $$ get the next input record
   1240  if      bitcnt(blox2)=0         $$ if nothing left
   1241  .       calc    binpt-tbinpt    $$ set binary pointer
                              <                               
   1242  .       goto    done
   1243  endif
   1244  calc    temp-lobit(blox2)       $$ find next block
                     <                                     
   1245          blox2-blox2 $mask$ (-(lmask(1) $cls$ temp))
                      <                                     
   1246  do      datain(temp+1)          $$ read next record
   1247  transfr s,zwpr;temp;1 $$ get last word
   1248  calc    lthleft-temp $mask$ o7777       $$ compute length
                        <                                         
   1249          temp-temp $mask$ lmask(8*zbpc)  $$ remove length
                     <                                           
   1250          word-1                  $$ next word to process
                     <                                          
   1251  transfr temp;s,zwpr;1 $$ write word back
   1252  *
                                                                                                             leave
   1253  unit    leave
   1254  comload
   1255  stoload nc1,1,zwpr $$ one block of storage
   1256  do      reserve                 $$ grab directory
   1257  do      datain(1)               $$ read it
   1258  find    blox,myblox(1),60,temp  $$ find our slot
   1259  calc    temp-temp+1             $$ damn find command
                     <                                       
   1260          myblox(temp)-0
                             < 
   1261          used(temp)-0
                           < 
   1262          file-filenam(temp)      $$ get filename back
                     <                                       
   1263          authcde-code(temp)      $$ and security code (dedit)
                        <                                            
   1264          bitmap-bitmap $mask$ (not(blox))  $$ deallocate
                       <                                        
   1265  dataout 1;s,1;1                 $$ write directory
   1266  jump    zreturn,x,ioerror('dataout',1)
   1267  do      mustclr                 $$ release everything
   1268  *
                                                                                                             reserve
   1269  unit    reserve
   1270  loop
   1271  .       reserve records,1,1 $$ reserve directory
   1272  outloop zreturn                 $$ leave if successfull
   1273  .       if      key/stop1       $$ if not in finish unit
                            =                                    
   1274  .       .       break    $$ wait a little while
   1275  .       endif
   1276  endloop
   1277  *
                                                                                                             datain
   1278  unit    datain(mtemp)           $$ input a record
   1279  datain  mtemp;s,1;1
   1280  jump    zreturn,x,ioerror('datain',mtemp)
   1281  *
                                                                                                             ioerror
   1282  unit    ioerror
   1283  if      key=stop1               $$ if in finish unit
   1284  .       stoload n(n1-1),1,1     $$ uncommon error
                             <                            
   1285  endif
   1286  inhibit
   1287  erase   abort
   1288  release records,1,1
   1289  at      1013
   1290  write   I/O error in command <a,temp1>.
                                      (       ) 
   1291          zreturn = <s,zreturn>, block = <s,temp2>.
                           (         )          (       ) 
   1292          Please inform the maintainers of this program
   1293  back    q
   1294  back1   q
   1295  pause   keys=next,term,back,back1
   1296  jump    outless
   1297  *
                                                                                                             truncbin
   1298  unit    truncbin
   1299  goto    Tbinpt+1-maxbin,bad err,x
   1300  write       Binary too long, truncated.
   1301  calc    buffer(binpt)-103       $$ exit.
                              <                  
   1302  calc    buffer(binpt+1)-103
                                <   
   1303  calc    buffer(binpt+2)-103
                                <   
   1304  calc    buffer(binpt+3)-103
                                <   
   1305  inhibit erase
   1306  jump    done
   1307  *
                                                                                                             bad err
   1308  unit    bad err
   1309  iferror
   1310  calc    lthleft-lthleft+lthline
                        <               
   1311          word-word-lthline               $$ reset things
                     <                                          
   1312  goto    ml              $$ this line again
   1313  *
part= 4, block=b --------------------------- done i/o
   1314  *
                                                                                                             done
   1315  unit    done
   1316  branch  Tbinpt-maxbin,x,1nomore
   1317  comload nc(ncbuff),s.comm,l.comm
   1318          binsegs,s.binsg+binoff,l.binsg
   1319  calc    line-'*end song*'       $$ fake for emptystk
                     <                                       
   1320          pnt-length-10
                    <      <  
   1321  do      emptystk
   1322  calc    inbin(103)
   1323  calc    inbin(103)      $$ problem with musicomp?
   1324  calc    inbin(103)
   1325          binpt-tbinpt
                      <      
   1326  *
   1327  ** find and list all measures that couldn't be found
   1328  1nomore
   1329  do      fixemup
   1330  *
   1331  comload         $$ just in case
   1332  *
   1333  *       save stuff before storage shortened
   1334  *
   1335  do      leave                   $$ deallocate things
   1336  * avoid crummy exec error (JT 11/20/76)
   1337  branch  gswlth>lstorag,99skip,x
   1338  stoload nc1,1,gswlth
   1339  zero    nc1,gswlth
   1340  99skip
   1341  stoload
   1342  transfr c,s.bin;s,1;int((Binpt-1)/8)+1+15
   1343  stoload nc1,1,1
   1344  calc    nc1-lstname
                    <       
   1345  stoload
   1346  **
   1347  calc    vproc-proctim-vproc
                      <             
   1348          timey-clock-timey
                      <           
   1349  mode    rewrite
   1350  at      3007
   1351  write   Elapsed time <s,timey> seconds   CPU time <s,vproc> seconds
                              (       )                    (       )        
   1352          Press NEXT for gswaids, SHIFT-LAB to edit the song
   1353             or SHIFT-DATA for detailed statistics
   1354  lab     q
   1355  data1   q
   1356  pause   keys=next,lab1,term,data1
   1357  jump    (key=data1),stats,x
   1358  jump    (key=lab1),toedit,prestonw
   1359  *
                                                                                                             prestonw
   1360  unit    prestonw
   1361  do      erase
   1362  zero    n1,150
   1363  do      mustclr
   1364  finish  q
   1365  at      1010
   1366  write   going to lesson gswaids...
   1367  inhibit jumpchk,dropstor
   1368  jumpout gswaids,binnew
   1369  jumpout
   1370  *
                                                                                                             nextgsw
   1371  unit    nextgsw
   1372  term    ngswaids
   1373  do      erase
   1374  zero    n1,150
   1375  do      mustclr
   1376  finish  q
   1377  at      1010
   1378  write   going to lesson ngswaids...
   1379  inhibit jumpchk,dropstor
   1380  jumpout ngswaids,binnew
   1381  jumpout
   1382  *
                                                                                                             toedit
   1383  unit    toedit
   1384  jump    (file),todedit,editp1,x
   1385  do      mustclr $$ finish unit
   1386  calc    n1-file
                   <    
   1387  jumpout musicomp
   1388  jumpout
   1389  *
                                                                                                             clear
   1390  unit    clear
   1391  audio   o37777
   1392  ext     rest
   1393  ext     rest
   1394  ext     rest
   1395  ext     rest
   1396  *
                                                                                                             todedit
   1397  unit    todedit
   1398  calc    n3-lmask(1)             $$ go to the directory page
                   <                                                
   1399          file-file $mask$ rmask(zbpw-1)
                     <                         
   1400  do      mustclr        $$ finish unit
   1401  inhibit jumpchk
   1402  jumpout dedit
   1403  jumpout
   1404  *
part= 4, block=c --------------------------- commands 1
   1405  *
                                                                                                             calc
   1406  unit    calc
   1407  goto    onearg-1,toofew(1),x
   1408  goto    -argindx,toomany(1),x
   1409  do      compute(1)
   1410  goto    ml
   1411  *
                                                                                                             compute
   1412  unit    compute(temp)
   1413  do      nextarg(temp)
   1414  calc    temp3-0
                      < 
   1415  compute vwork,errors,errlth,temp3
   1416  if      formok>-1
   1417  .       pack    errors,errlth,error <s,formok> in expression
                                             (        )              
   1418  .       goto    error
   1419  endif
   1420  *
                                                                                                             vol
   1421  unit    vol
   1422  goto    onearg-1,toofew(1),x
   1423  goto    argindx-3,x,x,toomany(4)
   1424  doto    999,work1-0,argindx
                          <         
   1425  do      compute(work1+1)
   1426  branch  vwork<0$or$vwork>7,1err,x
   1427  calc    vl(3-work1)-vwork
                            <     
   1428  999
   1429  goto    ml
   1430  1err
   1431  pack    errors,errlth,volume would be out of range
   1432  goto    error
   1433  *
                                                                                                             tempo
   1434  unit    tempo
   1435  goto    onearg-1,toofew(2),x
   1436  goto    argindx-1,x,x,toomany(2)
   1437  do      compute(1)
   1438  goto    vwork-1,noor,x
   1439  branch  argindx=0,1arg,x
   1440  calc    vwork3-vwork    $$ floating tempo
                       <                          
   1441  do      compute(2)
   1442  calc    vwork1-tempo(vwork3,vwork)/vwork
                       <                         
   1443          sths60-max2(round(vwork1),4)*vwork  $$ find tempo
                       <                                          
   1444          vwork1-vwork1*vwork
                       <            
   1445  if      abs((vwork1-sths60)/vwork1)>.02 $$ if not close
   1446  .       pack    errors,errlth,tempo rounded to <s,60*framlth*vwork/sths60> <s,vwork>th notes per minute
                                                        (                         ) (       )                   
   1447  .       do      warning
   1448  endif
   1449  calc    shortst-vwork
                        <     
   1450  goto    ml
   1451  1arg
   1452  calc    sths60-round(vwork)     $$ round tempo
                       <                               
   1453          shortst-999999          $$ no limit
                        <                           
   1454  goto    ml
   1455  *
                                                                                                             flat
   1456  unit    flat
   1457  calc    work4--1
                      <  
   1458  goto    sharflat
   1459  *
                                                                                                             natural
   1460  unit    natural
   1461  calc    work4-0
                      < 
   1462  goto    sharflat
   1463  *
                                                                                                             sharp
   1464  unit    sharp
   1465  calc    work4-1
                      < 
   1466  *
                                                                                                   sharflat
   1467  entry   sharflat
   1468  goto    onearg-1,toofew(1),x
   1469  doto    999,work3-0,argindx
                          <         
   1470  do      nextarg(work3+1)
   1471  find    errors,keys(1),l.keys-1,temp,1,kmask
   1472  if      temp
   1473  .       pack    errors,errlth,note is not a legal one
   1474  .       goto    error
   1475  endif
   1476  if      work4=0
   1477  .       calc    temp1-(keys(1+temp)$ars$6)$mask$o77
                              <                             
   1478  else
   1479  .       calc    temp1-keys(1+temp)$mask$o77
                              <                     
   1480  endif
   1481  calc    temp1-(temp1+work4)$mask$o77
                      <                      
   1482  calc    keys(temp+1)-(keys(temp+1)$mask$-o77)$union$temp1
                             <                                    
   1483  999
   1484  goto    ml
   1485  *
                                                                                                             setperm
   1486  unit    setperm
   1487  goto    onearg-1,toofew(1),x
   1488  goto    -argindx,toomany(1),x
   1489  do      compute(1)
   1490  calc    work-vwork
                     <     
   1491  setperm work
   1492  goto    ml
   1493  *
                                                                                                             randu
   1494  unit    randu
   1495  goto    onearg-1,toofew(2),x
   1496  goto    argindx-1,toofew(2),x,toomany(2)
   1497  do      compute(2)
   1498  calc    work-vwork
                     <     
   1499  randu   mtemp,work
   1500  goto    rstuff
   1501  *
                                                                                                             randp
   1502  unit    randp
   1503  goto    onearg-1,toofew(1),x
   1504  goto    -argindx,toomany(1),x
   1505  randp   mtemp
   1506  *
                                                                                                   rstuff
   1507  entry   rstuff
   1508  do      nextarg(1)
   1509  move    '-temp',1,errors,errlth+1,5
                  <                         
   1510  calc    temp1-0
                      < 
   1511          temp-mtemp
                     <     
   1512  compute temp,errors,errlth+5,temp1
   1513  if      formok>-1
   1514  .       pack    errors,errlth,error <s,formok> in expression
                                             (        )              
   1515  .       goto    error
   1516  endif
   1517  goto    ml
   1518  *
part= 4, block=d --------------------------- commands 2
   1519  *
                                                                                                             voice
   1520  unit    voice
   1521  do      vstuff
   1522  calc    cis-0
                    < 
   1523  goto    work,x,cis1,x
   1524  calc    numvoc-work
                       <    
   1525  calc    work-tbinpt
                     <      
   1526  calc    inbin(101)
                                                                                                   volin
   1527  entry   volin
   1528  calc    temp4-(vl(0)$cls$9)$union$(vl(1)$cls$6)$union$(vl(2)$cls$3)$union$vl(3)
                      <                                                                 
   1529          temp4-temp4$union$(temp4$cls$48)
                      <                          
   1530          temp4-temp4$cls$(3*(3-numvoc))
                      <                        
   1531          work1-[temp4$mask$o7777]$union$(numvoc$cls$12)
                      <                                        
   1532  calc    inbin([work1$ars$7]$mask$o177)
   1533  calc    inbin(work1$mask$o177)
   1534  branch  buffer(work-1)-100,1q,x,1q
   1535  branch  buffer(work-2)-101,x,1q,1q,x
   1536  calc    buffer(work)-buffer(work)+(buffer(work)>0)
                             <                             
   1537  1q
   1538  goto    ml
   1539  *
                                                                                                             vstuff
   1540  unit    vstuff
   1541  goto    onearg-1,toofew(1),x
   1542  goto    -argindx,toomany(1),x
   1543  do      emptystk
   1544  do      compute(1)
   1545  calc    work-vwork-1
                     <       
   1546  goto    work<0$or$work>3,noor,x
   1547  *
                                                                                                             cis
   1548  unit    cis
   1549  do      vstuff
                                                                                                   cis1
   1550  entry   cis1
   1551  calc    numvoc-cis-work
                       <   <    
   1552  calc    work-tbinpt
                     <      
   1553  calc    inbin(102)
   1554  goto    volin
   1555  *
                                                                                                             debugit
   1556  unit    debugit         $$ debug the compiler
   1557  back    q
   1558  inhibit erase
   1559  jump    debug2          $$ no more post-arrow
   1560  *
                                                                                                             debug2
   1561  unit    debug2
   1562  at      40,errloc
   1563  erase   40,3
   1564  at      40,errloc-8
   1565  write   Debug mode (BACK to exit)
   1566  arrow   40,errloc-24
   1567  long    10
   1568  jkey    back
   1569  specs   okassign
   1570  exact   debug
   1571  noword  ok
   1572  calc    debug--1
                      <  
   1573  judge   noquit
   1574  ok
   1575  judge   key=back,x,continue
   1576  at      40,errloc
   1577  erase   40,3
   1578  goto    ml              $$ proper contingency!
   1579  store   mtemp
   1580  noword  no
   1581  no
   1582  noword
   1583  at      140,errloc-24
   1584  write   <z,mtemp>  <a,mtemp>  <o,mtemp>
                 (       )  (       )  (       )
   1585  endarrow
   1586  *
                                                                                                             decode
   1587  unit    decode
   1588  *  'decode  m2,5c+'  evaluate note number
   1589  goto    onearg-1,toofew(2),x
   1590  goto    argindx-1,toofew(2),x,toomany(2)
   1591  do      nextarg(2)
   1592  do      note1
   1593  calc    mtemp-work1
                      <     
   1594  goto    rstuff
   1595  *
part= 4, block=e --------------------------- commands 3
   1596  *
                                                                                                             percus
   1597  unit    percus
   1598  goto    onearg-1,toofew(1),x
   1599  goto    -argindx,toomany(1),x
   1600  do      emptystk        $$ clear out all previous notes
   1601  calc    inbin(106)      $$ code number for percussion
   1602  do      compute(1)
   1603  branch  vwork<0$or$vwork>o177,1err,x
   1604  calc    inbin(vwork)
   1605  goto    ml
   1606  1err
   1607  pack    errors,errlth,percussion argument is out of range
   1608  goto    error
   1609  *
                                                                                                             pitch
   1610  unit    pitch
   1611  goto    onearg-1,toofew(1),x
   1612  goto    -argindx,toomany(1),x
   1613  do      emptystk
   1614  calc    inbin(107)
   1615  do      compute(1)
   1616  calc    inbin(vwork)
   1617  goto    ml
   1618  *
                                                                                                             temper
   1619  unit    temper
   1620  goto    onearg-1,toofew(1),x
   1621  goto    -argindx,toomany(1),x
   1622  do      nextarg(1)
   1623  find    errors,keys(0),l.keys,work,1,kmask
   1624  branch  work,1err,x
   1625  calc    inbin(108)
   1626  calcs   (keys(work)$mask$o77)-1,temp4-0,4,5,6,7,8,9,10,11,12,1,2,3
                                              <                            
   1627  calc    inbin(temp4)
   1628  goto    ml
   1629  1err
   1630  pack    errors,errlth,key given is not legal
   1631  goto    error
   1632  *
                                                                                                             marker
   1633  unit    marker
   1634  * one optional argument: marker number
   1635  do      emptystk
   1636  if      onearg-1                        $$ if no argument
   1637  .       calc    work-0
                             < 
   1638  else
   1639  .       do      compute(1)
   1640  .       calc    work-vwork
                             <     
   1641  endif
   1642  calc    inbin(110)
   1643          inbin(work)             $$ store marker number
   1644  at      40,errloc
   1645  write         Marker <s,work> at tbinpt=<s,Tbinpt>.
                               (      )           (        ) 
   1646  calc    errloc-wherey
                       <      
   1647  goto    ml
   1648  *
                                                                                                             slide
   1649  unit    slide
   1650  goto    onearg-1,toofew(3),x
   1651  goto    argindx-2,x,x,toomany(3)
   1652  do      emptystk
   1653  calc    inbin(105)
   1654  calc    temp1-9
                      < 
   1655  do      note(1)
   1656  calc    inbin(work1)
   1657  calc    temp1-arglist(1)+1
                      <            
   1658  do      note(2)
   1659  calc    inbin(work1)
   1660  do      nextarg(3)
   1661  do      time
   1662  calc    inbin(work)
   1663  goto    ml
   1664  *
                                                                                                             delay
   1665  unit    delay   $$ (JT 5/3/75 patterned after percus command)
   1666  goto    onearg-1,toofew(1),x
   1667  goto    -argindx,toomany(1),x
   1668  do      emptystk
   1669  do      nextarg(1)
   1670  do      time
   1671  * if 'stac', give delay req'd to finish the note,
   1672  * if 'tied', delay for full length, else subtract lpause
   1673  branch  work,1ml,1ml,x
   1674  1loop
   1675  calc    temp3-work
                      <    
   1676  branch  work>60,x,1short
   1677  calc    temp3-60
                      <  
   1678  1short
   1679  calc    inbin(100)
   1680  calc    inbin(temp3)
   1681  branch  (work-work-60)>0,1loop,x
                      <                  
   1682  1ml
   1683  goto    ml
   1684  *
                                                                                                             title
   1685  unit    title
   1686  calc    work-length-8   $$ # of chars to add
                     <                               
   1687          work-max2(0,work)
                     <            
   1688  branch  (titlect+work+1)>100,x,3ok
   1689  pack    errors,errlth,title is too long
   1690  goto    error
   1691  3ok
   1692  comload nc1,s.bin,l.bin $$ load binary
   1693  move    line,9,title,titlect+1,work
   1694  move    '?',1,title,titlect+1+work,1      $$ -cr-added
   1695  calc    titlect-titlect+1+work
                        <              
   1696  goto    reload                  $$ restore normal comload
part= 4, block=f --------------------------- commands 4
   1697  *
                                                                                                             key
   1698  unit    key
   1699  goto    onearg-1,toofew(1),x
   1700  goto    argindx-1,x,toomany(1)
   1701  do      emptystk
   1702  do      nextarg(1)
   1703  do      keys
   1704  calcs   errors='c',work-0,-1
                                <    
   1705  calcc   errors='g',work-1,0
                                <   
   1706  calcc   errors='d',work-2,0
                                <   
   1707  calcc   errors='a',work-3,0
                                <   
   1708  calcc   errors='e',work-4,0
                                <   
   1709  calcc   errors='b',work-5,0
                                <   
   1710  calcc   errors='f+',work-6,0
                                 <   
   1711  calcc   errors='c+',work-7,0
                                 <   
   1712  calcc   errors='g+',work-8,0
                                 <   
   1713  calcc   errors='d+',work-9,0
                                 <   
   1714  calcc   errors='a+',work-10,0
                                 <    
   1715  calcc   errors='e+',work-11,0
                                 <    
   1716  calcc   errors='b+',work-12,0
                                 <    
   1717  branch  work,1flats,x
   1718  doto    999,work1-1,work
                          <      
   1719  *calcs   work1-2,work2-12,5,15,8,1,11,4,13,6,16,9,2
                               <                            
   1720  calcs   work1-2,work2-'f','c','g','d','a','e','b','f+','c+','g+','d+','a+'
                              <                                                    
   1721  find    work2,keys(0),l.keys,work2,1,kmask
   1722  calc    work3-(keys(work2)$mask$o77)+1
                      <                        
   1723  calcc   work3>12,work3-work3-12,0
                               <          
   1724  calc    keys(work2)-(keys(work2)$mask$-o77)$union$work3
                            <                                   
   1725  999
   1726  goto    ml
   1727  1flats
   1728  calcc   errors='f',work-1,0
                                <   
   1729  calcc   errors='b-',work-2,0
                                 <   
   1730  calcc   errors='e-',work-3,0
                                 <   
   1731  calcc   errors='a-',work-4,0
                                 <   
   1732  calcc   errors='d-',work-5,0
                                 <   
   1733  calcc   errors='g-',work-6,0
                                 <   
   1734  calcc   errors='c-',work-7,0
                                 <   
   1735  calcc   errors='f-',work-8,0
                                 <   
   1736  calcc   errors='b--',work-9,0
                                  <   
   1737  calcc   errors='e--',work-10,0
                                  <    
   1738  calcc   errors='a--',work-11,0
                                  <    
   1739  calcc   errors='d--',work-12,0
                                  <    
   1740  branch  work,x,1do
   1741  pack    errors,errlth,key is not legal
   1742  goto    error
   1743  1do
   1744  doto    9,work1-1,work
                        <      
   1745  *calcs   work1-2,work2-4,11,1,8,15,5,12,2,9,16,6,13
                               <                            
   1746  calcs   work1-2,work2-'b','e','a','d','g','c','f','a+','d+','g+','c+','f+'
                              <                                                    
   1747  find    work2,keys(0),l.keys,work2,1,kmask
   1748  calc    work3-(keys(work2)$mask$o77)-1
                      <                        
   1749  calcc   work3<1,work3-work3+12,0
                              <          
   1750  calc    keys(work2)-(keys(work2)$mask$-o77)$union$work3
                            <                                   
   1751  9
   1752  goto    ml
   1753  *
part= 4, block=g --------------------------- commands 5
   1754  *
                                                                                                             keys
   1755  unit    keys
   1756  calc    work1--1
                      <  
   1757  calc
   1758          setkey('even',0)
   1759  *
   1760          setkey('a',na)
   1761          setkey('b--',na)
   1762          setkey('g++',na)
   1763  *
   1764          setkey('a+',nas)
   1765          setkey('b-',nas)
   1766          setkey('c--',nas)
   1767  *
   1768          setkey('b',nb)
   1769          setkey('a++',nb)
   1770          setkey('c-',nb)
   1771  *
   1772          setkey('c',nc)
   1773          setkey('b+',nc)
   1774          setkey('d--',nc)
   1775  *
   1776          setkey('c+',ncs)
   1777          setkey('d-',ncs)
   1778          setkey('b++',ncs)
   1779  *
   1780          setkey('d',nd)
   1781          setkey('e--',nd)
   1782          setkey('c++',nd)
   1783  *
   1784          setkey('d+',nds)
   1785          setkey('e-',nds)
   1786          setkey('f--',nds)
   1787  *
   1788          setkey('e',ne)
   1789          setkey('f-',ne)
   1790          setkey('d++',ne)
   1791  *
   1792          setkey('f',nf)
   1793          setkey('e+',nf)
   1794          setkey('g--',nf)
   1795  *
   1796          setkey('f+',nfs)
   1797          setkey('g-',nfs)
   1798          setkey('e++',nfs)
   1799  *
   1800          setkey('g',ng)
   1801          setkey('a--',ng)
   1802          setkey('f++',ng)
   1803  *
   1804          setkey('g+',ngs)
   1805          setkey('a-',ngs)
   1806  *
   1807  goto    work1-(l.keys-1),x,q,x
   1808  pack    errors,errlth, key table is wrong length
   1809  goto    error
   1810  *
                                                                                                             remap
   1811  unit    remap
   1812  *** we go here if the binary in nc variables is nearly
   1813  *** filled - this changes the comload pointers.
   1814  calc    work-int(tbinpt/8)      $$ see how many words we have
                     <                                                
   1815          tbinpt-tbinpt-8*work
                       <             
   1816          binoff-binoff+work      $$ move over ecs pointer
                       <                                         
   1817  goto    reload                  $$ and do the -comload-
   1818  *
part= 5, block=a --------------------------- measure
   1819  *
                                                                                                             measure
   1820  unit    measure
   1821  goto    onearg-1,toofew(1),x
   1822  goto    argindx-1,x,toomany(1)
   1823  goto    mat-l.meas,x,tabful
   1824  do      compute(1)
   1825  branch  measure<vwork,1skip,x
   1826  pack    errors,errlth,measure number is out of order
   1827  do      warning(1)
   1828  1skip
   1829  calc    measure-vwork   $$ current measure
                        <                          
   1830  at      linemx-8*16+50*8,linemy
   1831  write   <s,measure>
                 (         )
   1832  do      measdone        $$ output all notes, but allow tied notes
   1833  calc    mtemp-Tbinpt+1-(numvoc+3)*(ts(cis+1)>0) $$ =here.
                      <                                           
   1834          mtemp-mtemp$mask$o777777
                      <                  
   1835          work-(measure$mask$-o7777777)$union$o4000000
                     <                                       
   1836          work-work$union$mtemp
                     <                
   1837  c  so, (work) is nonzero in upper 40 bits, has the
   1838  c  o1000000 bit zero, and points to current location.
   1839  *  store measure pointers
   1840  calc    meas(mat-mat+1)-work    $$ add new one to end
                         <      <                             
   1841  goto    ml
   1842  *
   1843  9errs
   1844  pack    errors,errlth,measure number is redefined
   1845  goto    error
   1846  *
                                                                                                             goto
   1847  unit    goto
   1848  goto    onearg-1,toofew(1),x
   1849  goto    argindx-7,x,x,toomany(8)
   1850  goto    ngoto_15,tabful,x
                      >           
   1851  goto    mat-l.meas,x,tabful
   1852  do      emptystk
   1853  calc    mtemp-Tbinpt+4+2*argindx+1      $$ address after goto
                      <                                               
   1854  calc    inbin(104)
   1855  calc    inbin([argindx$cls$4]+[ngoto-ngoto+1]-1)
                                             <           
   1856  doto    999,onearg-1,argindx+1
                           <           
   1857  do      compute(onearg) $$ the next arg   (vwork=work)
   1858  branch  errors='x',900,x        $$ x option can be done immediatly
   1859  calc    work-(work$mask$-o7777777)$union$o4000000
                     <                                    
   1860          work-work$union$(Tbinpt+1)      $$ address to be fixed
                     <                                                 
   1861          meas(mat-mat+1)-work$union$o1000000     $$ set this bit
                         <      <                                       
   1862  *  get here with (work)=stuff to output
   1863  900
   1864  calc    work-mtemp-1    $$ sub 1 because presto adds 1 .....
                     <                                               
   1865          inbin(work$ars$7)       $$ (zaps temp4)
   1866          inbin(work)
   1867  999
   1868  goto    ml
   1869  *
part= 5, block=b --------------------------- measure
   1870  *
                                                                                                             fixemup
   1871  unit    fixemup
   1872  ** fix up all goto/measure references
   1873  ** find and list all measures that couldn't be found
   1874  goto    mat=0,q,x
   1875  comload nc(ncmeas),s.meas,l.meas
   1876  doto    999,work-1,mat
                         <     
   1877  *  you recall, the o1000000 bit is set for a goto reference
   1878  branch  ([work1-meas(work)]$mask$o1000000)-1,999,x
                        <                                  
   1879  calc    work2-work1$mask$-o1000000      $$ turn that bit off
                      <                                              
   1880  find    work2,meas(1),mat,temp1,1,-o777777      $$ find measure
   1881  branch  temp1,x,1fixit
   1882  mode    rewrite
   1883  at      40,errloc
   1884  write       Measure # <s,vwork1> not found, goto treated as goto x.
                                (        )                                   
   1885  find    0,meas(1),work,temp2,-1,o1000000
   1886  calcc   temp2,vwork1--1,work1-meas(temp2+1)$mask$-o7777777
                             <        <                            
   1887  write           Referenced from measure # <s,vwork1>.
                                                    (        ) 
   1888  calc    errloc-wherey
                       <      
   1889  branch  999
   1890  *
   1891  1fixit
   1892  c  work1 has goto address to be fixed
   1893  c  temp1 has pointer to correct measure address
   1894  calc    work1-work1$mask$o777777        $$ binary address
                      <                                           
   1895          work4-meas(temp1+1)$mask$o777777        $$ goto where?
                      <                                                
   1896          work4-work4-1   $$ sub1 because presto adds 1
                      <                                       
   1897  comload binsegs,s.binsg+int(work1/8)-1,l.binsg
   1898  calc    work1-work1-(int(work1/8)-1)*8
                      <                        
   1899          buffer(work1)-work4 $ars$ 7
                              <             
   1900          buffer(work1+1)-work4
                                <     
   1901  comload nc(ncmeas),s.meas,l.meas
   1902  999
   1903  *
part= 5, block=c --------------------------- change
   1904  *
                                                                                                             change
   1905  unit    change
   1906  do      commget
   1907  calc    command(work+1)-[command(work+1)$mask$o7777]$union$temp3
                                <                                        
   1908  goto    ml
   1909  *
                                                                                                             copy
   1910  unit    copy
   1911  goto    ncomnd_l.comnd,tabful,x
                       >                
   1912  do      commget
   1913  calc    command(ncomnd-ncomnd+1)-temp3$union$(command(work+1)$mask$o7777)
                               <         <                                        
   1914  goto    ml
   1915  *
                                                                                                             commget
   1916  unit    commget
   1917  calc    temp--1 $$ not in command name yet
                     <                             
   1918          temp4--1        $$ specifies first one = change from
                      <                                              
   1919          temp1-0
                      < 
   1920          temp2-temp3-'        '  $$ change from temp2 to temp3
                      <     <                                         
   1921          mtemp-9
                      < 
   1922  if      (line $mask$ o7777)="co" $and$ (l(2) $mask$ lmask(36))='mmand '
   1923  .       calc    mtemp-17        $$ skip word "command"
                              <                                
   1924  endif
   1925  doto    999,pnt-mtemp,length    $$ go through string looking
                        <                                            
   1926  * for " to" or ","
   1927  *check for end of old command
   1928  branch  nxt3(pnt)=" to",1new1,x
   1929  branch  char(pnt)=",",1new,x
   1930  branch  char(pnt)=o55,999,x     $$ bump all space codes
   1931  branch  (temp1-temp1+1)-8,x,x,1error    $$ command too long
                       <                                            
   1932  calc    temp-0  $$ in command now
                     <                    
   1933  branch  temp4,x,1
   1934  calc    temp2-(temp2 $mask$ (-o77 $cls$ 6(10-temp1))) $union$ (char(pnt)$cls$6(10-temp1))
                      <                                                                           
   1935  branch  999
   1936  *
   1937  1
   1938  calc    temp3-(temp3 $mask$ (-o77 $cls$ 6(10-temp1))) $union$ (char(pnt)$cls$6(10-temp1))
                      <                                                                           
   1939  branch  999
   1940  1new1
   1941  calc    pnt-pnt+2
                    <     
   1942  1new
   1943  branch  temp,2error,x   $$ no first argument
   1944  calc    temp1-0
                      < 
   1945  branch  (temp4-temp4+1)-1,x,6error
                       <                   
   1946  branch  temp2='        ',2error,x
   1947  find    temp2,command(1),ncomnd,work,1,-o7777
   1948  branch  work,5error,x   $$ 1st arg not a command yet
   1949  999
   1950  branch  temp,2error,x   $$ no first argument
   1951  branch  temp3='        ',3error,x
   1952  find    temp3,command(1),ncomnd,work1,1,-o7777
   1953  branch  work1,x,4error  $$ 2nd arg is already command
   1954  goto    q
   1955  *
   1956  *
   1957  1error  branch temp3='        ',x,1ps
   1958  pack    errors,errlth,first argument has too many characters
   1959  branch  1errgo
   1960  1ps
   1961  pack    errors,errlth,second argument has too many characters
   1962  branch  1errgo
   1963  2error
   1964  pack    errors,errlth,there is no first argument
   1965  branch  1errgo
   1966  3error
   1967  pack    errors,errlth,there is no second argument
   1968  branch  1errgo
   1969  4error
   1970  pack    errors,errlth,second argument is already a command
   1971  branch  1errgo
   1972  5error
   1973  pack    errors,errlth,first argument is not a command now
   1974  branch  1errgo
   1975  6error
   1976  pack    errors,errlth,too many arguments
   1977  1errgo
   1978  goto    error
   1979  *
part= 5, block=d --------------------------- arglist
   1980  *
                                                                                                             arglist
   1981  unit    arglist
   1982  zero    arglis1(1),l.args
   1983  calc    argindx-np-errors-onearg-temp-0
                        <  <      <      <    < 
   1984  doto    1loop,pnt-pnt+1,length
                          <            
   1985  if      (temp4-char(pnt))/o55
                       <          =   
   1986  .       calc    temp-temp+1
                             <      
   1987  .               onearg-1
                               < 
   1988  .       if      temp4="(" $or$ temp4="["
   1989  .       .       calc    np-np+1
                                   <    
   1990  .       elseif  temp4=")" $or$ temp4="]"
   1991  .       .       branch  (np-np-1),1badpar,x
                                    <               
   1992  .       elseif  temp4=","
   1993  .       .       if      np=0
   1994  .       .       .       if      argindx-l.args
   1995  .       .       .       .       calc    arglis1(argindx-argindx+1)-pnt $union$ ([temp-1] $cls$ 30)
                                                                <          <                               
   1996  .       .       .       .               temp-0
                                                     < 
   1997  .       .       .       else
   1998  .       .       .       .       goto    tabful
   1999  .       .       .       endif
   2000  .       .       endif
   2001  .       endif
   2002  endif
   2003  1loop
   2004  *
   2005  branch  np-1,x,1badpar
   2006  calc    arglis1(argindx+1)-temp$cls$30
                                   <           
   2007  goto    q
   2008  *
   2009  1badpar
   2010  pack    errors,errlth,parentheses are unmatched
   2011  goto    error
   2012  *
   2013  *
                                                                                                             nextarg
   2014  unit    nextarg(temp)
   2015  calc    temp1-9
                      < 
   2016  if      1-temp
   2017  .       calc    temp1-arglist(temp-1)+1
                              <                 
   2018  endif
                                                                                                   nextarg1
   2019  entry   nextarg1(temp)
   2020  zero    errors,l.error
   2021  calc    errlth-0
                       < 
   2022  calc    temp2-length
                      <      
   2023  if      temp-argindx-1
   2024  .       calc    temp2-arglist(temp)-1
                              <               
   2025  endif
   2026  if      temp2>0
   2027  .       calc    temp2-temp2+(char(temp2)=o76)
                              <                       
   2028  .       doto    999,temp3-temp1,temp2
                                  <           
   2029  .       branch  char(temp3)-o55,x,999,x
   2030  .       calc    err(errlth-errlth+1)-char(temp3)
                                   <         <           
   2031  .       999
   2032  endif
   2033  *
                                                                                                             stepper
   2034  unit    stepper
   2035  termop  step
   2036  group   mtemp
   2037  goto    mtemp='musician' $and$ user='author',x,q
   2038  step    on
   2039  *
part= 5, block=e --------------------------- marg error
                                                                                                             macarget
   2040  unit    macarget(temp)
   2041  calc    temp1-9
                      < 
   2042  if      1-temp
   2043  .       calc    temp1-arglist(temp-1)+1
                              <                 
   2044  endif
   2045  calc    errors-0
                       < 
   2046  calc    errlth-0
                       < 
   2047  calc    temp2-length
                      <      
   2048  if      temp-argindx-1
   2049  .       calc    temp2-arglist(temp)-1
                              <               
   2050  endif
   2051  goto    temp2-1,q,x
   2052  calc    temp2-temp2+(char(temp2)=o76)   $$ 3/12/76        jt
                      <                                              
   2053  doto    999,temp3-temp1,temp2
                          <           
   2054  branch  char(temp3)-o55,x,999,x
   2055  calc    err(errlth-errlth+1)-char(temp3)
                           <         <           
   2056  999
   2057  branch  errlth>10,2nope,x
   2058  *  fix null arguments
   2059  branch  errors=0,x,2ok
   2060  calc    errors-'0'
                       <   
   2061  2ok
   2062  calc    macputs(temp)-errors
                              <      
   2063  goto    q
   2064  *
   2065  2nope
   2066  pack    errors,errlth,macro arg too long
   2067  goto    error
   2068  *
   2069  *
   2070  *
   2071  *
   2072  *
                                                                                                             toomany
   2073  unit    toomany(temp)
   2074  pack    errors,errlth,you have too many arguments
   2075  calc    pnt-arglist(temp)
                    <             
   2076  goto    error
   2077  *
                                                                                                             toofew
   2078  unit    toofew(temp)
   2079  pack    errors,errlth,you need at least <s,temp> arguments
                                                 (      )          
   2080  goto    error
   2081  *
                                                                                                             noor
   2082  unit    noor
   2083  pack    errors,errlth,your number is out of range
   2084  goto    error
   2085  *
                                                                                                             error
   2086  unit    error
   2087  do      errdisp
   2088  inhibit erase
   2089  jump    mlp
   2090  *
                                                                                                             mlp
   2091  unit    mlp
   2092  inhibit arrow
   2093  arrow   3264
   2094  long    1
   2095  time    .75
   2096  jkey    stop
   2097  specs   nookno
   2098  ok
   2099  goto    key-stop,x,done,x
   2100  goto    reload
   2101  *
                                                                                                             warning
   2102  unit    warning
   2103  goto    length-1,q,x
   2104  goto    length>1000,q,x
   2105  at      40,errloc
   2106  write       warning in line=<s,linenum>  measure=<s,measure>   source line=
                                      (         )          (         )                
   2107  calc    temp4-where
                      <     
   2108  showa   line,length
   2109  draw    temp4;temp4+pnt
   2110  write         **type** <a,errors,errlth>
                                 (               )
   2111  calc    errloc-wherey
                       <      
   2112  *
                                                                                                             tabful
   2113  unit    tabful
   2114  pack    errors,errlth,sorry but you have overfilled a program table
   2115  goto    error
   2116  *
                                                                                                             errdisp
   2117  unit    errdisp
   2118  comload
   2119  mode    rewrite
   2120  at      40,errloc
   2121  write       ***error in  ***  line=<s,linenum>  measure=<s,measure>        source line=
                                             (         )          (         )                     
   2122  calc    work-where
                     <     
   2123  showa   line,length
   2124  write
   2125  draw    work;work+pnt
   2126  write         **type** <a,errors,errlth>
                                 (               )
   2127  calc    tbinpt-binpt
                       <     
   2128          errloc-wherey
                       <      
   2129  *
                                                                                                             toobad
   2130  unit    toobad
   2131  pack    errors,errlth,you just overflowed the note buffers
   2132  do      errdisp
   2133  calc    t(1)-t(2)-t(3)-t(4)-0   $$ empty buffers
                     <    <    <    <                    
   2134  inhibit erase
   2135  jump    done
   2136  *
part= 5, block=f --------------------------- macro
   2137  *
                                                                                                             macro
   2138  unit    macro
   2139  goto    onearg-1,toofew(1),x
   2140  goto    argindx-maxmarg,x,toomany(maxmarg)
   2141  goto    ncomnd_l.comnd,tabful,x
                       >                
   2142  comload
   2143  stoload nc1,s.disk,l.disk       $$ load disk block
   2144  * find the  endm  pseudo-command (must be in current block)
   2145  find    'endm    ',nc(word),lthleft,work        $$ full word search
   2146  stoload
   2147  branch  work,x,1null,1found
   2148  pack    errors,errlth,couldnt find -endm- pseudo-command
   2149  goto    error
   2150  1null
   2151  calc    word-word+1
                     <      
   2152          lthleft-lthleft-1
                        <         
   2153  goto    reload
   2154  1found
   2155  calc    work1-word      $$ pointer to first word of text
                      <                                          
   2156          lthleft-lthleft-work-1  $$ advance line pointers
                        <                                        
   2157          word-word+work+1
                     <           
   2158  if      (textusd+work)>l.text
   2159  .       pack    errors,errlth,macro text overflow
   2160  .       goto    error
   2161  endif
   2162  *   work has length of macro text, in words
   2163  *   work1 has pointer to first word of text
   2164  comload nc1,s.macro,l.macro
   2165  calc    macnum-macnum+1 $$ increment macro number
                       <                                  
   2166          macargs(macnum)-work2-argindx $$ number of args
                                <     <                         
   2167          macpos(macnum)-textusd  $$ start of text
                               <                         
   2168          maclen(macnum)-work     $$ length of text
                               <                          
   2169  do      nextarg(1)      $$ get macro name
   2170  branch  errlth>10,1nope,x
   2171  clean   errors,1        $$ space-fill first 8 characters
   2172  comload nc(ncbuff),s.comm,l.comm
   2173  calc    ncomnd-ncomnd+1
                       <        
   2174          command(ncomnd)-[errors$mask$-o7777]$union$(macnum+xmacrox)
                                <                                           
   2175  comload nc1,s.macro,l.macro
   2176  doto    2end,mtemp-1,work2
                           <       
   2177  do      nextarg(mtemp+1)        $$ get each macro dummy argument
   2178  branch  errlth>10,2nope,x
   2179  calc    macsub(macnum,mtemp)-errors
                                     <      
   2180  2end
   2181  comload
   2182  transfr s,s.disk-1+work1;c,s.text+textusd;work $$ store the text
   2183  calc    textusd-textusd+work    $$ increase storage pointer
                        <                                           
   2184  goto    reload
   2185  1nope
   2186  pack    errors,errlth,macro name is too long
   2187  goto    error
   2188  2nope
   2189  pack    errors,errlth,macro argument is too long
   2190  goto    error
   2191  *
                                                                                                             endm
   2192  unit    endm
   2193  pack    errors,errlth, stray -endm- command
   2194  goto    error
   2195  *
part= 5, block=g --------------------------- macrosb/p1
                                                                                                             macrosub
   2196  unit    macrosub
   2197  goto    argindx-maxmarg,x,toomany(maxmarg)
   2198  * enter from ml with work2= command number
   2199  comload nc1,s.macro,l.macro
   2200  calc    work1-work2-xmacrox
                      <             
   2201          work-maclen(work1)      $$ macro length
                     <                                  
   2202          work2-macargs(work1)    $$ argument count
                      <                                   
   2203          work3-macpos(work1)     $$ start of text
                      <                                  
   2204  if      work2/(argindx+1)*onearg
                      =                  
   2205  .       pack    errors,errlth,wrong number of macro args
   2206  .       goto    error
   2207  endif
   2208  *
   2209  * simple trick to get more space to expand macros
   2210  calc    temp-lstorag-lthleft+1
                     <                 
   2211  comload
   2212  if      word/temp
                     =    
   2213  .       transfr s,word;s,temp;lthleft
   2214  .       calc    word-temp
                             <    
   2215  endif
   2216  *
   2217  *  if zero args, process simply
   2218  goto    onearg-1,x,macrogo
   2219  calc    temp-word-work  $$ next first word pointer
                     <                                     
   2220  if      temp_1
                     > 
   2221  .       transfr c,s.text+work3;s,s.disk+temp-1;work
   2222  .       calc    word-temp
                             <    
   2223  .               lthleft-lthleft+work
                                <            
   2224  .       goto    reload
   2225  else
   2226  .       pack    errors,errlth,macro insertion overflow
   2227  .       goto    error
   2228  endif
   2229  *
                                                                                                             editp1
   2230  unit    editp1
   2231  calc    n2-lstname
                   <       
   2232  do      mustclr
   2233  jumpout p1
   2234  jumpout
   2235  *
part= 6, block=a --------------------------- macrogo
   2236  *
                                                                                                             macrogo
   2237  unit    macrogo
   2238  c process input of args, substitute, build source code:
   2239  c  work=length of text, words
   2240  c  work1=macro number
   2241  c  work2=number of args
   2242  c  work3=location in s.text of start of text
   2243  c  work4=temporary copy of word
   2244  c  temp2=number of words generated on this line
   2245  c  temp3=location of next lower o0000
   2246  c  temp4=location of o0000 on current line
   2247  doto    2end,mtemp-work2,1,-1
                           <          
   2248  do      macarget(mtemp)
   2249  2end
   2250  c  trick here is to output the last line of the macro text
   2251  c  first.  expanding downward thus overwrites lines which
   2252  c  have already been compiled.
   2253  calc    temp3-temp4-work3+work-1        $$ last word used
                      <     <                                     
   2254          work4-word
                      <    
   2255  *
   2256  comload nc1,s.macro,l.macro
   2257  long    l.line*zcpw-2  $$ allow for o0000 at end of line
   2258  3loop
   2259  * find end of previous line --
   2260  calc    temp3-temp3-1
                      <       
   2261  transfr c,s.text+temp3;mtemp;1
   2262  branch  (mtemp$mask$o7777)-1,3go,x
   2263  branch  temp3<work3,x,3loop     $$ wont return if true
   2264  3go
   2265  zero    line,l.line
   2266  transfr c,s.text+temp3+1;line;(temp4-temp3)
   2267  * perform -putv- all over the line:
   2268  judge   continue
   2269  loada   line,(temp4-temp3)*10
   2270  join    macputs,mtemp-1,work2
                              <       
   2271  storea  line,l.line*10-2
   2272  ok
   2273  * store the result
   2274  calc    temp2-1+int((jcount+1)/10)
                      <                    
   2275  transfr line;s,s.disk-1+work4-temp2;temp2
   2276  * end of 3loop
   2277  calc    work4-work4-temp2       $$ new start of source code
                      <                                             
   2278  branch  work4_1,3givup,x
                      <          
   2279  calc    temp4-temp3
                      <     
   2280  branch  temp3<work3,x,3loop
   2281  1done
   2282  * success --
   2283  calc    lthleft-lthleft+word-work4
                        <                  
   2284          word-work4
                     <     
   2285  goto    reload
   2286  *
   2287  3givup
   2288  pack    errors,errlth,macro expansion overflows buffer
   2289  goto    error
   2290  *
   2291  *
                                                                                                             macputs
   2292  unit    macputs $$ in judging state alla time
   2293  join    temp1-macsub(work1,mtemp),x
                      <                     
   2294  join    temp2-macputs(mtemp),x
                      <                
   2295  putv    temp1,count(temp1),temp2,count(temp2)
   2296  *
   2297  * all errors default to regular state, skip in judging state
   2298  pack    errors,errlth, macro execution error
   2299  goto    error
   2300  *
part= 6, block=b --------------------------- putd
   2301  *putd if you dare!
   2302  *
                                                                                                             putd
   2303  unit    putd
   2304  * ignore arglist since using delimiters here, not commas
   2305  * want to allow ^ as a delimiter
                         v               
   2306  calc    work-1 $$ chars in delimiter
                     <                       
   2307          work1-( temp-char(9) )$cls$54
                      <      <                
   2308  if      temp=o76 $or$ temp=o70
   2309  .       calc    work-work+1
                             <      
   2310  .               work1-work1$union$(char(10)$cls$48)
                              <                             
   2311  endif
   2312  search  work1,work,line,length,9+work,temp,2
   2313  c  temp=number of occurences
   2314  c  temp1=position of middle delimiter
   2315  c  temp2=position of last delimiter
   2316  if      temp/2
                     = 
   2317  .       pack    errors,errlth, wrong number of delimiters in putd
   2318  .       goto    error
   2319  endif
   2320  *
   2321  calc    work2-temp1-9-work  $$ chars in string1
                      <                                 
   2322          work3-temp2-temp1-work $$ chars in string2
                      <                                    
   2323  branch  (work2<1)$or$(work2>10),x,2ok
   2324  2error
   2325  pack    errors,errlth, length of putd argument is wrong
   2326  goto    error
   2327  *
   2328  2ok
   2329  branch  work3,2error,x,3ok
   2330  calc    char(temp1+work)-"0"  $$ fix null string
                                 <                       
   2331          work3-1
                      < 
   2332  3ok
   2333  calc    putdnum-putdnum+1
                        <         
   2334  branch  putdnum>maxputs,1tabful,x
   2335  comload nc1,s.putd,l.putd
   2336  calc    putstuf(putdnum)-(work3$cls$12)$union$textusd
                                 <                            
   2337          temp3-int([work3+9]/10)
                      <                 
   2338  move    line,9+work,putname(putdnum),1,work2
   2339  comload
   2340  move    line,temp1+work,line,1,work3
   2341  move    0,1,line,work3+1,10     $$ make sure end with 0's
   2342  transfr line;c,s.text+textusd;temp3
   2343  calc    textusd-textusd+temp3
                        <             
   2344  goto    reload
   2345  1tabful
   2346  goto    tabful
   2347  *
   2348  *
                                                                                                             putdgo
   2349  unit    putdgo
   2350  comload nc1,s.putd,l.putd
   2351  long    l.line*zcpw-2  $$ allow for o0000 at end of line
   2352  3loop
   2353  calc    length-length-1
                       <        
   2354  move    line,2,line,1,length    $$ delete "="
   2355  judge   continue        $$ faster than rejudge
   2356  loada   line,length
   2357  ok
   2358  do      putputs,mtemp-1,putdnum $$ perform each putd in turn
                              <                                      
   2359  judge   continue
   2360  storea  line,length-jcount
                            <      
   2361  ok
   2362  branch  char(1)-"=",x,3loop,x
   2363  comload nc(ncbuff),s.comm,l.comm
   2364          binsegs,s.binsg+binoff,l.binsg
   2365  **** exit is by un-joining.
   2366  *
                                                                                                             putputs
   2367  unit    putputs
   2368  calc    temp1-putname(mtemp)
                      <              
   2369          temp2-count(temp1)
                      <            
   2370          temp3-putstuf(mtemp)$mask$o7777 $$ pointer to text
                      <                                            
   2371          temp4-putstuf(mtemp)$ars$12     $$ length of text
                      <                                           
   2372          work4-int([temp4+9]/10)
                      <                 
   2373  transfr c,s.text+temp3;line;work4
   2374  judge   continue
   2375  *putv    temp1,count(temp1),macline(putstuf(mtemp)$mask$o7777),putstuf(mtemp)$ars$12
   2376  putv    temp1,temp2,line,temp4
   2377  * errors default to regular state --
   2378  pack    errors,errlth, putd processing caused line to expand too big
   2379  goto    error
   2380  ok
   2381  *
                                                                                                             if
   2382  unit    if
   2383  goto    onearg-1,toofew(1),x
   2384  goto    argindx-1,x,toomany(1)
   2385  do      compute(1)
   2386  calc    iftest-(vwork<0)
                       <         
   2387  goto    ml
   2388  *
------------------------------------------------------------------------------
   ------ s y m b o l    l e g e n d ------                ------ s y m b o l    l e g e n d ------------
                  upper case                                           upper-lower case
    '   shifted key         &   superscript                !   subscript              &   superscript
    !   subscript             backspace                    ?   carriage return        \   font
    ^   access              \   font                       .   understrike for access
    ?   carriage return     \   times                      ^   universal delimiter    \   times
                            /                              v                          /        
    :   divide              -   assign                     :   divide                 -   assign
    -                       <                              -                          <         
   ----------------------------------------                |   vertical line          .   arrow
                                                                                      >        
                                                           .   matrix multiply        \   vector product
                                                           o                          /                 
                                                           ----------------------------------------------
