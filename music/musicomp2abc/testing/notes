#!/usr/bin/python3 -B
# ----------------------------------------------------------------------------
# vim: tabstop=8 expandtab shiftwidth=4 softtabstop=4
# ----------------------------------------------------------------------------
import os
import sys

OUTPUT = sys.stdout
# OUTPUT = sys.stderr
# ----------------------------------------------------------------------------
WHOLE_NOTE = 120 * 4        # 120 = quarter note from csv "Header".
# ----------------------------------------------------------------------------
#    octave  2      3      4       5
#  c/b+     48     60     72      84
#  c+/d-    49     61     73      85
#  d        50     62     74      86
#  d+/e-    51     63     75      87
#  e/f-     52     64     76      88
#  f/e+     53     65     77      89
#  f+/g-    54     66     78      90
#  g        55     67     79      91
#  g+/a-    56     68     80      92
#  a        57     69     81      93
#  a+/b-    58     70     82      94
#  b/c-     59     71     83      95

# For octave 3c = 60.
note_in_octave_value = {
   'c': 60,
   'd-':61,
   'd': 62,
   'e-':63,
   'e': 64,
   'f': 65,
   'g-':66,
   'g': 67,
   'a-':68,
   'a': 69,
   'b-':70,
   'b': 71,
}

global note_to_midi_value
note_to_midi_value = { }

for o in range(0, 9):        # 0 thru 8
    for n in note_in_octave_value:
        x = str(o) + n
        v = (note_in_octave_value[n] - (60-24)) + 12*o      # 60-36=24 = '0c'
        note_to_midi_value[v] = x
    # rof
# rof

# ----------------------------------------------------------------------------
legal_mc_notes = [ 1/64, 1/32, 1/16, 1/8, 1/4, 1/2, 1/1 ]

def convert_fraction_note_remainder(v, n, frac, tie):
    q = frac + (1/48)
#--     q = int(q * 32) - 1
    q = int(q * 32)
    r = q / 32

#--    print("convert_fraction_note_remainder(v={}, n={}, frac={}, r={}, tie={})".format(v, n, frac, r, tie), file=sys.stderr)

    if tie == 't' or n != 'r':
        print_tie = 't'
    else:
        print_tie = ''
    # fi
    while r > (1 + (1/64)):
        print("=v {}: {}1{}".format(v, n, print_tie), file=OUTPUT)
        r = r - 1
    # elihw

    start_over = True
    while start_over:
        start_over = False
#--        print("convert_fraction_note_remainder #A v={} r={}".format(v,r), file=sys.stderr)
        for i in range(0, len(legal_mc_notes)):
            if r < legal_mc_notes[i]:
#--                print("convert_fraction_note_remainder #B r={} < legal_mc_notes[{}]={}".format(r,i,legal_mc_notes[i]), file=sys.stderr)
                if i == 0:
#--                    print("convert_fraction_note_remainder - too small a value: r={}".format(r), file=sys.stderr)
                    # Too small a value, ignore ??
                    return
                # fi
                note_val = round(1.0 / legal_mc_notes[i - 1])
                print("=v {}: {}{}{}".format(v, n, note_val, print_tie), file=OUTPUT)
                r = r - legal_mc_notes[i - 1]
                start_over = True
                break
            elif r == legal_mc_notes[i]:
#--                print("convert_fraction_note_remainder #C r={} == legal_mc_notes[{}]={}".format(r,i,legal_mc_notes[i]), file=sys.stderr)
                note_val = round(1.0 / legal_mc_notes[i])
                print("=v {}: {}{}{}".format(v, n, note_val, tie), file=OUTPUT)
                return
            # fi
        # rof
    # elihw
# End of convert_fraction_note_remainder

# ----------------------------------------------------------------------------
# Make this be comments.
global Comments
Comments = ['Control_c',
            'End_of_file',
            'End_track',
            'Header',
            'MIDI_port',
            'Pitch_bend_c',
            'Program_c',
            'Start_track',
            'Tempo',
            'Title_t',
            'Text_t',
            'Time_signature',
            'Copyright_t',
            'Key_signature',
            'Marker_t',
            ]
# ----------------------------------------------------------------------------
global working_voice
working_voice = -1              # Initialized with first line.

global notes_on
notes_on = {}                   # Voice name, and notes on it [time, freq, vol, lth] (lth=0 if on, but not off).
global max_notes
max_notes = {}                  # Voice name, and notes on it [time, freq, vol, lth] (lth=0 if on, but not off).
global notes_on_list
notes_on_list = {}              # Voice name - on it [time, freq, vol, lth] (lth=0 if on, but not off).

global max_voices
max_voices = 0

global ord_voice
ord_voice = ['A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z']

# ----------------------------------------------------------------------------
def print_on(s, voice):
    global notes_on_list
    global max_notes

    return

#--    print("  {} voice={} Entering notes_on_list={}".format(s, voice, notes_on_list), file=sys.stderr)
    if voice not in max_notes:
        print("  {} No max_notes for voice {}".format(s, voice), file=sys.stderr)
        return
    # fi
    for i in range(0, max_notes[voice]):
        voiceletter = ord_voice[i]
        q = 'VOICE{}{}'.format(voice, voiceletter)
        if q not in notes_on_list or notes_on_list[q] == []:
            continue
        # fi
        (t,f,vol,off) = notes_on_list[q][-1]
        if off != 0:
            continue
        # fi
        print("  {} notes_on_list[{}][-1]={}".format(s, q, notes_on_list[q][-1]), file=sys.stderr)
    # rof
# End of print_on

# ----------------------------------------------------------------------------
def do_note_start(voice, time, freq, volume):
    global notes_on
    global notes_on_list
    global max_notes

#--    print("do_note_start - here#0a voice={} time={} freq={} volume={}".format(voice, time, freq, volume), file=sys.stderr)
    print_on("  do_note_start#0a", voice)

    # Initialize for new voice.
    if voice not in notes_on:
        notes_on[voice] = 0                                 # No notes on for this voice yet.
        max_notes[voice] = 0                                # No notes on for this voice yet.
    # fi

#--    print("  do_note_start -- voice={}".format(voice), file=sys.stderr)
#--    print("  do_note_start -- notes_on[voice]={}".format(notes_on[voice]), file=sys.stderr)
#--    print("  do_note_start -- notes_on={}".format(notes_on), file=sys.stderr)
#--    print("  do_note_start -- notes_on_list={}".format(notes_on_list), file=sys.stderr)

    voiceletter = ord_voice[notes_on[voice]]
    v = 'VOICE{}{}'.format(voice, voiceletter)
    if v not in notes_on_list:
        notes_on_list[v] = []                               # No notes on for this voice yet.]
    # fi

#--    print("  do_note_start here -- before for", file=sys.stderr)
    for i in range(0, max_notes[voice]):
        voiceletter = ord_voice[i]
        v = 'VOICE{}{}'.format(voice, voiceletter)
        if v not in notes_on_list:
            notes_on_list[v] = []
#--            print("  do_note_start here -- new notes_on_list", file=sys.stderr)
            continue
        # fi
#--        print("  do_note_start here -- already notes on notes_on_list", file=sys.stderr)
        if notes_on_list[v] != []:
            (t,f,vol,off) = notes_on_list[v][-1]
            if off == 0:                                        # Do not start multiple on same voice.
#--                print("  do_note_start here -- off == 0", file=sys.stderr)
                continue
            # fi
        # fi
#--        print("  do_note_start here -- setting note on", file=sys.stderr)
        notes_on_list[v].append([time, freq, volume, 0])    # lth (last) of 0 for not turned off yet.
        notes_on[voice] = notes_on[voice] + 1
        if max_notes[voice] < notes_on[voice]:
            max_notes[voice] = notes_on[voice]
        # fi
        print_on("  do_note_start#0b", voice)
        return
    # rof
#--    print("  do_note_start here -- after for", file=sys.stderr)

    # Create new sub-voice (i.e. a gcs voice for multiple notes on same voice).
    voiceletter = ord_voice[notes_on[voice]]
    v = 'VOICE{}{}'.format(voice, voiceletter)

    notes_on[voice] = notes_on[voice] + 1
    if max_notes[voice] < notes_on[voice]:
        max_notes[voice] = notes_on[voice]
    # fi
    notes_on_list[v].append([time, freq, volume, 0])        # lth (last) of 0 for not turned off yet.

    print_on("  do_note_start#99", voice)
    return
# End of do_note_start

# ----------------------------------------------------------------------------
def do_note_stop(voice, time, freq):
    global notes_on
    global notes_on_list
    global max_notes

#--    print("do_note_stop - here#1a voice={} time={} freq={}".format(voice, time, freq), file=sys.stderr)

    if voice not in notes_on:
        print("No voice ({}) in notes_on={}".format(voice, notes_on), file=sys.stderr)
        return
    # fi

    print_on("  do_note_start#1a", voice)

    for i in range(0, max_notes[voice]):
        voiceletter = ord_voice[i]
        v = 'VOICE{}{}'.format(voice, voiceletter)
        if v not in notes_on_list or notes_on_list[v] == []:
            continue
        # fi
        (t,f,vol,off) = notes_on_list[v][-1]
        if off != 0:
            continue
        # fi
        if f != freq:
            continue
        # fi
        notes_on_list[v][-1] = (t,f,vol,time)       # Make unchangeable with ()'s. :)
        notes_on[voice] = notes_on[voice] - 1

        print_on("  do_note_stop#1b", voice)
        
        return
    # rof

    print("note {} not already turned on, cannot turn it off. time={}".format(freq, time), file=sys.stderr)
    print_on("  do_note_stop#99", voice)

    return
# End of do_note_stop

# ----------------------------------------------------------------------------
def process_note_on_c(a):
    global max_voices

    voice = int(a[0])
    time = int(a[1])
#       channel = int(a[3])                 # Ignore channel.
    freq = int(a[4])
    volume = int(a[5])
    if max_voices < voice:
        max_voices = voice
    # fi
    # If note is being turned on.
    if volume != 0:
        do_note_start(voice, time, freq, volume)
    else:
        do_note_stop(voice, time, freq)
    # fi
    return  # End of process_note_on_c
# End of process_note_on_c

# ----------------------------------------------------------------------------
def print_measure_rests_and_notes(measure_lth, measure, v, f, t, off):

#--    print("print_measure_rests_and_notes #9a - measure_lth={} measure={} v={} f={} t={} off={}".format(measure_lth, measure, v, f, t, off), file=sys.stderr)

    # Do rests before note starts. And any measures that need to occur.
    start_this_measure = int(measure_lth / WHOLE_NOTE)
    end_this_measure = (start_this_measure + 1) * WHOLE_NOTE
#--    print("print_measure_rests_and_notes #9b - end_this_measure={} t={}".format(end_this_measure, t), file=sys.stderr)
    while end_this_measure < t:
#--        print("print_measure_rests_and_notes #9c", file=sys.stderr)
        d = end_this_measure - measure_lth
        lth = d / WHOLE_NOTE          # give fraction of a note.
        convert_fraction_note_remainder(v, 'r', lth, '')
        measure = measure + 1
        measure_lth = end_this_measure
        print("measure {}".format(measure), file=OUTPUT)
        end_this_measure = end_this_measure + WHOLE_NOTE
    # elihw

    if t > (measure_lth + 5):
        d = t - measure_lth
        lth = d / WHOLE_NOTE          # give fraction of a note.
        convert_fraction_note_remainder(v, 'r', lth, '')
    # fi
    measure_lth = t

    # How long note is on.
    n = int(f)
    gcs = note_to_midi_value[n]
    d = (int(off) - int(t))

    # end_this_measure already set.
    # First, is it on longer than what is left in this measure?
    # NOTE: Tie goes on note before for v: format.
#--    print("print_measure_rests_and_notes #9d - end_this_measure={} off={}".format(end_this_measure,off), file=sys.stderr)
    while end_this_measure < (off - 1):
        d = end_this_measure - measure_lth
#--        print("print_measure_rests_and_notes #9d - d={}".format(d), file=sys.stderr)
        lth = d / WHOLE_NOTE          # give fraction of a note.
        if end_this_measure < (off - 1):
            tieit = ''
        else:
            tieit = 't'
        # fi
        convert_fraction_note_remainder(v, gcs, lth, tieit)
        measure = measure + 1
        measure_lth = end_this_measure
        print("measure {}".format(measure), file=OUTPUT)
        end_this_measure = end_this_measure + WHOLE_NOTE
    # elihw

    # If note length < WHOLE_NOTE:
    d = off - measure_lth
#--    print("print_measure_rests_and_notes #9e - d={}  off={} measure_lth={}".format(d,off,measure_lth), file=sys.stderr)
    if d > 0:
        lth = d / WHOLE_NOTE          # give fraction of a note.
        convert_fraction_note_remainder(v, gcs, lth, '')
    # fi
    measure_lth = off
#--    print("print_measure_rests_and_notes #9f - measure_lth={} measure={}".format(measure_lth, measure), file=sys.stderr)
    return (measure_lth, measure)
# End of print_measure_rests_and_notes

# ----------------------------------------------------------------------------
def print_voices():
    global max_voices
    global notes_on
    global notes_on_list
    global max_notes

#--    print("print_voices - here#8a", file=sys.stderr)

    print("voice   {}".format(len(notes_on_list.keys())), file=OUTPUT)
    for v in notes_on_list.keys():
        measure = 0
        measure_lth = 0
#--        print("print_voices - here#8b v={}".format(v), file=sys.stderr)
#--        print("print_voices - here#8c notes_on_list={}".format(notes_on_list), file=sys.stderr)
        if v not in notes_on_list:
#--            print("print_voices - here#8d v={} notes_on_list={}".format(v,notes_on_list), file=sys.stderr)
            continue
        # fi
        a = notes_on_list[v]
#--        print("print_voices - here#8e a={}".format(a), file=sys.stderr)
        print("measure {}".format(measure), file=OUTPUT)
        for i in a:
#--            print("print_voices - here#8f v={} i={}".format(v,i), file=sys.stderr)
            (t,f,vol,off) = i
#--            print("print_voices - here#8g (t={},f={},vol={},off={}) v={} i={}".format(t,f,vol,off,v,i), file=sys.stderr)
            (measure_lth, measure) = print_measure_rests_and_notes(measure_lth, measure, v, f, t, off)
        # rof
    # rof
    return
# End of print_voices

# ----------------------------------------------------------------------------
# Main program follows.
def main():
    global working_voice
    global max_voices
    global notes_on_list
    global number_notes_on_list
    global notes_on_list_start
    global last_lth
    global Comments

    for line in sys.stdin.buffer.raw:                   # Of ALL THE CRAZY THINGS! part 1.
        line = line.decode('utf-8', 'backslashreplace') # Of ALL THE CRAZY THINGS! part 2.
        line = line.rstrip()
        if line[0] and line[0] == '*':
            print(line, file=sys.stderr)
            continue
        # fi
        # Get rid of commas, and leading/trailing spaces
        nline = line.replace(',', '').strip()
        a = nline.split()            # Get everything.
#--        print("* a={}".format(a), file=sys.stderr)
        # Next voice starts.
        if a[0] != working_voice:
            # Initialize voice information.
            working_voice = a[0]
        # fi
        # Ignore a bunch of lines.
        if a[2] in Comments:
            print("* {}".format(line), file=OUTPUT)
            continue
        # fi
        # Only thing that should be left is Note_on_c.
        if a[2] != 'Note_on_c':
            print("* -unrecognized- {}".format(line), file=OUTPUT)
            continue
        # fi

        print("* {}".format(line), file=OUTPUT)
        process_note_on_c(a)
    # rof

# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
    print_voices()
# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
# NOTDONEYET --
    # Second print out notes for measures.
    #   for (measure_lth = 0; measure_lth <= time_end; measure_lth = measure_lth + WHOLE_NOTE)
    #     for (v = 0; v < max_voices; v = v + 1):
    #   rof
# Go through saved array and print all the v#: out and put measures/rests in.
    # There are problems with figuring out note going on, and then off.
    # a) Where do measures go? (When printed?)
    # b) If a note starts, is a rest needed before it?
    # c) If a note off is more than the rest of this measure away, break it into before measure and
    #    after.
    # d) If two notes start/end at same time (effectively -- figure out ignoring factors).
# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
    return
# End of main

# ----------------------------------------------------------------------------
if __name__ == '__main__':
    main()
# fi
# ----------------------------------------------------------------------------
exit(0)
# ----------------------------------------------------------------------------
# End of file musicomp2abc
