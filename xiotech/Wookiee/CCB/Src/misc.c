/* $Id: misc.c 159305 2012-06-16 08:00:46Z m4 $ */
/**
******************************************************************************
**
**  @file   misc.c
**
**  @brief  Miscellaneous Functions
**
**  Miscellaneous stuff that doesn't fit elsewhere.
**
**  Copyright (c) 2001-2010 XIOtech Corporation. All rights reserved.
**
******************************************************************************
**/
#include "misc.h"

#include <errno.h>

#include "ccb_flash.h"
#include "ccb_hw.h"
#include "ctype.h"
#include "debug_files.h"
#include "error_handler.h"
#include "idr_structure.h"
#include "kernel.h"
#include "mach.h"
#include "mode.h"
#include "nvram.h"
#include "OS_II.h"
#include "PacketInterface.h"
#include "PktCmdHdl.h"
#include "rtc.h"
#include "SerBuff.h"
#include "timer.h"
#include "XIO_Const.h"
#include "XIO_Std.h"
#include "XIO_Types.h"

#include "errorCodes.h"
#include "quorum.h"
#include "quorum_utils.h"
#include "xk_init.h"
#include "signal.h"

/*****************************************************************************
** Private defines
*****************************************************************************/
typedef struct procAddressTableHeader_t
{
    UINT8       id[4];
    UINT32      version;
    UINT32      count;          /* Number of records that follow the header */
    UINT32      crc;
} PROC_ADDRESS_TABLE_HEADER;

typedef struct procAddressTableEntry_t
{
    UINT8       id[8];
    UINT32      addr;
    UINT32      len;
} PROC_ADDRESS_TABLE_ENTRY;

/**
**  Magic number to ensure the validity of the device configuration
**  flash sectore.
**/
#define DEVICE_CONFIG_MAGIC_NUMBER      0x6731261

/**
**  Device Configuration Structure
**
**  The device configuration information is stored into a flash sector
**  so the structure below is defined with that in mind. Each of the
**  entries in the map are 32 bytes so in order to have an even number
**  of entries the header portion is padded out to 32 bytes.
**
**  This gives us the following available for the device configuration
**  sector:
**      - Header: 32 bytes
**      - Entries (8191): 262112 bytes
**
**      - TOTAL: 262144 bytes or 256K
**/
typedef struct
{
    UINT32      magicNumber;            /**< Magic Number                   */
    UINT8       rsvd4[2];               /**< RESERVED                       */
    UINT16      count;                  /**< Count of valid devices         */
    UINT8       rsvd8[24];              /**< RESERVED                       */
    ZeroArray(SES_DEV_INFO_MAP, map);   /**< Device Information Map
                                         **  32 bytes each                  */
} FLASH_DEVICE_CONFIG;

/*****************************************************************************
** Private variables
*****************************************************************************/
static II  *pProc_BEII = NULL;
static II  *pProc_FEII = NULL;
static void *pProc_FENVA = NULL;
static UINT32 length_FENVA = 0;

/**
**  Default device configuration information. This information
**  is used if the controller has not been updated by the ICON
**  with any information.
*/
static SES_DEV_INFO_MAP gDefaultDevInfoMaps[] = {
    /**
     * Note that the following file is generated by a rule in the Makefile
     * by means of the script convdev.sh. The source of the information is
     * the file ../../Tools/DeviceConfiguration<MODEL>.txt. The devices.gen
     * file winds up in the objects directory for the current build.
     * It is possible to add additional entries here that are not in the
     * normal text file and, of course, they can be conditionalized by
     * preprocessor directives, but that should not be a normal thing to
     * do.
     */
#include "devices.gen"
};

/*
** DEFAULT_DEV_INFO_COUNT is the number of elements in the
** gDefaultDevInfoMaps array.
*/
#define DEFAULT_DEV_INFO_COUNT  dimension_of(gDefaultDevInfoMaps)

/*****************************************************************************
** Private functions
*****************************************************************************/
static UINT32 PrintNVRAMBoardInfo(NVRAM_BOARD_INFO *pBoardInfo);

/*****************************************************************************
** Code Start
*****************************************************************************/

/**
******************************************************************************
**
**  @brief      Calculates an offset to add/subtract to translate
**              to a PCI address.
**
**  @param      proc - the processor you are coming from.
**
**  @return     The calculated offset as an integer.
**
******************************************************************************
**/
INT32 CalcPCIOffset(INT32 proc)
{
    INT32       offset = 0;     /* default for CCB */

    /* Calculate the offset based upon the processor */
    switch (proc)
    {
        case PROCESS_FE:
            offset = (INT32)(BASE_DRAM - FRONT_END_PCI_START);
            break;

        case PROCESS_BE:
            offset = (INT32)(BASE_DRAM - BACK_END_PCI_START);
            break;
    }
    return offset;
}

/**********************************************************************
*                                                                     *
*  Name:        ProcessResetTask()                                  *
*                                                                     *
*  Description: Forked task to resets the specified processor(s)      *
*                                                                     *
*  Input:       int which - the processor to reset (CCB or all)       *
*                                                                     *
*  Returns:     void                                                  *
*                                                                     *
**********************************************************************/
void ProcessResetTask(TASK_PARMS *parms)
{
    UINT32      which = parms->p1;

    LogMessage(LOG_TYPE_DEBUG, "ProcessResetTask-Pausing 5 seconds");
    TaskSleepMS(5000);
    ProcessReset(which);
}

/**
******************************************************************************
**
**  @brief  Resets the specified processor(s)
**
**  @param  which - the processor to reset (CCB or all)
**
**  @return none
**
******************************************************************************
**/
void ProcessReset(UINT32 which)
{
    UINT32 failureState;
    UINT32 errorState;

    LogMessage(LOG_TYPE_DEBUG, "ProcessReset-0x%x", which);

    switch (which)
    {
        case PROCESS_ALL:
            dprintf(DPRINTF_DEFAULT, "Reset FE and BE Processes\n");

            usleep(100);            /* Allow message to get into the logs. */

            /* Read in the controllers current failure data. */
            failureState = GetControllerFailureState();
            switch (failureState)
            {
                case FD_STATE_INACTIVATED:
                    {
                        MODEDATA    mBits;

                        ModeGet(&mBits);

                        if (mBits.ccb.bits & MD_DISABLE_INACTIVATE_POWER)
                        {
                            errorState = ERR_EXIT_DEADLOOP;
                        }
                        else
                        {
                            errorState = ERR_EXIT_SHUTDOWN;
                        }
                    }
                    break;

                default:
                    errorState = ERR_EXIT_RESET_ALL;
                    break;
            }
            errExit(errorState);
            /* no break -- fall through */
        case PROCESS_CCB:
            dprintf(DPRINTF_DEFAULT, "Reset CCB Process\n");

            CopyBacktraceDataToNVRAM();     /* Copy critical data to NVRAM */

            errExit(ERR_EXIT_RESET_CCB);    /* Exit with the Reset CCB value */
            break;

        default:
            break;
    }
}

/*----------------------------------------------------------------------------
** Function:    dumpByteArray and dumpByteArray2
**
** Description: Produce, for debug purposes, a hexadecimal dump of the input
**              byte array. The output is formatted in 4 byte chunks, 8
**              chunks to a line.
**
** Inputs:      theArray -- the byte array to dump
**              len -- length, in bytes, of the input buffer.
**
** Returns:     none
**
**--------------------------------------------------------------------------*/
static void dumpByteArray(UINT32 dprintfLvl, void *theArray, int theArrayLength)
{
    INT32       i;
    UINT8      *array = (UINT8 *)theArray;

    /* See if we have anything to print */
    if (!(modeData.ccb.bitsDPrintf & dprintfLvl))
    {
        return;
    }

    for (i = 0; i < theArrayLength; i += 16, array += 16)
    {
        dprintf(dprintfLvl,
                "%02hhx%02hhx%02hhx%02hhx %02hhx%02hhx%02hhx%02hhx  "
                "%02hhx%02hhx%02hhx%02hhx %02hhx%02hhx%02hhx%02hhx   "
                "%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c\n",
                array[0], array[1], array[2], array[3],
                array[4], array[5], array[6], array[7],
                array[8], array[9], array[10], array[11],
                array[12], array[13], array[14], array[15],
                (isprint(array[0])) ? array[0] : '.',
                (isprint(array[1])) ? array[1] : '.',
                (isprint(array[2])) ? array[2] : '.',
                (isprint(array[3])) ? array[3] : '.',
                (isprint(array[4])) ? array[4] : '.',
                (isprint(array[5])) ? array[5] : '.',
                (isprint(array[6])) ? array[6] : '.',
                (isprint(array[7])) ? array[7] : '.',
                (isprint(array[8])) ? array[8] : '.',
                (isprint(array[9])) ? array[9] : '.',
                (isprint(array[10])) ? array[10] : '.',
                (isprint(array[11])) ? array[11] : '.',
                (isprint(array[12])) ? array[12] : '.',
                (isprint(array[13])) ? array[13] : '.',
                (isprint(array[14])) ? array[14] : '.',
                (isprint(array[15])) ? array[15] : '.');

        /* Exchange every 8 lines */

        if ((i & 0x7) == 0x7)
        {
            TaskSwitch();
        }
    }
}


#define MAX_DUMP_LEN 256
void dumpByteArray2(UINT32 dprintfLvl,
                    const char *name, void *theArray, int theArrayLength)
{
    int         dumpLen;

    /* See if we have anything to print */
    if (!(modeData.ccb.bitsDPrintf & dprintfLvl))
    {
        return;
    }

    /*
     * Limit the output to 256 bytes (16 lines), else we can overflow buffers
     * really quickly...
     */
    if (theArrayLength > MAX_DUMP_LEN)
    {
        dumpLen = MAX_DUMP_LEN;
        dprintf(dprintfLvl, "%s (%d bytes, truncated to %d):\n",
                name, theArrayLength, dumpLen);
    }
    else
    {
        dumpLen = theArrayLength;
        dprintf(dprintfLvl, "%s (%d bytes):\n", name, theArrayLength);
    }

    dumpByteArray(dprintfLvl, theArray, dumpLen);
}

/**
******************************************************************************
**
**  @brief      Reads the BE and FE Processor Static Address Tables and saves
**              some of the addresses in global variables for later access.
**
**  @param      none
**
**  @return     none
**
******************************************************************************
**/

void LoadProcAddresses(void)
{
    UINT32      index1;
    PROC_ADDRESS_TABLE_ENTRY *pEntry;
    UINT32      addr;

    /*
     * Calculate the address of the first entry in the table. The
     * table starts with a header followed by the entries and the
     * base address is not a PCI address so it needs to be converted
     * before being used.
     */
    addr = (UINT32)ToPCIAddr(PROC_ADDRESS_TABLE_ADDR, CalcPCIOffset(PROCESS_BE));
    addr += sizeof(PROC_ADDRESS_TABLE_HEADER);
    pEntry = (PROC_ADDRESS_TABLE_ENTRY *)addr;

    dprintf(DPRINTF_DEFAULT, "LoadProcAddresses BE 0x%08X\n", (UINT32)pEntry);

    /* Load the BE static address. */
    for (index1 = 0; index1 < PROC_ADDRESS_TABLE_MAX_ENTRIES; ++index1)
    {
        if (pEntry->len > 0)
        {
            if (memcmp(pEntry->id, PROC_ADDRESS_TABLE_ENTRY_ID_II, 8) == 0)
            {
                /* Get the BE PCI address for the II entry. */
                addr = (UINT32)pEntry->addr;
                dprintf(DPRINTF_DEFAULT, "LoadProcAddresses pProc_BEII 0x%08X\n", addr);
                pProc_BEII = (II *)addr;
            }
        }
        pEntry++;
    }

    /*
     * Calculate the address of the first entry in the table. The
     * table starts with a header followed by the entries and the
     * base address is not a PCI address so it needs to be converted
     * before being used.
     */
    addr = (UINT32)ToPCIAddr(PROC_ADDRESS_TABLE_ADDR, CalcPCIOffset(PROCESS_FE));
    addr += sizeof(PROC_ADDRESS_TABLE_HEADER);
    pEntry = (PROC_ADDRESS_TABLE_ENTRY *)addr;

    dprintf(DPRINTF_DEFAULT, "LoadProcAddresses FE 0x%08X\n", (UINT32)pEntry);

    /* Load the FE static addresses. */
    for (index1 = 0; index1 < PROC_ADDRESS_TABLE_MAX_ENTRIES; ++index1)
    {
        if (pEntry->len > 0)
        {
            if (memcmp(pEntry->id, PROC_ADDRESS_TABLE_ENTRY_ID_II, 8) == 0)
            {
                /* Get the FE PCI address for the II entry. */
                addr = (UINT32)pEntry->addr;
                dprintf(DPRINTF_DEFAULT, "LoadProcAddresses pProc_FEII 0x%08X\n", addr);
                pProc_FEII = (II *)addr;
            }
            else if (memcmp(pEntry->id, PROC_ADDRESS_TABLE_ENTRY_ID_FE_NVRAM_P4, 8) == 0)
            {
                /*
                 * The FE NVA is a NVRAM address and does not need to
                 * be converted to a PCI address.
                 */
                pProc_FENVA = (void *)pEntry->addr;
                length_FENVA = pEntry->len;
            }
        }
        pEntry++;
    }
}

/**
******************************************************************************
**
**  @brief      Returns a pointer to the BE Processor II structure.
**
**  @param      none
**
**  @return     PROC_II* - pointer to the BE processor II structure.
**
******************************************************************************
**/
II         *GetProcAddress_BEII(void)
{
    return pProc_BEII;
}

/**
******************************************************************************
**
**  @brief      Returns a pointer to the FE Processor II structure.
**
**  @param      none
**
**  @return     PROC_II* - pointer to the FE processor II structure.
**
******************************************************************************
**/
II         *GetProcAddress_FEII(void)
{
    return pProc_FEII;
}

/**
******************************************************************************
**
**  @brief      Returns a pointer to the FE NVA Records.
**
**  @param      none
**
**  @return     PROC_II* - pointer to the FE NVA Records.
**
******************************************************************************
**/
void       *GetProcAddress_FENVA(void)
{
    return pProc_FENVA;
}

/**
******************************************************************************
**
**  @brief      Returns the length of the FE NVA Records.
**
**  @param      none
**
**  @return     UINT32 - length in bytes of the FE NVA records.
**
******************************************************************************
**/
UINT32 GetLength_FENVA(void)
{
    return length_FENVA;
}

/**
******************************************************************************
**
**  @brief  Print out the device info map entry.
**
**  @param  pCount      - pointer to hold the count of devices.
**  @param  ppDevConfig - address to hold the array of devices.
**  @param  shared      - non-zero to allocate from shared memory.
**
**  @return none
**
**  @attention  Caller must free the device configuration array pointed
**              to by ppDevConfig.
**
******************************************************************************
**/
static void print_SES_DEV_INFO_MAP(SES_DEV_INFO_MAP *pDev)
{
    dprintf(DPRINTF_DEFAULT, "SES_DEV_INFO_MAP: \"%8.8s\", \"%16.16s\", 0x%2.2X, 0x%2.2X, 0x%2.2X, 0x%2.2X, 0x%2.2X, 0x%2.2X, 0x%2.2X, 0x%2.2X\n",
        (char *)&(pDev->devVendor[0]), (char *)&(pDev->devProdID[0]),
        pDev->devFlags[0], pDev->devFlags[1], pDev->devFlags[2], pDev->devFlags[3],
        pDev->devFlags[4], pDev->devFlags[5], pDev->devFlags[6], pDev->devFlags[7]);
}

/**
******************************************************************************
**
**  @brief  Load the device configuration information from NVRAM.
**
**  @param  pCount      - pointer to hold the count of devices.
**  @param  ppDevConfig - address to hold the array of devices.
**  @param  shared      - non-zero to allocate from shared memory.
**
**  @return none
**
**  @attention  Caller must free the device configuration array pointed
**              to by ppDevConfig.
**
******************************************************************************
**/
void LoadDeviceConfig(UINT16 *pCount, SES_DEV_INFO_MAP ** ppDevConfig, int shared)
{
    UINT32      index1;
    UINT16      flashCount;
    FLASH_DEVICE_CONFIG *pFlashConfig;
    UINT32      iDefaults;
    SES_DEV_INFO_MAP *pDefaultDev;
    SES_DEV_INFO_MAP *pDev;
    bool        bDefault;

    pFlashConfig = (FLASH_DEVICE_CONFIG *)FLASH_DEVICE_CONFIG_START_ADDRESS;

    /*
     * The flash sector does not contain the correct magic number then
     * assume the flash is not valid.
     */
    if (pFlashConfig->magicNumber != DEVICE_CONFIG_MAGIC_NUMBER)
    {
        LogMessage(LOG_TYPE_DEBUG, "DEVCONFIG-Invalid flash magic number");
        flashCount = 0;
    }
    else
    {
        flashCount = pFlashConfig->count;
    }

    /*
     * Allocate enough information to hold all the default devices and
     * the number of devices currently in the flash.
     */
    if (shared == 0)
    {
        *ppDevConfig = MallocWC(sizeof(*pDefaultDev) * (flashCount + DEFAULT_DEV_INFO_COUNT));
    }
    else
    {
        *ppDevConfig = MallocSharedWC(sizeof(*pDefaultDev) * (flashCount + DEFAULT_DEV_INFO_COUNT));
    }

    /*
     * Update the count of devices and copy the default devices into
     * the output buffer.
     */
    *pCount = DEFAULT_DEV_INFO_COUNT;
    memcpy(*ppDevConfig, gDefaultDevInfoMaps, sizeof(gDefaultDevInfoMaps));

    /*
     * Loop through all the devices in flash configuration and determine
     * if they are a default item or new. If they are new they get added
     * to the output buffer.
     */
    for (index1 = 0; index1 < flashCount; index1++)
    {
        bDefault = false;
        pDev = &pFlashConfig->map[index1];

        /*
         * Loop through each of the default devices to determine if the
         * device is one of the defaults.
         */
        for (iDefaults = 0; iDefaults < DEFAULT_DEV_INFO_COUNT; ++iDefaults)
        {
            pDefaultDev = &gDefaultDevInfoMaps[iDefaults];

            if (strncmp((char *)(&pDefaultDev->devVendor), (char *)(&pDev->devVendor), 8) == 0 &&
                strncmp((char *)(&pDefaultDev->devProdID), (char *)(&pDev->devProdID), 16) == 0)
            {
                /* Copy in the flash items data values -- overwrite the compiled in defaults. */
                memcpy(&((*ppDevConfig)[iDefaults]), pDev, sizeof(*pDev));
                print_SES_DEV_INFO_MAP(pDev);
                bDefault = true;
                break;
            }
        }

        /*
         * If the device is not a default device, add it to the flash
         * configuration.
         */
        if (!bDefault)
        {
            memcpy(&((*ppDevConfig)[*pCount]), pDev, sizeof(*pDev));
            print_SES_DEV_INFO_MAP(pDev);

            (*pCount)++;
        }
    }
}

/**
******************************************************************************
**
**  @brief      Save the device configuration information into NVRAM.
**
**  @param      UINT16 count - count of devices.
**  @param      SES_DEV_INFO_MAP* pDevConfig - pointer to the array of devices.
**
**  @return     none
**
******************************************************************************
**/
void SaveDeviceConfig(UINT16 count, SES_DEV_INFO_MAP *pDevConfig)
{
    UINT32      index1;
    UINT32      flashConfigSize;
    FLASH_DEVICE_CONFIG *pFlashConfig;
    UINT32      iFlashDev;
    SES_DEV_INFO_MAP *pFlashDev;
    SES_DEV_INFO_MAP *pDev;
    bool        bFlashDev;
    int         rc;
    UINT32      maxDeviceCount;

    /*
     * Caclulate the maximum number of devices that can be entered into
     * the flash sector.
     *
     * SECTOR SIZE - SIZE OF BASE STRUCTURE / SIZE OF AN ENTRY
     */
    maxDeviceCount = (CCB_FLASH_LARGE_SECTOR_SIZE - sizeof(*pFlashConfig)) /
        sizeof(*pFlashDev);

    /* Calculate the size of the flash device configuration. */
    flashConfigSize = sizeof(*pFlashConfig) +
        (sizeof(*pFlashDev) * (DEFAULT_DEV_INFO_COUNT + count));

    /*
     * Allocate enough space to hold all the default values and the
     * entire list of devices passed in.
     */
    pFlashConfig = MallocWC(flashConfigSize);

    /*
     * Update the count of devices and copy the default devices into
     * the flash configuration.
     */
    pFlashConfig->magicNumber = DEVICE_CONFIG_MAGIC_NUMBER;
    pFlashConfig->count = DEFAULT_DEV_INFO_COUNT;
    memcpy(pFlashConfig->map, gDefaultDevInfoMaps, sizeof(gDefaultDevInfoMaps));

    /*
     * Loop through all the devices in the list passed in and determine
     * if they are a default item or new. If they are new they get added
     * to the flash configuration.
     */
    for (index1 = 0; index1 < count; index1++)
    {
        bFlashDev = false;
        pDev = &pDevConfig[index1];

        /*
         * Loop through each of the default devices to determine if the
         * device is one of the defaults.
         */
        for (iFlashDev = 0; iFlashDev < pFlashConfig->count; ++iFlashDev)
        {
            pFlashDev = &pFlashConfig->map[iFlashDev];

            if (strncmp((char *)(&pFlashDev->devVendor), (char *)(&pDev->devVendor), 8) == 0 &&
                strncmp((char *)(&pFlashDev->devProdID), (char *)(&pDev->devProdID), 16) == 0)
            {
                /* Copy in the new items data values -- overwrite what we have. */
                memcpy(&pFlashConfig->map[iFlashDev], pDev, sizeof(*pDev));
                bFlashDev = true;
                break;
            }
        }

        /* If the device is not already in the flash configuration, add it. */
        if (!bFlashDev)
        {
            memcpy(&pFlashConfig->map[pFlashConfig->count], pDev, sizeof(*pDev));

            pFlashConfig->count++;
        }

        if (pFlashConfig->count == maxDeviceCount)
        {
            LogMessage(LOG_TYPE_DEBUG, "DEVCONFIG-Maximum entries reached (%d of %d)",
                       index1, count);
            break;
        }
    }

    /*
     * Recalculate the size of the flash device configuration based on the
     * actual number of devices added to the flash configuration.
     */
    flashConfigSize = sizeof(*pFlashConfig) + (sizeof(*pFlashDev) * pFlashConfig->count);

    /*
     * Only if the flash configuration size is less than a sector will
     * the data get entered into flash.
     */
    if (flashConfigSize <= CCB_FLASH_LARGE_SECTOR_SIZE)
    {
        /* Write the new data for the device configuration flash sector */
        rc = CCBFlashProgramData((CCB_FLASH *)FLASH_DEVICE_CONFIG_START_ADDRESS,
                            (CCB_FLASH *)pFlashConfig,
                            flashConfigSize / 4);

        if (rc != GOOD)
        {
            LogMessage(LOG_TYPE_DEBUG, "DEVCONFIG-Failed to write flash data (0x%x)", rc);
        }
    }
    else
    {
        LogMessage(LOG_TYPE_DEBUG, "DEVCONFIG-Config size exceeded flash sector (%d)",
                   flashConfigSize);
    }

    Free(pFlashConfig);
}

/*----------------------------------------------------------------------------
** Function:    GetCPUCount()
**
** Description: Get the count of the physical CPU's in a controller.
**
** Inputs:      none
**
** Returns:     The number of CPU's. 0 if unknown.
**
**--------------------------------------------------------------------------*/
#define MAX_CPU_COUNT 16

UINT32 GetCPUCount(void)
{
    INT32       rc;
    static UINT32 linuxCpuCount = 0;
    UINT32      num;
    UINT32      physID[MAX_CPU_COUNT];  /* array of physical ID's */
    UINT32      seenIt;
    UINT32      i;

    FILE       *pF;
    char        pLine[256];             /* this should be more than we need */
    char       *pIdx;
    const char *pField = "physical id";
    UINT32      fLen = strlen(pField);

    if (linuxCpuCount != 0)
    {
        return linuxCpuCount;
    }

    /* Read and parse /proc/cpuinfo */
    pF = fopen("/proc/cpuinfo", "r");
    if (pF)
    {
        while (fgets(pLine, 256, pF))
        {
            pIdx = pLine;
            rc = memcmp(pIdx, pField, fLen);
            if (rc)
            {
                continue;
            }
            else
            {
                pIdx = index(pLine, ':');
                if (pIdx)
                {
                    pIdx++;
                    rc = sscanf(pIdx, "%u", &num);
                    if (rc != 1)
                    {
                        /* Hmm, couldn't convert number */
                        linuxCpuCount = 0;
                        break;  /* to bottom of while loop */
                    }

                    /* Look to see if we've seen this id before */
                    seenIt = 0;
                    for (i = 0; i < linuxCpuCount; i++)
                    {
                        if (physID[i] == num)
                        {
                            /* already seen this one */
                            seenIt = 1;
                        }
                    }

                    /* Nope, haven't seen it, add it to our list */
                    if (seenIt == 0 && linuxCpuCount < MAX_CPU_COUNT)
                    {
                        physID[linuxCpuCount] = num;
                        linuxCpuCount++;
                    }
                }
                else
                {
                    /* Hmm, no ':' */
                    linuxCpuCount = 0;
                    break;      /* to bottom of while loop */
                }
            }
        }
        Fclose(pF);
    }
    else
    {
        dprintf(DPRINTF_DEFAULT, "GetCPUCount: couldn't open /proc/cpuinfo, errno %d\n",
                errno);
    }

    return linuxCpuCount;
}

/**
******************************************************************************
**
**  @brief  Returns the Linux kernel version string.
**
**  @param  pBuf  - pointer to where string is to be copied
**  @param  len   - size of buffer pointed to by pBuf
**
**  @return none
**
******************************************************************************
**/
void GetKernelVersion(char *pBuf, UINT32 len)
{
    FILE       *pF;
    int         ret;
    char        pLine[256];     /* This should be more than we need */
    char        version[64] = "unknown";

    /* Read and parse /proc/version to get the Linux kernel version */

    pF = fopen("/proc/version", "r");
    if (!pF)
    {
        fprintf(stderr, "%s: couldn't open /proc/version, errno %d\n", __func__, errno);
        goto out;
    }

    if (!fgets(pLine, 256, pF))
    {
        fprintf(stderr, "%s: fgets failed\n", __func__);
        goto out;
    }

    ret = sscanf(pLine, "%*s%*s%64s", version);
    if (ret != 1)
    {
        fprintf(stderr, "%s: failed to parse /proc/version\n", __func__);
    }

  out:
    strncpy(pBuf, version, len);
    pBuf[len - 1] = 0;          /* Ensure termination */

    if (pF)                     /* If file open */
    {
        Fclose(pF);             /* Be sure to close file */
    }

    return;
}

/**
******************************************************************************
**
**  @brief      Emulate the Bigfoot environmental behavior
**
**  @param      whichBufferBoard - which board to shut down
**  @param      shutdownValue - shutdown or restore
**
**  @return     GOOD or ERROR
**
******************************************************************************
**/
UINT32 BufferBoardShutdownControl(void)
{
    UINT32      returnCode = ERROR;
    INT32       rc = PI_GOOD;
    PI_STATS_BUFFER_BOARD_REQ reqData = { 0 };
    PI_STATS_BUFFER_BOARD_RSP *pResponse = NULL;
    PI_PACKET_HEADER reqHdr;
    PI_PACKET_HEADER rspHdr;
    XIO_PACKET  reqPacket = { &reqHdr, (UINT8 *)&reqData };
    XIO_PACKET  rspPacket = { &rspHdr, NULL };

    memset(&reqHdr, 0, sizeof(reqHdr));
    memset(&rspHdr, 0, sizeof(rspHdr));
    dprintf(DPRINTF_IPMI, "BufferBoardShutdownControl\n");

    /*
     * The MicroMemory board doesn't have a POWER_ON command. The only
     * way to get the MM board back active is to cycle the 5 volts in
     * the system via a power cycle.
     */

    /* Set up the header for the PI call */
    reqPacket.pHeader->commandCode = PI_STATS_BUFFER_BOARD_CMD;
    reqPacket.pHeader->length = sizeof(reqData);

    /* We're getting the board information only */
    reqData.commandCode = NVRAM_BOARD_COMMAND_SHUT_DOWN;

    /* Issue the command through the packet command handler */
    rc = PacketCommandHandler(&reqPacket, &rspPacket);
    if (rc == PI_GOOD)
    {
        pResponse = (PI_STATS_BUFFER_BOARD_RSP *)rspPacket.pPacket;
        PrintNVRAMBoardInfo(&(pResponse->boardInfo));

        /* Return good status if the board was shut down successfully */
        if (pResponse->boardInfo.boardStatus == NVRAM_BOARD_STATUS_SHUT_DOWN)
        {
            dprintf(DPRINTF_DEFAULT, "Board has been shut down\n");

            /*
             * Set a flag to remember that the buffer boards have
             * been shut down by the CCB software.
             */
            returnCode = GOOD;
        }
        else
        {
            dprintf(DPRINTF_DEFAULT, "ERROR: Board reports non-shutdown mode\n");
        }
    }
    else
    {
        dprintf(DPRINTF_DEFAULT, "Error sending shutdown command\n");
    }

    /*
     * Done with the response packet
     * If a timeout occurred keep the response packet around -
     * the timeout code will free it.
     */
    if (rc != PI_TIMEOUT)
    {
        Free(rspPacket.pPacket);
    }

    dprintf(DPRINTF_IPMI, "BufferBoardShutdownControl - returning %d\n", returnCode);

    return (returnCode);
}

/**
******************************************************************************
**
**  @brief      Print the NVRAM board information
**
**  @param      whichBufferBoard - which board to shut down
**  @param      shutdownValue - shutdown or restore
**
**  @return     GOOD or ERROR
**
******************************************************************************
**/
static UINT32 PrintNVRAMBoardInfo(NVRAM_BOARD_INFO *pBoardInfo)
{
    UINT32      counter;

    if (pBoardInfo != NULL)
    {
        dprintf(DPRINTF_IPMI, "MM Board Status\n");
        dprintf(DPRINTF_IPMI, "  boardInfo:             %p\n", pBoardInfo);
        dprintf(DPRINTF_IPMI, "    boardStatus:         0x%08x\n",
                pBoardInfo->boardStatus);
        dprintf(DPRINTF_IPMI, "    revision\n");
        dprintf(DPRINTF_IPMI, "      major:             0x%08x\n",
                pBoardInfo->revision.major);
        dprintf(DPRINTF_IPMI, "      minor:             0x%08x\n",
                pBoardInfo->revision.minor);
        dprintf(DPRINTF_IPMI, "    memorySize:          0x%08x\n",
                pBoardInfo->memorySize);
        dprintf(DPRINTF_IPMI, "    memoryErrorCount:    0x%08x\n",
                pBoardInfo->memoryErrorCount);
        dprintf(DPRINTF_IPMI, "    batteryCount:        0x%08x\n",
                pBoardInfo->batteryCount);

        for (counter = 0; counter < NVRAM_BOARD_MAX_BATTERIES; counter++)
        {
            dprintf(DPRINTF_IPMI, "    Battery %d\n", counter);
            dprintf(DPRINTF_IPMI, "      status:            0x%08x\n",
                    pBoardInfo->batteryInformation[counter].status);
            dprintf(DPRINTF_IPMI, "      voltage:           0x%08x\n",
                    pBoardInfo->batteryInformation[counter].voltage);
            dprintf(DPRINTF_IPMI, "      chargePercent:     0x%08x\n",
                    pBoardInfo->batteryInformation[counter].chargePercent);
        }
        return (GOOD);
    }
    return (ERROR);
}

/***
** Modelines:
** Local Variables:
** tab-width: 4
** indent-tabs-mode: nil
** End:
** vi:sw=4 ts=4 expandtab
**/
