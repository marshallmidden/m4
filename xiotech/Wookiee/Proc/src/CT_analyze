#!/usr/bin/perl -w

=pod

=begin _no_way

Date of last edit - 2005-02-04@09:37:09

=end _no_way

=cut

=head1 F<CT_analyze>

The document F<CT_DOC> contains the following sections:

    Contents
       1.  Getting started.
       2.  CT_analyze description.
       3.  Needed inputs.
       4.  gdb use.
       5.  prototype file format.
       6.  CT_analyze options.
       7.  Creating i960 assembly source from .c program.
       8.  Compiler options for i386 gcc.
       9.  Makefile for using CT_analyze.
       10. Things that can't work without a lot of work.
       11. START_SH_DATA_SECTION, END_SH_DATA_SECTION
       12. Using CT_analyze for front-end and back-end code.

Section 6. describes F<CT_analyze> command line options.

The documentation that follows is for perl subroutine usage within the F<CT_analyze> program.

=cut

use strict;

=head1 Global variable section

The first section has the -W option (warning) variables that are available on the command line.

=cut

my $option_W_all = 0;                   # -Wall for turning on all warnings.
my $option_W_set_before_use = 0;        # A const in ".set" is used before set.
my $option_W_code_label_in_data = 0;    # A label in code section used in data section.
my $option_W_data_label_in_goto = 0;    # A data section label used in a goto.
my $option_W_data_label_in_call = 0;    # A data section label used in a call.
my $option_W_external_label_in_load_or_store = 0;
my $option_W_external_label_in_long = 0;
my $option_W_call_to_register = 0;      # If doing a call to a register.
my $option_W_call_expression = 0;       # if doing a call to an expression.
my $option_W_goto_register = 0;         # if a goto to a register.
my $option_W_goto_expression = 0;       # if doing a goto to an expression.
my $option_W_multiple_global = 0;       # if doing a .global multiple times.
my $option_W_org_pseudo_op = 0;         # if using a .org.
my $option_W_data_in_text_section = 0;  # if doing a data definition in .text section.
my $option_W_external_and_constant = 0; # If a .set and external done. (used before .set, etc.)
my $option_W_globl_nothing = 0;         # Doing a .globl, but name not label, set, etc.
my $option_W_fp_r0_r2_changed = 0;      # Doing something to change fp,r0,r2 directly or indirectly.
my $option_W_external_routine_used_as_variable = 0;
my $option_W_moving_to_data = 0;        # Warn if moving label to .data section.

=begin

The second section has the command line options that are not -W.
These include output filename, i386 or mips "c" code, -I, -Include,
and various other options for debug/performance, or debugging.
$main_program_name is computed from the C<-o outputfile> name.

=end

=cut

my $default_outputfile = 'a.out.CT.c';  # output file specification put here.
my $option_outputfile = $default_outputfile;    # output file specification put here.
my $option_i386 = 0;                    # pseudo-ops for i386 gcc.
my $option_mips = 0;                    # pseudo-ops for mips gcc.
my $option_L_local = 0;                 # if label starts with L, local to file.
my @option_I;                           # -I other directories for "files".
my @option_Include;                     # -Include options.  Directories to look for files.
my @not_opt;                            # ARVG's that aren't options -- i.e. files.
my $option_debug_labels = 0;            # -debug_labels prints out a line at each label.
my $option_debug_registers = 0;         # -debug_registers prints registers after each "line".
my $option_no_line_numbers = 0;         # -no_line_numbers, do not print out "# NNN "file".
my $option_no_assembler_comments = 0;   # Do not print out the assembler in comments.
my $option_assumes_works = 0;           # Do not put out error code if we "assume it works".
my $option_no_leading_underscore = 0;   # If a label has a leading underscore, delete it.
my $option_fullpath = '';               # Put full path names into '# NNN "filename"' lines.
my $option_all_asm_labels = 0;          # If set, put asm labels on all goto labels.
my $option_g_reg_proto_special = 0;     # If set, allow special prototype format (g5=void* ...).
my $option_CA_register_save_restore = 0; # If set, put in register save & restore for C to A.
my $option_AC_register_save_restore = 0; # If set, put in register save & restore for A to C.
my $option_check_r_reg_pattern_match = 0; # If set, generate code checking r register for pattern match.
my $option_save_memory_stored = 0;      # If set, save via CT_history_store(x,y) all stores.
my $option_check_local_memory = 0;      # If set, load & stores only to "local memory"
my $NO_MEMORY_ADDRESS_LOCAL_CHECK;      # Allow above to be disabled.
my $option_disable_question_mark = 0;   # If set, do not allow ? to disable memory check.
my $NO_CHECK_MEMORY_PATTERNS;           # Allow loads to not be checked for freed patterns (0).
my $main_program_name;                  # Name of main program (from file name).

=begin

The third section has global variables for the prototype file.
This includes the prototype file name, generated glue "c" code,
and "goto" labels that the glue routines call.

=end

=cut

my $proto_filename;                     # File containing prototype descriptions
my @proto_body;                         # Body of all prototypes
my @goto_label;                         # List of all internal goto labels.

=begin

The fourth section has global variables for keeping track of where we are in the source.
Filename, nested file count, linenumber.

=end

=cut

my $filename;                           # My current filename
my @filename;                           # Stack of enclosing filenames
my $filecount;                          # Used for labels with . to be unique.

my $linenumber;                         # Line number within filename
my @linenumber;                         # Stack of enclosing line numbers

=begin

The fifth section has global variables for parsing the input line into C<$opcode>>> and
C<@operands>, the C<$last_label> processed, tables for opcodes in the different sections,
register names and a number associated with a register (for the
next register in multi-register operations).
There is a global for the next file to include ("if"), and an array of already
included files, and an exitvalue that is set to non-zero if an error occurs.

=end

=cut

my $input;                              # Input line

my $opcode;                             # Opcode field contents
my @operand;                            # Array of operands
my $last_label;                         # Last label processed.

my %code_opcode;                        # Opcode hash for .text section
my %data_opcode;                        # Opcode hash for data sections
my %shmem_opcode;                       # Opcode START_SH_DATA_SECTION -> END_SH_DATA_SECTION

my @regname;                            # Register names
my %regnum;                             # Register numbers

my $do_include;                         # Include file to process
my %already_included;                   # Do not include a file twice -- fix lomem.

my $exitvalue = 0;                      # exit with this value.

=begin

The sixth section has global variables for processing the .if, .else, .endif pseudo-ops.
NOTE: missing endif's are not checked when reach end of file.

=end

=cut

my $normal_list = 0;                    # Allow anything.
my $else_list = 1;                      # .if false, is there an else?
my $endif_list = 2;                     # only .endif allowed (.else false)
my $almost_normal_list = 3;             # else not allowed.
my $ifnoprocess_list = 4;               # in a .if that we are not processing.
my @lookingfor;                         # nested list.
my $lookingfor;                         # we are processing, do anything.

=begin

The seventh section has global variables for processing "c".
This includes the C<$pass_number>, C<$external_c_file>, C<$external_s_file>,
%const which contains the .set pseudo-op variables and values, and %const_count
which counts how many times each %const is initialized.
%global for .globl pseudo-ops, $autolabel for the last internally generated
"automatic" branch label.
$section is the section that we are currently working on.
%defines holds the -D command line definitions.

$GFILE, $HFILE, and $SPECIAL_FILE are for goto's in data section,
external data defined here, and LC routines that are jumped/loaded
instead of called from "c".

=end

=cut

# Set following for each file/pass processed as appropriate.
my $pass_number;                        # Which pass through file processing.
my $external_c_file;                    # The "c" source put here (from i960 assembler).
my $external_s_file;                    # The "s" source put here (from i960 assembler).
my $GFILE;                              # GOTO labels in .data section.
my $GFILE_COUNT = 0;                    # Count of lines to output.
my $HFILE;                              # external data referenced, and global data defined in here.
my $HFILE_COUNT = 0;                    # Count of lines to output.
my $SPECIAL_linenumber = 0;             # For "c" routines jumped or loaded instead of called.
my $SPECIAL_FILE = '';                  # For "c" routines jumped or loaded instead of called.
my %const;                              # .set pseudo-ops's put values here.
my %const_count;                        # Count of number times variable set.
my %const_2;                            # pass 1's consts for pass2 re-check.
my %const_2_count;                      # pass 1's count of const set for pass2.
my %defines;                            # -D options as command argument(s).
my %global;                             # .globl (.global) pseudo-ops.
my $section = 'text';                   # Not in a section, error?
my %sections;                           # The known sections.
my $autolabel;                          # Last generated "automatic" branch label

=begin

The eighth secontion has variables defined as a "c" enum for how each
label in C<%label> is used.
C<%AC_labels> are labels defined as "glue" routines, and need to have "asm" labels attached.
C<%C_variables> are lines in the prototype file starting with "Variable".
These labels need C<extern>al variable definitions for the i960 translated assembler.
C<%LA_label> are the labels in i960 assembler needed by "c" for later asm use (call/branch, load/store).

=end

=cut

my $L_defined_code = 1;                 # label defined in code
my $L_defined_data = 2;                 # label defined in data section
my $L_used_data = 4;                    # label used in data section
my $L_used_goto = 8;                    # label used in a goto.
my $L_used_ret = 16;                    # label used for ret after call.
my $L_used_call = 32;                   # label used in a call.
my $L_used_load = 64;                   # label used in a load (??).
my $L_used_store = 128;                 # label used in a store (??).
my $L_used_text_data = 256;             # label used in data that is in text section.
my $L_extra_asm_2_c_code = 512;         # label used in load/store, but is external "c".
my $L_label_must_data = 1024;           # label has .word, etc after it.  Put in data section.
my $L_used_in_code = $L_used_goto | $L_used_call | $L_used_ret |
                $L_used_load | $L_used_store | $L_used_text_data;
my %labels;                             # labels defined.
##++ my %labels_count;			# Count of label use.
my %AC_labels;                          # labels defined as "glue" routines.
my %C_variables;                        # memory defined in "c".
my %LA_label;                           # labels defined in i960 asm, needed by c for asm use.

=begin

The ninth contains for each section (.text, .data, ...) a global %save_section
entry where the output lines are tacked on.
$save_section_one is a flag to force the next line into the .text section, needed
for nested include printing of the preprocessor file-line-number line.
%save_section_count is the line count for the section.

=end

=cut

my %save_section;                       # output these after "c" program.
my $save_section_one = 0;               # non-zero = print this line "now".
my %save_section_count;

=begin

Tenth section has variables for use in C<put_linenumber()> to know if we
have changed input files, sections, or lines.
This allow us to delete blank lines and comment lines from the output, if desired.

=end

=cut

my $last_filename = '';                 # for printing out line numbers before lines.
my $last_linenumber = -1;
my $last_section = '';

=begin

Eleventh section has the $ASM and $ASMV variables define how the "asm" and "asm volatile" look for gcc.

=end

=cut

my $ASM = 'asm';
my $ASMV = 'asm volatile';

=begin

Twelveth section defines the $used_cmps variable, which is set to non-zero if
any instruction is used that needs the two compare variables cmp_tmp0 and
cmp_tmp1 defined.

=end

=cut

my $used_cmps = 0;                      # do not generate variables if not used.
#my $used_order = 0;                    # do not generate variable if not used.

=begin

Thirteenth section defines the %change_label array, which allows a label to be
changed from one name to another.

=end

=cut

my %change_label;                       # Change these names to something else.

=begin

Fourteenth section defines $atable and $stable variables, which are the
last names generated within a "tablename" m4 macro.

=end

=cut

my $atable = '';                        # action table name.
my $stable = '';                        # state table name.

=begin

Fifteenth section defines the $shdata_section_save, $shdata_byte_count_total,
$shdata_byte_count, and $shdata_count variables, which are used within the
C<START_SH_DATA_SECTION> and C<END_SH_DATA_SECTION> macros.
They keep track of the number of bytes generated, and then later create
a table of "from", "to", and "length" for initialization in the main program.

=end

=cut

my $shdata_section_save;                # If in .shdata, previous section saved.
my $shdata_byte_count_total;            # byte count of current .shdata section.
my $shdata_byte_count;                  # count since last label put out.
my $shdata_count = 0;                   # number of different .shdata entries.

##############################################################################

=head1 Initialize register list.

The i960 registers g0 through g15, and r0 through r15 are defined in an
associate array C<regname> for indexed use in associate array C<regnum>.
This makes a unique internal number for each register, and allows for getting
the next register in a multi-register instruction by incrementation
(i.e. g4 and g5 on a C<movl>).
Additionaly, fp, pfp, sp, and rip are defined as additional names for
g15, r0, r1, and r2 respectively.

=cut

##############################################################################

@regname = qw( g0 g1 g2 g3 g4 g5 g6 g7 g8 g9 g10 g11 g12 g13 g14 g15
               r0 r1 r2 r3 r4 r5 r6 r7 r8 r9 r10 r11 r12 r13 r14 r15 );

for (my $i = 0; $i <= $#regname; $i++) {
  $regnum{$regname[$i]} = $i;
}

# The following are additional names for certain registers.
$regnum{'fp'} = $regnum{'g15'};
$regnum{'pfp'} = $regnum{'r0'};
$regnum{'sp'} = $regnum{'r1'};
$regnum{'rip'} = $regnum{'r2'};


#-----------------------------------------------------------------------------
# Subroutines start.
#-----------------------------------------------------------------------------
##############################################################################

=head1 Subroutine C<printregisters> creates a line of output to the C file
that prints out the contents of all registers to standard error.  It is
called after each i960 assembler line.
If C<$option_debug_registers> is not set (zero), exit instead.

=over

=item Z<>

=item Input:

None.

=item Output:

Code to insert into the C file.

=item Globals:

None directly used nor changed.

=item Execution:

Uses contents of all g and r registers.

=back

=cut

##############################################################################
sub printregisters()
{
  if ($option_debug_registers == 0) {
    return('');
  }
  my $code;
  $code = ' fprintf(stderr, "%-8.8lx %-8.8lx %-8.8lx %-8.8lx %-8.8lx %-8.8lx %-8.8lx %-8.8lx %-8.8lx %-8.8lx %-8.8lx %-8.8lx %-8.8lx %-8.8lx %-8.8lx %-8.8lx\n", greg[0], greg[1], greg[2], greg[3], greg[4], greg[5], greg[6], greg[7], greg[8], greg[9], greg[10], greg[11], greg[12], greg[13], greg[14], greg[15]); fprintf(stderr, "%-8.8lx %-8.8lx %-8.8lx %-8.8lx %-8.8lx %-8.8lx %-8.8lx %-8.8lx %-8.8lx %-8.8lx %-8.8lx %-8.8lx %-8.8lx %-8.8lx %-8.8lx %-8.8lx\n", rreg[0], rreg[1], rreg[2], rreg[3], rreg[4], rreg[5], rreg[6], rreg[7], rreg[8], rreg[9], rreg[10], rreg[11], rreg[12], rreg[13], rreg[14], rreg[15]);' . "\n";
}


##############################################################################

=head1 Subroutine C<printdebugp> will create a debug line of output to the C
file. The line calls routine C<CT_history> with the argument passed in, with a
newline added to the text of the argument. Compute the length of the argument
for C<CT_history>.

=over

=item Z<>

=item Input:

0 -Text to pass to C<CT_history()> C execution routine.

=item Output:

Code to insert into the C file.

=item Globals:

None directly used nor changed.

=item Execution:

Will call C<CT_history()> with the argument passed to the routine.

=back

=cut

##############################################################################
sub printdebugp($)
{
  if ($option_debug_labels == 0) {
    return('');
  }
  my $code;
  $code  = 'CT_history("' . $_[0] . '\n");';
}


##############################################################################

=head1 Subroutine C<printdebug> will create a debug line of output to the C
file. The line generated calls C<CT_history1()> .  This routine is called
for each i960 assembler label, and each auto-generated label after a call.

=over

=item Z<>

=item Input:

0 - Text for C<CT_history1()> execution routine.

1 - Eight byte hex value to print with the text.

=item Output:

Code to insert into the C file.

=item Globals:

None directly used nor changed.

=item Execution:

Will call C<CT_history1()> with the two arguments passed to the routine, and
the length of the text.  No newline is added to the text.

=back

=cut

##############################################################################
sub printdebug($$)
{
  if ($option_debug_labels == 0) {
    return('');
  }
  my $code;
  $code  = ' CT_history1("' . $_[0] . '", ' . $_[1] . ');';
}


##############################################################################

=head1 Subroutine C<error> displays an error message with the file and line
number that is currently being parsed.
The second line displayed contains the original i960 input line.

=over

=item Z<>

=item Input:

0 - The error message to print to standard error.

=item Output:

None.

=item Globals:

Sets C<$exitvalue = 1;> to terminate with an error.
Uses C<$pass_number>, C<$filename>, C<$linenumber>, C<$input>.

=item Execution:

Second pass terminates without writing output files.

=back

=cut

##############################################################################
sub error($)
{
  if ($pass_number == 2) {
    print STDERR "$filename:$linenumber: error: $_[0]\n";
    print STDERR "\t$input\n";
    $exitvalue = 1;
  }
}


##############################################################################

=head1 Subroutine C<warning> will display a warning message to standard error
with the file and line number in question, if the option passed in is on (1).
The second line contains the original i960 input line.  A newline is added to
the end of the message text.

=over

=item Z<>

=item Input:

0 - The warning option to check if enabled.

1 - The warning message to display.

=item Output:

None.

=item Globals:

Uses C<$pass_number>, C<$filename>, C<$linenumber>, C<$input>.

=item Execution:

None.

=back

=cut

##############################################################################
sub warning($$)
{
  my $opt = $_[0];
  my $mess = $_[1];

  if ($pass_number == 2 && ($option_W_all == 1 || $opt == 1)) {
    print STDERR "$filename:$linenumber: warning: $mess\n";
    print STDERR "\t$input\n";
  }
}


##############################################################################

=head1 Subroutine C<label_use> fixes a label up to be correct.
If option $option_no_leading_underscore is non-zero then leading underscores are deleted.
It makes sure that it is not a number, nor a hex number, nor a constant.
If the label is already defined, return it's value.  Otherwise use the second
argument to define the type of the label (for checking label use correct in
the second pass for given instruction types).  The kept label is checked when
the external list is written, for incorrect use of the label.


=over

=item Z<>

=item Input:

0 - label to change. (Possibly several.)

1 - Use of the label (call/jump/instruction/bss ...).

=item Output:

Label fixed up if necessary.

=item Globals:

Changes and uses %labels for usage of label.
Uses %const, %const2, %AC_labels for C<-D variable> or C<.set>.

Possible error if defined in data and text section.

=item Execution:

None.

=back

=cut

##############################################################################
sub label_use($$)
{
  my $working = $_[0];
  my $bit_union = $_[1];        # Type of "use" for label.
  my $label = '';

# print STDERR "label input=($working)\n";
  while ($working =~ /(.*?)([0-9a-z_.\$]+)(.*)/i) {
    my $before = $1;
    my $match = $2;
    my $after = $3;
    if ($option_no_leading_underscore != 0) {
      $match =~ s/^_//;         # delete leading underscore.
    }
    if ($match =~ /^\d+U?$/) {
       ;                        # Do not change numbers.
    } elsif ($match =~ /^0[Xx]([0-9a-fA-F]+)(U|LL)$/) {
       $match = "0x" . $1;      # Make hex numbers not be a label.
       $match = expression($match,0);
    } elsif (defined($const{$match})) {
# print STDERR "label($match) is really a constant($const{$match})\n";
      $match = expression($const{$match},0);
    } elsif ($pass_number == 2 && defined($const_2{$match})) {
        $match = expression($const_2{$match},0);
    } else {
      if (defined($AC_labels{$match})) {
        $match = $AC_labels{$match};
# print  STDERR "label_use to AC_labels =>($match)\n";
      }
      if (!defined($labels{$match})) {
        $labels{$match} = $bit_union;
##++         $labels_count{$match} = 0;
# print STDERR "old label 1 $match $labels{$match}\n";
      } else {
        $labels{$match} |= $bit_union;
# print STDERR "old label 2 $match $labels{$match}\n";
        # error if defining a label, and it is in both code and data sections.
        if (($bit_union & ($L_defined_code | $L_defined_data)) != 0 &&
          ($labels{$match} & ($L_defined_code | $L_defined_data)) ==
            ($L_defined_code | $L_defined_data)) {
          error("label $match defined in both code and data section.");
        }
      }
##++       $labels_count{$match}++;
    }
    $label = $label . $before . $match;
    $working = $after;
# print STDERR "   match gave '$before','$match','$after'    label=$label,working=$working\n";
  }
  $label .= $working;
# print STDERR "label output=($label)\n";
  return $label;
}


##############################################################################

=head1 Subroutine C<local_label_name> checks for a label starting with a period (dot).
If only a dot, this is an error.
If option $option_no_leading_underscore is non-zero, delete leading underscore characters.
Change starting period (dot) to C<D_>, and internal periods (dots) into the string C<_D_>.

=over

=item Z<>

=item Input:

0 - label to potentially be changed.

=item Output:

Label with underscores and periods (dots) deleted/changed.

=item Globals:

None changed.
Uses C<$option_no_leading_underscore>, C<$option_L_local>.

=item Execution:

None.

=back

=cut

##############################################################################
sub local_label_name($)
{
  my $label = $_[0];

  if ($label eq '.') {
    error("dot (.) alone as a symbol not done yet.");
    return ('.');
  }
  if ($option_no_leading_underscore != 0) {
    $label =~ s/^_//;                   # delete leading underscore.
  }
  if ($label =~ /^[.]/) {
    $label = 'D_' . substr($label, 1);  # GLOBAL!
  }
  $label =~ s/[.]/_D_/g;                # Dots in middle of name.
  if ($option_L_local != 0 && $label =~ /^L/) {
    $label = 'CT_' . $filecount . '_' . $label;
  }
  return ($label);
}


##############################################################################

=head1 Subroutine C<asm_label_generate> generates the necessary C<asm>
directive to create a label in the "c" generated assembler (x86) output.
This is so that the label can be found with F<gdb>.
There is a problem with gcc optimization copying or moving code into several
places, and thus a C<.ifndef> / C<.endif> is put around the C<asm> directive.

=over

=item Z<>

=item Input:

0 - label to put in the x86 assembler output.

=item Output:

Code to insert into the C file.

=item Globals:

None directly used nor changed.

=item Execution:

Enables F<gdb> to find the label.

=back

=cut

##############################################################################
sub asm_label_generate($)
{
  my $label = $_[0];
  my $code;

  $code  =  $ASMV . '(".ifndef Defined_' . $label . ' ; ';
  $code .=            '.set Defined_' . $label . ',0 ; ';
  $code .=            '.global ' . $label . ' ; ';
  $code .=             $label . ':; .endif"); ';
# The following 2 lines may replace above 4 lines, if we get a gcc 4.3.1 or newer version. *grumble*
#   $code  =  $ASMV . '(".global ' . $label . ' ; ';
#   $code .=             $label . ':;"); ';
  return($code);
}


##############################################################################

=head1 Subroutine C<label_generate> on the first pass will define the label
in global structures as belonging to the code or data section.
The second pass will put the label into the section.
There is a lot of potential error or warning checks done.
The correct prefix for the label is added, such as if a CT_ or CT_GOTO_
depending on a "c" goto label, or a data label.
Checks for labels in the prototype section LA are done.

=over

=item Z<>

=item Input:

0 - Label to generate into "c" code.

=item Output:

Code to insert into the C file for making the label.

=item Globals:

C<$section> may be changed.
Uses C<$option_L_local>, C<$pass_number>, C<%LA_label>, C<%labels>,
C<$last_label>, C<%save_section>, C<$option_W_moving_to_data>,
C<$option_W_code_label_in_data>, C<$option_all_asm_labels>, C<$filecount>.

=item Execution:

Label generated as appropriate for location, section, and as the various
command line option flags dictate, as F<gdb> and F<as> needs.

=back

=cut

##############################################################################
sub label_generate($)
{
  my $label = $_[0];
  my $def = ($section eq 'text') ? $L_defined_code : $L_defined_data;
  my $code = '';

  $label = local_label_name($label);
  if ($pass_number == 2) {
# print STDERR "label_generate $label = $labels{$label}\n";
    if ((($labels{$label} & $L_label_must_data) != 0) || ($labels{$label} & $L_defined_data) != 0) {
      if ($section eq 'text') {
        warning($option_W_moving_to_data,
                "Moving $label to .data section");
        if (!defined($save_section{'data'})) {
          $code  = $ASMV . '(".data");';
        }
        $section = 'data';
        $def = $L_defined_data;
      }
    } else {
      if ($section eq 'text') {
      } else {
        if (!defined($save_section{'text'})) {
          warning($option_W_moving_to_data,
                  "Moving $label to .text section");
#          $code  = $ASMV . '(".text");';
        }
        $section = 'text';
        $def = $L_defined_code;
      }
    }
# print STDERR "label_generate 2 $label = $labels{$label}, def=$def\n";
    $label = label_use($label, $def);
    if ($section eq 'text') {           # label in code section
      if ($option_L_local != 0 && $label =~ /^L/) {
        $label = 'CT_' . $filecount . '_' . $label;
      }
      $code .= 'CT_GOTO_' . $label . ': ';              # "c" style label.
      if (($labels{$label} & ($L_used_data | $L_used_text_data)) != 0) {
      ### If label in text section used in data section, must __asm__ for global.
        $code .= asm_label_generate('CT_GOTO_' . $label);
        warning($option_W_code_label_in_data,
                "Label $label in code section used in data section.");
        if ($option_all_asm_labels == 1) {
          $code .= asm_label_generate('ct_' . $label);
        }
      } else {
      # NOTDONEYET -- Any other reasons to put in asm label ?
        if ($option_all_asm_labels == 1) {
          $code .= asm_label_generate('ct_' . $label);
        }
#        $code .= ';';                                   # force "c" command end.
      }
#--- BAD, jump tables in .text can't have this.---
    } else {                            # label in data section
      if ($option_L_local != 0 && $label =~ /^L/) {
        $label = 'CT_' . $filecount . '_' . $label;
      }
      if (($labels{$label} & $L_used_in_code) != 0) {
        if (($labels{$label} & $L_used_goto) != 0) {    # Goto ??
          warning($option_W_data_label_in_goto,
                "Label $label in data section used in a goto??");
        } elsif (($labels{$label} & $L_used_call) != 0) { # call ??
          warning($option_W_data_label_in_call,
                "Label $label in data section used in a call??");
        } elsif (($labels{$label} & $L_used_ret) != 0) { # ret ??
          error("Label $label in data section used for a ret??");
        }
      }
      $code .= $ASM . '(".globl ' . $label . '");';
      $code .= $ASM . '("' . $label . ':");';
    }
    if (defined($LA_label{$label})) {
      $code .= $ASM . '("' . $LA_label{$label} . ':");';
      $code .= $ASM . '(".globl ' . $LA_label{$label} . '");';
    }
  } else {
    $label = label_use($label, $def);
    $code = ' ';
  }
  $last_label = $label;                 # Last label processed.
  return ($code);
}


########################################################################

=head1 Subroutine C<get_value> converts either a symbol or number to a constant value.
It puts hex or octal constants into a standard format, and deletes fractions.
If the input is a C<.set> or C<-D> value, return that value.
If the value was defined "after" it's first use, return value at the end of pass 1.
Do not change quoted tokens.
Do not change labels or numbers.
If an expression, return it inside a set of parentheses.

=over

=item Z<>

=item Input:

0 - Input token to get value returned.

=item Output:

Changed token, as defined above.

=item Globals:

None changed.
Uses %const_2, %const, %const_2.

=item Execution:

None.

=back

=cut

########################################################################
sub get_value($)
{
    my $name = shift;

    # Convert hex and octal numbers and fractions to decimal.

    if ($name =~ s/^0x([a-f0-9]*)U*L*$/hex($1)/ei ||
		 $name =~ s/^0([0-9]+)$/oct($1)/ei     ||
		 $name =~ s/^([0-9]*)\.[0-9]+$/$1/) {
	# Append "U" to large numbers to avoid compiler warnings.
	if ($name > 0x7fffffff) {
	    $name .= 'U';
	}
	return $name;
    }

    my $value = $const{$name};

    if (!defined($value) && defined($const_2{$name})) {

        $value = $const_2{$name};

        if ($const_2_count{$name} != 1) {
            warning($option_W_set_before_use,
                    ".set $name done $const_2_count{$name} times," .
                    " but not set before use.");
        }
    }

    # If the name is undefined, just return the name.

    return $name if !defined $value;

    # Return the value, if the value is quoted.

    return $value if $value =~ /[\'\"]/;

    # Return the value if it looks like a number.

    if ($value =~ /^-?[0-9]+$/) {
	# Append "U" to large numbers to avoid compiler warnings.
	if ($value > 0x7fffffff) {
	    $value .= 'U';
	}
	return $value;
    }

    # Return the value if it looks like a label or a number.

    return $value if $value =~ /^-?[a-z0-9._\$]+$/;

    # Otherwise assume the value is an expression, and
    # put it in parens to avoid ambiguity.

    return "($value)";
}


########################################################################

=head1 Subroutine C<const_expression> evaluate numeric expressions with
operators the same way GAS evaluates them.

  Unary +,-,~,! first.
  Then *,/,%,E<lt>E<lt>,E<gt>E<gt> second.
  Then |,&,^,! third.
  Then +,-,==,E<lt>E<gt>,E<lt>,E<gt>,E<gt>=,E<lt>= fourth.
  Then && and || lastly.

=over

=item Z<>

=item Input:

0 - expression to evaluate.

1 - a flag, if non-zero then ignore errors.

=item Output:

New expression, possibly similified with constants evaluated.

=item Globals:

None used or changed.

=item Execution:

None.

=back

=cut

########################################################################
sub const_expression($$)
{
    my $e = shift;
    my $ignore_errors = shift;

    # Evaluate unary operators + - ~ !

    1 while $e =~ (s/(?<![0-9])([\#+!~]|--)(-?[0-9]+)/
                              $1 eq '+'  ?  $2 :
                              $1 eq '--' ?  $2 :
                              $1 eq '~'  ? ((~(0+$2))&0xFFFFFFFF) :
                              $1 eq '!'  ? ($2 == 0 ? 1 : 0) :
                              error("internal error")/e);

    # Evaluate high precedence operators * / % << >>

    1 while $e =~ (s/(?<![0-9])(-?[0-9]+)([\/\*%]|<<|>>)(-?[0-9]+)/
                              $2 eq '*'  ? $1 * $3 :
                              $2 eq '\/' ? int($1 \/ $3) :
                              $2 eq '%'  ? int($1 % $3) :
                              $2 eq '<<' ? $1 << $3 :
                              $2 eq '>>' ? $1 >> $3 :
                              error("internal error")/e);

    # Evaluate intermediate precedence operators | & ^ !

    1 while $e =~ (s/(?<![0-9])(-?[0-9]+)([|&^!])(-?[0-9]+)/
                              $2 eq '|' ? (0+$1) |  (0+$3) :
                              $2 eq '&' ? (0+$1) &  (0+$3) :
                              $2 eq '^' ? (0+$1) ^  (0+$3) :
                              $2 eq '!' ? (0+$1) | ~(0+$3) :
                              error("internal error")/e);

    # Evaluate low precedence operators + - == <> < > >= <=

    1 while $e =~ (s/(-?[0-9]+)([\-+<>]|==|<>|>=|<=)(-?[0-9]+)/
                              $2 eq '+'  ? $1 + $3 :
                              $2 eq '-'  ? $1 - $3 :
                              $2 eq '<'  ? ($1 <  $3 ? 1 : 0) :
                              $2 eq '>'  ? ($1 >  $3 ? 1 : 0) :
                              $2 eq '==' ? ($1 == $3 ? 1 : 0) :
                              $2 eq '<>' ? ($1 != $3 ? 1 : 0) :
                              $2 eq '<=' ? ($1 <= $3 ? 1 : 0) :
                              $2 eq '>=' ? ($1 >= $3 ? 1 : 0) :
                              error("internal error")/e);

    # Evaluate lowest precedence operators && and very lowest ||

    1 while $e =~ (s/([0-9]+)\&\&([0-9]+)/$1 && $2 ? 1 : 0/e);

    1 while $e =~ (s/([0-9]+)\|\|([0-9]+)/$1 || $2 ? 1 : 0/e);

    # By now there should be nothing left but a number.

    return $e if $e =~ /^-?[0-9]+$/;

    if ($ignore_errors == 0) {
      error("Strange operators present: $e");
      return 0;
    } else {
      return $e;
    }
}


########################################################################

=head1 Subroutine C<expression> evaluates a general expression.
Of note is that this may be called multiple times with the same expression,
and thus must be able to undo any changes put in for "c" (ULL, etc).

=over

=item Z<>

=item Input:

0 - expression to evaluate.

1 - non-zero if should ignore errors.

=item Output:

Expression potentially simplified, and in the correct format for "c".

=item Globals:

None directly changed or used.
See routines const_expression and get_value.

=item Execution:

None.

=back

=cut

########################################################################
sub expression($$)
{
    my $e = shift;
    my $ignore_errors = shift;
    my $e1 = $e;

    # Accept a quoted string.

    if ($e =~ /[\"\']/) {
        return $e if $e =~ /^".*"$/;
        return $e if $e =~ /^'.'$/;

        return "\"$1\"" if $e =~ /^'(.*)'/;

        if ($ignore_errors == 0) {
          error("Cannot process quotes in expression: $e");
          return 0;
        } else {
          return($e);
        }
    }

    # Convert symbols to decimal values

    my $ee = $e;
    my $count = 0;

    while ($e =~ (s/(?<![0-9a-z._\$])
                  ([a-z._\$][0-9a-z._\$]* | 0[0-7]+ | 0x[0-9a-f]+U*L* | [0-9]+U)
                  (?![0-9a-z._\$])
                  /get_value($1)/igex))
    {
        last if $e eq $ee;

        $ee = $e;

        if (++$count > 100) {
            if ($ignore_errors == 0) {
              error("Recursive symbol definition? $e");
              return 0;
            } else {
              return($e);
            }
        }
    }

    # Remove all white space.

    $e =~ s/\s+//g;

    # Remove any trailing "U" or "LL" after a number.

    $ee = $e;
    $e =~ s/(?<![0-9a-z._\$])([0-9]+)U(?![0-9a-z._\$])/$1/ig;
    $e =~ s/(?<![0-9a-z._\$])([0-9]+)LL(?![0-9a-z._\$])/$1/ig;

    # Exit if some value is undefined.

    return $ee if $e =~ /[a-z._\$]/i;

    # Evaluate parenthesized sub-expressions.

    my $e2 = $e;

    if ($ignore_errors == 0) {          # if "c", do not get rid of parenthesis.
      1 while $e =~ s/\(([^()]*)\)/const_expression($1,$ignore_errors)/ge;
    }

    # Exit on unbalanced parenthesis.

    if ($e =~ /[\(\)]/) {
        if ($ignore_errors == 0) {
          error("Unbalanced parenthesis");
        } else {
          return $ee;
        }
    }

    # Evaluate the entire expression.

    $e = const_expression($e,$ignore_errors);

    # Append "U" to large numbers to avoid compiler warnings.

    $e =~ (s/(?<![0-9a-z._\$])([0-9]+)U?(?![0-9a-z._\$])/
           $1 <= 0x7fffffff ? $1 : "$1U"/eig);

    #print "/* $e1  ==>   $e2  ==>  $e */\n" if $e1 !~ /^[-+a-z0-9_.\$]+$/i;

    return $e;
}


##############################################################################

=head1 Subroutine C<bitpos> returns an operand in i960 bitpos format.
This is either a register or literal.

=over

=item Z<>

=item Input:

0 - Operand number to get.

=item Output:

Simplifed expression representing the operand requested, in "c" format.

=item Globals:

None changed.
%operand used to get the requested operand.

=item Execution:

None.

=back

=cut

##############################################################################
sub bitpos($)
{
  if (!defined($operand[$_[0]])) {
    error('Not enough arguments to command, error on #' . ($_[0]+1) . '.');
    return(' ');
  }
  return (expression($operand[$_[0]],0));
}


##############################################################################

=head1 Subroutine C<src> returns an i960 source register expression.
This is either a register or literal.

=over

=item Z<>

=item Input:

0 - Operand number to get.

=item Output:

Either a register or a simplified expression.

=item Globals:

None changed.
%operand used to get the requested operand.

=item Execution:

None.

=back

=cut

##############################################################################
sub src($)
{
  my $input = $operand[$_[0]];

  if (!defined($input)) {
    error('Not enough arguments to command, error on #' . ($_[0]+1) . '.');
    return(' ');
  }
  if (!defined($regnum{$input})) {
    $input = expression($input,0);
  }
  return ($input);
}


##############################################################################

=head1 Subroutine C<dst> returns an i960 destination register.
Sometimes it is both source and destination.

=over

=item Z<>

=item Input:

0 - Operand number to get.

=item Output:

A register for destination is returned.

=item Globals:

None changed.
%operand used to get the requested operand.

=item Execution:

None.

=back

=cut

##############################################################################
sub dst($)
{
  my $input = $operand[$_[0]];

  if (!defined($input)) {
    error('Not enough arguments to command, error on #' . ($_[0]+1) . '.');
    return(' ');
  }
  if (!defined($regnum{$input})) {
    error("Not a register.")
  }
  ### check if fp or g15 changed anywhere ### optimization planning ####
  if ($regnum{$input} == $regnum{'g15'} ||
      $regnum{$input} == $regnum{'r0'} ||
      $regnum{$input} == $regnum{'r2'}) {
    warning($option_W_fp_r0_r2_changed, 'fp/g15/r0/pfp/r2/rip register as destination.');
  }
  return ($input);
}


##############################################################################

=head1 Subroutine C<local_label> changes the input into the format that labels
need to be for "c", and define it's use methodology (load/store/call/goto/etc.).
For example, change one with periods (dots) gets changed to have 'D_' in their place.
(Calls routines C<local_label_name> and C<label_use>.)

=over

=item Z<>

=item Input:

0 - The label to define and possibly change.

1 - A bit field representing the use of the label.

=item Output:

The new label.

=item Globals:

None changed directly.  See C<local_label_name> and C<label_use>.

=item Execution:

None.

=back

=cut

##############################################################################
sub local_label($$)
{
  my $label = $_[0];
  my $bit_union = $_[1];

  $label = local_label_name($label);
  $label = label_use($label, $bit_union);
  return ($label);
}



##############################################################################

=head1 Subroutine C<add_byte_star> will create a string by putting the first
argument before the second argument, and the third argument last.
The third argument may be a label, upon which it needs to have the right
type of prefix added to it.
Specifically, a goto label needs CT_GOTO_ prepended, and the string S<(byte *)&>
needs an extra S<&> tacked on; that is the gcc syntax for the address of a goto label.
If the label is that of a "glue" routine, it needs CT_GLUE_call_ prepended.
Deleted a possible precending underscore.

=over

=item Z<>

=item Input:

0 - Text to prepend. Normally S<(byte *)&> or S<(byte *)&&>.

1 - Label to check.

2 - Text to be postpended (usually a null string).

=item Output:

New string for "c" getting the address of the label.

=item Globals:

None changed.
Used %change_label, %labels, %AC_labels.

=item Execution:

"c" code for the address of the label is produced.

=back

=cut

##############################################################################
sub add_byte_star($$$)
{
  my $before = $_[0];
  my $chars = $_[1];
  my $label = $_[2];

# This allows fixing "c" special labels.
  if (defined($change_label{$label})) {
    $label = $change_label{$label};
  }
  if (defined($labels{$label})) {
    if (($labels{$label} & $L_defined_code) != 0) {     # label in code section
      $label = 'CT_GOTO_' . $label;
    } elsif (($labels{$label} & $L_used_call) != 0) {
# Label is a "glue routine".
      my $glue = $label;
      $glue =~ s/^_//;
      if (defined($AC_labels{$glue})) {
        $label = $AC_labels{$glue};
# print  STDERR "add_byte_star to AC_labels =>($label)\n";
      } else {
        $label = 'CT_GLUE_call_' . $glue;       # no leading underscore.
      }
    }
    if ($chars ne '') {
      if ($label =~ /^CT_goto_/) {
        $chars .= '&';
      }
    }
  }
  return( $before . $chars . $label );
}


##############################################################################

=head1 Subroutine C<add_amps> calls add_byte_star to do the actual work of
adding ampersands before a label.

=over

=item Z<>

=item Input:

0 - Label that needs ampersands added to it.

1 - If a new label, this is a bit field describing it's usage.

=item Output:

New string for "c" getting the address of the label.

=item Globals:

None changed.
Used $section, %labels.

=item Execution:

"c" code for the address of the label is produced.

=back

=cut

##############################################################################
sub add_amps($$)
{
  my $memory_address = $_[0];
  my $bit_union = $_[1];
  my $label;
  my $before;

# print STDERR "in add_amps($memory_address)  :$input\n";
  if ($section eq 'text' && $bit_union != $L_used_text_data ) {
# In code section, with code.
# print STDERR "in code section with code\n";
    if (defined($labels{$memory_address}) && ($labels{$memory_address} & $L_defined_code) != 0) {
# code label in code needs && in "c".
# print STDERR "a label is directly defined in code section.\n";
      $memory_address =~ s/(^|[^a-z0-9._\$])([a-z._\$][a-z0-9._\$]*)/add_byte_star($1,'(byte *)&&',$2)/gie;
    } elsif (defined($labels{$memory_address}) && ($labels{$memory_address} & $L_defined_data) != 0) {
# data label in code needs & in c.
# print STDERR "data label in code needs & in c\n";
      if (($bit_union & ($L_used_load | $L_used_store)) != 0) {
        $memory_address =~ s/(^|[^a-z0-9._\$])([a-z._\$][a-z0-9._\$]*)/add_byte_star($1,'(byte *)&',$2)/gie;
      } else {
        error("Not doing a load/store to data section label $memory_address");
      }
# external label in code (careful).
    } else {
# print STDERR "external label in code (careful)\n";
      if (($bit_union & ($L_used_load | $L_used_store)) != 0) {
# print STDERR "Doing a load/store to external label\n";
        warning($option_W_external_label_in_load_or_store,
                "Doing a load/store to external label $memory_address");
        if ($memory_address =~ /^CT_GLUE_call_(.*)$/) {
          $memory_address = 'CT_super_special_' . $1;
# print STDERR "undoing label and marking it for special super trailer processing ($memory_address).\n";
          $labels{$memory_address} |= $L_extra_asm_2_c_code;
# print STDERR "add_amps label $memory_address $labels{$memory_address}\n";
          $memory_address = '&' . $memory_address;
        }
      } else {
# print STDERR "Doing a call or goto.\n";
        # call or goto.  Further checks in routines themselves.
      }
      $memory_address =~ s/(^|[^a-z0-9._\$])([a-z._\$&][a-z0-9._\$&]*)/add_byte_star($1,'(byte *)&',$2)/gie;
    }
  } else {
# In data section
# print STDERR "in data section\n";
    # Only need to change goto labels.
    $memory_address =~ s/(^|[^a-z0-9._\$])([a-z._\$][a-z0-9._\$]*)/add_byte_star($1,'',$2)/gie;
  }
  return ($memory_address);
}


##############################################################################

=head1 Subroutine C<add_externals> is a routine that is used as a pattern
substitution with the "gie" options.
Tt is re-executed each time through the global substitution,
ignoring upper/lower case differences.
This routine calls add_amps to have the correct number of ampersands added to
matched label.
It returns a string that is the new string to use, with the correct number of
ampersands added.

=over

=item Z<>

=item Input:

0 - Characters before the label.

1 - Label that needs ampersands added to it.

2 - If a new label, this is a bit field describing it's usage.

=item Output:

New string for getting the address of the label.

=item Output:

Code to insert into the C file.

=item Globals:

None directly used nor changed.

=item Execution:

None.

=back

=cut

##############################################################################
sub add_externals($$$)
{
  my $before = $_[0];
  my $label = $_[1];
  my $bit_union = $_[2];

# print STDERR "add_externals($label)\n";
  return ($before . add_amps($label, $bit_union) );
}


##############################################################################

=head1 Subroutine C<check_external_warning> is called if $extra_warnings is
non-zero.
On pass 2, it checks that a label was defined in pass 1,
and defined in either the code section or the data section.
If it is an external, give an error.
Example usage would be for .long pseudo-op.

=over

=item Z<>

=item Input:

0 - Label to check if an external.

=item Output:

None.

=item Globals:

None changed.
Uses %labels.

=item Execution:

None.

=back

=cut

##############################################################################
sub check_external_warning($)
{
  if ($pass_number != 2) {
    return;
  }
  my $label = $_[0];
  if (defined($labels{$label})) {
# if an external label
    if (($labels{$label} & ($L_defined_code | $L_defined_data)) == 0) {
      warning($option_W_external_label_in_long,
              "label ($label) is an external");
    }
  } else {
    warning(1, "label ($label) is not defined in pass 2?");
  }
}


##############################################################################

=head1 Subroutine C<convert_label_ampamp> adds the correct number of
ampersands to a label.
A goto label in "c" requires two, otherwise one.
Calls local_label, check_external_warning, add_amps, add_externals.
Effectively all labels inside a memory address to have (byte*)&& in front of them.

=over

=item Z<>

=item Input:

0 - The field to potentially add ampersands into.

1 - The bit field for potential first use.

2 - If non-zero, check for potential extra warnings on substitution.

=item Output:

Code to insert into the C file that takes the address of any input labels.

=item Globals:

None changed directly.
Used %labels.

=item Execution:

Code to correctly take the address of the label(s).

=back

=cut

##############################################################################
sub convert_label_ampamp($$$)
{
  my $memory_address = $_[0];
  my $bit_union = $_[1];
  my $extra_warnings = $_[2];

# print STDERR "convert_label_ampamp:$memory_address\n";
# Following is not complete, but should work for i960 existing code.    WARNING
  if ($memory_address =~ /^[+-]*\d+$/ ||
      $memory_address =~ /^'.*'$/ ||
      $memory_address =~ /^".*"$/ ) {
# print STDERR "    Not label($memory_address):($input)\n";
  } else {
# print STDERR "    label($memory_address):($input)\n";
    $memory_address = local_label($memory_address, $bit_union);
# print STDERR "    memory_address=$memory_address\n";
    if (defined($labels{$memory_address})) {
      if ($extra_warnings != 0) {
        check_external_warning($memory_address);
      }
      $memory_address = add_amps($memory_address, $bit_union);
# print STDERR "    a label memory_address=$memory_address\n";
    } else {
# not defined label? (complicated address)
# print STDERR "    complicated memory_address=$memory_address\n";
      $memory_address =~ s/(^|[^a-z0-9._\$])([a-z._\$][a-z0-9._\$]*)/
                    if ($extra_warnings == 0) {
                      add_externals($1,$2,$bit_union);
                    } else {
                     check_external_warning($2);
                     add_externals($1,$2,$bit_union);
                    }
                     /gie;
    }
  }
# print STDERR "    returning $memory_address\n";
  return ($memory_address);
}


##############################################################################

=head1 Subroutine C<CHECK_RREG> prints out the R register if input is one.

=over

=item Z<>

=item Input:

0 - The potential R register.

=item Output:

Character string of the R register.

=item Globals:

None changed.
Uses %regnum.

=item Execution:

Used for debugging to get the R register.

=back

=cut

##############################################################################
sub CHECK_RREG($)
{
# if option is on, or ? at start of line, do not generate call to check registers.
    if ($option_check_r_reg_pattern_match == 0 || $NO_CHECK_MEMORY_PATTERNS == 0) {
        return('');
    }
    my $reg = $_[0];
    if (!defined($reg)) {
        return('');
    }
    if (!defined $regnum{$reg}) {
        return('');
    }
    # Convert to basic name (get rid of aliases).
    $reg = $regname[$regnum{$reg}];
    if ($reg =~ /^r[0-9]+$/) {
# print STDERR "r reg=$reg\n";
        my $code = 'CHECK_RREG_PATTERN("' . "$filename:$linenumber  $opcode " .
                   join(',', @operand) . '    REG=' . $reg . '", ' . $reg . ');';
        return($code);
    }
# print STDERR "NOT r reg=$reg\n";
    return('');
}


##############################################################################

=head1 Subroutine C<mem> gets an i960 "mem" type operand.
This is an expression,
followed by a register indirect reference (surrounded by parentheses),
then a displacement (which is surrounded by square brackets).
The expression usually contains memory address via a label.
For "c", this needs to have the correct number of ampersands added in front
of it.

Example:    ld  abc(r1)[r2*4],r3

Calls expression() and convert_label_ampamp().

=over

=item Z<>

=item Input:

0 - The index of the operand containing the "mem" type operand.

1 - A bit field describing the usage of the "mem" operand (load, store, etc.).

=item Output:

Code for "c" to get at the memory location.

=item Globals:

None changed directly.
Uses %regnum.

=item Execution:

"c" code to get the effective memory address or expression.

=back

=cut

##############################################################################
sub mem($$)
{
    my $m = $operand[$_[0]];
    my $bit_union = $_[1];
    my $code;
    my $memory_address;
    my $displacement;
    my $register_indirect;
    my $pre_code = '';

    if (!defined($m)) {
        error('EA field not present' . ($_[0]+1) . '.');
        return(' ');
    }

    ### Extract the three components of an i960 effective address.

    if ($m =~ (/^
               (?: (.*? [0-9a-z._\$\)\'])   )??
               (?: \( ([a-z0-9]+)         \))?
               (?: \[ ([a-z0-9\*]+)       \])?   $/xi))
    {
        $memory_address = $1;
        $register_indirect = $2;
        $displacement = $3;

        ### Detect incorrect recognition of memory field as indirect
        ### register, and incorrect register specification.

        if (defined($register_indirect) &&
            !defined $regnum{$register_indirect})
        {
            if (!defined($memory_address)) {

                $memory_address = $register_indirect;
                $register_indirect = undef;
                error("Probably misparsed: $memory_address");

            } else {

                error("Not a register: $register_indirect");
            }
        }

        ### Detect incorrect displacement field contents.

        if (defined($displacement)) {
            if ($displacement !~ /^([a-z][a-z0-9]+)(\*\d+)?$/x ||
                 !defined $regnum{$1}) {
                error("Not a register multiply: $displacement");
            } elsif (!defined($2) ||
               ( "$2" ne "*1" &&
                 "$2" ne "*2" &&
                 "$2" ne "*4" &&
                 "$2" ne "*8" &&
                 "$2" ne "*16")) {
                error("Multiply displacement not 1,2,4,8,16: $displacement");
            } else {
                $pre_code .= CHECK_RREG($1);
            }
        }
    } else {

        error("Could not recognize: $m");
    }

    ### Generate code to add together the memory address/offset,
    ### the indirect register, and the displacement fields.

    if (defined($memory_address)) {
        if (defined($regnum{$memory_address})) {
            error("ld needs parentheses around register ($memory_address).");
            $code = 'error on ld instruction';
        } else {
            $memory_address = expression($memory_address,0);
            $memory_address = convert_label_ampamp($memory_address, $bit_union,0);
            $code = $memory_address;
        }
    }

    if (defined($register_indirect)) {

        $code .= '+' if defined $code;
        $register_indirect =~ s/^\((.*)\)$/$1/;
        $register_indirect = expression($register_indirect,0);
        $pre_code .= CHECK_RREG($register_indirect);
        $code .= $register_indirect;

    }

    if (defined($displacement)) {

        $code .= '+' if defined $code;
        $displacement =~ s/^\[(.*)\]$/$1/;
        $displacement = expression($displacement,0);
        $code .= '(' . expression($displacement,0) . ')';
    }
# if ($pre_code ne '') {print STDERR "input=$m  pre_code=$pre_code\n";}
    return ($code, $pre_code);
}


##############################################################################

=head1 Subroutine C<disp> gets an i960 "displacement" expression.
This is the target of a branch instruction.
Calls local_label().

=over

=item Z<>

=item Input:

0 - The index of the operand containing the "disp" type operand.

1 - A bit field describing the usage of the "disp" operand (load, store, etc.).

=item Output:

Code for "c" to get the "disp" offset.

=item Globals:

None used or changed.

=item Execution:

"c" code to get a displacement expression.

=back

=cut

##############################################################################
sub disp($$)
{
  my $label = $operand[$_[0]];
  my $bit_union = $_[1];

  if (!defined($label)) {
    error('Not enough arguments to command, error on #' . ($_[0]+1) . '.');
    return(' ');
  }
  $label = local_label($label, $bit_union);
  return ($label);
}


##############################################################################

=head1 Subroutine C<condition> creates "c" code for a condition check.
There are two global "c" variables cmp_tmp0 and cmp_tmp1 that are set to the
values to be compared.
Xor magic takes care of signed verses unsigned compares.
This routine inserts the input argument between the two variables and returns
the string thus created.

=over

=item Z<>

=item Input:

0 - condition code string.

=item Output:

"c" code to compare the last two operands compared.

=item Globals:

None directly used nor changed.

=item Execution:

Uses the "c" global variables cmp_tmp0 and cmp_tmp1.

=back

=cut

##############################################################################
sub condition($)
{
  $used_cmps = 1;
  return ("cmp_tmp0 $_[0] cmp_tmp1");
}


##############################################################################

=head1 Subroutine C<op_notimp> is called for those i960 operations not implemented.

=over

=item Z<>

=item Input:

None.

=item Output:

"c" code that won't compile.

=item Globals:

None directly used nor changed.

=item Execution:

Impose no execution possible.

=back

=cut

##############################################################################
sub op_notimp()
{
  error("$opcode not implemented.");
  return ('Not implemented');
}


##############################################################################

=head1 Subroutine C<op_addc> generates code for an i960 add-with-carry.
The carry bit is implemented as a condition('==').
The carry for the next time is set if the this add overflows.
Add Ordinal with Carry works with ordinal or integer arithmetic.

=over

=item Z<>

=item Input:

None.
Uses src() and dst().

=item Output:

Code to do the equivalent in "c" of the i960 add-with-carry.

=item Globals:

None directly used nor changed.

=item Execution:

Execute code emulating the i960 add-with-carry instruction.

=back

=cut

##############################################################################
sub op_addc()
{
  my $src1 = src(0);
  my $src2 = src(1);
  my $dst = dst(2);
  my $code = '';

  $code .= CHECK_RREG($src1);
  $code .= CHECK_RREG($src2);
  $code .= '{ ';
  $code .=   'unsigned long long tmp_addc = ' . $src1 . '; ';
  $code .=   'tmp_addc += ' . $src2 . '; ';
  $code .=   'tmp_addc += ' . condition('==') . '; ';
  $code .=   $dst . ' = (ulong)tmp_addc; ';
  $code .=   'cmp_tmp0 = 1; ';
# NOTE: true is 1.  (i.e. 0==0 gives a 1.)  Therefore if bit 32 is set, ... .
  $code .=   'cmp_tmp1 = (tmp_addc >> 32) & 1;}';
#  if ($used_order == 1) {
#    $code .=' cmp_ordered = 0;';               # Not unordered.
#  }
  $used_cmps = 1;
  return ($code);
}


##############################################################################

=head1 Subroutine C<op_alterbit> generates code for the i960 alterbit instruction.
It copies src to dst with one bit altered at src0, using condition code '==' to set 1.
Calls bitpos(0), src(1), dst(2).

=over

=item Z<>

=item Input:

None.

=item Output:

Code to do the equivalent in "c" of the i960 alterbit.

=item Globals:

None directly used nor changed.

=item Execution:

Execute code emulating the i960 alterbit instruction.

=back

=cut

##############################################################################
sub op_alterbit()
{
  my $bitpos = bitpos(0);
  my $src = src(1);
  my $dst = dst(2);
  my $code = '';

  $code .= CHECK_RREG($bitpos);
  $code .= CHECK_RREG($src);
  $code .= 'if (' . condition('!=') . ') {';    # NOTE, ==  check.
  $code .=   $dst . ' = ' . $src .  ' & ~(1<<(' . $bitpos . ' & 0x1f));'; # clear
  $code .= '} else {';
  $code .=   $dst . ' = ' .  $src . ' | (1<<(' . $bitpos . ' & 0x1f));';  # set
  $code .= '}';
  return ($code);
}


##############################################################################

=head1 Subroutine C<op_atadd> generates code for the i960 atadd - Atomic Add instruction.
Please NOTE that this is probably not correct.
This adds src(1) to location at src(0) and stores the original value at src(0) in dst.
Calls src(0), src(1), dst(2).
This is implemented via "c" routine C<CT_atomic_add()>.
If the value at src(0) changes before the routine C<CT_atomic_add()> is finished
executing, then the dst value will be wrong.
This tries very hard to work correctly for the cases that were in use for at_add when the code was written.
The x86 does not have an equivalent instruction.

=over

=item Z<>

=item Input:

None.

=item Output:

Code to do the almost the equivalent in "c" of the i960 atadd instruction.

=item Globals:

None directly used nor changed.

=item Execution:

Execute code emulating the i960 atadd instruction.

=back

=cut

##############################################################################
sub op_atadd()
{
  my $addr = src(0);
  my $src = src(1);
  my $dst = dst(2);
  my $code = '';

  $code .= CHECK_RREG($addr);
  $code .= CHECK_RREG($src);
  if ($option_i386 == 1 || $option_mips == 1) {
      $code .= '{ ulong *tempa; ';
      $code .=   'tempa = (ulong *)(' . $addr . ' & 0xfffffffc);';
      $code .=   $dst . ' = *tempa;';
      $code .=   'CT_atomic_add(tempa, ' . $src . ');';
      $code .= '}';
  } else {
      $code .= '__asm__ __volatile__( "atadd %2,%1,%0" : "=r" (' . $addr . ') : "ir" (' . $src . '), "r" (' . $dst . '));';
  }
  return ($code);
}


##############################################################################

=head1 Subroutine C<op_atmod> generates code for atmod - Atomic Modify instruction.
Please NOTE that this is NOT correct.
This copies selected bits of src/dst into memory specified by mask (2nd argument).
This can not be done atomically in the x86, and it is suggested to use
the C<CT_atomic_xchg()> routine instead.
Calls src(0), src(1), dst(2).

=over

=item Z<>

=item Input:

None.

=item Output:

Code to do the almost the equivalent in "c" of the i960 atmod instruction.

=item Globals:

None directly used nor changed.

=item Execution:

Execute code emulating the i960 atmod instruction.

=back

=cut

##############################################################################
sub op_atmod()
{
  my $addr = src(0);
  my $mask = src(1);
  my $dst = dst(2);
  my $code = '';

  $code .= CHECK_RREG($addr);
  $code .= CHECK_RREG($mask);
  $code .= CHECK_RREG($dst);
  if ($option_i386 == 1 || $option_mips == 1) {
    $code .= '{ ulong *tempa; ulong tempb; ';
    $code .=   'tempa = (ulong *)(' . $addr . ' & 0xfffffffc);';
    $code .=   'tempb = *tempa; ';
    $code .=   '*tempa = (tempb & ~' . $mask . ') |';
    $code .=                       ' (' . $dst . ' & ' . $mask . '); ';
    $code .=   $dst . '=tempb;';
    $code .= '}';
    warning(1, "atmod is not atomic, try using \"c   CT_atomic_xchg(&XX,&YY)\"");
  } else {
    $code .= '__asm__ __volatile__( "atadd %2,%1,%0" : "=r" (' . $dst. ') : "r" (' . $mask. '), "r" (' . $addr. '));';
  }
  return ($code);
}


##############################################################################

=head1 Subroutine C<check_address_range> is a debug routine that checks
that the argument lies within the i960 translated "c" code at execution time.
This is to ensure that a call or branch to a register stays within the i960 code.
If it were to enter the "c" code in other files, the "c" stack and i960 stack
would not be coherent.

=over

=item Z<>

=item Input:

0 - Address to be checked for within the i960 "c" code section.

=item Output:

Code to insert into the C file.

=item Globals:

None directly used nor changed.

=item Execution:

Execute code in debug mode that checks that the address is within the i960 "c"
translated section of code.

=back

=cut


##############################################################################
sub check_address_range($)
{
  my $label = $_[0];
  my $code = '';

  if ($option_assumes_works != 0) {
    return($code);
  }
  if ($option_i386 == 1 || $option_mips == 1) {
    $code .= "if ((ulong)($label) < (ulong)&CT_start || ";
    $code .=     "(ulong)($label) >= (ulong)&CT_end) { ";
    $code .=   "fprintf(stderr, \"\\ncheck_address_range($label) %s:%d\\n    0x%-8.8lx < [0x%-8.8lx] < 0x%-8.8lx\\n\", __FILE__, __LINE__, (ulong)&CT_start, (ulong)($label), (ulong)&CT_end);";
    $code .= "abort(); };";
  }
  return($code);
}


##############################################################################

=head1 Subroutine C<print_rip> generates code to move r registers, return address, etc.
Calls nothing.

=over

=item Z<>

=item Input:

0 - label to branch back to when ret is done.

=item Output:

Code in "c" to do rip processing.

=item Globals:

Uses $newlabel.

=item Execution:

The i960 stack, previous frame pointer, frame pointer, return instruction pointer are emulated.

=back

=cut

##############################################################################
sub print_rip($)
{
  my $newlabel = $_[0];
  my $code;
  $code  =   'rip = (ulong)&&CT_GOTO_' . $newlabel . '; ';
  $code .=   'fp = (ulong)((sp+0xf)&~0xfUL); ';
  $code .=   'pfp = ofp; ';
  $code .=   'sp = (ulong)fp + 64; ';
  if ($option_assumes_works == 0) {
    $code .=   'rip = (ulong)&&ct_error; ';
  }
  if ($option_check_r_reg_pattern_match == 1) {
    $code .= 'r3=r4=r5=r6=r7=r8=r9=r10=r11=r12=r13=r14=r15=0xBABEBABE;';
  }
  return($code);
}


##############################################################################

=head1 Subroutine C<generate_call> generates code to do everything needed to emulate
an i960 call (all kinds).
Calls label_use(), check_address_range(), printdebug(), printdebugp(), label_generate().

=over

=item Z<>

=item Input:

0 - label to call.

=item Output:

Code in "c" to emulate an i960 call.

=item Globals:

None changed directly, %labels updated through label_use().
Uses %labels, %regnum, %AC_labels.

=item Execution:

The i960 stack, previous frame pointer, frame pointer, return instruction pointer are emulated.

=back

=cut

##############################################################################
sub generate_call($)
{
  my $label = $_[0];
  my $code = '';

  if ($pass_number == 2) {
    my $newlabel = '';
    if (!defined($labels{$label}) ||
        ($labels{$label} & $L_defined_code) != 0) {
      $newlabel = 'autolabel_' . (++$autolabel);       # Note: no reference from code, ever.
      $newlabel = label_use($newlabel, $L_used_ret);
      $code  = '{ ';    # }
      $code .=   'ulong ofp = fp; ';
# Must save forward reference, if "r" register, fp moves giving us new ones.
      if (!defined($labels{$label})) {
        $code .= 'void *CT_SAVE_go_here = (void *)(' . $label . ');';
        $code .= check_address_range($label);
      }
    }
    if (!defined($labels{$label})) {
      if (defined($regnum{$label})) {
        warning($option_W_call_to_register,
                "call to register '$label' done");
      } else {
          warning($option_W_call_expression,
                "call expression '$label'");
      }
      $code .= printdebug("$filename:$linenumber  $opcode $label", "(ulong)CT_SAVE_go_here");
      $code .= print_rip($newlabel);        # Has brace and ofp
      $code .= 'goto *CT_SAVE_go_here; ';
    } else {
#-- print STDERR "generate_call($label) is defined\n";
      if (($labels{$label} & $L_defined_code) != 0) {
#-- print STDERR "generate_call($label) is defined in code\n";
        # label in "c" code, just do it.
        $code .= printdebugp("$filename:$linenumber  $opcode $label");
        $code .= print_rip($newlabel);      # has brace and ofp
        $code .= 'goto CT_GOTO_' . $label . '; ';
      } elsif (($labels{$label} & $L_defined_data) != 0) {
#-- print STDERR "generate_call($label) is defined in data\n";
        error("generating call to label $label defined in data section.");
        $code .= ' ';
      } else {
#-- print STDERR "generate_call($label) is external label\n";
      # external label -- like to "c".
        my $glue = $label;
        $glue =~ s/^_//;
        if (defined($AC_labels{$glue})) {
          $glue = $AC_labels{$glue};
        ### call's go to glue routines, goto's to goto, unless call is register.
          if ($glue =~ /^CT_goto_(.*)$/) {
            $glue = 'CT_GLUE_call_' . $1;
          }
# print  STDERR "call to AC_labels =>($glue)\n";
        } else {
          $glue = 'CT_GLUE_call_' . $glue;      # no leading underscore.
        }
        $code .= printdebugp("$filename:$linenumber  $glue()");
        $code .= $glue . '();';
      }
    }
    if ($newlabel ne '') {  # {
      $code .= '}; ';
      $code .= label_generate($newlabel);
      $code .= printdebugp("$filename:$linenumber  $newlabel:");
    }
  } else {
    $code = ' ';        # Don't bother with pass1 code.
  }
  return ($code);
}


##############################################################################

=head1 Subroutine C<generate_goto> does what is necessary to emulate
an i960 goto or branch instruction.
Calls check_address_range(), printdebug(), printdebugp().

=over

=item Z<>

=item Input:

0 - label to branch to.

=item Output:

Code in "c" to emulate an i960 branch instruction.

=item Globals:

None changed directly.
Uses %labels.

=item Execution:

A "c" goto is preformed.

=back

=cut

##############################################################################
sub generate_goto($)
{
  my $label = $_[0];
  my $code = '';

  if ($pass_number == 2) {
    if (!defined($labels{$label})) {
      $code .= CHECK_RREG($label);
      $code .= check_address_range($label);
      if (defined($regnum{$label})) {
        warning($option_W_goto_register,
                "goto register '$label' done");
      } else {
        warning($option_W_goto_expression,
                "generate_goto expression '$label'");
      }
      $code .= printdebug("$filename:$linenumber  $opcode $label", "(ulong)$label");
      $code .= 'goto *(void *)(' . $label . '); ';
    } else {
      if (($labels{$label} & $L_defined_code) != 0) {
      # label in "c" code, just do it.
        $code .= printdebugp("$filename:$linenumber  $opcode $label");
        $code .= 'goto CT_GOTO_' . $label . '; ';
      } elsif (($labels{$label} & $L_defined_data) != 0) {
        error("generating goto to label $label defined in data section.");
        $code = ' ';
      } else {
        error("generating goto to external label $label.");
        $code = ' ';
      }
    }
# presume that it is a register we are doing a goto to.
  } else {
    $code = ' ';        # Don't bother with pass1 code.
  }
  return ($code);
}


##############################################################################

=head1 Subroutine C<op_b> handles i960 branch ('b') instruction.
Calls C<generate_goto()>.

=over

=item Z<>

=item Input:

None.

=item Output:

Code to do the branch.

=item Globals:

None directly used nor changed.

=item Execution:

Code to do the "c" goto.

=back

=cut

##############################################################################
sub op_b()
{
  my $disp = disp(0, $L_used_goto);
  my $code;

  $code = generate_goto($disp);
  return ($code);
}


##############################################################################

=head1 Subroutine C<op_bal> handles the i960 branch and link (C<bal>) instruction.
Execution assumes that register g14 will end with the address of the next instruction
to execute that is after the bal instruction.
Calls disp(0), label_use(), generate_goto(), label_generate(), printdebugp().

=over

=item Z<>

=item Input:

None.

=item Output:

"c" code to do the branch and link instruction.

=item Globals:

None directly changed nor used.

=item Execution:

Do the branch and link instruction, changing "c" global g14 to be the return address.

=back

=cut

##############################################################################
sub op_bal()
{
  my $disp = disp(0, $L_used_goto);
  my $code;
  my $label = 'autolabel_' . (++$autolabel);    # Note: no reference from code, ever.

  $label = label_use($label, $L_used_ret);
  $code  = 'g14 = (ulong)&&CT_GOTO_' . $label . '; ';
  $code .= generate_goto($disp);
  $code .= label_generate($label);
  $code .= printdebugp("$filename:$linenumber  $label");
  return ($code);
}


##############################################################################

=head1 Subroutine C<op_balx> handles i960 balx (branch-through-register) instruction.
This is nearly identical to balx, but has second argument that is the register to
save the return address in.
Calls disp(0), dst(1), generate_goto(), label_generate(), printdebugp(), label_use().

Note: bigfoot code always has label for balx instructions.

=over

=item Z<>

=item Input:

None.

=item Output:

"c" code for branch-through-register instruction.

=item Globals:

None directly changed nor used.

=item Execution:

Do the branch-through-register instruction,
changing "c" global register that is 2nd argument to be the return address.

=back

=cut

##############################################################################
sub op_balx()
{
  my $disp = disp(0, $L_used_goto);
  my $dst = dst(1);
  my $code;
  my $label = 'autolabel_' . (++$autolabel);

  $label = label_use($label, $L_used_ret);
  $code  = $dst . ' = (ulong)&&CT_GOTO_' . $label . '; ';
  $code .= generate_goto($disp);
  $code .= label_generate($label);
  $code .= printdebugp("$filename:$linenumber  $label");
  return ($code);
}


##############################################################################

=head1 Subroutine C<op_bbc> generates code for branch bit clear (bbc).
Calls bitpos(0), src(1), disp(2), generate_goto().

=over

=item Z<>

=item Input:

0 - A string argument of '', 'likely', or 'unlikely' for optimization hints.

=item Output:

"c" code to emulate the i960 bbc instruction.

=item Globals:

None directly used nor changed.

=item Execution:

The cmp_tmp0 and cmp_tmp1 global variables are changed to match bit clear or set.
A branch is done if the bit is clear.

=back

=cut

##############################################################################
sub op_bbc($)
{
  my $bitpos = bitpos(0);
  my $src = src(1);
  my $disp = disp(2, $L_used_goto);
  my $code = '';

  $code .= CHECK_RREG($src);
  $code .= CHECK_RREG($bitpos);
  $code .= 'cmp_tmp0 = 1; ';
  $code .= 'cmp_tmp1 = ' . $src . ' & (1 << (' . $bitpos . ' & 0x1f)); ';
  $code .= 'if (' . $_[0] . '(cmp_tmp1 == 0)) { ';
  $code .=   generate_goto($disp);              # (not equal).
  $code .= '} else {';
  $code .=   'cmp_tmp1 = cmp_tmp0;';            # (equal)
  $code .= '}';
  $used_cmps = 1;
#  $used_order = 1;
  return ($code)
}


##############################################################################

=head1 Subroutine C<op_bbs> generates code for branch bit set (bbs).
Calls bitpos(0), src(1), disp(2), generate_goto().

=over

=item Z<>

=item Input:

0 - A string argument of '', 'likely', or 'unlikely' for optimization hints.

=item Output:

"c" code to emulate the i960 bbs instruction.

=item Globals:

None directly used nor changed.

=item Execution:

The cmp_tmp0 and cmp_tmp1 global variables are changed to match bit clear or set.
A branch is done if the bit is set.

=back

=cut

##############################################################################
sub op_bbs($)
{
  my $bitpos = bitpos(0);
  my $src = src(1);
  my $disp = disp(2, $L_used_goto);
  my $code = '';

  $code .= CHECK_RREG($src);
  $code .= CHECK_RREG($bitpos);
  $code .= 'cmp_tmp0 = 0; ';
  $code .= 'cmp_tmp1 = ' . $src . ' & (1 << (' . $bitpos . ' & 0x1f)); ';
  $code .= 'if (' . $_[0] . '(cmp_tmp1 != 0)) { ';
  $code .=   'cmp_tmp1 = cmp_tmp0; ';           # (equal)
  $code .=   generate_goto($disp);
  $code .= '} else { ';
  $code .=   'cmp_tmp1 = 1; ';                  # (not equal)
  $code .= '}';
  $used_cmps = 1;
#  $used_order = 1;
  return ($code)
}


##############################################################################

=head1 Subroutine C<op_bcc> generates code for one of many conditional branches.

=over

=item Z<>

=item Input:

0 - The type of compare to perform.

1 - A string argument of '', 'likely', or 'unlikely' for optimization hints.

=item Output:

"c" code to do the compare and branch if condition is met.

=item Globals:

None directly used nor changed.

=item Execution:

Execute code emulating the various i960 conditional branch instructions.

=back

=cut

##############################################################################
sub op_bcc($$)
{
  my $op = $_[0];
  my $likely = $_[1];
  my $disp = disp(0, $L_used_goto);
  my $code;

  $code  = 'if (' . $likely . '(' . condition($op) . ')) {';
  $code .=   generate_goto($disp);
  $code .= '}';
  return ($code);
}


##############################################################################

=head1 Subroutine C<op_binary> is called for addition and subtraction of signed or unsigned numbers.
Calls src(0), src(1), dst(2).

=over

=item Z<>

=item Input:

0 - The operation to perform on source registers.

=item Output:

"c" code to perform the add or subtract of the two source registers and put result in destination.

=item Globals:

None directly used nor changed.

=item Execution:

Execute code emulating the i960 add or subtract instruction.

=back

=cut

##############################################################################
sub op_binary($)
{
  my $src1 = src(0);    # Note changing names to match typical book case.
  my $src2 = src(1);
  my $dst = dst(2);
  my $code = '';

  $code .= CHECK_RREG($src1);
  $code .= CHECK_RREG($src2);
  $code .= $dst . ' = ' . $src2 . $_[0] . $src1 . ';';
  return ($code);
}


##############################################################################

=head1 Subroutine C<op_binary_cc> generates code for i960 instructions that do
conditional addition or subtraction of signed or unsigned numbers.
Calls condition(), op_binary().

=over

=item Z<>

=item Input:

0 - Operation to be performed (add or subtract).

1 - Condition code for determining if operation is to be performed.

=item Output:

Conditional code to perform or not the operation.

=item Globals:

None directly used nor changed.

=item Execution:

Execute code emulating the i960 conditional add or subtract instruction.

=back

=cut

##############################################################################
sub op_binary_cc($$)
{
  my $condition_code = $_[1];
  my $operation = $_[0];
  my $code;

  $code  = 'if (' . condition($condition_code) . ') {';
  $code .=   op_binary($operation);
  $code .= '}';
  return ($code);
}


##############################################################################

=head1 Subroutine C<op_bno> generates code for the i960 instruction bno (branch unordered).
The unordered routines do not work precisely correctly.
They are implemented as unequal.
To work correctly, all comparison instructions would have to emulate the
three condition code bits completely, and that would be quite slow and
generate a lot of "c" code.
This turns into a branch unequal instruction.
Calls condition() and generate_goto().

=over

=item Z<>

=item Input:

0 - A string argument of '', 'likely', or 'unlikely' for optimization hints.

=item Output:

Conditional code to test for not equal branch.

=item Globals:

None directly changed nor used.

=item Execution:

Execute code emulating the i960 bno instruction as a branch unequal.

=back

=cut

##############################################################################
sub op_bno($)
{
  my $likely = $_[0];
  my $disp = disp(0, $L_used_goto);
  my $code;

  $code  = 'if (' . $likely . '('. condition('!=') . ')) {';    # (not equal)
  $code .=   generate_goto($disp);
  $code .= '}';
#  $used_order = 1;
  return ($code);
}


##############################################################################

=head1 Subroutine C<op_bo> generates code for the i960 instruction bo (branch ordered).
The branch ordered routine does not work correctly.
They are implemented as equal.
In order to work correctly, all comparison instructions everywhere would have to emulate the
three condition code bits completely, and that would be quite slow and
generate a lot of "c" code.
This turns into a branch equal instruction.
Calls condition() and generate_goto().

=over

=item Z<>

=item Input:

0 - A string argument of '', 'likely', or 'unlikely' for optimization hints.

=item Output:

Conditional code to test for not equal branch.

=item Globals:

None directly changed nor used.

=item Execution:

Execute code emulating the i960 bno instruction as a branch unequal.

=back

=cut

##############################################################################
sub op_bo($)
{
  my $likely = $_[0];
  my $disp = disp(0, $L_used_goto);
  my $code;

  $code  = 'if (' . $likely . '('. condition('==') . ')) {';    # (equal)
  $code .=   generate_goto($disp);
  $code .= '}';
#  $used_order = 1;
  return ($code);
}


##############################################################################

=head1 Subroutine C<op_bswap> generates code for bswap instruction.
Calls src(0) and  dst(1).

=over

=item Z<>

=item Input:

None.

=item Output:

"c" code to swap the 4 bytes in the 32 bit source input, and store them in the destination.

=item Globals:

None directly used nor changed.

=item Execution:

Destination will equal the swapped bytes of the 32 bit source.

=back

=cut

##############################################################################
sub op_bswap()
{
  my $src = src(0);
  my $dst = dst(1);
  my $code = '';

  $code .= CHECK_RREG($src);
  $code .= $dst . ' = bswap_32(' . $src . ');';
  return ($code);
}


##############################################################################

=head1 Subroutine C<op_bx> generates code for the i960 bx (branch through registers) instruction.
Also known as branch extended.
Calls mem(0) and generate_goto().

=over

=item Z<>

=item Input:

None.

=item Output:

"c" code to do the branch.

=item Globals:

None directly used nor changed.

=item Execution:

Branch to the expression.

=back

=cut

##############################################################################
sub op_bx()
{
  my ($mem, $pre_code) = mem(0, $L_used_goto);
  my $code = $pre_code;

  $code .= generate_goto($mem);
  return ($code);
}


##############################################################################

=head1 Subroutine C<op_call> generates code for either an i960 call or callj instruction.
Calls disp(0), generate_call().

=over

=item Z<>

=item Input:

None.

=item Output:

"c" code to do the routine call, and code to allow return.

=item Globals:

None directly used nor changed.

=item Execution:

The execution changes to new "r" register stack, and location of execution changes.

=back

=cut

##############################################################################
sub op_call()
{
  my $disp = disp(0, $L_used_call);
  my $code;

  $code  = generate_call($disp);
  return ($code);
}


##############################################################################

=head1 Subroutine C<op_callx> generates code for either a callx or calljx instruction.
Calls disp(0), mem(0), generate_call().

=over

=item Z<>

=item Input:

None.

=item Output:

"c" code to do the routine call, and code to allow return.

=item Globals:

None directly used nor changed.

=item Execution:

The execution changes to new "r" register stack, and location of execution changes.

=back

=cut

##############################################################################
sub op_callx()
{
  my $mem = src(0);
  my $pre_code = '';
  my $code;

  if ($mem =~ /^[.a-z\$_][.a-z0-9\$_]*$/i) {    # just a label or number
    $mem = disp(0, $L_used_call);
  } else {
    ($mem, $pre_code) = mem(0, $L_used_call);
  }
  $code  = $pre_code . generate_call($mem);
  return ($code);
}


##############################################################################

=head1 Subroutine C<op_cbranch> generates code for the many conditional i960 branch instructions.
Calls src(0), src(1), disp(2), condition(), generate_goto().

=over

=item Z<>

=item Input:

0 - If this is an integer compare branch, this is 0x80000000. If ordinal, then zero.

1 - The comparison to be done as a string.

2 - A string argument of '', 'likely', or 'unlikely' for optimization hints.

=item Output:

Code to do the comparision, and conditionally do the branch.

=item Globals:

None directly used nor changed.

=item Execution:

The global variables cmp_tmp0 and cmp_tmp1 are set.
Execution conditionally continues at the new location.

=back

=cut

##############################################################################
sub op_cbranch($$$)
{
  my $xor = $_[0];
  my $cmp = $_[1];
  my $likely = $_[2];
  my $src1 = src(0);    # Note reordered to match book
  my $src2 = src(1);
  my $disp = disp(2, $L_used_goto);
  my $code = '';

  # Must do a compare first.

  $code .= CHECK_RREG($src1);
  $code .= CHECK_RREG($src2);
  $code .= 'cmp_tmp0 = ' . $src1 . ' ^ ' . $xor . 'U; ';
  $code .= 'cmp_tmp1 = ' . $src2 . ' ^ ' . $xor . 'U; ';
#  if ($used_order == 1) {
#    $code .=' cmp_ordered = 0;';               # Not unordered.
#  }

  # Must do branch on condition code next.

  $code .= 'if (' . $likely . '(' . condition($cmp) . ')) {';
  $code .=   generate_goto($disp);
  $code .= '}';
  $used_cmps = 1;
  return ($code);
}


##############################################################################

=head1 Subroutine C<op_chkbit> generates "c" code for the i960 chkbit instruction.
Calls bitpos(0), src(1).
The i960 instruction sets the compare flags to unordered if the bit is set.

=over

=item Z<>

=item Input:

None.

=item Output:

"c" code to set the compare flags as equal if the bit is set.

=item Globals:

None directly used or changed.

=item Execution:

Execution changes global variables cmp_tmp0 and cmp_tmp1.

=back

=cut

##############################################################################
sub op_chkbit()
{
  my $bitpos = bitpos(0);
  my $src = src(1);
  my $code = '';

  # Note: there are only 2 fields on instruction, ignore book.
  $code .= CHECK_RREG($src);
  $code .= CHECK_RREG($bitpos);
  $code .= 'cmp_tmp1 = ' . $src . ' & (1 << (' . $bitpos . ' & 0x1f)); ';
  $code .= 'if (cmp_tmp1 == 0) { ';
  $code .=   'cmp_tmp0 = 1;';           # not equal
  $code .= '} else { ';
  $code .=   'cmp_tmp0 = cmp_tmp1;';    # i960 sets equal bit.
  $code .= '}';
  $used_cmps = 1;
#  $used_order = 1;
  return ($code);
}


##############################################################################

=head1 Subroutine C<op_clrbit> generates "c" code for the i960 clrbit instruction.
This clears one bit.
Calls bitpos(0), src(1), dst(2).

=over

=item Z<>

=item Input:

None.

=item Output:

"c" code to set the destination to the source register with the bit cleared.

=item Globals:

None directly used or changed.

=item Execution:

Execute code emulating the i960 instruction.

=back

=cut

##############################################################################
sub op_clrbit()
{
  my $bitpos = bitpos(0);
  my $src = src(1);
  my $dst = dst(2);
  my $code = '';

  $code .= CHECK_RREG($src);
  $code .= CHECK_RREG($bitpos);
  $code .= $dst . ' = ' . $src . ' & ~(1 << (' . $bitpos .  ' & 0x1f));';
  return ($code);
}


##############################################################################

=head1 Subroutine C<op_cmp> generates code for the various i960 compare (cmp) instructions.
Works for signed or unsigned compares.
Calls src(0), src(1).

=over

=item Z<>

=item Input:

0 - A mask of the number of bytes in 32 bit register to compare.

1 - A single bit set for a signed number, the bit is the top bit for the byte size of the instruction.

=item Output:

"c" code to compare two numbers of the right size.

=item Globals:

None directly used nor changed.

=item Execution:

Execute code emulating the i960 instructions behavior.

=back

=cut

##############################################################################
sub op_cmp($$)
{
  my $mask = $_[0];
  my $xor = $_[1];
  my $src1 = src(0);    # Note: order changed to match book;
  my $src2 = src(1);    # Note: order changed to match book;
  my $code = '';

  $code .= CHECK_RREG($src1);
  $code .= CHECK_RREG($src2);
  $code .= 'cmp_tmp0 = (' . $src1 . ' ^ ' . $xor . 'U) & ' . $mask . 'U; ';
  $code .= 'cmp_tmp1 = (' . $src2 . ' ^ ' . $xor . 'U) & ' . $mask . 'U; ';
#  if ($used_order == 1) {
#    $code .=' cmp_ordered = 0;';               # Not unordered.
#  }
  $used_cmps = 1;
  return ($code);
}


##############################################################################

=head1 Subroutine C<op_cmpadd> generates code for the i960 compare then decrement
and compare then increment instructions.
Calls src(0), src(1), dst(2).

=over

=item Z<>

=item Input:

0 - A single upper bit set for a signed number, else zero.

1 - The value to add to do the operation. (+1 or -1)

=item Output:

"c" code to set the compare variables and then do the add or subtract.

=item Globals:

None directly used nor changed.

=item Execution:

Execute code emulating the i960 instructions behavior.
Changes global variables cmp_tmp0 and cmp_tmp1.

=back

=cut

##############################################################################
sub op_cmpadd($$)
{
  my $mask = $_[0];
  my $value = $_[1];
  my $src1 = src(0);    # Note: order changed to match book;
  my $src2 = src(1);
  my $dst = dst(2);
  my $code = '';

  $code .= CHECK_RREG($src1);
  $code .= CHECK_RREG($src2);
  $code .= 'cmp_tmp0 = ' . $src1 . ' ^ ' . $mask . 'U; ';
  $code .= 'cmp_tmp1 = ' . $src2 . ' ^ ' . $mask . 'U; ';
#  if ($used_order == 1) {
#    $code .=' cmp_ordered = 0;';               # Not unordered.
#  }
  $code .= $dst . ' = ' . $src2 . ' + ' . $value . ';';
  $used_cmps = 1;
  return ($code);
}


##############################################################################

=head1 Subroutine C<op_concmp> does the i960 Conditional Compare Integer or Ordinal.
If condition code is "greater than or equal", then do the compare -- but
set the condition code to equal if <=, otherwise set greater than.
Calls condition().

=over

=item Z<>

=item Input:

0 - A single upper bit set for a signed number, else zero.

=item Output:

"c" code to do the conditional compare.

=item Globals:

None directly used nor changed.

=item Execution:

Execute code emulating the i960 instructions behavior.
Conditionally changes global variables cmp_tmp0 and cmp_tmp1.

=back

=cut

##############################################################################
sub op_concmp($)
{
  my $xor = $_[0];
  my $code;

  $code  = 'if (' . condition('>=') . ') {';
  op_cmp(0xffffffff, $xor);
  $code .=   'if (' . condition('<=') . ') {';
  $code .=    'cmp_tmp0 = cmp_tmp1 = 0; ';
#  if ($used_order == 1) {
#    $code .=    'cmp_ordered = 0;';            # Not unordered.
#  }
  $code .=   '}';               # else, greater already set.
  $code .= '}';         # else, do nothing.
  $used_cmps = 1;
  return ($code);
}

##############################################################################

=head1 Subroutine C<op_dcctl> generates "c" code to call i960_dcctl() for the dcctl (Data cache management
and control) instruction.
Calls src(0), src(1), dst(2).

=over

=item Z<>

=item Input:

None.

=item Output:

"c" code calling i960_dcctl with 3 arguments.

=item Globals:

None directly used nor changed.

=item Execution:

Calls a "c" support routine that prints out "dcctl not decoded yet".

=back

=cut

# Generate code for dcctl.
##############################################################################
# Data cache management and control.
sub op_dcctl()
{
  my $src1 = src(0);    # Note: order changed to match book
  my $src2 = src(1);
  my $dst = dst(2);
  my $code = '';

  if ($option_i386 == 1 || $option_mips == 1) {
    if ($option_assumes_works == 0) {   # if not set, put out instruction
      $code .= 'i960_dcctl(' . $src1 . ', ' . $src2 . ', &' . $dst . ');';
    } else {
      $code .= ' ';
    }
  } else {
    $code .= '__asm__ __volatile__( "dcctl %2,%1,%0" : "=r" (' . $dst. ') : "ir" (' . $src2 . '), "r" (' . $src1. '));';
  }
  return ($code);
}


##############################################################################

=head1 Subroutine C<op_ediv> creates the "c" code necessary to do an i960 ediv (extended divide).
Calls src(0), src(1), dst(2).

=over

=item Z<>

=item Input:

None.

=item Output:

Code to insert into the C file.

=item Globals:

None directly changed.
Used %regname, %regnum.

=item Execution:

Execute code emulating the i960 ediv instruction.
Calls external "c" routine i960_generate_fault() if denominator is zero.

=back

=cut

##############################################################################
sub op_ediv()
{
  my $src1 = src(0);    # Note: order changed to match book
  my $src2 = src(1);
  my $src2u = $regname[$regnum{$src2}+1];
  my $dst = dst(2);
  if ($regnum{$dst} + 1 > 0x1f) {
    warning(1, 'op_ediv, wrapping destination register.');
  }
  my $dst2 = $regname[$regnum{$dst}+1];
  my $type_cast = '';
  my $code = '';

  $code .= CHECK_RREG($src1);
  $code .= CHECK_RREG($src2u);
  $code .= CHECK_RREG($src2);
  ### check if fp or g15 changed anywhere ### optimization planning ####
  if ($regnum{$dst2} == $regnum{'g15'} ||
      $regnum{$dst2} == $regnum{'r0'} ||
      $regnum{$dst2} == $regnum{'r2'}) {
    warning($option_W_fp_r0_r2_changed, 'op_ediv - fp/g15/r0/pfp/r2/rip register as extended destination.');
  }

  $code .= '{ unsigned long long tmp1; unsigned long tmps = ' . $src1 . ';';
  if ($option_assumes_works == 0) {   # if not set, put out instruction
    $code .=   'if (' . $src1 . ' == 0) {';
    if ($option_i386 == 1 || $option_mips == 1) {
      $code .=     'i960_generate_fault("ediv register ' . $src1 . ' is zero", __FILE__, __LINE__);';
    } else {
      $code .=     'asm("cmpo g0,g0; faulte");';
    }
    $code .=   '} else {';
  }
  $code .=     'tmp1 = ((unsigned long long)(' . $src2u . ') << 32) | (' . $src2 . '); ';
  $code .=     $dst2 . ' = (tmp1 / tmps);';
  $code .=     $dst  . ' = (tmp1 % tmps); ';
  $code .=   '}';
  if ($option_assumes_works == 0) {   # if not set, put out instruction
    $code .= '}';
  }
  return ($code);
}


##############################################################################

=head1 Subroutine C<op_emul> creates the "c" code necessary to do an i960 emul (extended multiply).
Calls src(0), src(1), dst(2).


=over

=item Z<>

=item Input:

None.

=item Output:

Code to insert into the C file.

=item Globals:

None directly changed.
Used %regnum, %regname.

=item Execution:

Execute code emulating the i960 emul instruction.

=back

=cut

##############################################################################
sub op_emul()
{
  my $src1 = src(0);    # Note: order changed to match book
  my $src2 = src(1);
  my $dst = dst(2);

  if ($regnum{$dst} + 1 > 0x1f) {
    warning(1, 'op_emul, wrapping destination register.');
  }
  my $dst2 = $regname[$regnum{$dst}+1];
  my $type_cast = '';
  my $code = '';

  $code .= CHECK_RREG($src1);
  $code .= CHECK_RREG($src2);
  ### check if fp or g15 changed anywhere ### optimization planning ####
  if ($regnum{$dst2} == $regnum{'g15'} ||
      $regnum{$dst2} == $regnum{'r0'} ||
      $regnum{$dst2} == $regnum{'r2'}) {
    warning($option_W_fp_r0_r2_changed, 'op_emul - fp/g15/r0/pfp/r2/rip register as extended destination.');
  }

  $code .= '{ long long tmp; tmp = (unsigned long long)' . $src1 . ' * (unsigned long long)' . $src2 . '; ';
  $code .=   $dst . ' = tmp & 0xffffffffU; ';
  $code .=   $dst2 . ' = ' . $type_cast . '((tmp>>32) & 0xffffffffU); ';
  $code .= '}';
  return ($code);
}


##############################################################################

=head1 Subroutine C<op_extract> generates "c" code to do the extract bits operation.
Calls src(0), src(1), dst(2).
Extracts number of bits at a bit position.
Source and destination register are the same.

=over

=item Z<>

=item Input:

None.

=item Output:

Code to insert into the C file.

=item Globals:

None directly used nor changed.

=item Execution:

Execute code emulating the i960 extract instruction.

=back

=cut

##############################################################################
sub op_extract()
{
# Searches src value for the most significant set bit.
  my $src1 = src(0);    # Note order changed to match book.
  my $src2 = src(1);
  my $dst = dst(2);
  my $code = '';

  $code .= CHECK_RREG($dst);
  $code .= CHECK_RREG($src1);
  $code .= CHECK_RREG($src2);
  $code .= $dst . ' = (' . $dst . ' >> ' . $src1 . ') & ~(0xffffffff << ';
  $code .= $src2 . ');';
  return ($code);
}


##############################################################################

=head1 Subroutine C<op_flushreg> calls a "c" routine i960_flushreg() in debug mode,
or generates no code for a PERF compilation.

=over

=item Z<>

=item Input:

None.

=item Output:

Code to insert into the C file.

=item Globals:

None directly used nor changed.

=item Execution:

Do nothing, as there is no r register cache in the x86 nor mips.

=back

=cut

##############################################################################
sub op_flushreg()
{
  my $code;

  if ($option_i386 == 1 || $option_mips == 1) {
    if ($option_assumes_works == 0) {   # if not set, put out instruction
      $code  = 'i960_flushreg();';
    } else {
      $code = ' ';
    }
  } else {
    $code .= '__asm__ __volatile__( "' . $opcode . '");';
  }
  return ($code);
}


##############################################################################

=head1 Subroutine C<op_icctl> does nothing for the icctl
(Instruction cache management and control) instruction.
If compiling in non-PERF mode, it calls "c" routine i960_icctl().

=over

=item Z<>

=item Input:

None.

=item Output:

Code to insert into the C file.

=item Globals:

None directly used nor changed.

=item Execution:

Do nothing, as there is nothing a userland program running in linux should be doing.

=back

=cut

##############################################################################
sub op_icctl()
{
  my $src1 = src(0);    # Note: order changed to match book
  my $src2 = src(1);
  my $dst = dst(2);
  my $code;

  if ($option_i386 == 1 || $option_mips == 1) {
    if ($option_assumes_works == 0) {   # if not set, put out instruction
      $code  = 'i960_icctl(' . $src1 . ', ' . $src2 . ', &' . $dst . ');';
    } else {
      $code = ' ';
    }
  } else {
    $code .= '__asm__ __volatile__( "icctl %2,%1,%0" : "=r" (' . $dst. ') : "ir" (' . $src2 . '), "r" (' . $src1. '));';
  }
  return ($code);
}


##############################################################################

=head1 Subroutine C<op_fault> handles the various fault conditional instructions.
Calls i960_fault();

=over

=item Z<>

=item Input:

0 - A string representing the compare operation to be performed.

=item Output:

Code to insert into the C file.

=item Globals:

None directly used nor changed.

=item Execution:

This calls the "c" helper routine i960_fault() if the compare condition matches.
This routine will print out a message "fault ==" (example) then abort().

=back

=cut

##############################################################################
sub op_fault($)
{
  my $code;

  if ($option_i386 == 1 || $option_mips == 1) {
    my $op = $_[0];
    my $ulong;

    if ($op eq '==') {
      $ulong = 0;
    } elsif ($op eq '!=') {
      $ulong = 1;
    } elsif ($op eq '<') {
      $ulong = 2;
    } elsif ($op eq '<=') {
      $ulong = 3;
    } elsif ($op eq '>') {
      $ulong = 4;
    } elsif ($op eq '>=') {
      $ulong = 5;
    } else {
      error ("fault on $op not implemented");
      return ("fault on $op is not implemented");
    }
    $code  = 'if (' . condition($op) . ') {';
    $code .=   'i960_fault(cmp_tmp0, cmp_tmp1, ' . $ulong . ', __FILE__, __LINE__);';
    $code .= '}';
  } else {
    $code .= '__asm__ __volatile__( "' . $opcode . '");';
  }
  return ($code);
}


##############################################################################

=head1 Subroutine C<op_intctl> handles the i960 intctl operation.
Calls src(0), dst(1).
If in non-PERF compiling mode, it calls the "c" helper routine i960_intctl().

=over

=item Z<>

=item Input:

None.

=item Output:

Code to insert into the C file.

=item Globals:

None directly used nor changed.

=item Execution:

Does nothing for PERF compilation. Else it calls "c" routine i960_intctl(),
which keeps track of interrupt enable, disable for the various types, and
returns the previous supposed value.
As this does nothing with interrupts, it probably should not be in code
run on an x86.

=back

=cut

##############################################################################
sub op_intctl()
{
  my $src = src(0);
  my $dst = dst(1);
  my $code;

  if ($option_i386 == 1 || $option_mips == 1) {
    if ($option_assumes_works == 0) {   # if not set, put out instruction
      $code  = 'i960_intctl(' . $src . ', (ulong *)&' . $dst . ');';
    } else {
      $code = ' ';
    }
  } else {
    $code .= '__asm__ __volatile__( "intctl %1,%0" : "=r" (' . $dst . ') : "r" (' . $src . '));';
  }
  return ($code);
}


##############################################################################

=head1 Subroutine C<op_intdis> handles the interrupt disable (intdis) i960 instruction.
If compiling in PERF mode, this is a do nothing.
Else it calls "c" helper routine i960_intdis().

=over

=item Z<>

=item Input:

None.

=item Output:

Code to insert into the C file.

=item Globals:

None directly used nor changed.

=item Execution:

Execute code emulating the i960 intdis instruction.
Since hardware interrupts can not be handled in a userland program, this does nothing.
In non-PERF mode, it keeps track of the current state of the interrupts.

=back

=cut

##############################################################################
sub op_intdis()
{
  my $code;

  if ($option_i386 == 1 || $option_mips == 1) {
    if ($option_assumes_works == 0) {   # if not set, put out instruction
      $code = 'i960_intdis();';
    } else {
      $code = ' ';
    }
  } else {
    $code .= '__asm__ __volatile__( "' . $opcode . '");';
  }
  return ($code);
}


##############################################################################

=head1 Subroutine C<op_inten> handles the interrupt enable (inten) i960 instruction.
If compiling in PERF mode, this does nothing.
Else it calls "c" helper routine i960_inten().

=over

=item Z<>

=item Input:

None.

=item Output:

Code to insert into the C file.

=item Globals:

None directly used nor changed.

=item Execution:

Execute code emulating the i960 inten instruction.
Since interrupts are not handled in a normal userland program, this does nothing,
except in non-PERF mode, it keeps track of the current state of the interrupts.

=back

=cut

##############################################################################
sub op_inten()
{
  my $code;

  if ($option_i386 == 1 || $option_mips == 1) {
    if ($option_assumes_works == 0) {   # if not set, put out instruction
      $code = 'i960_inten();';
    } else {
      $code = ' ';
    }
  } else {
    $code .= '__asm__ __volatile__( "' . $opcode . '");';
  }
  return ($code);
}


##############################################################################

=head1 Subroutine C<op_lda> generates code for a load address operation.
This does not load from memory, but does allow all the addressing modes that
a load or store instruction does.
Calls mem(0), dst(1).

=over

=item Z<>

=item Input:

None.

=item Output:

Code to insert into the C file.

=item Globals:

None directly used nor changed.

=item Execution:

Execute code emulating the i960 lda instruction.

=back

=cut

##############################################################################
sub op_lda()
{
  my ($mem, $pre_code) = mem(0, $L_used_load);
  my $dst = dst(1);
  my $code = $pre_code;

  $code .= $dst . ' = (ulong)(' . $mem . ');';
  return ($code);
}


##############################################################################

=head1 Subroutine C<op_ldm> generates code for the load multiple (ldl, ldt, ldq) operations.
Calls mem(0), dst(1).

=over

=item Z<>

=item Input:

0 - The number of adjacent registers to load.

=item Output:

Code to insert into the C file.

=item Globals:

None directly changed.
Used %regname, %regnum.

=item Execution:

Execute code emulating the appropriate i960 ldl, ldt, or ldq instructions.

=back

=cut

# Generates code for a load multiple operation.
##############################################################################

sub op_ldm($)
{
  my ($mem, $pre_code) = mem(0, $L_used_load);
  my $count = $_[0];
  my $dst1 = dst(1);
  my $reg = $regnum{$dst1};
  my $type_cast = '';
  my $code = $pre_code;

  $code .= '{ ulong tmp = (ulong)(' . $mem . '); ';
  if ($NO_MEMORY_ADDRESS_LOCAL_CHECK == 1 && $option_check_local_memory == 1) {
    $code .= 'CHECK_LOCAL_MEMORY("' . "$filename:$linenumber  $opcode $mem,$dst1" . '", tmp);';
  }
  $code .= $dst1 . ' = *(ulong*)tmp;';
  if (defined($defines{'HISTORY_KEEP'}) &&
      $NO_CHECK_MEMORY_PATTERNS != 0) {
    $code .= 'check_memory_patterns("' . "$filename:$linenumber  $opcode $mem,$dst1" . '", ' . $dst1 . ');';
  }
  for (my $i = 1; $i < $count; $i++) {
    my $newdst = $regname[$reg+$i];

    ### check if fp or g15 changed anywhere ### optimization planning ####
    if ($regnum{$newdst} == $regnum{'g15'} ||
        $regnum{$newdst} == $regnum{'r0'} ||
        $regnum{$newdst} == $regnum{'r2'}) {
      warning($option_W_fp_r0_r2_changed, 'op_ldm - fp/g15/r0/pfp/r2/rip register as extended destination.');
    }

    $code .= ' ' . $newdst . ' = ' . $type_cast . '(*(ulong*)(tmp + ' . (4 * $i) . '));';
    if (defined($defines{'HISTORY_KEEP'}) &&
        $NO_CHECK_MEMORY_PATTERNS != 0) {
      my $j = $i + 1;
      $code .= 'check_memory_patterns("' . "$filename:$linenumber  $opcode #$j of $count,$newdst" . '", ' . $newdst . ');';
    }
  }
  $code .= '}';
  return ($code);
}


##############################################################################

=head1 Subroutine C<op_load> generates code for a load from memory
(ld, ldob, ldos, ldib, ldis) i960 instruction.
Calls mem(0), dst(1).

=over

=item Z<>

=item Input:

0 - the "c" casting type needed to restrict memory load.

=item Output:

Code to insert into the C file.

=item Globals:

None directly used nor changed.

=item Execution:

Execute code emulating the appropriate instruction.

=back

=cut

##############################################################################
sub op_load($)
{
  my $type = $_[0];
  my ($mem, $pre_code) = mem(0, $L_used_load);
  my $dst = dst(1);
  my $code = $pre_code;

  if ($option_check_local_memory == 1 && $NO_MEMORY_ADDRESS_LOCAL_CHECK == 1) {
    $code .= 'CHECK_LOCAL_MEMORY("' . "$filename:$linenumber  $opcode $mem,$dst" . '", (ulong)(' .  $mem . '));';
  }
  $code .= $dst . ' = *(volatile ' . $type . '*)(' . $mem . ');';
  if (defined($defines{'HISTORY_KEEP'}) &&
      $NO_CHECK_MEMORY_PATTERNS != 0 &&
      $type eq 'ulong') {
    $code .= 'check_memory_patterns("' . "$filename:$linenumber  $opcode $mem,$dst" . '", ' . $dst . ');';
  }
  return ($code);
}


##############################################################################

=head1 Subroutine C<op_logical> generates code for the various boolean i960
(and, andnot, nand, nor, notand, notor, or, ornot, xnor, xor) instructions.
Calls src(0), src(1), dst(2).

=over

=item Z<>

=item Input:

0 - Possible "~" (complement) of first argument.

1 - Logical operation to perform.

2 - Possible "~" (complement) of second argument.

=item Output:

Code to insert into the C file.

=item Globals:

None directly used nor changed.

=item Execution:

Execute code emulating the i960 logical instruction.

=back

=cut

##############################################################################
sub op_logical($$$)
{
  my $op1 = $_[0];
  my $op2 = $_[1];
  my $op3 = $_[2];
  my $src1 = src(0);    # Note numbering changed to match book.
  my $src2 = src(1);
  my $dst = dst(2);
  my $code = '';

  $code .= CHECK_RREG($src1);
  $code .= CHECK_RREG($src2);
  $code .= dst(2) . ' = ' . $op1 . $src1 . $op2 . $op3 . $src2 . ';';
  return ($code);
}


##############################################################################

=head1 Subroutine C<op_modify> generates code for the i960 modify bits instruction.
Calls src(0), src(1), src(2), dst(2).
The destination register is also the third input register.

=over

=item Z<>

=item Input:

None.

=item Output:

Code to insert into the C file.

=item Globals:

None directly used nor changed.

=item Execution:

Execute code emulating the i960 modify instruction.
The destination is set to the second register anded with the first, then
ored with the complement of the first register anded with the third.

=back

=cut

##############################################################################
sub op_modify()
{
  my $mask = src(0);
  my $src1 = src(1);
  # The source and destination done separately, in unlikely case fp/g15 used.
  my $src2 = src(2);            # both input and output
  my $dst = dst(2);             # both input and output
  my $code = '';

  $code .= CHECK_RREG($mask);
  $code .= CHECK_RREG($src1);
  $code .= CHECK_RREG($src2);
  $code .= $dst . '= (' . $src1 . ' & ' . $mask . ') | (' . $src2 . ' & ~' . $mask . ');';
  return ($code);
}


##############################################################################

=head1 Subroutine C<op_modpc> handles the modpc instruction.
It performs system management and control operations (like software interrupts, etc.).
This routine calls a "c" helper routine i960_modpc().
Calls src(0), src(1), dst(2).

=over

=item Z<>

=item Input:

None.

=item Output:

Code to insert into the C file.

=item Globals:

None directly used nor changed.

=item Execution:

The "c" helper routine i960_modpc() writes out "modpc not decoded yet." and exits.
There should be no modpc instructions executed in production code.

=back

=cut

##############################################################################
sub op_modpc()
{
  my $src1 = src(0);    # Note: order changed to match book
  my $src2 = src(1);
  my $dst = dst(2);
  my $code;

  if ($option_i386 == 1 || $option_mips == 1) {
    $code = 'i960_modpc(' . $src1 . ', ' . $src2 . ', &' . $dst . ');';
  } else {
    $code .= '__asm__ __volatile__( "modpc %2,%1,%0" : "=r" (' . $dst. ') : "ir" (' . $src2 . '), "r" (' . $src1. '));';
  }
  return ($code);
}


##############################################################################

=head1 Subroutine C<op_movm> generates code for the various i960 move
instructions (mov, movl, movt, movq).
Calls src(0), dst(1).
Code is generated to do multiple register moves.
If the first argument is a constant, then other registers are loaded with zero.
The code does not check for legal first register on multiple moves.

=over

=item Z<>

=item Input:

None.

=item Output:

Code to insert into the C file.

=item Globals:

None directly changed.
Uses %regnum, %regname.

=item Execution:

Execute code emulating the appropriate instruction.

=back

=cut

##############################################################################
sub op_movm($)
{
  my $count = $_[0];
  my $src = src(0);
  my $dst = dst(1);
  my $newsrc = $regnum{$src};
  my $newdst = $regnum{$dst};
  my $i;
  my $code = '';
  my $dstname;
  my $type_cast = '';

  if (!defined($newsrc)) {              # if not a register
    if ($src =~ /^\d+$/) {              # if a number.
      if (($src & 0x1f) != $src) {
        error("op_movm, value not fit in 5 bits '$src'.");
      }
      $code .= $dst . ' = ' . ($src & 0x1f) . ';';      # limit to 5 bits.
      for ($i = 1; $i < $count; $i++) {
        if ($newdst + $i > 0x1f) {
          warning(1, 'op_movm, wrapping registers storing constant.');
        }
        $dstname = $regname[($newdst + $i) & 0x1f];
        ### check if fp or g15 changed anywhere ### optimization planning ####
        if ($regnum{$dstname} == $regnum{'g15'} ||
            $regnum{$dstname} == $regnum{'r0'} ||
            $regnum{$dstname} == $regnum{'r2'}) {
          warning($option_W_fp_r0_r2_changed, 'op_movm - fp/g15/r0/pfp/r2/rip register as extended destination.');
        }
        $type_cast = '';
        $code .= ' ' . $dstname . ' = ' . $type_cast . '(0);'; # Others are zero.
      }
      return ($code);
    } else {
      error("op_movm newsrc: mov -- operand[0]=($operand[0]) -- src=($src)");
    }
  } else {
    if (defined($regnum{$dst}) && ($regnum{$dst} == $regnum{'g15'} ||
        $regnum{$dst} == $regnum{'r0'} || $regnum{$dst} == $regnum{'r2'})) {
      warning($option_W_fp_r0_r2_changed, 'op_movm - fp/g15/r0/pfp/r2/rip register as extended destination.');
    }
    $code .= CHECK_RREG($src);
    $code .= $dst . ' = ' . $type_cast . '(' . $src . ');';
  }
  for ($i = 1; $i < $count; $i++) {
    if ($newsrc + $i > 0x1f) {
      warning(1, 'op_movm, wrapping registers on load.');
    }
    if ($newdst + $i > 0x1f) {
      warning(1, 'op_movm, wrapping registers on store.');
    }
    $dstname = $regname[($newdst + $i) & 0x1f];
    ### check if fp or g15 changed anywhere ### optimization planning ####
    if ($regnum{$dstname} == $regnum{'g15'} ||
        $regnum{$dstname} == $regnum{'r0'} ||
        $regnum{$dstname} == $regnum{'r2'}) {
      warning($option_W_fp_r0_r2_changed, 'op_movm - fp/g15/r0/pfp/r2/rip register as extended destination.');
    }
    $type_cast = '';
    $code .= CHECK_RREG($regname[($newsrc + $i) & 0x1f]);
    $code .= ' ' . $dstname . ' = ' . $type_cast . '(' . $regname[($newsrc + $i) & 0x1f] . ');';
  }
  return ($code);
}


##############################################################################

=head1 Subroutine C<op_mult> generates code for i960 multiply, divide and remainders,
signed or unsigned instructions (divi, divo, modi, muli, mulo, remi, remo).
Calls src(0), src(1), dst(2).

=over

=item Z<>

=item Input:

0 - The type casting to be done for the operation.

1 - A string of the operation to be done ('/').

=item Output:

Code to insert into the C file.

=item Globals:

None directly used nor changed.

=item Execution:

Execute code emulating the i960 instruction.

=back

=cut

##############################################################################
sub op_mult($$)
{
  my $type = $_[0];
  my $op = $_[1];
  my $src1 = src(0);    # Note numbering change to match book.
  my $src2 = src(1);
  my $dst = dst(2);
  my $code = '';

  $code .= CHECK_RREG($src1);
  $code .= CHECK_RREG($src2);
  $code .= $dst . ' = (' . $type . ')(' . $src2 . ') ' .
                     $op . ' (' . $type . ')(' . $src1 . ');';
  return ($code);
}


##############################################################################

=head1 Subroutine C<op_not> generates code for the not instruction.
Calls src(0), dst(1).
This complements the input value.

=over

=item Z<>

=item Input:

None.

=item Output:

Code to insert into the C file.

=item Globals:

None directly used nor changed.

=item Execution:

Execute code emulating the i960 instruction.

=back

=cut

##############################################################################
sub op_not()
{
  my $src1 = src(0);    # Note numbering changed to match book.
  my $dst = dst(1);
  my $code = '';

  $code .= CHECK_RREG($src1);
  $code .= $dst . ' = ~' . $src1 . ';';
  return ($code);
}


##############################################################################

=head1 Subroutine C<op_notbit> generates code for the notbit instruction.
Calls bitpos(0), src(1), dst(2).
This complements the one bit position specified.

=over

=item Z<>

=item Input:

None.

=item Output:

Code to insert into the C file.

=item Globals:

None directly used nor changed.

=item Execution:

Execute code emulating the i960 notbit instruction.

=back

=cut

##############################################################################
sub op_notbit()
{
  my $bitpos = bitpos(0);
  my $src = src(1);
  my $dst = dst(2);
  my $code = '';

  $code .= CHECK_RREG($bitpos);
  $code .= CHECK_RREG($src);
  $code .=  $dst . ' = ' . $src .  ' ^ (1<<(' . $bitpos . ' & 0x1f));'; # toggle
  return ($code);
}


##############################################################################

=head1 Subroutine C<op_return> generates code to execute the i960 ret instruction.
This sets the frame pointer to the previous frame pointer, then does a "c"
goto to the address in the rip register.

=over

=item Z<>

=item Input:

None.

=item Output:

Code to insert into the C file.

=item Globals:

None directly used nor changed.

=item Execution:

Execute code emulating the i960 ret instruction.
This changes global register fp (g15).
Execution continues at the address saved with the last call.

=back

=cut

##############################################################################
sub op_return()
{
  my $code;

  $code  = printdebugp("$filename:$linenumber  before ret");
  if ($option_check_r_reg_pattern_match == 1) {
    $code .= '{ ulong tmp = pfp;';
    $code .=   'r0=r1=r2=r3=r4=r5=r6=r7=r8=r9=r10=r11=r12=r13=r14=r15=0xBABEBABE;';
    $code .=   'fp = tmp;';
    $code .= '}';
  } else {
    $code .= 'fp = pfp; ';
  }
#  $code .= printdebugp("$filename:$linenumber  after ret");
  $code .= 'goto *(void*) rip;';
  return ($code);
}


##############################################################################

=head1 Subroutine C<op_rotate> generates code to do a left shift.
Calls bitpos(0), src(1), dst(2).

=over

=item Z<>

=item Input:

None.

=item Output:

Code to insert into the C file.

=item Globals:

None directly used nor changed.

=item Execution:

Execute code emulating the i960 rotate instruction.

=back

=cut

##############################################################################
sub op_rotate()
{
  my $len = bitpos(0);
  my $src = src(1);
  my $dst = dst(2);
  my $code = '';

  $code .= CHECK_RREG($len);
  $code .= CHECK_RREG($src);
  $code .= $dst . ' = ' . $src . ' << ' . $len . ';';
  return ($code);
}


##############################################################################

=head1 Subroutine C<op_scanbit> generates code to do the i960 scanbit (Scan for Bit) instruction.
Calls src(0), dst(1).

=over

=item Z<>

=item Input:

None.

=item Output:

Code to insert into the C file.

=item Globals:

None directly used nor changed.

=item Execution:

Execute code emulating the i960 scanbit instruction.
A loop is done to find the highest bit turned on,
and sets the compare flag to equal.

=back

=cut

##############################################################################
sub op_scanbit()
{
  my $src1 = src(0);    # Note numbering changed to match book.
  my $dst = dst(1);
  my $code = '';

  $code .= CHECK_RREG($src1);
  $code .= 'cmp_tmp0 = 0; ';
  $code .= 'if (' . $src1 . '== 0) {';
  $code .=   'cmp_tmp1 = 1;';
  $code .=   $dst . '= 0xffffffff;';
  $code .= '} else {';
  $code .=   '__asm__ ("bsrl %1,%0" : "=r" (' . $dst .') : "r" (' . $src1 . '));';
  $code .=   'cmp_tmp1 = 0;';
  $code .= '}';
  $used_cmps = 1;
#  $used_order = 1;
  return ($code);
}


##############################################################################

=head1 Subroutine C<op_select> generates code for the i960 select instructions
(sele, selne, selg, selge, sell, selle).
Calls src(0), src(1), dst(2).

=over

=item Z<>

=item Input:

0 - String representing the comparison to perform, and if true return the
second value, otherwise the first.

=item Output:

Code to insert into the C file.

=item Globals:

None directly used nor changed.

=item Execution:

Execute code emulating the i960 select instructions.
The two condition variables cmp_tmp0 and cmp_tmp1 are set to the first two arguments.

=back

=cut

##############################################################################
sub op_select($)
{
  my $condition_code = $_[0];
  my $src1 = src(0);    # Note numbering changed to match book.
  my $src2 = src(1);
  my $dst = dst(2);
  my $code = '';

  my $check1 = CHECK_RREG($src1);
  my $check2 = CHECK_RREG($src2);

  $code .= $dst . ' = ' . condition($condition_code) . ' ? ';
  if ($check2 ne '') {
      $check2 =~ s/;$//;
      $code .= '(' . $check2 . ',' . $src2 . ')';
  } else {
      $code .= $src2;
  }
  $code .= ' : ';
  if ($check1 ne '') {
      $check1 =~ s/;$//;
      $code .= '(' . $check1 . ',' . $src1 . ');';
  } else {
      $code .= $src1 . ';';
  }
  return ($code);
}


##############################################################################

=head1 Subroutine C<op_selno> generates code for select not ordered.
Calls src(0), src(1), dst(2).
Not ordered is implemented as not equal, change it to that.

=over

=item Z<>

=item Input:

None.

=item Output:

Code to insert into the C file.

=item Globals:

None directly used nor changed.

=item Execution:

Execute code emulating the i960 selno instruction.

=back

=cut

##############################################################################
sub op_selno()
{
  my $src1 = src(0);    # Note numbering changed to match book.
  my $src2 = src(1);
  my $dst = dst(2);
  my $code = '';

  $code .= CHECK_RREG($src1);
  $code .= CHECK_RREG($src2);
  $code .= $dst . ' = cmp_tmp0 != cmp_tmp1 ? ';         # (not equal)
  $code .=            $src2 . ' : ' . $src1 . ';';
#  $used_order = 1;
  return ($code);
}


##############################################################################

=head1 Subroutine C<op_selo> generates code for select ordered.
Calls src(0), src(1), dst(2).
As ordered is implemented as equal, change it to that.

=over

=item Z<>

=item Input:

None.

=item Output:

Code to insert into the C file.

=item Globals:

None directly used nor changed.

=item Execution:

Execute code emulating the i960 selo instruction.

=back

=cut

##############################################################################
sub op_selo()
{
  my $src1 = src(0);    # Note numbering changed to match book.
  my $src2 = src(1);
  my $dst = dst(2);
  my $code = '';

  $code .= CHECK_RREG($src1);
  $code .= CHECK_RREG($src2);
  $code .= $dst . ' = cmp_tmp0 == cmp_tmp1 ? ';
  $code .=            $src2 . ' : ' . $src1 . ';';
#  $used_order = 1;
  return ($code);
}


##############################################################################

=head1 Subroutine C<op_shlo> generates code for a shift left (shlo).
The top bits are tossed, zeros into bottom.
Calls (src(0), src(1), dst(2).

=over

=item Z<>

=item Input:

None.

=item Output:

Code to insert into the C file.

=item Globals:

None directly used nor changed.

=item Execution:

Execute code emulating the i960 shlo instruction.

=back

=cut

##############################################################################
sub op_shlo()
{
  my $len = src(0);     # Note numbering changed to match book.
  my $src = src(1);
  my $dst = dst(2);
  my $code = '';

  $code .= CHECK_RREG($len);
  $code .= CHECK_RREG($src);
  $code .= $dst . ' = (' . $len . ' < 32) ? (' . $src . ' << ' . $len . ') : 0;';
  return ($code);
}


##############################################################################

=head1 Subroutine C<op_shri> generates code for an arithmetic shift right (shri).
This tosses the lower bits, and keeps the upper bit as it moves right.
Calls (src(0), src(1), dst(2).

=over

=item Z<>

=item Input:

None.

=item Output:

Code to insert into the C file.

=item Globals:

None directly used nor changed.

=item Execution:

Execute code emulating the i960 shri instruction.

=back

=cut

##############################################################################
sub op_shri()
{
  my $len = src(0);     # Note numbering changed to match book.
  my $src = src(1);
  my $dst = dst(2);
  my $code = '';

  $code .= CHECK_RREG($len);
  $code .= CHECK_RREG($src);
  $code .= $dst . ' = (' . $len . ' < 32) ? ((long)' . $src . ' >> ' . $len . '): (long)' . $src . '>>31;';
  return ($code);
}


##############################################################################

=head1 Subroutine C<op_shro> generates code for a shro (shift right, zeros into top).
Calls src(0), src(1), dst(2).

=over

=item Z<>

=item Input:

None.

=item Output:

Code to insert into the C file.

=item Globals:

None directly used nor changed.

=item Execution:

Execute code emulating the i960 shro instruction.

=back

=cut

##############################################################################
sub op_shro()
{
  my $len = src(0);     # Note numbering changed to match book.
  my $src = src(1);
  my $dst = dst(2);
  my $code = '';

  $code .= CHECK_RREG($len);
  $code .= CHECK_RREG($src);
  $code .= $dst . ' = (' . $len . ' < 32) ? ((ulong)' . $src . ' >> ' . $len . '): 0;';
  return ($code);
}


##############################################################################

=head1 Subroutine C<op_setbit> generates code for i960 setbit operation.
Calls src(0), src(1), dst(2).

=over

=item Z<>

=item Input:

None.

=item Output:

Code to insert into the C file.

=item Globals:

None directly used nor changed.

=item Execution:

Execute code emulating the i960 setbit instruction.

=back

=cut

##############################################################################
sub op_setbit()
{
  my $src1 = src(0);    # Note numbering changed to match book.
  my $src2 = src(1);
  my $dst = dst(2);
  my $code = '';

  $code .= CHECK_RREG($src1);
  $code .= CHECK_RREG($src2);
  $code .= $dst . ' = ' . $src2 . ' | (1 << (' . $src1 .  ' & 0x1f));';
  return ($code);
}


##############################################################################

=head1 Subroutine C<op_spanbit> generates "c" code for a Span Over Bit (spanbit) i960 operation.
Calls src(0), dst(1).

=over

=item Z<>

=item Input:

None.

=item Output:

Code to insert into the C file.

=item Globals:

None directly used nor changed.

=item Execution:

Execute code emulating the i960 spanbit instruction.
Loops from top bit downwards looking for a bit that is clear.
Returns first bit clear (31 is top bit).
Sets the comparison variables cmp_tmp0 and cmp_tmp1 to equal if one is found.

=back

=cut

##############################################################################
sub op_spanbit()
{
  my $src1 = src(0);    # Note numbering changed to match book.
  my $dst = dst(1);
  my $code = '';

  $code .= CHECK_RREG($src1);
  $code .= 'cmp_tmp0 = 0; ';
  $code .= 'if (' . $src1 . '== 0xffffffff) {';
  $code .=   'cmp_tmp1 = 1;';
  $code .=   $dst . '= 0xffffffff;';
  $code .= '} else {';
  $code .=   '__asm__ ("bsrl %1,%0" : "=r" (' . $dst . ') : "r" (~(' . $src1 . ')));';
  $code .=   'cmp_tmp1 = 0;';
  $code .= '}';
  $used_cmps = 1;
#  $used_order = 1;
  return ($code);
}


##############################################################################

=head1 Subroutine C<op_store> generates code for an i960 store (st, stob, stos) operation.
Calls src(0), mem(1).

=over

=item Z<>

=item Input:

0 - The type of cast to do for the store (ushort).

=item Output:

Code to insert into the C file.

=item Globals:

None directly used nor changed.

=item Execution:

Execute code emulating the i960 appropriate store instruction.
Works for ulong, uchar, ushort.

=back

=cut

##############################################################################
sub op_store($)
{
  my $type = $_[0];
  my $src = src(0);
  my ($mem, $pre_code) = mem(1, $L_used_store);
  my $code = $pre_code;

  if ($option_check_local_memory == 1 && $NO_MEMORY_ADDRESS_LOCAL_CHECK == 1) {
    $code .= 'CHECK_LOCAL_MEMORY("' . "$filename:$linenumber  $opcode $src,$mem" . '", (ulong)(' .  $mem . '));';
  }
  $code .= '*(volatile ' . $type . '*)(' . $mem . ') = ' . $src . ';';
  if ($option_save_memory_stored == 1) {
    $code .= ' CT_history_store("' . "$filename:$linenumber $opcode" . '",' .  '(ulong)(' . $src  . '),(ulong)(' . $mem . '));';
  }
  return ($code);
}


##############################################################################

=head1 Subroutine C<op_stm> generates code for a Store Multiple (stl, stt, stq) operation.
Calls src(0), mem(1).

=over

=item Z<>

=item Input:

0 - the number of 32 bit stores to be done.

=item Output:

Code to insert into the C file.

=item Globals:

None directly changed.
Uses %regnum, %regname.

=item Execution:

Execute code emulating the i960 store multiple instruction.
A loop is done in perl to create the correct number of stores.

=back

=cut

##############################################################################
sub op_stm($)
{
  my $count = $_[0];
  my $src = src(0);
  my ($mem, $pre_code) = mem(1, $L_used_store);
  my $reg = $regnum{$src};
  my $code = $pre_code;

  $code .= CHECK_RREG($src);
  if ($option_check_local_memory == 1 && $NO_MEMORY_ADDRESS_LOCAL_CHECK == 1) {
    $code .= 'CHECK_LOCAL_MEMORY("' . "$filename:$linenumber  $opcode $src,$mem" . '", (ulong)(' .  $mem . '));';
  }
  $code .= '*(ulong *)(' . $mem . ') = ' . $src . ';';
  if ($option_save_memory_stored == 1) {
    $code .= ' CT_history_store("' . "$filename:$linenumber $opcode" . '",' .  '(ulong)(' . $src  . '),(ulong)(' . $mem . '));';
  }
  for (my $i = 1; $i < $count; $i++) {
    $code .= CHECK_RREG($regname[$reg + $i]);
    $code .= ' *(ulong *)(' . $mem . ' + ' . 4*$i . ') = ' . $regname[$reg + $i] . ';';
    if ($option_save_memory_stored == 1) {
      $code .= ' CT_history_store("' . "$filename:$linenumber $opcode" . '",' .  '(ulong)(' . $src  . '),(ulong)(' . $mem . '));';
    }
  }
  return ($code);
}


##############################################################################

=head1 Subroutine C<op_subc> generates code for a subtract-with-carry (subc).
Calls src(0), src(1), dst(2).

=over

=item Z<>

=item Input:

None.

=item Output:

Code to insert into the C file.

=item Globals:

None directly used nor changed.

=item Execution:

Execute code emulating the i960 subc instruction.
The first argument is subtracted from the second argument.
One more is subtracted.
If the last comparison done is equal, then add one.
Condition code is set to the 33rd bit of the calculation.

=back

=cut

##############################################################################
sub op_subc()
{
  my $src1 = src(0);    # Note numbering changed to match book.
  my $src2 = src(1);
  my $dst = dst(2);
  my $code = '';

  $code .= CHECK_RREG($src1);
  $code .= CHECK_RREG($src2);
  $code .= '{ ';
  $code .=   'unsigned long long tmp_subc = ' . $src2 . '; ';
  $code .=   'tmp_subc = tmp_subc -' . $src1 . '-1; ';
  $code .=   'tmp_subc += ' . condition('==') . '; ';
  $code .=   $dst . ' = (ulong)tmp_subc; ';
  $code .=   'cmp_tmp0 = 0; ';
  $code .=   'cmp_tmp1 = (tmp_subc >> 32) & 1;}';
  $used_cmps = 1;
  return ($code);
}


##############################################################################

=head1 Subroutine C<op_sysctl> handles the sysctl instruction.
On the i960 it performs system management and control operations.
This routine calls a "c" helper routine i960_sysctl().
Calls src(0), src(1), dst(2).

=over

=item Z<>

=item Input:

None.

=item Output:

Code to insert into the C file.

=item Globals:

None directly used nor changed.

=item Execution:

The "c" helper routine i960_sysctl() writes out "sysctl not decoded yet." and exits.
There should be no sysctl instructions executed in production code.

=back

=cut

##############################################################################
sub op_sysctl()
{
  my $src1 = src(0);    # Note: order changed to match book
  my $src2 = src(1);
  my $dst = dst(2);
  my $code;

  if ($option_i386 == 1 || $option_mips == 1) {
    $code  = 'i960_sysctl(' . $src1 . ', ' . $src2 . ', &' . $dst . ');';
  } else {
    $code .= '__asm__ __volatile__( "sysctl 2,%1,%0" : "=r" (' . $dst. ') : "ir" (' . $src2 . '), "r" (' . $src1. '));';
  }
  return ($code);
}


##############################################################################

=head1 Subroutine C<op_test> generates code for the i960 test
(teste, testne, testl, testle, testg, testge) instructions.
Calls dst(0).

=over

=item Z<>

=item Input:

0 - String representing comparison to be done ('==').

=item Output:

Code to insert into the C file.

=item Globals:

None directly used nor changed.

=item Execution:

Execute code emulating the i960 test instructions.
The destination is set to 1 if the condition is true, else zero.

=back

=cut

##############################################################################
sub op_test($)
{
  my $condition_code = $_[0];           # type of comparison
  my $dst = dst(0);
  my $code;

  $code  = $dst . ' = ' . condition($condition_code) . ' ? 1 : 0;';
  return ($code);
}


##############################################################################

=head1 Subroutine C<op_PushRegs> generates code for the m4 preprocessor macro
for saving g0 through g14 onto the stack using an "r" register.

=over

=item Z<>

=item Input:

None.

=item Output:

Code to insert into the C file.

=item Globals:

None directly changed.
Uses %operand;

=item Execution:

The code executed sets the argument to current sp (stack pointer).
The stack pointer is incremented by 60 (15*4, note g15 points to r registers).
Then using the argument, stores g0 through g14 on the stack.
g14 is then set to zero (for potential "c" code).

=back

=cut

##############################################################################
sub op_PushRegs()
{
  my $code;
  my $reg = '';
  if (defined($operand[0]))
  {
    $reg = $operand[0];
  }

  $reg =~ s/^\((.*)\)$/$1/;             # toss parenthesis

# If no parenthesis and register, just use the stack, else put stack pointer into register.
  if (!defined($reg) || $reg eq '' || $reg eq ' ') {
    $code .= "sp = (ulong)(60+sp); ";
    $code .= "*(ulong*)(sp-60)=g0; *(ulong*)(sp-56)=g1; *(ulong*)(sp-52)=g2; *(ulong*)(sp-48)=g3; ";
    $code .= "*(ulong*)(sp-44)=g4; *(ulong*)(sp-40)=g5; *(ulong*)(sp-36)=g6; *(ulong*)(sp-32)=g7; ";
    $code .= "*(ulong*)(sp-28)=g8; *(ulong*)(sp-24)=g9; *(ulong*)(sp-20)=g10; *(ulong*)(sp-16)=g11; ";
    $code .= "*(ulong*)(sp-12)=g12; *(ulong*)(sp-8)=g13; *(ulong*)(sp-4)=g14; ";
  } else {
    $code  = "$reg=sp; ";                 # allocate stack frame
    $code .= "sp = (ulong)(60+sp); ";
    $code .= "*(ulong*)($reg)=g0; *(ulong*)($reg+4)=g1; *(ulong*)($reg+8)=g2; *(ulong*)($reg+12)=g3; ";
    $code .= "*(ulong*)(16+$reg)=g4; *(ulong*)(20+$reg)=g5; *(ulong*)(24+$reg)=g6; *(ulong*)(28+$reg)=g7; ";
    $code .= "*(ulong*)(32+$reg)=g8; *(ulong*)(36+$reg)=g9; *(ulong*)(40+$reg)=g10; *(ulong*)(44+$reg)=g11; ";
    $code .= "*(ulong*)(48+$reg)=g12; *(ulong*)(52+$reg)=g13; *(ulong*)(56+$reg)=g14; ";
  }
  return ($code);
}


##############################################################################

=head1 Subroutine C<op_PopRegsVoid> generates code for the m4 macro PopRegsVoid
for restoring g0 through g14 registers via an "r" register.

=over

=item Z<>

=item Input:

None.

=item Output:

Code to insert into the C file.

=item Globals:

None directly changed.
Uses %operand.

=item Execution:

The code executed restores the g registers from the location pointed to by
the argument.  Then the stack pointer is decremented by 60 (popping the stack).

=back

=cut

##############################################################################
sub op_PopRegsVoid()
{
  my $code = '';
  my $reg = '';
  if (defined($operand[0]))
  {
    $reg = $operand[0];
  }

  $reg =~ s/^\((.*)\)$/$1/;             # toss parenthesis

# If no parenthesis and register, just use the stack, else put stack pointer into register.
  if (!defined($reg) || $reg eq '' || $reg eq ' ') {
    $code .= "g0=*(ulong*)(sp-60); g1=*(ulong*)(sp-56); g2=*(ulong*)(sp-52); g3=*(ulong*)(sp-48); ";
    $code .= "g4=*(ulong*)(sp-44); g5=*(ulong*)(sp-40); g6=*(ulong*)(sp-36); g7=*(ulong*)(sp-32); ";
    $code .= "g8=*(ulong*)(sp-28); g9=*(ulong*)(sp-24); g10=*(ulong*)(sp-20); g11=*(ulong*)(sp-16); ";
    $code .= "g12=*(ulong*)(sp-12); g13=*(ulong*)(sp-8); g14=*(ulong*)(sp-4); ";
    $code .= "sp = (ulong)(sp-60); ";
  } else {
    $code .= CHECK_RREG($reg);
    $code .="g0=*(ulong*)($reg); g1=*(ulong*)($reg+4); g2=*(ulong*)($reg+8); g3=*(ulong*)($reg+12); ";
    $code .= "g4=*(ulong*)(16+$reg); g5=*(ulong*)(20+$reg); g6=*(ulong*)(24+$reg); g7=*(ulong*)(28+$reg); ";
    $code .= "g8=*(ulong*)(32+$reg); g9=*(ulong*)(36+$reg); g10=*(ulong*)(40+$reg); g11=*(ulong*)(44+$reg); ";
    $code .= "g12=*(ulong*)(48+$reg); g13=*(ulong*)(52+$reg); g14=*(ulong*)(56+$reg); ";
    $code .= "sp=sp-60;";
  }
  return ($code);
}


##############################################################################

=head1 Subroutine C<op_PopRegs> generates code for the m4 preprocessor macro
for restoring g1 through g14 registers (g0 is return code and saved).

=over

=item Z<>

=item Input:

None.

=item Output:

Code to insert into the C file.

=item Globals:

None directly changed.
Uses %operand.

=item Execution:

The code executed restores the g registers from the location pointed to by
the argument.  Then the stack pointer is decremented by 60 (popping the stack).
This macro does not restore g0, assuming it is a return value.

=back

=cut

##############################################################################
sub op_PopRegs()
{
  my $reg = '';
  if (defined($operand[0]))
  {
    $reg = $operand[0];
  }
  my $code = '';

  $reg =~ s/^\((.*)\)$/$1/;             # toss parenthesis

# If no parenthesis and register, just use the stack, else put stack pointer into register.
  if (!defined($reg) || $reg eq '' || $reg eq ' ') {
    $code .= "g1=*(ulong*)(sp-56); g2=*(ulong*)(sp-52); g3=*(ulong*)(sp-48); ";
    $code .= "g4=*(ulong*)(sp-44); g5=*(ulong*)(sp-40); g6=*(ulong*)(sp-36); g7=*(ulong*)(sp-32); ";
    $code .= "g8=*(ulong*)(sp-28); g9=*(ulong*)(sp-24); g10=*(ulong*)(sp-20); g11=*(ulong*)(sp-16); ";
    $code .= "g12=*(ulong*)(sp-12); g13=*(ulong*)(sp-8); g14=*(ulong*)(sp-4); ";
    $code .= "sp = (ulong)(sp-60); ";
  } else {
    $code .= CHECK_RREG($reg);
    $code .="g1=*(ulong*)($reg+4); g2=*(ulong*)($reg+8); g3=*(ulong*)($reg+12); ";
    $code .= "g4=*(ulong*)(16+$reg); g5=*(ulong*)(20+$reg); g6=*(ulong*)(24+$reg); g7=*(ulong*)(28+$reg); ";
    $code .= "g8=*(ulong*)(32+$reg); g9=*(ulong*)(36+$reg); g10=*(ulong*)(40+$reg); g11=*(ulong*)(44+$reg); ";
    $code .= "g12=*(ulong*)(48+$reg); g13=*(ulong*)(52+$reg); g14=*(ulong*)(56+$reg); ";
    $code .= "sp=sp-60;";
  }
  return ($code);
}


##############################################################################

=head1 Subroutine C<internal_do_global> will take the passed in label and
mark it as needing to be global.
Used by routines doing m4 macro expansion / simulation.
Only effective for pass 1.

=over

=item Z<>

=item Input:

0 - Label to be marked as needing to be global.

=item Output:

None.

=item Globals:

Uses and Changes %global.

=item Execution:

N/A.

=back

=cut

##############################################################################
sub internal_do_global($)
{
  my $name = $_[0];

  if ($pass_number == 1) {
    if (defined($global{$name})) {
      $global{$name}++;
      warning($option_W_multiple_global,
        "$name set as global $global{$name} times");
    } else {
      $global{$name} = 1;
    }
  }
}

##############################################################################

=head1 Subroutine C<internal_do_word> creates a C<.word> entry with value
passed to routine.
Used for m4 macro expansion/simulation.
Calls convert_label_ampamp().

=over

=item Z<>

=item Input:

0 - Value to store in the C<.word>.

=item Output:

Code to insert into the C file.

=item Globals:

None directly used nor changed.

=item Execution:

N/A.

=back

=cut

##############################################################################
sub internal_do_word($)
{
  my $value = expression($_[0],0);
  my $type;
  my $code;

  if ($option_i386 == 1 || $option_mips == 1) {
    $type = '.long';
  } else {
    $type = '.word';
  }
  $value = convert_label_ampamp($value, $L_used_data,$option_W_external_label_in_long);
  $code = $ASM . '("' . $type . ' ' . $value . '");';
  return($code);
}

##############################################################################

=head1 Subroutine C<internal_do_set> does the equivalent of a C<.set> of the
first argument with the second.
Used for m4 macro expansion/simulation.
Calls expression().

=over

=item Z<>

=item Input:

0 - Variable to be created and have it's value set.

1 - Value to be put into variable.

=item Output:

None.

=item Globals:

Uses and changes %const, %const_count.

=item Execution:

N/A.

=back

=cut

##############################################################################
sub internal_do_set($$)
{
  my $var = $_[0];
  my $value = $_[1];
  my $expression = expression($value,0);   # simplify expression.

  if (!defined($const{$var})) {
    $const_count{$var} = 1;
  } else {
    $const_count{$var}++;
  }
  $const{$var} = $expression;
}

##############################################################################

=head1 Subroutine C<internal_do_align> does the equivalent of a C<.align>.
Used for m4 macro expansion/simulation.
For x86 and mips, this value is x to the second power.

=over

=item Z<>

=item Input:

0 - Bit to align upon. (i.e. 2 aligns on four bytes.)

=item Output:

Code to insert into the C file.

=item Globals:

None directly used nor changed.

=item Execution:

N/A.

=back

=cut

##############################################################################
sub internal_do_align($)
{
  my $var = $_[0];
  my $code  = $ASM . '( ".align';

  if ($option_i386 == 1 || $option_mips == 1) {
    $code .= ' ' . $var ** 2 . '");';
  } else {
    $code .= ' ' . $var . '");';
  }
  return($code);
}

##############################################################################

=head1 Subroutine C<op_tablename> handles an m4 pre-processor tablename line.
It emulates what the m4 macro in Proc/inc/macros.inc does.
See the comments in the code, which matches with the macro definition.
Macro tablename creates the two base pointer for the state array and the action array.
Calls routines internal_do_global(), internal_do_align(), label_generate(),
internal_do_word(), internal_do_set().

=over

=item Z<>

=item Input:

None.

=item Output:

Code to insert into the C file.

=item Globals:

None directly changed.
Uses %const.

=item Execution:

N/A.

=back

=cut

##############################################################################
sub op_tablename()
{
  my $code;
  my $name = $operand[0];

  $name =~ s/^\((.*)\)$/$1/;            # toss parenthesis

  if (!defined($const{'EQU_ONLY'})) {         # .ifndef EQU_ONLY
    internal_do_global($name);                #    .global ${name}
    $code .= internal_do_align(2);            #    .align  2
    $code .= label_generate($name);           # ${name}:
    $code .= internal_do_word("s_D_${name}"); #    .word  s.${name}
    $code .= internal_do_word("a_D_${name}"); #    .word  a.${name}
    $stable = "s_D_${name}";                  #     definemacro("stable", "s.${name}:")
    $atable = "a_D_${name}";                  #     definemacro("atable", "a.${name}:")
  } else {                                    # .else  /* EQU_ONLY */
    internal_do_set("STATECOUNT",0);          #    .set   STATECOUNT,0
    internal_do_set("EVENTCOUNT",0);          #    .set   EVENTCOUNT,0
    internal_do_set("ACTIONCOUNT",0);         #    .set   ACTIONCOUNT,0
    $code = "/* tablename ${name} not generated */";
  }                                           # .endif /* EQU_ONLY */
  return ($code);
}


##############################################################################

=head1 Subroutine C<op_state> handles an m4 pre-processor state line.
It emulates what the m4 macro in Proc/inc/macros.inc does.
See the comments in the code, which matches with the macro definition.
Macro state creates an entry in the state array.
Calls internal_do_set(), internal_do_word(), expression().

=over

=item Z<>

=item Input:

None.

=item Output:

Code to insert into the C file.

=item Globals:

None directly changed.
Uses %const.

=item Execution:

N/A.

=back

=cut

##############################################################################
sub op_state()
{
  my $code = '';
  my $name = $operand[0];
  my $expr;

  $name =~ s/^\((.*)\)$/$1/;            # toss parenthesis

  if (!defined($const{'EQU_ONLY'})) {           # .ifndef EQU_ONLY
    if (!defined($const{'STATECOUNT'})) {       # .ifndef STATECOUNT
      $code .= label_generate($stable);         # stable   # definemacro in ps_tablename.
      internal_do_set("STATECOUNT",0);          #    .set   STATECOUNT,0
    }                                           # .endif /* STATECOUNT */
    $expr = expression("STATECOUNT",0);
    internal_do_set("s_D_${name}",$expr);       #    .set   s.${name},STATECOUNT
    $code .= internal_do_word("xc_D_${name}");  #    .word  xc.${name}
    $expr = expression("STATECOUNT+4",0);
    internal_do_set("STATECOUNT",$expr);        #    .set   STATECOUNT,STATECOUNT+4
  } else {                                      # .endif /* EQU_ONLY */
    $code = "/* state ${name} not generated */";
  }
  return ($code);
}


##############################################################################

=head1 Subroutine C<op_event> handles an m4 pre-processor event line.
It emulates what the m4 macro in Proc/inc/macros.inc does.
See the comments in the code, which matches with the macro definition.
Macro event defines an event.
Calls routines internal_do_set(), expression(), internal_do_word().

=over

=item Z<>

=item Input:

None.

=item Output:

Code to insert into the C file.

=item Globals:

None directly changed.
Uses %const.

=item Execution:

N/A.

=back

=cut

##############################################################################
sub op_event()
{
  my $code;
  my $name = $operand[0];
  my $expr;

  $name =~ s/^\((.*)\)$/$1/;            # toss parenthesis

  if (!defined($const{'EVENTCOUNT'})) {  # .ifndef EVENTCOUNT
    internal_do_set("EVENTCOUNT",0);     #    .set   EVENTCOUNT,0
  }                                      # .endif /* EVENTCOUNT */
  $expr = expression("EVENTCOUNT",0);
  internal_do_set("$name",$expr);        # .set   ${name},EVENTCOUNT
  $code = internal_do_word("${name}");   # .word  ${name}
  $expr = expression("EVENTCOUNT+4",0);
  internal_do_set("EVENTCOUNT",$expr);   # .set   EVENTCOUNT,EVENTCOUNT+4
  return ($code);
}


##############################################################################

=head1 Subroutine C<op_action> handles an m4 pre-processor action line.
It emulates what the m4 macro in Proc/inc/macros.inc does.
See the comments in the code, which matches with the macro definition.
Macro action creates an entry in the action array.
Calls internal_do_set(), internal_do_word(), expression().

=over

=item Z<>

=item Input:

None.

=item Output:

Code to insert into the C file.

=item Globals:

None directly changed.
Uses %const.

=item Execution:

N/A.

=back

=cut

##############################################################################
sub op_action()
{
  my $code = '';
  my $name = $operand[0];
  my $expr;

  $name =~ s/^\((.*)\)$/$1/;            # toss parenthesis

  if (!defined($const{'EQU_ONLY'})) {       # .ifndef EQU_ONLY
    if (!defined($const{'ACTIONCOUNT'})) {  # .ifndef ACTIONCOUNT
      $code .= label_generate($atable);     # atable   # definemacro in ps_tablename.
      internal_do_set("ACTIONCOUNT",0);     #    .set   ACTIONCOUNT,0
    }                                       # .endif /* ACTIONCOUNT */
    $expr = expression("ACTIONCOUNT",0);
    internal_do_set("a_D_$name",$expr);     #    .set   a.${name},ACTIONCOUNT
    $code .= internal_do_word("${name}");   #    .word  ${name}
    $expr = expression("ACTIONCOUNT+4",0);
    internal_do_set("ACTIONCOUNT",$expr);   #    .set   ACTIONCOUNT,ACTIONCOUNT+4
  } else {                                  # .endif /* EQU_ONLY */
    $code = "/* action ${name} not generated */";
  }
  return ($code);
}


##############################################################################

=head1 Subroutine C<op_column> handles an m4 pre-processor column line.
It emulates what the m4 macro in Proc/inc/macros.inc does.
See the comments in the code, which matches with the macro definition.
Calls label_generate().
Macro column creates a state column array.

=over

=item Z<>

=item Input:

None.

=item Output:

Code to insert into the C file.

=item Globals:

None directly changed.
Uses %const.

=item Execution:

N/A.

=back

=cut

##############################################################################
sub op_column()
{
  my $code;
  my $name = $operand[0];

  $name =~ s/^\((.*)\)$/$1/;            # toss parenthesis

  if (!defined($const{'EQU_ONLY'})) {        # .ifndef EQU_ONLY
    $code = label_generate("xc_D_${name}"); # xc.${name}:
  } else {                                   # .endif /* EQU_ONLY */
    $code = "/* column xc.${name} not generated */";
  }
  return ($code);
}


##############################################################################

=head1 Subroutine C<op_node> handles an m4 pre-processor node line.
It emulates what the m4 macro in Proc/inc/macros.inc does.
See the comments in the code, which matches with the macro definition.
Calls expression().
Macro node creates a state node array.

=over

=item Z<>

=item Input:

None.

=item Output:

Code to insert into the C file.

=item Globals:

None directly changed.
Uses %const %operand.

=item Execution:

N/A.

=back

=cut

##############################################################################
sub op_node()
{
  my $code;
  my $name = $operand[0];

  $name =~ s/^\(//;              # toss left parenthesis
  $name =~ s/\)$//;              # toss right parenthesis
  my @name = split(/,\s*/, $name);

  if ($#name != 3) {
    $name = $operand[1];
    $name =~ s/^\(//;            # toss left parenthesis
    $name =~ s/\)$//;            # toss right parenthesis
    my @name1 = split(/,\s*/, $name);
    @name = (@name, @name1);
    if ($#name != 3) {
      $name = $operand[2];
      $name =~ s/^\(//;          # toss left parenthesis
      $name =~ s/\)$//;          # toss right parenthesis
      @name1 = split(/,\s*/, $name);
      @name = (@name, @name1);
      if ($#name != 3) {
        $name = $operand[3];
        $name =~ s/^\(//;        # toss left parenthesis
        $name =~ s/\)$//;        # toss right parenthesis
        @name1 = split(/,\s*/, $name);
        @name = (@name, @name1);
        if ($#name != 3) {
          printf STDERR "Not enough arguments in op_node, only %d, want 4\n", $#name + 1;
        }
      }
    }
  }
  $name[0] = expression('a_D_' . $name[0],0);
  $name[1] = expression('a_D_' . $name[1],0);
  $name[2] = expression('a_D_' . $name[2],0);
  $name[3] = expression('s_D_' . $name[3],0);
# print STDERR "op_node arguments=[$name[0]], [$name[1]], [$name[2]], [$name[3]]\n";

# Do:
  if (!defined($const{'EQU_ONLY'})) {       # .ifndef EQU_ONLY
                                            #   .byte  a.$name[0],a.$name[1],a.$name[2],s.$name[3]
    $code = $ASM . '(".byte ' . join(', ', @name) . '");';
  } else {                                  # .endif /* EQU_ONLY */
    $code = "/* node ${name} not generated */";
  }
  return ($code);
}


##############################################################################

=head1 Subroutine C<c> puts the rest of the line into the "c" as it exists.
As lines are broken up by semicolons (';'), care must be taken with their
embedded use (like don't).  A semi-colon is tacked onto the end of the line.
This allows lines of "c" to be embedded within i960 assembler.
Calls expression().

=over

=item Z<>

=item Input:

None.

=item Output:

Code to insert into the C file.

=item Globals:

None directly changed.
Uses %operand.

=item Execution:

N/A.

=back

=cut

##############################################################################
sub c()
{
  my $code = '';

  for (my $i = 0; $i <= $#operand; $i++) {
# print STDERR "operand[$i]='$operand[$i]'\n";
    if ($i > 0) {
# print STDERR "   add ','\n";
      $code .= ',';
    }
#?? TODO CHECK_RREG??
    my @words = split(/\s+/, $operand[$i]);
    my $newcode = '';
    my $cnt = 0;
    foreach my $j ( @words) {
# print STDERR "   word='$j'\n";
      $cnt++;
      if ($cnt != 1) {
        $newcode .= ' ';
      }
      my $ret = expression($j,1);
# print STDERR "     expression returned='$ret'\n";
      $newcode .= $ret;
    }
    $code .= $newcode;
# print STDERR "  newcode='$newcode'\n";
# print STDERR "  code='$code'\n";
  }
  return ($code . ';');
}


sub cdefine()
{
  my $code = ' #define ';

  for (my $i = 0; $i <= $#operand; $i++) {
# print STDERR "operand[$i]='$operand[$i]'\n";
    if ($i > 0) {
      $code .= ',';
    }
#?? TODO CHECK_RREG??
    my @words = split(/\s+/, $operand[$i]);
    my $newcode = '';
    my $cnt = 0;
    foreach my $j ( @words) {
      $cnt++;
      if ($cnt != 1) {
        $newcode .= ' ';
      }
      my $ret = expression($j,1);
      $newcode .= $ret;
    }
    $code .= $newcode;
  }
  return ($code);
}

sub cundef()
{
  my $code = ' #undef ';

  for (my $i = 0; $i <= $#operand; $i++) {
# print STDERR "operand[$i]='$operand[$i]'\n";
    if ($i > 0) {
      $code .= ',';
    }
#?? TODO CHECK_RREG??
    my @words = split(/\s+/, $operand[$i]);
    my $newcode = '';
    my $cnt = 0;
    foreach my $j ( @words) {
      $cnt++;
      if ($cnt != 1) {
        $newcode .= ' ';
      }
      my $ret = expression($j,1);
      $newcode .= $ret;
    }
    $code .= $newcode;
  }
  return ($code);
}

##############################################################################

=head1 Subroutine C<putit> either sends lines to the text section,
or the current section.
This causes all output to be saved in a variable for later output.

=over

=item Z<>

=item Input:

0 - Line(s) of code to be output.

1 - The number of lines being output.

=item Output:

None.

=item Globals:

Uses $section, and $save_section_one.
Changes %save_section, and  %save_section_count.

=item Execution:

N/A.

=back

=cut

##############################################################################
sub putit($$)
{
  my $printit = $_[0];
  my $count = $_[1];

  if ($printit ne '') {
      if ($section ne 'text' && $save_section_one != 1) {
          $save_section{$section} .= $printit;
          $save_section_count{$section} += $count;
      } else {
          $save_section{'text'} .= $printit;
          $save_section_count{'text'} += $count;
      }
  }
  $save_section_one = 0;
}


##############################################################################

=head1 Subroutine C<put_linenumber> will put out the preprocessor line that
tells the file name and line number within a file, if needed.

=over

=item Z<>

=item Input:

0 - The line number we are currently on.

1 - The name of the file we are currently in.

2 - The section that we are currently working within.

3 - If exists, print this information after the line number.
This is used for nested includes and when popping out of one.

=item Output:

Code to insert into the C file.

=item Globals:

Changes $last_linenumber, $last_section, and $last_filename.
Used $option_fullpath.

=item Execution:

N/A.

=back

=cut

##############################################################################
sub put_linenumber($$$$)
{
  my $linenumber = $_[0];
  my $filename = $_[1];
  my $section = $_[2];
  my $after = $_[3];

  if ($linenumber != $last_linenumber ||
      $filename ne $last_filename ||
      $section ne $last_section) {
    if ($after eq '') {
      putit("# $linenumber \"$option_fullpath$filename\"\n", 1);
    } else {
      putit("# $linenumber \"$option_fullpath$filename\" $after\n", 1);
    }
    $last_filename = $filename;
    $last_section = $section;
  }
  $last_linenumber = $linenumber + 1;
}


##############################################################################

=head1 Subroutine C<ps_ignore> exists to ignore an assembler pseudo-op.

=over

=item Z<>

=item Input:

None.

=item Output:

None.  (Well, ' ' so that an error is not detected.)

=item Globals:

None directly used nor changed.

=item Execution:

N/A.

=back

=cut

##############################################################################
sub ps_ignore()
{
  return (' ');
}


##############################################################################

=head1 Subroutine C<ps_bss> does the new equivalent of the i960 .bss pseudo-op.
Calls local_label_name(), label_use(), putit(), expression().
Since there is a label on this command, we can move it into the "data" file.

=over

=item Z<>

=item Input:

None.

=item Output:

Code to insert into the C "data" file ("c" file number 2).

=item Globals:

Changes and restores $section.
Changes $shdata_byte_count, $shdata_byte_count_total.
Uses %operand.

=item Execution:

N/A.

=back

=cut

##############################################################################
sub ps_bss()
{
    my $save_section = $section;
    my $var = $operand[0];
    my $length = expression($operand[1],0);    # simplify expression.
    my $alignment = expression($operand[2],0); # simplify expression.
    my $code;

    if ($save_section ne '.shmem' && $save_section ne '.shdata') {
        $section = 'data';                     # force to data section.
    }
    $var = local_label_name($var);
    $var = label_use($var, $L_defined_data);
    if ($option_i386 == 1 || $option_mips == 1) {
# printf STDERR ".bss var=$var  length=$length  alignment=$alignment\n";
        $code  = $ASMV . '(".local ' . $var . '");';
        if ($save_section ne '.shdata') {
            $alignment = 2 ** $alignment;      # power of two alignment in i960.
        } else {
            $alignment = 0;                    # no alignment in .shdata section.
        }
# printf STDERR "     var=$var  length=$length  alignment=$alignment\n";
        $code .= $ASMV . '(".comm ' . $var . ',' . $length . ',' . $alignment . '");';
    } else {
        $code .= $ASMV . '(".bss ' . $var . ',' . $length . ',' . $alignment . '");';
    }
    if ($pass_number == 2) {
        putit($code . "\n", 1);
        $code = "/* moved to $section section */";
        if ($save_section eq '.shdata') {
            $section = '.shinit';
            if ($shdata_byte_count > 0) {
                putit("$ASM(\"ps_bss  .space $shdata_byte_count\");\n", 1);
            }
            putit("$ASM(\"$var:\");\n", 1);
            $shdata_byte_count = $length;
            $shdata_byte_count_total += $length;
        }
    }
    $section = $save_section;
    return ($code);
}


##############################################################################

=head1 Subroutine C<ps_comm> does the new equivalent of the i960 .comm pseudo-op.
Calls local_label_name(), label_use(), putit(), expression().
Since there is a label on this command, we can move it into the "data" file.

=over

=item Z<>

=item Input:

None.

=item Output:

Code to insert into the C file.

=item Globals:

Changes and restores $section.
Uses %operand.

=item Execution:

N/A.

=back

=cut

##############################################################################
sub ps_comm()
{
  my $save_section = $section;
  if ($save_section ne '.shmem') {
    $section = 'data';                    # force to data section.
  }
  my $var = $operand[0];
  my $expression = expression($operand[1],0);   # simplify expression.
  my $alignment;
  my $code;

  $var = local_label_name($var);
  $var = label_use($var, $L_defined_data);
  if ($option_i386 == 1 || $option_mips == 1) {
    if ($expression < 4096) {
      $alignment = $expression;
    } else {
      $alignment = 4096;                # max it at 4096.
    }
# printf STDERR ".comm var=$var  expression=$expression  alignment=$alignment\n";
    $code .= $ASMV . '(".comm ' . $var . ',' . $expression . ',' . $alignment . '");';
  } else {
    $code .= $ASMV . '(".comm ' . $var . ',' . $expression . '");';
  }
  if ($pass_number == 2) {
    putit($code . "\n", 1);
    $code = '/* moved to .data section */';
  }
  $section = $save_section;
  return ($code);
}


##############################################################################

=head1 Subroutine C<ps_data> handles the i960 .data pseudo-op.
This changes to the .data section for saving the "c" code.

=over

=item Z<>

=item Input:

None.

=item Output:

None.

=item Globals:

Changes $section to be 'data'.

=item Execution:

N/A.

=back

=cut

##############################################################################
sub ps_data()
{
  my $code;

  if ($section eq 'data') {             # if no section change.
    return (' /* still in data section */');
  }
  if (!defined($save_section{'data'})) {
    $code  = $ASMV . '(".data");';
  } else {
    $code  = " /* reverting to data section from $section */";
  }
  $section = 'data';
  return ($code);
}


##############################################################################

=head1 Subroutine C<ps_else> handles the .else pseudo-op.
This either enables else processing, or ignores it as appropriate for .if.

=over

=item Z<>

=item Input:

None.

=item Output:

None.

=item Globals:

Changes $lookingfor as needed for this .if.

=item Execution:

N/A.

=back

=cut

##############################################################################
sub ps_else()
{
  if ($#lookingfor < 0) {               # if bad else.
    error("bad .else -- nested $#lookingfor");
    return ("bad .else -- nested $#lookingfor");
  }
  $lookingfor = $endif_list;
  return ("/* else ignoring.  nested $#lookingfor */");
}


##############################################################################

=head1 Subroutine C<ps_endif> handles the .endif pseudo-op.
This finishes this .if handling, and potentially pops back into a nested
.if/.else processing.

=over

=item Z<>

=item Input:

None.

=item Output:

None.

=item Globals:

Changes $lookingfor (and @lookingfor) to previous via pop(@lookingfor).

=item Execution:

N/A.

=back

=cut

##############################################################################
sub ps_endif()
{
  if ($#lookingfor < 0) {               # if bad endif.
    error ("bad .endif --  nested $#lookingfor");
    return ("bad .endif --  nested $#lookingfor");
  }
# printf STDERR "ps_endif before:$filename-$linenumber lookingfor=(%s)\n\t$input\n", join(',', @lookingfor);
  $lookingfor = pop(@lookingfor);       # back to last thing doing.
# printf STDERR "ps_endif after:$filename-$linenumber lookingfor=(%s)\n\t$input\n", join(',', @lookingfor);
  return ("/* endif processed.  nested $#lookingfor */");
}


##############################################################################

=head1 Subroutine C<ps_if> handles the i960 pseudo-op .if.
If the value is equal to zero (false), then look for .else or .endif, but one
must also check for other .if's and nest them as don't look at.

=over

=item Z<>

=item Input:

None.

=item Output:

None.

=item Globals:

Changes @lookingfor, $lookingfor nesting information.
Uses %operand.

=item Execution:

N/A.

=back

=cut

##############################################################################
sub ps_if()
{
  my $exp = expression($operand[0],0);
  my $ret;

  if ("$exp" !~/^\d$/) {
    printf STDERR "ps_if:$filename-$linenumber input=($operand[0]) is not a defined expression=>($exp)\n";
    error("input=($operand[0]) is not a defined expression=>($exp)\n");
  }

  if ($exp eq '0') {                    # then false
    push(@lookingfor, $lookingfor);     # save last value
    $lookingfor = $else_list;           # else, endif, if, ifdef
    $ret .= ' false';
  } else {
    push(@lookingfor, $lookingfor);     # save last value
    $lookingfor = $normal_list;         # look for normal stuff.
    $ret .= ' true';
  }
# printf STDERR "ps_if:$filename-$linenumber lookingfor=(%s)\n\t$input\n", join(',', @lookingfor);
  return ("/* $ret -- nested $#lookingfor */");
}


##############################################################################

=head1 Subroutine C<ps_ifdef> handles the .ifdef pseudo-op.
Similar to .if, except sees if a constant variable is set in this pass,
or from the command line.

=over

=item Z<>

=item Input:

None.

=item Output:

None.

=item Globals:

Changes @lookingfor, $lookingfor nesting information.
Uses %operand.

=item Execution:

N/A.

=back

=cut

##############################################################################
sub ps_ifdef()
{
  my $exp = $operand[0];
  my $ret = $exp;

  if (!defined($const{$exp})) {         # then false
    push(@lookingfor, $lookingfor);     # save last value
    $lookingfor = $else_list;           # else, endif, if, ifdef
    $ret .= ' false';
  } else {
    push(@lookingfor, $lookingfor);     # save last value
    $lookingfor = $normal_list;         # look for normally.
    $ret .= ' true';
  }
  return ("/* $ret -- nested $#lookingfor */");
}


##############################################################################

=head1 Subroutine C<ps_ifndef> handles the .ifndef pseudo-op.
Similar to .if, except sees if a constant variable is NOT set in this pass,
or from the command line.

=over

=item Z<>

=item Input:

None.

=item Output:

None.

=item Globals:

Changes @lookingfor, $lookingfor nesting information.
Uses %operand.

=item Execution:

N/A.

=back

=cut

##############################################################################
sub ps_ifndef()
{
  my $exp = $operand[0];
  my $ret = $exp;

  if (defined($const{$exp})) {          # then false
    push(@lookingfor, $lookingfor);     # save last value
    $lookingfor = $else_list;           # else, endif, if, ifdef
    $ret .= ' false';
  } else {
    push(@lookingfor, $lookingfor);     # save last value
    $lookingfor = $normal_list;         # look for normally.
    $ret .= ' true';
  }
  return ("/* $ret -- nested $#lookingfor */");
}


##############################################################################

=head1 Subroutine C<ps_global> handles the i960 .globl or .global pseudo-op.
This sets a label to be global in nature, and counts the number of times
it is seen in .globl's.

=over

=item Z<>

=item Input:

None.

=item Output:

None.

=item Globals:

Changes %global.  Uses %operand.

=item Execution:

Execute code emulating the i960 instruction.

=back

=cut

##############################################################################
sub ps_global()
{
  my $label = $operand[0];

  if ($pass_number == 1) {
    if (defined($global{$label})) {
      $global{$label}++;
      warning($option_W_multiple_global,
        "$label set as global $global{$label} times");
    } else {
      $global{$label} = 1;
    }
  }
  return ('/* global label */');
}


##############################################################################

=head1 Subroutine C<ps_include> handles the nesting of a .include pseudo-op.

=over

=item Z<>

=item Input:

None.

=item Output:

None.

=item Globals:

Uses %operand, changes $do_include.

=item Execution:

N/A.

=back

=cut

##############################################################################
sub ps_include()
{
  my $f = $operand[0];

  $f =~ s/"(.*)"/$1/;
  if ($f !~ /^\// && ! -r $f) {         # don't change files starting with /
    if (-r "../inc/$f") {               # if include directory has the file.
      $f = "../inc/$f";
    } else {
      foreach my $dir (@option_Include) {
        if (-r "$dir/$f") {
          $f = "$dir/$f";
          last;
        }
      }
    }
  }
  $do_include = $f;
  return ('/* nested include */');
}


##############################################################################

=head1 Subroutine C<ps_align> handles a .align pseudo-op.
For an x86 or mips processor the alignment is specified as 2 to the power,
but i960 is specified as merely the power.

=over

=item Z<>

=item Input:

None.

=item Output:

Code to insert into the C file.

=item Globals:

Uses %operand and $opcode.

=item Execution:

N/A.

=back

=cut

##############################################################################
sub ps_align()
{
  my $code;

  if ($sections{$section} eq 'text') {
    warning(1, ".align definition in text section");
    $code  = $ASMV . '("' . $opcode;
  } else {
    $code  = $ASM . '("' . $opcode;
  }
  if ($#operand >= 0) {
    if ($option_i386 == 1 || $option_mips == 1) {
      $code .= ' ' . 2 ** $operand[0];
    } else {
      $code .= ' ' . $operand[0];
    }
  }
  if (1 <= $#operand ) {
    if ($option_i386 == 1 || $option_mips == 1) {
      $code .= ' /* ';
    }
    for (my $i = 1; $i <= $#operand; $i++) {
      $code .= ', ' . $operand[$i];
    }
    if ($option_i386 == 1 || $option_mips == 1) {
      $code .= ' */ ';
    }
  }
  $code .= '");';
  return ($code);
}


##############################################################################

=head1 Subroutine C<org> prints out a warning if a .org instruction is reached
and $option_W_org_pseudo_op is non-zero.

=over

=item Z<>

=item Input:

None.

=item Output:

None.

=item Globals:

Uses $option_W_org_pseudo_op.

=item Execution:

N/A.

=back

=cut

##############################################################################
sub ps_org()
{
  warning($option_W_org_pseudo_op,
        ".org definition in section ($section), ignoring");
  return ("/* ignoring .org definition in section $section */");
}


##############################################################################

=head1 Subroutine C<ps_data_define> handles the data creating pseudo-ops of
C<.ascii>, C<.asciz>, C<.byte>, C<.int>, C<.long>, C<.short>, and C<.word>.
Calls expression(), convert_label_ampamp().
This changes the names of those that are different in assembler syntax.
Duplicates those in the .shdata section section by incrementing the
globals $shdata_byte_count and $shdata_byte_count_total.

=over

=item Z<>

=item Input:

None.

=item Output:

Code to insert into the C file.

=item Globals:

Uses %sections, $section, $opcode, %labels, $last_label, %operand,
$shdata_byte_count, $shdata_byte_count_total.

=item Execution:

N/A.

=back

=cut

##############################################################################
sub ps_data_define()
{
  my $type = $opcode;
  my $code;
  my $i;
  my $size;
  my $which_used;
  my $byte_count = 0;
  my $byte_inc = 1;

  if ($sections{$section} eq 'text') {
    warning($option_W_data_in_text_section,
        "Data definition in a text section ($section)");
  }
  if ($type eq '.int' || $type eq '.long') {
    $type = '.word';            # both are 32 bits via assembler book.
  }
  if ($option_i386 == 1 || $option_mips == 1) {
    if ($type eq '.word') {     # 32 bits, not 16 !!!
      $type = '.long';
    }
  }
  if ($type eq '.byte') {
      $byte_inc = 1;
  } elsif ($type eq '.long') {
      $byte_inc = 4;
  } elsif ($type eq '.short') {
      $byte_inc = 2;
  } elsif ($type eq '.word') {
      $byte_inc = 2;            # not x86 or mips compilation.
  } else {
      $byte_inc = 0;            # .ascii or .asciz
      if ($section eq '.shmem') {
          error(".ascii or .asciz not allowed in .shmem section");
          return('ERROR .ascii not allowed in .shmem section;');
      }
  }
# print "ps_data_define($last_label, $labels{$last_label})\n";
  if ($sections{$section} eq 'text') {
    if (($labels{$last_label} & $L_label_must_data) == 0) {
      warning($option_W_moving_to_data,
              "Found $opcode in .text section after label $last_label\n");
    }
    $labels{$last_label} |= $L_label_must_data | $L_defined_data;
    $labels{$last_label} &= ~$L_defined_code;
    $code  = $ASMV . '("' . $type;
  } else {
    $code  = $ASM . '("' . $type;
  }
  for ($i = 0; $i <= $#operand; $i++) {
    $size = expression($operand[$i],0);
# Count the uses of the label.  Also change labels to have special names.
    $which_used = $sections{$section} eq 'text' ? $L_used_text_data : $L_used_data;

    if ($size !~ /^[\'\"]/) {
#      $size = expression($size,0);
      $size = convert_label_ampamp($size, $which_used,$option_W_external_label_in_long);
      if ($byte_inc == 0) {
        error(".ascii or .asciz does not have quoted string.");
      }
      $byte_count += $byte_inc;
    } else {
      $byte_count += length($size) - 2;    # subtract out the two quotes.
      if ($type eq '.asciz') {
          $byte_count += 1;                # add in terminating zero for string.
      }
      # NOTDONEYET (doesn't matter): subtracting out backslashes in double quoted strings.
    }
    if ($i == 0) {
      $code .= ' ';
    } else {
      $code .= ',';
    }
    $size =~ s/([^a-zA-Z_.\$]\d+)U($|[^a-zA-Z_.\$])/$1$2/;
    $size =~ s/\\/\\\\/g;
    $size =~ s/\"/\\\"/g;
    if ($section eq '.shmem') {
        if ("$size" ne '0') {
            error('non-zero argument in .shmem section');
            return('non-zero argument in .shmem section;');
        }
    }
    $code .= "$size";
  }
  $code .= '");';
  if ($section eq '.shdata') {
      $shdata_byte_count += $byte_count;
      $shdata_byte_count_total += $byte_count;
  }
  return ($code);
}


##############################################################################

=head1 Subroutine C<ps_space> handles the .space (reserve memory space) pseudo-op.
Similar to C<ps_data_define>.
Calls routine expression().

=over

=item Z<>

=item Input:

None.

=item Output:

Code to insert into the C file.

=item Globals:

%sections, $section, %labels, $last_label, %operand, $shdata_byte_count, $shdata_byte_count_total.

=item Execution:

N/A.

=back

=cut

##############################################################################
sub ps_space()
{
  my $code;
  my $size = 0;

  if ($sections{$section} eq 'text') {
    warning($option_W_data_in_text_section,
        "SERIOUS - Data definition in a text section ($section)");
  }
  if ($sections{$section} eq 'text') {
    if (($labels{$last_label} & $L_label_must_data) == 0) {
      warning($option_W_moving_to_data,
              "Found $opcode in .text section after label $last_label\n");
    }
    $labels{$last_label} |= $L_label_must_data | $L_defined_data;
    $labels{$last_label} &= ~$L_defined_code;
    $code  = $ASMV . '("' . $opcode;
  } else {
    $code  = $ASM . '("' . $opcode;
  }
  if ($#operand >= 0) {
    $size = expression($operand[0],0);
    $code .= ' ' . $size;
  }
  if (1 <= $#operand ) {
    for (my $i = 1; $i <= $#operand; $i++) {
      my $value = expression($operand[$i],0);
      $code .= ', ' . $value;
    }
  }
  $code .= '");';
  if ($section eq '.shdata') {
    $shdata_byte_count += $size;
    $shdata_byte_count_total += $size;
  }
  return ($code);
}


##############################################################################

=head1 Subroutine C<ps_section> handles the .section pseudo-op.
Checks for legal section name (.shdata is special), and changes the variable
$section to point at that.  Do nothing if staying in the same section name.

=over

=item Z<>

=item Input:

None.

=item Output:

Code to insert into the C file.

=item Globals:

Uses %operand, %sections, $section.

=item Execution:

N/A.

=back

=cut

##############################################################################
sub ps_section()
{
  my $section_name;
  my $code;

  if ($#operand >= 0) {
    $section_name = $operand[0];
  } else {
    error('.section does not have a name?');
    return (' /* bad .section */');
  }
  if (!defined($sections{$section_name}) || $section_name eq '.shdata') {
    error(".section has unknown name of ($section_name)");
    return (" /* bad .section $section_name */");
  }
  if ($sections{$section_name} eq 'text') {     # code is all code.
    $section_name = 'text';
    if ($section_name eq $section) {            # if no section change.
      return (" /* still in $section section */");
    }
#    $code  = $ASMV . '(".text");';             #### With all text's together, don't do this.
    $code = ' ';
    $section = $section_name;
    return ($code);
  } elsif ($sections{$section_name} eq '.shmem') {
    $section_name = '.shmem';
    if ($section_name eq $section) {            # if no section change.
      return (" /* still in $section section */");
    }
    $code  = $ASM . '(".section .shmem,\\"aw\\",@nobits");';
    $section = $section_name;
    return ($code);
  } else {
    $section_name = 'data';
    if ($section_name eq $section) {            # if no section change.
      return (" /* still in $section section */");
    }
    $code  = $ASM . '(".data");';
    $section = $section_name;
    return ($code);
  }
}

##############################################################################

=head1 Subroutine C<ps_set> handles the i960 .set pseudo-op.
This sets the variable/constant to the expression.
It may be changed later, and that is alright to do.
Calls expression().

=over

=item Z<>

=item Input:

None.

=item Output:

None.

=item Globals:

Changes %const, %const_count.
Uses %operand.

=item Execution:

N/A.

=back

=cut

##############################################################################
sub ps_set()
{
  my $var = $operand[0];
  $var =~ s/[.]/_D_/g;                # Dots in middle of name.
  my $expression = expression($operand[1],0);   # simplify expression.
  if (!defined($const{$var})) {
    $const_count{$var} = 1;
  } else {
    $const_count{$var}++;
  }
  $const{$var} = $expression;
  return ("/* set $var=$expression */");
}

##############################################################################

=head1 Subroutine C<ps_unset> handles the added .unset pseudo-op that is
used before the two files "OCstate.as CCstate.as" and "CCstate.as OCstate.as".
The files need four .set's undone before the second is called.
The order of the compilation changes the results.

=over

=item Z<>

=item Input:

None.

=item Output:

None.

=item Globals:

Uses %operand.  Changes %const and %const_count.

=item Execution:

N/A.

=back

=cut

##############################################################################
sub ps_unset()
{
  my $var = $operand[0];

  $var =~ s/[.]/_D_/g;                # Dots in middle of name.
  if (defined($const{$var})) {
    undef($const_count{$var});
    undef($const{$var});
  }
  return ("/* unset $var */");
}

##############################################################################

=head1 Subroutine C<ps_text> handles the .text i960 pseudo-op.
This moves to the linkers .text section (which is for code).

=over

=item Z<>

=item Input:

None.

=item Output:

None.

=item Globals:

Changes $section.

=item Execution:

N/A.

=back

=cut

##############################################################################
sub ps_text()
{
  my $code;

  if ($section eq 'text') {             # if no section change.
    return (' /* still in code section */');
  }
  $code  = " /* reverting back to .text section ($section moved) */";
  $section = 'text';
  return ($code);
}


##############################################################################

=head1 Subroutine C<ps_START_SH_DATA_SECTION> is for an added pseudo-op
called START_SH_DATA_SECTION and terminates the section with the
END_SH_DATA_SECTION pseudo-op.
The purpose of this section is to have data in the shared memory section
(i.e. FE/BE/CCB see the memory) initialized with values.
This is used by some communication through the link layer to other processes,
and passing a pre-setup communications array.
Calls putit(), label_generate().

=over

=item Z<>

=item Input:

None.

=item Output:

Code to insert into the C file.

=item Globals:

Changes %section, $shdata_section_save, $shdata_byte_count,
 $shdata_byte_count_total, $shdata_count.

=item Execution:

Three sections of data are created.
First is the data to initialize.
Second is reserved memory in the shared memory.
Third is a short table of "From, To, Count" that is used to initialize
the Second from the First.
This is done in fe_main.c and be_main.c after the shared memory is gotten,
and before K$start() is called [kernel.as].

=back

=cut

##############################################################################
sub ps_START_SH_DATA_SECTION()
{
  my $code;

  $shdata_section_save = $section;
  $shdata_byte_count = 0;
  $shdata_byte_count_total = 0;
  $shdata_count++;
  if ($pass_number == 2) {
      $section = '.shinit';
      if ($shdata_count == 1) {
        putit("$ASM(" . '".section .shinit,\\"a\\",@nobits");' . "\n", 1);
      }
  }
  $code = label_generate('CT_COPY_TO_' . $shdata_count);
  if ($pass_number == 2) {
      putit($code . "\n", 1);
      $section = '.shinittable';
      if ($shdata_count == 1) {
        putit("$ASM(\".section .shinittable\");\n", 1);
      }
      putit("$ASM(\".long CT_COPY_FROM_$shdata_count\");\n", 1);
      putit("$ASM(\".long CT_COPY_TO_$shdata_count\");\n", 1);
  }
  $section = '.shdata';
  if ($shdata_count == 1 && $pass_number == 2) {
    putit("$ASM(\".section .shdata\");\n", 1);
  }
  $code = label_generate('CT_COPY_FROM_' . $shdata_count);
  return ($code);
}

##############################################################################

=head1 Subroutine C<ps_END_SH_DATA_SECTION> is for an added pseudo-op called
END_SH_DATA_SECTION, which goes along with START_SH_DATA_SECTION.
See START_SH_DATA_SECTION for more information.

=over

=item Z<>

=item Input:

None.

=item Output:

None.

=item Globals:

Changes $section.
Uses $shdata_byte_count, $shdata_byte_count_total, $pass_number.

=item Execution:

N/A.

=back

=cut

##############################################################################
sub ps_END_SH_DATA_SECTION()
{
    $section = '.shinittable';
    if ($pass_number == 2) {
        putit("$ASM(\".long $shdata_byte_count_total\");\n", 1);
        if ($shdata_byte_count > 0) {
            $section = '.shinit';
            putit("$ASM(\".space $shdata_byte_count\");\n", 1);
            $shdata_byte_count = 0;
            $shdata_byte_count_total = 0;
        }
    }
    $section = $shdata_section_save;
    $shdata_section_save = 'text';
    return (' ');
}

##############################################################################

=head1 Subroutine C<ps_if_noprocess> is for when a nested .if is reached,
but it is in a section that is not being processed.
This means that an .endif for it must be processed before we continue
processing the current .if (looking for .else, or .endif).

=over

=item Z<>

=item Input:

None.

=item Output:

None.

=item Globals:

Changes $lookingfor, @lockingfor.

=item Execution:

N/A.

=back

=cut

##############################################################################
sub ps_if_noprocess()
{
  push(@lookingfor, $lookingfor);       # save last value
# printf STDERR "ps_if_noprocess:$filename-$linenumber lookingfor=(%s)\n\t$input\n", join(',', @lookingfor);
  $lookingfor = $ifnoprocess_list;      # else, endif, if, ifdef
  return ("/* ignore nested .if -- nested $#lookingfor */");
}


##############################################################################

=head1 Subroutine C<ifnoprocess_list> is for processing lines that are
being ignored after a .if that is not being processed.
Such an .if occurs if we are in the .else section of a "true" .if.
This looks for a .endif, or a nested .if.

=over

=item Z<>

=item Input:

None.

=item Output:

None.

=item Globals:

Changes $lookingfor, @lookingfor.
Uses $opcode.

=item Execution:

N/A.

=back

=cut

##############################################################################
sub ifnoprocess_list()
{
  if ($opcode eq '.endif') {            # YIPPIE, the only legal thing
    $lookingfor = pop(@lookingfor);     # back to last thing doing.
# printf STDERR "ifnoprocess_list:$filename-$linenumber lookingfor=(%s)\n\t$input\n", join(',', @lookingfor);
    return ("/* .endif in nested .if section, mostly ignoring -- nested $#lookingfor */");
  } elsif ($opcode =~ /^.if/) {         # YIPPIE, Ah, nested ignore.
    push(@lookingfor, $lookingfor);     # save last value
# printf STDERR "ifnoprocess_list:$filename-$linenumber lookingfor=(%s)\n\t$input\n", join(',', @lookingfor);
    return ("/* .if in nested .if section, mostly ignoring -- nested $#lookingfor */");
  } else {
    return ('/* ignoring in nested .if section */');
  }
}


##############################################################################

=head1 Subroutine C<else_list> is for when the .if is false, and we are looking
for either a .else or a .endif.
Calls ps_endif(), ps_if_noprocess().

=over

=item Z<>

=item Input:

None.

=item Output:

None.

=item Globals:

Changes $lookingfor.
Uses $opcode.

=item Execution:

N/A.

=back

=cut

##############################################################################
sub else_list()
{
  if ($opcode eq '.else') {
# no push for an else, just change type of processing for this level.
    $lookingfor = $almost_normal_list;          # else not allowed.
    return ("/* processing .else condition -- nested $#lookingfor */");
  } elsif ($opcode eq '.endif') {
    return (ps_endif());
  } elsif ($opcode =~ /^.if(|def|ndef)$/ ) {
    return (ps_if_noprocess());
  }
  return ('/* ignored .if false condition */');
}


##############################################################################

=head1 Subroutine C<endif_list> we are looking for only a .endif.
As in not processing the .else, and just waiting for an .endif -- but we
might get another .if.
Calls ps_endif(), ps_if_noprocess().

=over

=item Z<>

=item Input:

None.

=item Output:

None.

=item Globals:

None directly changed.
Uses $opcode.

=item Execution:

N/A.

=back

=cut

##############################################################################
sub endif_list()
{
  if ($opcode eq '.else') {
    error('In endif_list got unexpected .else');
  } elsif ($opcode eq '.endif') {
    return (ps_endif());
  } elsif ($opcode =~ /^.if(|def|ndef)$/ ) {
    return (ps_if_noprocess());
  }
  return ('/* ignored .else condition */');
}


##############################################################################

=head1 Subroutine C<chompit> deletes any carriage returns and/or new-lines
from the end of the input line. We use substitute because it is about 14 seconds
faster than several other methods tried.

=over

=item Z<>

=item Input:

String to have trailing characters hacked off.

=item Output:

String with trailing characters hacked off.

=item Globals:

None changed.

=item Execution:

N/A.

=back

=cut

##############################################################################
sub chompit($)
{
  my $line = $_[0];

  $line =~ s/\n*\r*\n*$//;
  return($line);
}

##############################################################################

=head1 Subroutine C<opcode_generate> will use the parsed line to decode
and process an i960 opcode or pseudo-op.
It grabs the entry from the appropriate table and does a perl eval on it.
If no error, return the return value to subroutine include_file(),
which puts it into the "c" file.
A helpful message about an opcode not being allowed in the wrong
section is attempted.

=over

=item Z<>

=item Input:

None.

=item Output:

Code to insert into the C file.

=item Globals:

Uses $section, $opcode, %code_opcode, %shmem_opcode, %data_opcode.
Uses perl built-in $@ for error code.

=item Execution:

N/A.

=back

=cut

##############################################################################

sub opcode_generate()
{
  if ($opcode eq '') {
    return(' ');
  }
  my $s;
  my $code;
  if ($section eq 'text') {
    $s = $code_opcode{$opcode};
  } elsif ($section eq '.shdata') {
    $s = $shmem_opcode{$opcode};
  } else {
    $s = $data_opcode{$opcode};
  }

  #### If an opcode entry is defined, and processing is successful
  #### output the parsed code.  However if an error occurs, then
  #### output the error.

  if (defined($s)) {
    $code = eval{ $s->() };
    if (!defined $code) {
print STDERR "CT_analyze, internal problems?? -- " . '$' . "code is undefined.  $@\n";
      my $err = $@;
      $err = chompit($err);
      error($err);
      return ($err);            # This puts the error message into the "code".
    }
    if ($code ne '') {
      return ($code);
    }
    error('Nothing returned from subroutine execution.');
  }

# We got here because the opcode is not defined in table.
# See if it is in the other table, and put out the appropriate error message.

  $s = ($section eq 'text') ? $data_opcode{$opcode} : $code_opcode{$opcode};
  if (defined($code_opcode{$opcode})) {
    error("opcode $opcode not defined for section $section, but is defined in text -- ignoring.");
  } elsif (defined($data_opcode{$opcode})) {
    error("opcode $opcode not defined for section $section, but is defined in data -- ignoring.");
  } elsif (defined($shmem_opcode{$opcode})) {
    error("opcode $opcode not defined for section $section, but is defined in .shdata -- ignoring.");
  } else {
    error("opcode $opcode not defined for code or data sections -- ignoring.");
  }
  return (' ');
}


##############################################################################

=head1 Subroutine C<include_file> handles a new file.

Whether it is a nested include file, or the next file on the command
line, file processing starts here.
Much care is given to keeping track of where in the file we are working.
The line is read, then all comments are removed from the input line.

Next the line is broken into components, possible label first, then opcode,
then operands.
A line may consist of multiple "opcodes" separated by semicolons.

If in pass 2 processing, output the first 80 characters of the input as
a comment, followed by the generated "c" code.
The assembler input is truncated at 80 columns, but the "c" is not truncated.
If a nested include, process the new file.

The last part of this routine handles popping out of nested include files,
and keeping the filename and linenumbers correct.

Calls label_generate(), opcode_generate(), putit(), put_linenumber(),
include_file() -- recursive.

=over

=item Z<>

=item Input:

0 - The file name to start processing.

=item Output:

N/A.

=item Globals:

Changes $save_section_one, $linenumber, $filename, $section,
%save_section_count, %already_included, @filename, @linenumber,
$opcode, @operand.

=item Execution:

N/A.

=back

=cut

##############################################################################
sub include_file($);                    # prototype for recusion

sub include_file($)
{
    my $newfilename = $_[0];

    return if (defined($already_included{$newfilename}));

    $already_included{$newfilename} = 1;

    if ($pass_number == 2) {
        if ($section ne 'text') {
            $section = 'text';
#            putit("$ASMV(\".text\");\n", 1);
#            putit("", 1);
        }
    }

    push(@filename, $filename);
    push(@linenumber, $linenumber);

    $filename = $newfilename;
    $linenumber = 0;

    if ($pass_number == 2) {

        if ($option_no_line_numbers == 0) {
            $save_section_one = 1;
            put_linenumber(1, $filename, $section, 1);
        }

        if ($section ne 'text') {
            if ($option_no_line_numbers == 0) {
                put_linenumber(1, $filename, $section, '');
            }
        }
    }

    my($FILE);

    if (!defined(open($FILE, "<$filename"))) {

        error("Cannot open source file: $filename");

        $filename = pop(@filename);
        $linenumber = pop(@linenumber);

        if ($pass_number == 2) {
            putit("\n", 1);
        }

        return;
    }

    #### Main loop.

    my $incomment = 0;

    while (<$FILE>) {

        $_ = chompit($_);

        $linenumber++;
        $input = $_;

        my $listing = $_;
        my $working = $_;

        #### Process the next line of an unterminated comment.

        if ($incomment) {

            if ($working =~ s/^ .*? (?<!\\) (?:\\\\)* \*\/ //x) {
                $incomment = 0;
            } else {
                $working = '';
            }
        }

        #### Remove all comments from the input line.  This is tricky
        #### because of quotes and backslashes.

        my $valid = '';

        while ($working =~ s/^(.*?(?<!\\)(?:\\\\)*)(\#|\/\/|\"|\'|\/\*)//) {

            $valid .= $1;
            my $s = $2;

            # print "<$valid>  <$s>  <$working>\n";

            if ($s eq '#' || $s eq '/') {

                $working = '';

            } elsif ($s eq '\'' || $s eq '"') {

                if ($working !~ s/^(.*?(?<!\\)(?:\\\\)*$s)//) {
                    error("Unterminated quotes\n");
                    $working = $valid = '';
                    last;
                }

                $valid .= $s . $1;

            } elsif ($working !~ s/^.*?(?<!\\)(?:\\\\)*\*\///) {

                $working = '';
                $incomment = 1;
                last;
            }
        }

        $working = $valid . $working;

        #### Loop to process one complete line of input.

        my $code = '';

        do {
# Allow turning off local memory checking debugging.
            if (substr($working,0,1) eq '!') {
              $NO_MEMORY_ADDRESS_LOCAL_CHECK = 0;
              $working = substr($working,1);
            } else {
              $NO_MEMORY_ADDRESS_LOCAL_CHECK = 1;
            }
            if (substr($working,0,1) eq '?') {
              # option_disable_question_mark usually 0, but -disable_question_mark makes it 1.
              $NO_CHECK_MEMORY_PATTERNS = $option_disable_question_mark;
              $working = substr($working,1);
            } else {
              $NO_CHECK_MEMORY_PATTERNS = 1;
            }

            #### Tear off any label.

            while ($working =~ s/^\s*([.a-z0-9\$_]+)://i) {
                my $label = $1;
                if ($lookingfor == $normal_list ||
                    $lookingfor == $almost_normal_list) {
                    if ($pass_number == 2) {
                        if ($section eq '.shdata') {
                            $section = '.shinit';
                            if ($shdata_byte_count > 0) {
                                putit("$ASM(\".space $shdata_byte_count\");\n", 1);
                                $shdata_byte_count = 0;
                            }
                        }
                    }
                    $code .= label_generate($label);
                    if ($pass_number == 2) {
                        if ($section eq '.shinit') {
                            putit($code . "\n", 1);
                            $code = ' ';
                            $section = '.shdata';
                        }
                    }
                } else {
                    $code .= ' ';
                }
            }

            #### Get the opcode and operand fields.

            if ($working =~ s/^\s*([.a-zA-Z0-9_]+)//) {

                $opcode = $1;
                @operand = ();

                while ($working =~ s/^ \s*
                       ((?: [^,;\'\"] | ([\'\"]) .*? (?<!\\) (?:\\\\)* \2)+?)
                       \s* ( [,] | (?=;) | $ ) //x)
                {
                    push(@operand, $1);
                }

                #### Generate code for an opcode.

                if ($lookingfor == $normal_list) {
                    $code .= opcode_generate();
                } elsif ($lookingfor == $almost_normal_list) {
                    if ($opcode eq '.else') {
                        error ('.else found, but in .else processing.');
                    } else {
                        $code .= opcode_generate();
                    }
                } elsif ($lookingfor == $else_list) {
                    $code = else_list();
                } elsif ($lookingfor == $endif_list) {
                    $code = endif_list();
                } elsif ($lookingfor == $ifnoprocess_list) {
                    $code = ifnoprocess_list();
                } else {
                    error ("ERROR in lookingfor=$lookingfor");
                }
            }

            $working =~ s/^\s+//;

        } while $working =~ s/^;//;

        if ($pass_number == 2) {

            #### Enclose the first 80 characters of the line in comments,
            #### and print it.  Stupidly alter any comment delimiters that
            #### would mess up the works.

            (my $realcode = $code) =~ s/^\s*(?:\/\*.*?\*\/\s*)*$//;

            if ($realcode ne '' && ! $option_no_line_numbers) {
                put_linenumber($linenumber, $filename, $section, '');
            }

            if ($option_no_assembler_comments == 0) {
                $listing =~ s/\/\*/\(*/g;       # Alter comments that could
                $listing =~ s/\*\//*\)/g;       # confuse the compiler.

                putit('/* ', 0);
                $listing = substr($listing . '                                                                                ', 0, 80);
                putit($listing, 0);
#-                for (my $i = 10; --$i >= 0;) {
#-                    if ($listing =~ s/^([^\t]{8})//) {
#-                        putit($1, 0);
#-                    } elsif ($listing =~ s/^([^\t]{0,7})\t?//) {
#-                        putit(substr("$1        ",0,8), 0);
#-                    }
#-                }
                putit(" */ ", 0);
            }

            #### Output the generated code.

            if ($working ne '') {
                error("Unparseable code: $working");
                next;
            }

            if ($option_no_assembler_comments == 0 || $code ne '') {
                putit($code . "\n", 1);
            }
        }

        #### Process nested include.

        if (defined $do_include) {

            my $f = $do_include;

            $do_include = undef;
            include_file($f);
        }
    }

    #### Clean up and exit.

    close($FILE);

    $filename = pop(@filename);
    $linenumber = pop(@linenumber);

    #### Process nested "include" files.

    if ($pass_number == 2) {

        if (!defined($filename)) {

            if ($option_no_line_numbers == 0) {
                $save_section_one = 1;
                put_linenumber($save_section_count{'text'}+1, $external_c_file, $section, 2);
            }

            if ($section ne 'text') {
                if ($option_no_line_numbers == 0) {
                    put_linenumber($save_section_count{'text'}+1, $external_c_file, $section, '');
                }
            }

        } else {

            if ($option_no_line_numbers == 0) {
                $save_section_one = 1;
                put_linenumber($linenumber, $filename, $section, 2);
            }

            if ($section ne 'text') {
                if ($option_no_line_numbers == 0) {
                    put_linenumber($linenumber, $filename, $section, '');
                }
            }
        }
    }
}


##############################################################################

=head1 Subroutine C<external_definitions> goes through the %labels array and
creates the c "extern" directives, and CT_fake entries for labels referenced
in the .data section.
If a "forward" reference is needed, it is created.
Many error checks for cross-type usage, prototype specification but no label
found and visa versa.
If a .set is specified in a .globl, create it with "asm" directives.

=over

=item Z<>

=item Input:

Global variable %labels.

=item Output:

In global variables below.

=item Globals:

Changes $GFILE, $GFILE_COUNT, $HFILE, $HFILE_COUNT, $SPECIAL_FILE, $SPECIAL_linenumber.

=item Execution:

N/A.

=back

=cut

# Puts out the externals and forwards.
##############################################################################

sub external_definitions()
{
# Put out the extern prototypes needed.
  foreach my $i (sort(keys(%labels))) {
# if ($i eq 'c$inquiry1end') {
# printf STDERR "external_definitions: $i=$labels{$i}\n";
# }
##++     if (!defined($labels_count{$i}))
##++     {
##++       printf STDERR "LABEL $i never defined?\n";
##++     }
##++     elsif ($labels_count{$i} <= 1)
##++     {
##++       printf STDERR "LABEL $i only used $labels_count{$i} times!\n";
##++     }
    if (defined($const{$i})) {
      if ($option_W_all != 0 || $option_W_external_and_constant != 0) {
        printf STDERR "Warning - $i defined as external label and constant.\n";
      }
      next;
    }
    if ($i eq '__sF' || $i eq 'optind' || $i eq '___sF') {
      # NOT THESE (for "c" translated to i960.s, then compiled with this script.)
    } elsif (($labels{$i} & $L_defined_code) != 0) {
#? print STDERR "/* $i is a label defined in the \".text\" section -- must be goto.  type=$labels{$i} */\n";
      if (($labels{$i} & ($L_used_data | $L_used_text_data)) != 0) {
        $GFILE .= "\t&&CT_GOTO_$i,\n";
        $GFILE_COUNT++;
      }
    } elsif (($labels{$i} & $L_defined_data) != 0) {
#? print STDERR "/* $i is a label defined in the \".data\" section.  type=$labels{$i} */\n";
      if (($labels{$i} & $L_used_goto) != 0) {
        print STDERR "ERROR - data label $i used in goto\n";
        $exitvalue = 1;
      } elsif (($labels{$i} & $L_used_ret) != 0) {
        print STDERR "ERROR - data label $i used in ret?\n";
        $exitvalue = 1;
      } elsif (($labels{$i} & $L_used_call) != 0) {
        print STDERR "ERROR - data label $i used in call?\n";
        $exitvalue = 1;
      } else {
        if (defined($C_variables{$i})) {
          $HFILE .= "extern $C_variables{$i} $i; /* $i is a label defined in the .data section. */\n";
          $HFILE_COUNT++;
        } else {
          $HFILE .= "extern ulong $i; /* $i is a label defined in the .data section. */\n";
          $HFILE_COUNT++;
        }
      }
    } else {
# Externals, not defined in here.
      if (($labels{$i} & $L_used_goto) != 0) {
        print STDERR "ERROR - external label $i used in goto\n";
        $exitvalue = 1;
      } elsif (($labels{$i} & $L_used_ret) != 0) {
        print STDERR "ERROR - external label $i used in ret?\n";
        $exitvalue = 1;
      } elsif (($labels{$i} & $L_used_call) != 0) {
        if (!defined($AC_labels{$i})) {
          printf STDERR "ERROR - external label $i not in AC section of prototype file\n";
          $exitvalue = 1;
        }
# print  STDERR "external_definitions #1 to AC_labels =>($i)\n";
# These are done via the -P option, because prototype of call is needed.
#       print HFILE "extern ulong $i; /* $i is an external call-ed routine */\n";
#       print HFILE "extern void CT_GLUE_call_$i(ulong); /* Define glue routine for $i */\n";
      } elsif (($labels{$i} & ($L_used_load | $L_used_store)) != 0) {
        if ($i ne 'stderr' &&
            $i ne 'stdout' &&
            $i ne 'stdin' ) {   # linux exceptions.
          if (!defined($C_variables{$i})) {
            if (!defined($AC_labels{$i})) {
              printf STDERR "ERROR - external label $i not in Variable section of prototype file\n";
              $exitvalue = 1;
# following two try to make it "work" anyway -- which it might.
              $HFILE .= "extern ulong $i; /* $i is an external load/store. */\n";
              $HFILE_COUNT++;
            } else {
# print  STDERR "external_definitions #2 to AC_labels =>($i)\n";
              if ($option_W_external_routine_used_as_variable != 0) {
                print STDERR "Warning: label $i used as variable, but defined as routine.\n";
              }
            }
          } else {
            if ($C_variables{$i} !~ /^[_]*noext/ ) {
              $HFILE .= "extern $C_variables{$i} $i; /* $i is an external load/store. */\n";
              $HFILE_COUNT++;
            }
          }
        }
      } elsif (($labels{$i} & $L_used_data ) != 0) {
        if (defined($C_variables{$i})) {
          $HFILE .= "extern $C_variables{$i} $i; /* $i is in the data section. */\n";
          $HFILE_COUNT++;
        } else {
          print STDERR "ERROR - external label use error in data section '$i' ($labels{$i})?\n";
          $exitvalue = 1;
        }
      } elsif (($labels{$i} & $L_extra_asm_2_c_code ) != 0) {
        my $changeit = $i;
        $changeit =~ s/^CT_super_special_//;
        $SPECIAL_FILE .= $i . ': { ';
        $SPECIAL_FILE .=   'CT_GLUE_call_' . $changeit . '(); ';
        $SPECIAL_FILE .=   'fp = pfp; ';                # now for next return
        $SPECIAL_FILE .=   'goto *(void*) rip; }' . "\n";
        $SPECIAL_linenumber++;
      } else {
        print STDERR "ERROR - external label use error '$i' ($labels{$i})?\n";
        $exitvalue = 1;
      }
    }
  }

# This handles any possible .globl set's.
  foreach my $i (sort(keys(%global))) {
    if (!defined($labels{$i})) {
      if (defined($const{$i})) {
        $HFILE .= "$ASMV (\"  .globl ${i}\");\n";
        $HFILE_COUNT++;
        my $j = expression($const{$i},0);
        $HFILE .= "$ASMV (\"  .set ${i}, $j\");\n";
        $HFILE_COUNT++;
      } else {
        if ($option_W_all != 0 || $option_W_globl_nothing != 0) {
          print STDERR "Warning .globl of $i, but $i not .set, or a label???\n";
        }
      }
    } else {
    # Can't have a .globl of a "c" label used for goto.
      if (($labels{$i} & $L_defined_code) != 0) {
#       print STDERR "ERROR - .globl label $i defined in c code.\n";
#       $exitvalue = 1;
      } elsif (($labels{$i} & $L_defined_data) != 0) {
        $HFILE .= "$ASM (\"  .globl ${i}\");\n";
        $HFILE_COUNT++;
      } elsif (($labels{$i} & $L_used_goto) != 0) {
        print STDERR "ERROR - .globl label $i used in goto\n";
        $exitvalue = 1;
      } elsif (($labels{$i} & $L_used_ret) != 0) {
        print STDERR "ERROR - .globl label $i used in ret?\n";
        $exitvalue = 1;
      } elsif (($labels{$i} & $L_used_call) != 0) {
        $HFILE .= "$ASM (\"  .globl ${i}\");\n";
        $HFILE_COUNT++;
      } elsif (($labels{$i} & ($L_used_load | $L_used_store)) != 0) {
        $HFILE .= "$ASM (\"  .globl ${i}\");\n";
        $HFILE_COUNT++;
      } else {
        print STDERR "ERROR - .globl label $i use error?\n";
        $exitvalue = 1;
      }
    }
  }
}


##############################################################################

=head1 Subroutine C<parse_input_parameters> takes the command line and
processes the options and file names.
An option starts with a minus sign, then some alphanumberic characters.
An option like -set_before_use will have a variable $option_W_set_before_use
set to one if it appears on the command line.
Several, like -D, may have an option space after it before the argument starts.

=over

=item Z<>

=item Input:

None.

=item Output:

None.

=item Globals:

Various options are set.
%defines is set for -D.
The -I option sets @option_I.
The -Include sets @option_Include.
The -P (prototype file) sets @proto_filename.
The -o sets $option_outputfile.
The -option_fullpath sets $option_fullpath to `pwd`/.
If a file name, @not_opt is set.

=item Execution:

N/A.

=back

=cut

##############################################################################
sub parse_input_parameters()
{
  while ($#ARGV >= 0) {
    my $A = shift(@ARGV);
# print STDERR "argument=$A\n";
# Do -D option.
    if ($A =~ /^-D(.*)$/) {
      $A = $1;
      if (!defined($A) || $A eq '') {
        $A = shift(@ARGV);                      # next argument.
        if (!defined($A) || $A eq '') {
          print STDERR "-D argument requires a definition to follow.\n";
          exit(1);
        }
      }
      if ($A =~ /^(.*)=(.*)$/) {                # if -DSOMETHING=THIS
        $defines{$1} = $2;
      } else {
        $defines{$A} = 0;                       # Guess that 0 is correct.
      }
# Do -U option.
    } elsif ($A =~ /^-U(.*)$/) {
      $A = $1;
      if (!defined($A) || $A eq '') {
        $A = shift(@ARGV);                      # next argument.
        if (!defined($A) || $A eq '') {
          print STDERR "-U argument requires a definition to follow.\n";
          exit(1);
        }
      }
      if (defined($defines{$A})) {
   undef($defines{$A});
      }
# Do -Include option.
    } elsif ($A =~ /^-Include(.*)/){
      $A = $1;
      if (!defined($A) || $A eq '') {
        $A = shift(@ARGV);                      # next argument.
        if (!defined($A) || $A eq '') {
          print STDERR "-Include argument requires a file name to follow.\n";
          exit(1);
        }
      }
      push(@option_Include, $A);
# Do -I option.
    } elsif ($A =~ /^-I(.*)/){
      $A = $1;
      if (!defined($A) || $A eq '') {
        $A = shift(@ARGV);                      # next argument.
        if (!defined($A) || $A eq '') {
          print STDERR "-I argument requires a file name to follow.\n";
          exit(1);
        }
      }
      push(@option_I, $A);
# Do -o option.
    } elsif ($A =~ /^-o(.*)/){
      $A = $1;
      if (!defined($A) || $A eq '') {
        $A = shift(@ARGV);                      # next argument.
        if (!defined($A) || $A eq '') {
          print STDERR "-o argument requires a file name to follow.\n";
          exit(1);
        }
      }
      if ($option_outputfile ne $default_outputfile) {
        print STDERR "Multiple -o's not allowed, '$option_outputfile' and '$A'\n";
        exit(1);
      }
      $option_outputfile = $A;
# -L_local labels option.
    } elsif ($A =~ /^-L_local$/) {
      $option_L_local = 1;
# -P Prototype file.
    } elsif ($A =~ /^-P(.*)$/) {
      $proto_filename = $1 ne '' ? $1 : shift(@ARGV);
      -r $proto_filename || die "-P argument requires a readable file name.\n";
# -W options for warnings.
    } elsif ($A =~ /^-W(.*)$/){
      $A = $1;
      if (!defined($A) || $A eq '') {
        $A = shift(@ARGV);                      # next argument.
        if (!defined($A) || $A eq '') {
          print STDERR "-W argument requires a warning name to follow.\n";
          exit(1);
        }
      }
      if ($A eq 'all') { $option_W_all = 1;}
      elsif ($A eq 'set_before_use') { $option_W_set_before_use = 1;}
      elsif ($A eq 'code_label_in_data') { $option_W_code_label_in_data = 1;}
      elsif ($A eq 'data_label_in_goto') { $option_W_data_label_in_goto = 1;}
      elsif ($A eq 'data_label_in_call') { $option_W_data_label_in_call = 1;}
      elsif ($A eq 'external_label_in_load_or_store') { $option_W_external_label_in_load_or_store = 1;}
      elsif ($A eq 'call_to_register') { $option_W_call_to_register = 1;}
      elsif ($A eq 'call_expression') { $option_W_call_expression = 1;}
      elsif ($A eq 'goto_register') { $option_W_goto_register = 1;}
      elsif ($A eq 'goto_expression') { $option_W_goto_expression = 1;}
      elsif ($A eq 'multiple_global') { $option_W_multiple_global = 1;}
      elsif ($A eq 'org_pseudo_op') { $option_W_org_pseudo_op = 1;}
      elsif ($A eq 'data_in_text_section') { $option_W_data_in_text_section = 1;}
      elsif ($A eq 'external_and_constant') { $option_W_external_and_constant = 1;}
      elsif ($A eq 'globl_nothing') { $option_W_globl_nothing = 1;}
      elsif ($A eq 'fp_r0_r2_changed') { $option_W_fp_r0_r2_changed = 1;}
      elsif ($A eq 'external_routine_used_as_variable') { $option_W_external_routine_used_as_variable = 1;}
      elsif ($A eq 'moving_to_data') { $option_W_moving_to_data = 1;}
      else {
        print STDERR "Unknown -W option '$A'\n";
        exit(1);
      }
    }
# -no_line_numbers option.
    elsif ($A eq '-no_line_numbers') { $option_no_line_numbers = 1;}
# -option_fullpath option.
    elsif ($A eq '-full_path_name') {
      $option_fullpath = `pwd`;
      $option_fullpath = chompit($option_fullpath);
      $option_fullpath .= '/';      ### ERROR! This line is wrong. Ouch.
    }
# -all_asm_labels option.
    elsif ($A eq '-all_asm_labels') { $option_all_asm_labels = 1;}
# -no_leading_underscore option.
    elsif ($A eq '-no_leading_underscore') { $option_no_leading_underscore = 1;}
# -no_comments
    elsif ($A eq '-no_comments') { $option_no_assembler_comments = 1;}
# -i386 option.
    elsif ($A eq '-i386') { $option_mips = 0; $option_i386 = 1;}
# -mips option.
    elsif ($A eq '-mips') { $option_mips = 1; $option_i386 = 0;}
# -i960 option.
    elsif ($A eq '-i960') { $option_mips = 0; $option_i386 = 0;}

    elsif ($A eq '-debug_labels') { $option_debug_labels = 1;}
    elsif ($A eq '-debug_registers') { $option_debug_registers = 1;}
    elsif ($A eq '-assumes_works') { $option_assumes_works = 1;}
    elsif ($A eq '-g_reg_proto_special') {
        $option_g_reg_proto_special = 1;
        $defines{'G_REG_PROTO_SPECIAL'} = 0;
    }
    elsif ($A eq '-CA_register_save_restore') { $option_CA_register_save_restore = 1;}
    elsif ($A eq '-AC_register_save_restore') { $option_AC_register_save_restore = 1;}
    elsif ($A eq '-check_r_reg_pattern_match') {$option_check_r_reg_pattern_match = 1;}
    elsif ($A eq '-save_memory_stored') {$option_save_memory_stored = 1;}
    elsif ($A eq '-check_local_memory') {$option_check_local_memory = 1;}
    elsif ($A eq '-disable_question_mark') {$option_disable_question_mark = 1;}

# If it starts with a -, it should have been an option.
    elsif ($A =~ /^-/){
      print STDERR "Unknown minus ('-') option $A\n";
      exit(1);
    }
# Otherwise assume it is a filename.
    else {
      push(@not_opt, $A);
    }
  }
}


##############################################################################

=head1 Subroutine C<output_proto_body> prints the prototype body out,
adding newlines to each line.
Calls putit().

=over

=item Z<>

=item Input:

Indirectly @proto_body, no arguments.

=item Output:

Code is inserted into the C file.

=item Globals:

Uses @proto_body.

=item Execution:

N/A.

=back

=cut

##############################################################################
sub output_proto_body()
{
    for (@proto_body) {
        putit("$_\n", 1);
    }
}


##############################################################################

=head1 Subroutine C<output_goto_table> prints out the entries on the @goto_label list.
This is the "c" to "a"ssembler (CA in prototype file) jump table, and the order
is extremely important.
Calls putit().

=over

=item Z<>

=item Input:

Indirectly @goto_label, no arguments.

=item Output:

Code is insert into the C file.

=item Globals:

None changed.

=item Execution:

N/A.

=back

=cut

##############################################################################
sub output_goto_table()
{
    for (@goto_label) {
        putit("\t&&CT_GOTO_$_,\n", 1);
    }
}


##############################################################################

=head1 Subroutine C<read_proto_file> reads the prototype file and makes
the glue routines for types and arguments and variable definitions for "c" externals.

Process CA, AC, LA, LC, and Variable types.
Global @proto_body has all glue types for "c" file appended.

Global %AC_labels set for AC and LC routines,
notifying which i960 labels need "asm" labels attached,
and to be put into the CT_fake list ($GFILE).

Extra glue code for LC routines put into %SPECIAL_FILE which is output after
the return for the main subroutine, but before the ct_alldone label.
ct_alldone is referenced in the i960 code for checking if a register expression
branch or call is outside the i960 "c" translated code section (in debug mode)
and thus an error -- i.e. probably need LC prototype.

=over

=item Z<>

=item Input:

Global $proto_filename as the file to process.

=item Output:

In global variables below.

=item Globals:

Changes @proto_body, %AC_labels, %SPECIAL_FILE, $GFILE.

=item Execution:

N/A.

=back

=cut

##############################################################################
sub read_proto_file()
{
    open(my $pfile, "<$proto_filename") || die "Cannot open prototype file: $proto_filename";

    ### Loop over all lines in the prototype file, generating one definition
    ### for each line found.

    my $line = 0;

    while (<$pfile>) {
        $line++;
        $_ = chompit($_);                          # delete \r and \n combinations.

        ### Skip blank lines and comments.
        next if (/^\s*(\s*|\#.*|\/\/.*|\/\*.*\*\/\s*)$/);

        my $save_line = $_;
        ### "not defined" Conditional prototype line
     redocondition:
        if (/^!\?(\S+)\s+(.*)$/) {
            my $condition = $1;
            my $protoline = $2;
            if (!defined($defines{$condition})) {
                $_ = $protoline;
                goto redocondition;
            } else {
                next;
            }
        }
        ### "defined" Conditional prototype line
        if (/^\?(\S+)\s+(.*)$/) {
            my $condition = $1;
            my $protoline = $2;
            if (defined($defines{$condition})) {
                $_ = $protoline;
                goto redocondition;
            } else {
                next;
            }
        }
        ### Process valid prototype directives.
        if (/^(\S+)\s+(.+?)\s+(\S+)\s*\((.*)\)\s*;*\s*$/) {
            my $desc = $1;
            my $type = $2;
            my $name = $3;
            my @param = split(/\s*,\s*/, $4);

            my @body = ();

            ### Process C calls to assembly.
            if ($desc eq 'CA') {
                push(@goto_label, "$name");
                push(@body, 0);         # This is set later via $body[0].
                push(@body, 1);         # This is set later via $body[1].
                push(@body, "{");

                my @def;
                my $reg = 0;
                my $parm = 0;
                my $output_reg = 0;     # default output register is g0.
                if ($option_g_reg_proto_special == 1) {
# (specify g registers on CA).   Recognize "gNN=".
                    if ($type =~ /^g([0-9]+)=(.+)$/) {
                        if ($1 > 13) {
                            print STDERR "$proto_filename:$line: error: result register specification > g13 ($type)\t$save_line\n";
                            $exitvalue = 1
                        } else {
                            $output_reg = $1;
                        }
                        $type = $2;
                    }
                }
                if ($type ne "void") {
                    push(@body, "\t$type retval;");
                }
                if ($option_CA_register_save_restore == 1) {
                    push(@body, "\tunsigned long gsave[15];");
                    push(@body, "\t__builtin_memcpy(gsave, greg, sizeof(gsave));");
                }
                for (@param) {
                    s/^\s*//;
                    s/\s*$//;
                    my $value = $_;
                    if ($option_g_reg_proto_special == 1) {
# (specify g registers on CA).  Change $value to recognize "gNN=".
                        # Check if input register specified. */
                        if ($value =~ /^g([0-9]+)=(.+)$/) {
                            if ($1 > 14) {
                                print STDERR "$proto_filename:$line: error: input register specification > g14 ($value)\t$save_line\n";
                                $exitvalue = 1
                            } else {
                                $reg = $1;
                            }
                            $value = $2;
                        }
                    }
                    if ($value eq 'void') {
                        push(@def, 'void');
                    } else {
                        push(@def, "$value p$parm");
                    }
                    if (/64|long.*long/) {                    # even number registers
                        $reg = int(($reg+1) / 2) * 2;
                        if ($reg > 13) {
                            print STDERR "$proto_filename:$line: error: input register specification > g13 ($value)\t$save_line\n";
                            $exitvalue = 1
                        }
                        push(@body, "\tg$reg = (ulong)(p$parm & 0xffffffffL);");
                        $reg++;
                        push(@body, "\tg$reg = (ulong)(p$parm >> 32);");
                    } else {
                        if ($value eq 'void') {         # don't do void.
                            if ($#param != 0) {
                                print STDERR "$proto_filename:$line: error: void and more than one argument.\n\t$save_line\n";
                                $exitvalue = 1
                            }
                        } else {
                            push(@body, "\tg$reg = (ulong) p$parm;");
                        }
                    }
                    if ($reg > 14) {
                        print STDERR "$proto_filename:$line: error: input register specification > g14 ($value)\t$save_line\n";
                        $exitvalue = 1
                    }
                    $reg++;
                    $parm++;
                }

                $body[0] = "extern $type $name(" . join(', ', @def) . ");";   # prototype.
                $body[1] = "$type $name(" . join(', ', @def) . ")";
                if ($option_debug_labels != 0) {
                    push(@body, printdebugp('before CA routine ' . $name . ' number ' . $#goto_label));
                }
                push(@body, "\t$main_program_name($#goto_label);");
                if ($option_debug_labels != 0) {
                    push(@body, printdebugp('after CA routine ' . $name . ' number ' . $#goto_label));
                }
                if ($type ne 'void') {
                    push(@body, "\tretval = *($type *)((byte *)&g$output_reg);");
                }
                if ($option_CA_register_save_restore == 1) {
                    push(@body, "\t__builtin_memcpy(greg, gsave, sizeof(gsave));");
                }

                if ($type ne 'void') {
                    push(@body, "\treturn retval;");
                }
                push(@body, "}");
                push(@body, "");

                push(@proto_body, @body);
                next;
            }

            ### Process Assembly calls to C.
            if ($desc =~ /^(AC|LC)(\S*)/) {
                my $desc_variety = $1;
                my $desc_type = $2;
                my @def;
                my @p_regs;
                my $reg = 0;
                my $parm = 0;
                my @body = ();
                my $underscore;
                my $external;
                my $deleteunderscore = 0;
                my $static;
                my $savethese = 0x60FF;   # 2^14 + 2^13 + (2^7 through 2^0).

                my $tmpname = $name;
#                if ($desc_type =~ /no_/) {
                    $underscore = '';
#                } else {
#                    $underscore = '_';
#                }
                if ($desc_type =~ /delete_/) {
                    $deleteunderscore = 1;
                    $tmpname =~ s/^_//;
                    $underscore = '';             # also don't add one.
                }
                if ($desc_type =~ /noext/) {
                    $external = 0;
                } else {
                    $external = 1;
                }
                if ($desc_type =~ /global/) {
                    $static = "";
                } else {
                    $static = "static ";
                }
                if ($external == 1) {
                    push(@body, "extern $type $underscore$tmpname(" . join(", ", @param) . ");");
                }
                if (defined($AC_labels{$name})) {
                    print STDERR "$proto_filename:$line: error: AC routine $name defined twice\n\t$save_line\n";
                    $exitvalue = 1;
                    next;
                }
                if (defined($C_variables{$name})) {
                    print STDERR "$proto_filename:$line:AC routine $name as defined as a Variable\n\t$save_line\n";
                    $exitvalue = 1;
                    next;
                }
                $AC_labels{$name} = "CT_GLUE_call_" . $name;
                $AC_labels{"CT_GLUE_call_" . $name} = "CT_GLUE_call_" . $name;
                if ($desc_type !~ /noglue/) {
#                  push(@body, "${static}inline void CT_GLUE_call_$name(void)");
                    push(@body, "void CT_GLUE_call_$name(void);");   # prototype declaration.
                    push(@body, "void CT_GLUE_call_$name(void)");
                    push(@body, "{");

                    for (@param) {
                        s/^\s*//;
                        s/\s*$//;
                        push(@def, "$_ p$parm");
                        if ($_ eq 'void') {
                            next;
                        }
                        push(@p_regs, "p$parm");
                        if (/64|long.*long/) {
                            my $reg0 = int(($reg+1) / 2) * 2;
                            if ($option_AC_register_save_restore == 1) {
                                if (((1<<$reg0) & $savethese) != 0) { # if reg to be saved is used, don't save.
                                    $savethese &= ~(1<<$reg0);          # turn bit for register off.
                                }
                            }
                            $reg = $reg0 + 1;
                            push(@body, ("\t$_ p$parm = (($_)g$reg << 32) | g$reg0;"));
                        } elsif ($_ eq 'double') {
                            my $reg0 = int(($reg+1) / 2) * 2;
                            if ($option_AC_register_save_restore == 1) {
                                if (((1<<$reg0) & $savethese) != 0) { # if reg to be saved is used, don't save.
                                    $savethese &= ~(1<<$reg0);          # turn bit for register off.
                                }
                            }
                            $reg = $reg0 + 1;
  # The following line is not correct.  Need a union to make it work.
                            push(@body, ("\t$_ p$parm = (double)(((long64)g$reg << 32) | g$reg0);"));
                      } elsif ($_ eq 'float') {
  # The following line is not correct.  Need a union to make it work.
                            push(@body, ("\t$_ p$parm =  (float)g$reg;"));
                      } else {
                            push(@body, "\t$_ p$parm = ($_) g$reg;");
                      }
                      $parm++;
                      if ($option_AC_register_save_restore == 1) {
                          if (((1<<$reg) & $savethese) != 0) {  # if reg to be saved is used, don't save.
                              $savethese &= ~(1<<$reg);           # turn bit for register off.
                          }
                      }
                      $reg++;
                  }
                  my @restoreafter;
                  if ($option_AC_register_save_restore == 1) {
                      my $tmpreg = 0;
                      if ($type ne "void") {
                          $savethese &= ~(1);           # turn bit for return register off.
                          if (($type =~ /64|long.*long/) || ($type eq 'double')) {
                              $savethese &= ~(1);         # turn bit for 2nd return register off.
                          }
                      }
                      while ($savethese != 0) {
                          if (($savethese & 1) == 1) {
                              push(@body, "\tulong save_g$tmpreg = g$tmpreg;");
                              push(@restoreafter, "\tg$tmpreg = save_g$tmpreg;");
                          }
                          $tmpreg++;
                          $savethese = $savethese >> 1;
                      }
                  }
                  if ($option_debug_labels != 0) {
                      push(@body, printdebugp('before AC routine ' . $underscore . $tmpname));
                  }
                  if ($type eq "void") {
                      push(@body, "\t$underscore$tmpname(" . join(", ", @p_regs) . ");");
                  } else {
                      push(@body, "\t$type r = $underscore$tmpname(" . join(", ", @p_regs) . ");");
                      if ($type =~ /64|long.*long/) {
                          push(@body, "\tg0 = r & 0xffffffffl;");
                          push(@body, "\tg1 = r >> 32;");
                      } elsif ($type eq 'double') {                             # NOTDONEYET
  # The following two lines are not correct.  Need a union to make it work.
                          push(@body, "\tg0 = (ulong64)r & 0xffffffffl;");
                          push(@body, "\tg1 = (ulong64)r >> 32;");
                      } elsif ($type eq 'float') {                              # NOTDONEYET
  # The following line is not correct.  Need a union to make it work.
                          push(@body, "\tg0 = (ulong)r;");
                      } else {
                          push(@body, "\tg0 = (ulong) r;");
                      }
                  }
                  if ($option_debug_labels != 0) {
                      push(@body, printdebugp('after AC routine ' . $underscore . $tmpname));
                  }
                  if ($option_AC_register_save_restore == 1) {
                      for (@restoreafter) {
                          push(@body, $_);
                      }
                  }
                  push(@body, "}");
                  push(@body, "");

                  push(@proto_body, @body);
                }
                if ($desc =~ /^LC/) {
#                    $SPECIAL_FILE .= $ASMV . '(".text"); ';
                    $SPECIAL_FILE .= 'CT_goto_' . $name . ': { ';
                    # This comment is to line up with the opposite brace above }
                    $SPECIAL_FILE .=   $ASMV . '("CT_LC_' . $name . ':"); ';
                    $SPECIAL_FILE .=   $ASMV . '(".globl CT_LC_' . $name . '"); ';
                    $SPECIAL_FILE .=     'CT_GLUE_call_' . $name . '(); ';
                    $SPECIAL_FILE .=     'fp = pfp; ';                # "ret" equivalent.
                    $SPECIAL_FILE .=     'goto *(void*) rip; ';
                    $SPECIAL_FILE .= '}' . "\n";
                    $SPECIAL_linenumber++;
                    $GFILE .= "\t&&CT_goto_$name,\n";
                    $GFILE_COUNT++;
                    $AC_labels{$name} = "CT_goto_" . $name;
                    $AC_labels{"CT_goto_" . $name} = "CT_goto_" . $name;
                }
                next;
            }

            ### Unknown Proto descriptor.
            print STDERR "$proto_filename:$line: error: Poorly formed prototype\n\t$save_line\n";
            $exitvalue = 1
        } else {
            ### Process C variables used by assembly.
            if (/^Variable([^   ]*)\s+([^       ]*)\s+([^       ;]*)\s*;*\s*$/) {
                my $ext = "$1";
                my $type = $2;
                my $label = $3;
                if (defined($C_variables{$label})) {
                    print STDERR "$proto_filename:$line:Variable $label defined twice\n\t$save_line\n";
                    $exitvalue = 1;
                }
                if (defined($AC_labels{$label})) {
                    print STDERR "$proto_filename:$line:Variable $label defined also as AC routine\n\t$save_line\n";
                    $exitvalue = 1;
                }
                $C_variables{$label} = $ext . $type;
                next;
            }

            ### Code (goto) Label in Assembler referenced in "c", used in assembler.
            if (/^LA\s+(\S+)\s*;*\s*$/) {
                my $label = $1;
                if (defined($LA_label{$label})) {
                    print STDERR "$proto_filename:$line:LA routine $label defined twice\n\t$save_line\n";
                    $exitvalue = 1;
                    next;
                }
                $LA_label{$label} = $label;
                $GFILE .= "\t&&CT_GOTO_$label,\n";
                $GFILE_COUNT++;
                next;
            }

            print STDERR "$proto_filename:$line: error: Unrecognized prototype line\n\t$save_line\n";
            $exitvalue = 1;
        }
    }
    close($pfile);
}


##############################################################################

=head1 Table C<code_opcode> contains the master i960 .text assembler instructions.
The index to the hash name is the i960 instruction and it points to a function to execute.
The function may be an in-line fuction.
The entry chosen is executed via a perl 'eval'.
The return from the function is "c" code to be inserted into the "c" file.

It is defined at the end of the subroutines,
so that perl can do syntax checking on the function calls with "use strict".
There are not separate pass1 and pass2 tables,
because a label can be used anywhere and this means nearly complete parsing for both passes.

In additon to the i960 instructions, there are pseudo-ops allowed in code sections.
There are three m4 preprocessor macros PushReg, PopReg, PopRegVoid that are
implemented directly.

There is one new "c" pseudo-op that is for inserting the line as "c" code.

=over

=item Z<>

=item Input:

The $opcode variable is used to index this table.
%operand are potential arguments to the i960 command.

=item Output:

N/A.

=item Globals:

N/A.

=item Execution:

N/A.

=back

=cut

##############################################################################
%code_opcode = (
            addono  => \&op_notimp,
            addoo   => \&op_notimp,
            addio   => \&op_notimp,
            addino  => \&op_notimp,

            addog   => sub() { op_binary_cc('+', '>')  },
            addoe   => sub() { op_binary_cc('+', '==') },
            addoge  => sub() { op_binary_cc('+', '>=') },
            addol   => sub() { op_binary_cc('+', '<')  },
            addone  => sub() { op_binary_cc('+', '!=') },
            addole  => sub() { op_binary_cc('+', '<=') },

            addig   => sub() { op_binary_cc('+', '>')  },
            addie   => sub() { op_binary_cc('+', '==') },
            addige  => sub() { op_binary_cc('+', '>=') },
            addil   => sub() { op_binary_cc('+', '<')  },
            addine  => sub() { op_binary_cc('+', '!=') },
            addile  => sub() { op_binary_cc('+', '<=') },

            addc    => \&op_addc,

            addi    => sub() { op_binary('+') },
            addo    => sub() { op_binary('+') },

            alterbit=> sub() { op_alterbit() },

            and     => sub() { op_logical(' ', '&', ' ') },
            andnot  => sub() { op_logical('~', '&', ' ') },

            atadd   => \&op_atadd,
            atmod   => \&op_atmod,

            b       => \&op_b,
            bx      => \&op_bx,

            bal     => \&op_bal,
            balx    => \&op_balx,

            bbc     => sub() { op_bbc('') },
            'bbc.t' => sub() { op_bbc('likely') },
            'bbc.f' => sub() { op_bbc('unlikely') },
            bbs     => sub() { op_bbs('') },
            'bbs.t'  => sub() { op_bbs('likely') },
            'bbs.f' => sub() { op_bbs('unlikely') },

            be      => sub() { op_bcc('==','') },
            'be.t'  => sub() { op_bcc('==','likely') },
            'be.f'  => sub() { op_bcc('==','unlikely') },
            bne     => sub() { op_bcc('!=','') },
            'bne.t' => sub() { op_bcc('!=','likely') },
            'bne.f' => sub() { op_bcc('!=','unlikely') },
            bl      => sub() { op_bcc('<' ,'') },
            'bl.t'  => sub() { op_bcc('<' ,'likely') },
            'bl.f'  => sub() { op_bcc('<' ,'unlikely') },
            ble     => sub() { op_bcc('<=','') },
            'ble.t' => sub() { op_bcc('<=','likely') },
            'ble.f' => sub() { op_bcc('<=','unlikely') },
            bg      => sub() { op_bcc('>' ,'') },
            'bg.t'  => sub() { op_bcc('>' ,'likely') },
            'bg.f'  => sub() { op_bcc('>' ,'unlikely') },
            bge     => sub() { op_bcc('>=','') },
            'bge.t'   => sub() { op_bcc('>=','likely') },
            'bge.f'   => sub() { op_bcc('>=','unlikely') },

            bno     => sub() { op_bno('')},
            'bno.t' => sub() { op_bno('likely')},
            'bno.f' => sub() { op_bno('unlikely')},
            bo     => sub() { op_bo('')},
            'bo.t' => sub() { op_bo('likely')},
            'bo.f' => sub() { op_bo('unlikely')},

            bswap   => \&op_bswap,

            call    => \&op_call,
            callx   => \&op_callx,
            calls   => \&op_notimp,
            callj   => \&op_call,       # One of call, calls, bal.
            calljx  => \&op_callx,      # One of callx, calls, balx.

            chkbit  => sub() { op_chkbit() },
            clrbit  => sub() { op_clrbit() },

            cmpdeci => sub() { op_cmpadd(0x80000000, -1) },
            cmpdeco => sub() { op_cmpadd(0x00000000, -1) },
            cmpinci => sub() { op_cmpadd(0x80000000, +1) },
            cmpinco => sub() { op_cmpadd(0x00000000, +1) },

            cmpi    => sub() { op_cmp(0xffffffff, 0x80000000) },
            cmpib   => sub() { op_cmp(0x000000ff, 0x00000080) },
            cmpis   => sub() { op_cmp(0x0000ffff, 0x00008000) },
            cmpo    => sub() { op_cmp(0xffffffff, 0x00000000) },
            cmpob   => sub() { op_cmp(0x000000ff, 0x00000000) },
            cmpos   => sub() { op_cmp(0x0000ffff, 0x00000000) },

            cmpibe   =>    sub() { op_cbranch(0x80000000, '==', '') },
            'cmpibe.t' =>  sub() { op_cbranch(0x80000000, '==', 'likely') },
            'cmpibe.f' =>  sub() { op_cbranch(0x80000000, '==', 'unlikely') },
            cmpibne  =>    sub() { op_cbranch(0x80000000, '!=', '') },
            'cmpibne.t' => sub() { op_cbranch(0x80000000, '!=', 'likely') },
            'cmpibne.f' => sub() { op_cbranch(0x80000000, '!=', 'unlikely') },
            cmpibl   =>    sub() { op_cbranch(0x80000000, '<', '' ) },
            'cmpibl.t' =>  sub() { op_cbranch(0x80000000, '<', 'likely') },
            'cmpibl.f' =>  sub() { op_cbranch(0x80000000, '<', 'unlikely') },
            cmpible  =>    sub() { op_cbranch(0x80000000, '<=', '') },
            'cmpible.t' => sub() { op_cbranch(0x80000000, '<=', 'likely') },
            'cmpible.f' => sub() { op_cbranch(0x80000000, '<=', 'unlikely') },
            cmpibg   =>    sub() { op_cbranch(0x80000000, '>', '' ) },
            'cmpibg.t' =>  sub() { op_cbranch(0x80000000, '>', 'likely') },
            'cmpibg.f' =>  sub() { op_cbranch(0x80000000, '>', 'unlikely') },
            cmpibge  =>    sub() { op_cbranch(0x80000000, '>=', '') },
            'cmpibge.t' => sub() { op_cbranch(0x80000000, '>=', 'likely') },
            'cmpibge.f' => sub() { op_cbranch(0x80000000, '>=', 'unlikely') },

            cmpobe   =>    sub() { op_cbranch(0x00000000, '==', '') },
            'cmpobe.t' =>  sub() { op_cbranch(0x00000000, '==', 'likely') },
            'cmpobe.f' =>  sub() { op_cbranch(0x00000000, '==', 'unlikely') },
            cmpobne  =>    sub() { op_cbranch(0x00000000, '!=', '') },
            'cmpobne.t' => sub() { op_cbranch(0x00000000, '!=', 'likely') },
            'cmpobne.f' => sub() { op_cbranch(0x00000000, '!=', 'unlikely') },
            cmpobl   =>    sub() { op_cbranch(0x00000000, '<' , '') },
            'cmpobl.t' =>  sub() { op_cbranch(0x00000000, '<', 'likely') },
            'cmpobl.f' =>  sub() { op_cbranch(0x00000000, '<', 'unlikely') },
            cmpoble  =>    sub() { op_cbranch(0x00000000, '<=', '') },
            'cmpoble.t' => sub() { op_cbranch(0x00000000, '<=', 'likely') },
            'cmpoble.f' => sub() { op_cbranch(0x00000000, '<=', 'unlikely') },
            cmpobg   =>    sub() { op_cbranch(0x00000000, '>',  '') },
            'cmpobg.t' =>  sub() { op_cbranch(0x00000000, '>', 'likely') },
            'cmpobg.f' =>  sub() { op_cbranch(0x00000000, '>', 'unlikely') },
            cmpobge  =>    sub() { op_cbranch(0x00000000, '>=', '') },
            'cmpobge.t' => sub() { op_cbranch(0x00000000, '>=', 'likely') },
            'cmpobge.f' => sub() { op_cbranch(0x00000000, '>=', 'unlikely') },

            cmpibo  => \&op_notimp,
            cmpibno => \&op_notimp,

            concmpi => sub() { op_concmp(0x80000000) },
            concmpo => sub() { op_concmp(0x00000000) },

            dcctl   => \&op_dcctl,      # NOTE: FIX THIS FOR MIPS

            divi    => sub() { op_mult('long ', '/')  },
            divo    => sub() { op_mult('ulong', '/') },

            ediv    => \&op_ediv,
            emul    => \&op_emul,
            eshro   => \&op_notimp,

            extract => \&op_extract,

            faulte  => sub() { op_fault('==') },
            faultne => sub() { op_fault('!=') },
            faultl  => sub() { op_fault('<' ) },
            faultle => sub() { op_fault('<=') },
            faultg  => sub() { op_fault('>' ) },
            faultge => sub() { op_fault('>=') },

            faulto  => \&op_notimp,
            faultno => \&op_notimp,

            flushreg => \&op_flushreg,  # NOTE: FIX THIS FOR MIPS
            fmark    => \&op_notimp,
            halt     => \&op_notimp,
            icctl    => \&op_icctl,     # NOTE: FIX THIS FOR MIPS

            intctl  => \&op_intctl,
            intdis  => \&op_intdis,
            inten   => \&op_inten,

            ld      => sub() { op_load('ulong')  },
            ldob    => sub() { op_load('uchar')  },
            ldos    => sub() { op_load('ushort') },
            ldib    => sub() { op_load('schar')  },
            ldis    => sub() { op_load('short')  },

            ldl     => sub() { op_ldm(2) },
            ldt     => sub() { op_ldm(3) },
            ldq     => sub() { op_ldm(4) },

            ldconst => \&op_lda,
            lda     => \&op_lda,

            mark    => \&op_notimp,
            modac   => \&op_notimp,     # Examine and/or Modify Arithmetic Control register

            modi    => sub() { op_mult('long', '%') },

            modify  => \&op_modify,

            modpc   => \&op_modpc,
            modtc   => \&op_notimp,     # NOTE: FIX THIS FOR MIPS

            mov     => sub() { op_movm(1) },
            movl    => sub() { op_movm(2) },
            movt    => sub() { op_movm(3) },
            movq    => sub() { op_movm(4) },

            muli    => sub() { op_mult('long',  '*') },
            mulo    => sub() { op_mult('ulong', '*') },

            nand    => sub() { op_logical('~', '&', '~') },
            nor     => sub() { op_logical('~', '|', '~') },
            notand  => sub() { op_logical(' ', '&', '~') },
            notor   => sub() { op_logical(' ', '|', '~') },

            not     => \&op_not,

            notbit  => \&op_notbit,

            or      => sub() { op_logical(' ', '|', ' ') },
            ornot   => sub() { op_logical('~', '|', ' ') },

            remi    => sub() { op_mult('long',  '%') },
            remo    => sub() { op_mult('ulong', '%') },

            ret     => \&op_return,

            rotate  => \&op_rotate,
            scanbit => \&op_scanbit,
            scanbyte=> \&op_notimp,

            selno   => \&op_selno,
            selo    => \&op_selo,

            sele    => sub() { op_select('==') },
            selne   => sub() { op_select('!=') },
            selg    => sub() { op_select('>' ) },
            selge   => sub() { op_select('>=') },
            sell    => sub() { op_select('<' ) },
            selle   => sub() { op_select('<=') },

            setbit  => sub() { op_setbit() },

            shli    => \&op_notimp,     # shift left, but only till top bit changes.
            shlo    => \&op_shlo,       # shift left, bits on top tossed.
            shri    => \&op_shri,       # shift right, normal.
            shro    => \&op_shro,       # shift right, zeros into top.
            shrdi   => \&op_notimp,     # shift right, but add one if top bit was negative (??)

            spanbit => \&op_spanbit,

            st      => sub() { op_store('ulong') },
            stob    => sub() { op_store('uchar') },
            stos    => sub() { op_store('ushort') },

            stl     => sub() { op_stm(2) },
            stt     => sub() { op_stm(3) },
            stq     => sub() { op_stm(4) },

            subc    => \&op_subc,

            subono  => \&op_notimp,
            suboo   => \&op_notimp,
            subio   => \&op_notimp,
            subino  => \&op_notimp,

            subog   => sub() { op_binary_cc('-', '>')  },
            suboe   => sub() { op_binary_cc('-', '==') },
            suboge  => sub() { op_binary_cc('-', '>=') },
            subol   => sub() { op_binary_cc('-', '<')  },
            subone  => sub() { op_binary_cc('-', '!=') },
            subole  => sub() { op_binary_cc('-', '<=') },

            subig   => sub() { op_binary_cc('-', '>')  },
            subie   => sub() { op_binary_cc('-', '==') },
            subige  => sub() { op_binary_cc('-', '>=') },
            subil   => sub() { op_binary_cc('-', '<')  },
            subine  => sub() { op_binary_cc('-', '!=') },
            subile  => sub() { op_binary_cc('-', '<=') },

            subi    => sub() { op_binary('-') },
            subo    => sub() { op_binary('-') },

            syncf   => \&op_notimp,
            sysctl  => \&op_sysctl,     # NOTE: FIX THIS FOR MIPS

            teste   => sub() { op_test('==') },
            testne  => sub() { op_test('==') },
            testl   => sub() { op_test('<' ) },
            testle  => sub() { op_test('<=') },
            testg   => sub() { op_test('>' ) },
            testge  => sub() { op_test('>=') },

            xnor    => sub() { op_logical('~', '^', '') },
            xor     => sub() { op_logical(' ', '^', '') },

#######################################################################
# The following three (3) are m4 preprocessor macros that we implement
# directly.  Their purpose is to allow a consistant manner of calling
# "c" routines from assembler.  (They save/restore lots of registers.)
#######################################################################

            PushRegs    => \&op_PushRegs,       # Save g0-g14 on stack
            PopRegsVoid => \&op_PopRegsVoid,    # Restore g0-g14 from stack
            PopRegs     => \&op_PopRegs,        # Restore g1-g14 from stack

# The following is an addition to alloc "c" embedded in i960 assembler.
            c           => \&c,         # put rest of line as is ('c')
            cdefine     => \&cdefine,   # put rest of line as is ('cdefine')
            cundef      => \&cundef,    # put rest of line as is ('cundef')

#######################################################################
# Create pseudo-ops table and entries in the opcode table.
#######################################################################

            '.align'   => \&ps_align,
            '.ascii'   => \&ps_data_define,
            '.asciz'   => \&ps_data_define,
            '.bss'     => \&ps_bss,     # Special cased in routine.
            '.byte'    => \&ps_data_define,
            '.comm'    => \&ps_comm,    # Special cased in routine.
            '.data'    => \&ps_data,
            '.eject'   => \&ps_ignore,
            '.else'    => \&ps_else,
            '.endif'   => \&ps_endif,
            '.globl'   => \&ps_global,
            '.global'  => \&ps_global,  # either spelling is ok.
            '.if'      => \&ps_if,
            '.ifdef'   => \&ps_ifdef,
            '.ifndef'  => \&ps_ifndef,
            '.include' => \&ps_include,
            '.int'     => \&ps_data_define,
            '.leafproc'=> \&ps_ignore,
            '.list'    => \&ps_ignore,
            '.long'    => \&ps_data_define,
            '.nolist'  => \&ps_ignore,
            '.org'     => \&ps_org,
            '.section' => \&ps_section,
            '.set'     => \&ps_set,
            '.short'   => \&ps_data_define,
            '.space'   => \&ps_space,
            '.text'    => \&ps_text,
            '.title'   => \&ps_ignore,
            '.word'    => \&ps_data_define,
            );


#######################################################################

=head1 Table C<data_opcode> is the list of pseudo-ops allowed in the .data
section.
The index to the hash name is the i960 pseudo-op and it points to a function to execute.
The function may be an in-line fuction.
The entry chosen is executed via a perl 'eval'.
The return from the function is "c" code to be inserted into file.

This table is defined at the end of the subroutines,
so that perl can do syntax checking on the function calls with "use strict".
There are not separate pass1 and pass2 tables, because a label can be used
anywhere and this means nearly complete parsing for both passes.

There are six m4 preprocessor macros that we implement directly
(tablename, state, event, action, column, node).
Their purpose is to allow creation of state tables.

One pseudo-op is added (.unset) to allow compiling as one big file,
instead of as several .o files.
This makes the state table macros work when swapping the two files order,
and compiling them twice.

The START_SH_DATA_SECTION pseudo-op has been added to allow
initialization of a shared memory table.
Such tables are typically passed through the link layer to another
process.

=over

=item Z<>

=item Input:

The $opcode variable is used to index this table.
%operand are potential arguments to the i960 pseudo-ops.

=item Output:

N/A.

=item Globals:

N/A.

=item Execution:

N/A.

=back

=cut

#######################################################################
%data_opcode = (
            '.align'   => \&ps_align,
            '.ascii'   => \&ps_data_define,
            '.asciz'   => \&ps_data_define,
            '.bss'     => \&ps_bss,
            '.byte'    => \&ps_data_define,
            '.comm'    => \&ps_comm,
            '.data'    => \&ps_data,
            '.eject'   => \&ps_ignore,
            '.else'    => \&ps_else,
            '.endif'   => \&ps_endif,
            '.globl'   => \&ps_global,
            '.if'      => \&ps_if,
            '.ifdef'   => \&ps_ifdef,
            '.ifndef'  => \&ps_ifndef,
            '.include' => \&ps_include,
            '.int'     => \&ps_data_define,
            '.list'    => \&ps_ignore,
            '.long'    => \&ps_data_define,
            '.nolist'  => \&ps_ignore,
            '.org'     => \&ps_org,
            '.section' => \&ps_section,
            '.set'     => \&ps_set,
            '.short'   => \&ps_data_define,
            '.space'   => \&ps_space,
            '.text'    => \&ps_text,
            '.title'   => \&ps_ignore,
            '.word'    => \&ps_data_define,

#######################################################################
# The following six (6) are m4 preprocessor macros that we implement
# directly.  Their purpose is to allow creation of state tables.
#######################################################################
            'tablename' => \&op_tablename,
            'state'    => \&op_state,
            'event'    => \&op_event,
            'action'   => \&op_action,
            'column'   => \&op_column,
            'node'     => \&op_node,

#######################################################################
# The following is to allow the above to work when compiling as one
# big file, instead of as several .o files.
#######################################################################
            '.unset'   => \&ps_unset,

#######################################################################
# The following is to allow initialization of shared memory section.
#######################################################################
            'START_SH_DATA_SECTION' => \&ps_START_SH_DATA_SECTION,

            );


#######################################################################

=head1 Table C<shmem_opcode> is the list of pseudo-ops allowed in the
.shmem section.
The index to the hash name is the i960 pseudo-op and it points to a function to execute.
The function may be an in-line fuction.
The entry chosen is executed via a perl 'eval'.
The return from the function is "c" code to be inserted into file.

This table is defined at the end of the subroutines,
so that perl can do syntax checking on the function calls with "use strict".
There are not separate pass1 and pass2 tables, because a label can be used
anywhere and this means nearly complete parsing for both passes.

The END_SH_DATA_SECTION pseudo-op has been added to allow
knowing that the initialization of a shared memory table has ended.
Such tables are typically passed through the link layer to another
process.

This may be thought of as the pseudo-ops allowed in
START_SH_DATA_SECTION -> END_SH_DATA_SECTION.

=over

=item Z<>

=item Input:

The $opcode variable is used to index this table.
%operand are potential arguments to the i960 pseudo-ops.

=item Output:

N/A.

=item Globals:

N/A.

=item Execution:

N/A.

=back

=cut

#######################################################################
%shmem_opcode = (
            '.ascii'   => \&ps_data_define,
            '.asciz'   => \&ps_data_define,
            '.bss'     => \&ps_bss,
            '.byte'    => \&ps_data_define,
            '.eject'   => \&ps_ignore,
            '.else'    => \&ps_else,
            '.endif'   => \&ps_endif,
            '.if'      => \&ps_if,
            '.ifdef'   => \&ps_ifdef,
            '.ifndef'  => \&ps_ifndef,
            '.int'     => \&ps_data_define,
            '.list'    => \&ps_ignore,
            '.long'    => \&ps_data_define,
            '.nolist'  => \&ps_ignore,
            '.set'     => \&ps_set,
            '.short'   => \&ps_data_define,
            '.space'   => \&ps_space,
            '.word'    => \&ps_data_define,

#######################################################################
# The following is to notify the end of shared memory initialization.
#######################################################################
            'END_SH_DATA_SECTION' => \&ps_END_SH_DATA_SECTION,
            );


##############################################################################

=head1 Table C<sections> is used to determine the type of section.
It originally allowed for many section types.
Now there are mainly three types:  .text, .shmem, and everything else is .data.
The .shinit and .shinittable sections are generated by the
START_SH_DATA_SECTION and END_SH_DATA_SECTION pseudo-ops.
Any section name not listed in C<sections> is not allowed.

=over

=item Z<>

=item Input:

Section name to find which type it is.

=item Output:

N/A.

=item Globals:

N/A.

=item Execution:

N/A.

=back

=cut

##############################################################################
%sections = ( "cds"      => 'data',
              "critdata" => 'lomem',
              "data"     => 'data',
              "end"      => 'bss',
              "lowuse"   => 'text',
              "ltext"    => 'text',
              "mtext"    => 'text',
              ".shmem"   => '.shmem',
              "text"     => 'text',
              "z_init"   => 'text',
              ".shdata"  => '.shdata',  # NOTE: this is not really allowed.
              ".shinit"  => '.shinit',  # NOTE: this is not really allowed.
              ".shinittable"  => '.shinittable',  # NOTE: this is not really allowed.
              );


##############################################################################

=head1 Table C<change_label> is for changing a label into something else.
This was needed for i960 assembler generated from a gcc that produces i960
assembler with the -S option, then that code passed through CT_analyze.

=over

=item Z<>

=item Input:

Label to see if there is a different name to use instead.

=item Output:

N/A.

=item Globals:

N/A.

=item Execution:

N/A.

=back

=cut

##############################################################################
# Special for OpenBSD.
$change_label{'___sF'} = '__sF';        # only two underscores
$change_label{'_errno'} = 'errno';      # no underscores


##############################################################################

=head1 Main program

Call parse_input_parameters() to parse the command line arguments.
Creates the "c" main program name (for the i960 translated code) from the name of the -o option.
If prototype file to read, call read_proto_file().

Set up to do the first pass of the i960 files.
Set pass_number to 1, undefine %const, %const_count. %labels, %global.
Define variables on -D options.
Treat the every file on the command line as a include_file(), and process it.
This is to define every .set command, and know every label and it's use
(i.e. used in a store, branch, .word, etc).

Set up to do the second pass of the i960 files.
Set pass_number to 2
Open the .CT.c and .CTS.c files.
Create memory copies of what goes into the output files.
Put all -I options into the "c" file.
Include "CT_asm_defines.h".
Output register definitions for greg[0->14] and *rreg.
Note that rreg is g15 and points to the "r" registers and is immediately after greg[14], thus
becoming greg[15].
Output main routine name as a forward; proto type glue routines; externals, globals, forwards.

Start outputting the main routine.
Output the goto jump list for the glue routines.
Output the list of all data items (CT_fake) that are used so they are not optimized away by gcc.
These are externals (globals) that are not necessarily referenced by a "c" goto statement,
but through indirect jump tables.

Save the %const and %const_count variables as %const_2 and %const_2_count.
Clear variables as per pass 1.
Define and initialize main routine variables cmp_tmp0 and cmp_tmp1 as
automatic variables, not globals.
Set rip, fp, pfp, sp as we have entered a routine.
Doing it here saves having to do it in all the glue routines.
Put out the jump to the goto label CT_entry_table.
Insure that the CT_fake goto table is not optimized away by putting in
some code that references it.

Define variables on -D options.
Treat the every file on the command line as a include_file(), and process it.

Force the $section type to .text and output termination code for the routine.

Do the real write to the ".CT.c" file.
Then write ".CTS.c" file with all non-text sections.

Exit with error if one is encountered, else zero.

=over

=item Z<>

=item Input:

Command line arguments.

=item Output:

Code written to .CT.c and .CTS.c files.
Exit value if error encountered, else zero.

=item Globals:

Many initialized and used.

=item Execution:

N/A.

=back

=cut

##############################################################################
parse_input_parameters();

# Generate the "c" subroutine name from the file name (periods become dots).
$main_program_name = $option_outputfile;
$main_program_name =~ s/^\.\/obj\///;
$main_program_name =~ s/^obj\///;
$main_program_name =~ s/\./_/g;
$main_program_name =~ s;/;_;g;

# Process the prototype file.
if (defined($proto_filename) && $proto_filename ne '') {
  read_proto_file();
}


# Do this in two passes.  First gets all labels. --------------------
$pass_number = 1;

$lookingfor = $normal_list;     # we are processing, do anything.
undef(%const);                  # no .set's done.
undef(%const_count);
foreach my $i (keys(%defines)) {
  $const{$i} = $defines{$i};
  $const_count{$i} = 1;
}
undef(%labels);
undef(%global);                 # no .global's done.
$autolabel = 0;                 # Last automatic branch label index
undef($last_label);             # Last label processed.
print STDERR "Pass 1\n";
$save_section_one = 0;          # save one line to save_section
$filecount = 0;
undef(%already_included);
for my $f (@not_opt) {          # Process files.
  $filecount++;
  undef($already_included{$f});
  include_file($f);
}

if ($section eq '.shdata') {
    error("Missing END_SH_DATA_SECTION, pass 1");
}

# Second pass, write file.  ----------------------------------------
$pass_number = 2;
print STDERR "Pass 2\n";
undef($last_label);             # Last label processed.

# Open the .c file for writing.
$external_c_file = $option_outputfile;
if (!defined(open(CFILE, ">$external_c_file"))) {
  die("Cannot open external_c_file: $external_c_file");
}
$external_s_file = $external_c_file;
$external_s_file =~ s/\.CT\.c$/.CTS.c/;
if (!defined(open(SFILE, ">$external_s_file"))) {
  die("Cannot open external_s_file: $external_s_file");
}

$shdata_count = 0;              # number of different .shdata entries.

# Create external definitions, and goto labels for inclusion shortly.
external_definitions();

$section = 'text';
$save_section_count{$section} = 1;        # off by one to start with.
if ($option_no_line_numbers == 0) {
  put_linenumber(2, $external_c_file, 'text', ''); # The "#" line is number 1.
}

# If any -I options on command line, insert them now.
for my $f (@option_I) {
  putit("#include \"$f\"\n", 1);
}

# Include a small definition file.
putit("#include \"CT_asm_defines.h\"\n", 1);

# This allows for checking if unitialized memory  is being loaded.
# Do a -DHISTORY_KEEP.
if (defined($defines{'HISTORY_KEEP'})) {
  putit("extern void check_memory_patterns(const char *str, ulong arg);\n", 1);
}
# If check local memory (i.e. do not change another processes memory), need external routine.
if ($option_check_local_memory == 1) {
  putit("extern void CHECK_LOCAL_MEMORY(const char *str, ulong arg);\n", 1);
}
# If check r registers for pattern before use, need external routine.
if ($option_check_r_reg_pattern_match == 1) {
  putit("extern void CHECK_RREG_PATTERN(const char *str, ulong arg);\n", 1);
}

if ($option_i386 == 1 || $option_mips == 1) {
  putit("asm(\".text\");", 1);
#  putit("unsigned long  greg[15] __attribute__((section(\".data\"), aligned(4)));\n", 1);
#  putit("unsigned long * rreg     __attribute__((section(\".data\"), aligned(4)));\n", 1);
  putit("asm (\"  .data\");\n", 1);
  putit("asm (\"  .globl greg\");\n", 1);
  putit("asm (\"  .globl rreg\");\n", 1);
  putit("asm (\"greg: .space 15*4;  rreg: .space 1*4\");\n", 1);
} else {
  putit("unsigned long  greg[15];\n", 1);
  putit("unsigned long * rreg;\n", 1);
}
putit("$ASM (\"  .globl _rreg\");\n", 1);
putit("$ASM (\"  .set _rreg, rreg\");\n", 1);

# Make sure "c" starts with .text.
putit($ASM . "(\".text\");\n", 1);

# Output the forward for the main_program.
putit("static void $main_program_name(int);\n", 1);

# output_proto_body() outputs all prototypes.
output_proto_body();

# Create the externals/globals/forwards.
if ($HFILE_COUNT > 0) {
    putit($HFILE, $HFILE_COUNT);
}

if ($option_no_line_numbers == 0) {
  put_linenumber($save_section_count{'text'}+1, $external_c_file, $section, '');
}
putit("static void $main_program_name(int CT_which_entry)\n", 1);
putit("{\n", 1);

# Include the labels file from *.CT.labels.h
putit("  static void * const CT_entry_table [] = {\n", 1);
# output_goto_table() outputs the label jump table.
output_goto_table();
# Force keep next.
putit("\t&&CT_fake,\n", 1);
putit("  };\n", 1);
putit("  static void * const CT_used_data [] = {\n", 1);
if ($GFILE_COUNT > 0) {
    putit($GFILE, $GFILE_COUNT);
}
putit("\t&&CT_fake,\n", 1);        # Force keep this table.
putit("  };\n", 1);

if ($used_cmps != 0) {
  putit("  ulong cmp_tmp0 = 0, cmp_tmp1 = 0;\n", 1);
}
#if ($used_order != 0) {
#  putit("  ulong cmp_ordered;\n", 1);
#}
putit("  {\n", 1);
if ($option_debug_registers != 0) {
  putit(printregisters(), 1);
}
putit("    ulong ofp = fp;\n", 1);
putit("    rip = (ulong)&&ct_alldone;\n", 1);
putit("    fp = (ulong)((sp + 0xf) & ~0xfUL);\n", 1);
putit("    pfp = ofp;\n", 1);
putit("    sp = fp + 64;\n", 1);
if ($option_assumes_works == 0) {
  putit("    rip = (ulong)&&ct_error;\n", 1);
}
if ($option_debug_registers != 0) {
  putit(printregisters(), 1);
}
putit("  }\n", 1);
# if ($option_debug_labels != 0) {
#   putit('  CT_history1("' . $main_program_name . ' entered, CT_which_entry=%d\n", CT_which_entry);' . "\n", 1);
# }
putit("\n", 1);
putit("  goto *CT_entry_table[CT_which_entry];\n", 1);

# If one does not reference a data structure, there is a warning.
putit("CT_fake:  g0 = (ulong)CT_used_data[g0];\n", 1);
putit("  return;\n", 1);
putit("\n", 1);

# This is to reduce memory usage for many different 80 byte message arrays on stack.
# NOTE: VRPAVAILABLE is 80 bytes long, LL_LinuxLinkLayer.c copies <=80 messages into MRP.
putit("  UINT8 TmpStackMessage[80];\n", 1);

# Following pretty much matches pass 1's -- except for labels.
$lookingfor = $normal_list;             # we are processing, do anything.
%const_2 = %const;              # allow for strange use before set.
%const_2_count = %const_count;  # allow for strange use before set.
undef(%const);                  # no "set's" done.
undef(%const_count);            # count of sets.
foreach my $i (keys(%defines)) {
  $const{$i} = $defines{$i};
  $const_count{$i} = 1;
}
# The following should not happen on pass 2.
$autolabel = 0;                 # Last automatic branch label index
$save_section_one = 0;          # save one line to save_section
$filecount = 0;
undef(%already_included);
for my $f (@not_opt) {          # Process files.
  $filecount++;
  undef($already_included{$f});
  include_file($f);
}

if ($section eq '.shdata') {
    error("Missing END_SH_DATA_SECTION, pass 2");
}

if ($section ne 'text') {
  $section = "text";            # force back to text section.
  if ($option_no_line_numbers == 0) {
    putit("# $save_section_count{'text'} \"$option_fullpath$external_c_file\"\n", 1);
  }
#  putit($ASMV . '(".text");' . "\n", 1);
}
# End of this generated subroutine.
# putit("return;\n", 1);
putit($SPECIAL_FILE, $SPECIAL_linenumber);
if ($option_assumes_works == 0) {
  putit("ct_error: asm(\".global ct_error; ct_error: ;\"); fprintf(stderr, \"reached ct_error?\\n\"); abort();\n", 1);
}
putit("ct_alldone: asm(\".global ct_alldone; ct_alldone: ;\"); \n", 1);
putit("}\n", 1);

if ($option_no_line_numbers == 0) {
  put_linenumber($save_section_count{'text'}, $external_c_file, "$section" . 'done', '');
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# NOW, really write out the "c" source now "first".
if (defined($save_section{'text'})) {
  print CFILE $save_section{'text'};
}

# my $linecounter = $save_section_count{'text'};

# Write out the ".data" (non-text) sections.
# The .shdata, .shinit, and .shinittable are never specified directly, they are done via
# pseudo commands START_SH_DATA_SECTION and END_SH_DATA_SECTION.
for my $i (sort(keys(%save_section))) {
  if ($i ne 'text') {
# Force into .data section.
    print SFILE $ASM . '(".data");' . "\n";
    print SFILE $save_section{$i};
    print SFILE $ASM . '(".text");' . "\n";
#    $linecounter += $save_section_count{$i}
  }
}

# print STDERR "linecounter=$linecounter\n";

# Close SFILE first, to stop a potential NFS file synchronization problem.
undef($external_s_file);
close(SFILE);

undef($external_c_file);
close(CFILE);

#- # print out .set's done more than once.
#- foreach my $i (sort(keys(%const_count))) {
#-   if ($const_count{$i} != 1) {
#-     print STDERR "warning: variable $i set $const_count{$i} times\n";
#-   }
#- }

exit($exitvalue);

##############################################################################
# End of File CT_analyze
## Modelines:
## vi:sw=2 ts=2 expandtab

